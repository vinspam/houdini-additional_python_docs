

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>hou module &mdash; Houdini Python modules 17.0.439 documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="houdiniInterpreter module" href="houdiniInterpreter.html" />
    <link rel="prev" title="hotkeys package" href="hotkeys.html" /> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> Houdini Python modules
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="modules.html">python2.7libs</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="EC2.html">EC2 module</a></li>
<li class="toctree-l2"><a class="reference internal" href="alignutils.html">alignutils module</a></li>
<li class="toctree-l2"><a class="reference internal" href="assetauthortools.html">assetauthortools module</a></li>
<li class="toctree-l2"><a class="reference internal" href="assetdownload.html">assetdownload module</a></li>
<li class="toctree-l2"><a class="reference internal" href="autorig.html">autorig package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="autorig.html#submodules">Submodules</a></li>
<li class="toctree-l3"><a class="reference internal" href="autorig.html#module-autorig.isbodypart">autorig.isbodypart module</a></li>
<li class="toctree-l3"><a class="reference internal" href="autorig.html#module-autorig.mocapbodypart">autorig.mocapbodypart module</a></li>
<li class="toctree-l3"><a class="reference internal" href="autorig.html#module-autorig.mocapgui">autorig.mocapgui module</a></li>
<li class="toctree-l3"><a class="reference internal" href="autorig.html#module-autorig.mocappartmapping">autorig.mocappartmapping module</a></li>
<li class="toctree-l3"><a class="reference internal" href="autorig.html#module-autorig.mocaprigutils">autorig.mocaprigutils module</a></li>
<li class="toctree-l3"><a class="reference internal" href="autorig.html#module-autorig.rigtoolutils">autorig.rigtoolutils module</a></li>
<li class="toctree-l3"><a class="reference internal" href="autorig.html#module-autorig.utils">autorig.utils module</a></li>
<li class="toctree-l3"><a class="reference internal" href="autorig.html#module-autorig">Module contents</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="autorigs.html">autorigs package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="autorigs.html#subpackages">Subpackages</a><ul>
<li class="toctree-l4"><a class="reference internal" href="autorigs.asset.html">autorigs.asset package</a><ul>
<li class="toctree-l5"><a class="reference internal" href="autorigs.asset.html#subpackages">Subpackages</a><ul>
<li class="toctree-l6"><a class="reference internal" href="autorigs.asset.geometry.html">autorigs.asset.geometry package</a></li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="autorigs.asset.html#submodules">Submodules</a></li>
<li class="toctree-l5"><a class="reference internal" href="autorigs.asset.html#autorigs-asset-autorigsasset-module">autorigs.asset.autoRigsAsset module</a></li>
<li class="toctree-l5"><a class="reference internal" href="autorigs.asset.html#autorigs-asset-autorigsmodules-module">autorigs.asset.autoRigsModules module</a></li>
<li class="toctree-l5"><a class="reference internal" href="autorigs.asset.html#autorigs-asset-autorigssettings-module">autorigs.asset.autoRigsSettings module</a></li>
<li class="toctree-l5"><a class="reference internal" href="autorigs.asset.html#autorigs-asset-defaultproperties-module">autorigs.asset.defaultProperties module</a></li>
<li class="toctree-l5"><a class="reference internal" href="autorigs.asset.html#autorigs-asset-modulefactory-module">autorigs.asset.moduleFactory module</a></li>
<li class="toctree-l5"><a class="reference internal" href="autorigs.asset.html#autorigs-asset-moduleinfos-module">autorigs.asset.moduleInfos module</a></li>
<li class="toctree-l5"><a class="reference internal" href="autorigs.asset.html#module-autorigs.asset">Module contents</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="autorigs.modules.html">autorigs.modules package</a><ul>
<li class="toctree-l5"><a class="reference internal" href="autorigs.modules.html#subpackages">Subpackages</a><ul>
<li class="toctree-l6"><a class="reference internal" href="autorigs.modules.advancedFace.html">autorigs.modules.advancedFace package</a></li>
<li class="toctree-l6"><a class="reference internal" href="autorigs.modules.arm.html">autorigs.modules.arm package</a></li>
<li class="toctree-l6"><a class="reference internal" href="autorigs.modules.base.html">autorigs.modules.base package</a></li>
<li class="toctree-l6"><a class="reference internal" href="autorigs.modules.basicFace.html">autorigs.modules.basicFace package</a></li>
<li class="toctree-l6"><a class="reference internal" href="autorigs.modules.extremity.html">autorigs.modules.extremity package</a></li>
<li class="toctree-l6"><a class="reference internal" href="autorigs.modules.foot.html">autorigs.modules.foot package</a></li>
<li class="toctree-l6"><a class="reference internal" href="autorigs.modules.geometry.html">autorigs.modules.geometry package</a></li>
<li class="toctree-l6"><a class="reference internal" href="autorigs.modules.hand.html">autorigs.modules.hand package</a></li>
<li class="toctree-l6"><a class="reference internal" href="autorigs.modules.head.html">autorigs.modules.head package</a></li>
<li class="toctree-l6"><a class="reference internal" href="autorigs.modules.jaw.html">autorigs.modules.jaw package</a></li>
<li class="toctree-l6"><a class="reference internal" href="autorigs.modules.leg.html">autorigs.modules.leg package</a></li>
<li class="toctree-l6"><a class="reference internal" href="autorigs.modules.limb.html">autorigs.modules.limb package</a></li>
<li class="toctree-l6"><a class="reference internal" href="autorigs.modules.master.html">autorigs.modules.master package</a></li>
<li class="toctree-l6"><a class="reference internal" href="autorigs.modules.quadFoot.html">autorigs.modules.quadFoot package</a></li>
<li class="toctree-l6"><a class="reference internal" href="autorigs.modules.quadHead.html">autorigs.modules.quadHead package</a></li>
<li class="toctree-l6"><a class="reference internal" href="autorigs.modules.quadleg.html">autorigs.modules.quadleg package</a></li>
<li class="toctree-l6"><a class="reference internal" href="autorigs.modules.simpleexample1.html">autorigs.modules.simpleexample1 package</a></li>
<li class="toctree-l6"><a class="reference internal" href="autorigs.modules.spine.html">autorigs.modules.spine package</a></li>
<li class="toctree-l6"><a class="reference internal" href="autorigs.modules.tail.html">autorigs.modules.tail package</a></li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="autorigs.modules.html#module-autorigs.modules">Module contents</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="autorigs.ui.html">autorigs.ui package</a><ul>
<li class="toctree-l5"><a class="reference internal" href="autorigs.ui.html#submodules">Submodules</a></li>
<li class="toctree-l5"><a class="reference internal" href="autorigs.ui.html#autorigs-ui-modulelistitemwidget-module">autorigs.ui.moduleListItemWidget module</a></li>
<li class="toctree-l5"><a class="reference internal" href="autorigs.ui.html#module-autorigs.ui.moduleTabsWidget">autorigs.ui.moduleTabsWidget module</a></li>
<li class="toctree-l5"><a class="reference internal" href="autorigs.ui.html#module-autorigs.ui.moduleUiTab">autorigs.ui.moduleUiTab module</a></li>
<li class="toctree-l5"><a class="reference internal" href="autorigs.ui.html#autorigs-ui-uiassetcontainer-module">autorigs.ui.uiAssetContainer module</a></li>
<li class="toctree-l5"><a class="reference internal" href="autorigs.ui.html#autorigs-ui-uicharactersettings-module">autorigs.ui.uiCharacterSettings module</a></li>
<li class="toctree-l5"><a class="reference internal" href="autorigs.ui.html#autorigs-ui-uicharactertabs-module">autorigs.ui.uiCharacterTabs module</a></li>
<li class="toctree-l5"><a class="reference internal" href="autorigs.ui.html#autorigs-ui-uicreatetabs-module">autorigs.ui.uiCreateTabs module</a></li>
<li class="toctree-l5"><a class="reference internal" href="autorigs.ui.html#module-autorigs.ui.uiDropDownMenu">autorigs.ui.uiDropDownMenu module</a></li>
<li class="toctree-l5"><a class="reference internal" href="autorigs.ui.html#autorigs-ui-uigeometrycapture-module">autorigs.ui.uiGeometryCapture module</a></li>
<li class="toctree-l5"><a class="reference internal" href="autorigs.ui.html#autorigs-ui-uigeometrycontainer-module">autorigs.ui.uiGeometryContainer module</a></li>
<li class="toctree-l5"><a class="reference internal" href="autorigs.ui.html#autorigs-ui-uigeometryinfo-module">autorigs.ui.uiGeometryInfo module</a></li>
<li class="toctree-l5"><a class="reference internal" href="autorigs.ui.html#autorigs-ui-uigeometryparams-module">autorigs.ui.uiGeometryParams module</a></li>
<li class="toctree-l5"><a class="reference internal" href="autorigs.ui.html#autorigs-ui-uimenubar-module">autorigs.ui.uiMenuBar module</a></li>
<li class="toctree-l5"><a class="reference internal" href="autorigs.ui.html#autorigs-ui-uimodulelist-module">autorigs.ui.uiModuleList module</a></li>
<li class="toctree-l5"><a class="reference internal" href="autorigs.ui.html#autorigs-ui-uinewautorigdialog-module">autorigs.ui.uiNewAutorigDialog module</a></li>
<li class="toctree-l5"><a class="reference internal" href="autorigs.ui.html#module-autorigs.ui.uiParamColor">autorigs.ui.uiParamColor module</a></li>
<li class="toctree-l5"><a class="reference internal" href="autorigs.ui.html#module-autorigs.ui.uiParamComboBox">autorigs.ui.uiParamComboBox module</a></li>
<li class="toctree-l5"><a class="reference internal" href="autorigs.ui.html#module-autorigs.ui.uiParamDescriptions">autorigs.ui.uiParamDescriptions module</a></li>
<li class="toctree-l5"><a class="reference internal" href="autorigs.ui.html#module-autorigs.ui.uiParamFactory">autorigs.ui.uiParamFactory module</a></li>
<li class="toctree-l5"><a class="reference internal" href="autorigs.ui.html#module-autorigs.ui.uiParamFile">autorigs.ui.uiParamFile module</a></li>
<li class="toctree-l5"><a class="reference internal" href="autorigs.ui.html#module-autorigs.ui.uiParamFloat">autorigs.ui.uiParamFloat module</a></li>
<li class="toctree-l5"><a class="reference internal" href="autorigs.ui.html#module-autorigs.ui.uiParamInt">autorigs.ui.uiParamInt module</a></li>
<li class="toctree-l5"><a class="reference internal" href="autorigs.ui.html#module-autorigs.ui.uiParamLabelButton">autorigs.ui.uiParamLabelButton module</a></li>
<li class="toctree-l5"><a class="reference internal" href="autorigs.ui.html#module-autorigs.ui.uiParamLocatorWidget">autorigs.ui.uiParamLocatorWidget module</a></li>
<li class="toctree-l5"><a class="reference internal" href="autorigs.ui.html#module-autorigs.ui.uiParamMultiParm">autorigs.ui.uiParamMultiParm module</a></li>
<li class="toctree-l5"><a class="reference internal" href="autorigs.ui.html#module-autorigs.ui.uiParamName">autorigs.ui.uiParamName module</a></li>
<li class="toctree-l5"><a class="reference internal" href="autorigs.ui.html#autorigs-ui-uiparamnodepicker-module">autorigs.ui.uiParamNodePicker module</a></li>
<li class="toctree-l5"><a class="reference internal" href="autorigs.ui.html#module-autorigs.ui.uiParamNum">autorigs.ui.uiParamNum module</a></li>
<li class="toctree-l5"><a class="reference internal" href="autorigs.ui.html#module-autorigs.ui.uiParamOperator">autorigs.ui.uiParamOperator module</a></li>
<li class="toctree-l5"><a class="reference internal" href="autorigs.ui.html#module-autorigs.ui.uiParamString">autorigs.ui.uiParamString module</a></li>
<li class="toctree-l5"><a class="reference internal" href="autorigs.ui.html#module-autorigs.ui.uiParentComboMenu">autorigs.ui.uiParentComboMenu module</a></li>
<li class="toctree-l5"><a class="reference internal" href="autorigs.ui.html#module-autorigs.ui.uiToggleButtonsWidget">autorigs.ui.uiToggleButtonsWidget module</a></li>
<li class="toctree-l5"><a class="reference internal" href="autorigs.ui.html#module-autorigs.ui">Module contents</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="autorigs.utils.html">autorigs.utils package</a><ul>
<li class="toctree-l5"><a class="reference internal" href="autorigs.utils.html#subpackages">Subpackages</a><ul>
<li class="toctree-l6"><a class="reference internal" href="autorigs.utils.rigtoolutils.html">autorigs.utils.rigtoolutils package</a></li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="autorigs.utils.html#submodules">Submodules</a></li>
<li class="toctree-l5"><a class="reference internal" href="autorigs.utils.html#module-autorigs.utils.autoRigsBuilderCtrlUtils">autorigs.utils.autoRigsBuilderCtrlUtils module</a></li>
<li class="toctree-l5"><a class="reference internal" href="autorigs.utils.html#module-autorigs.utils.autoRigsBuilderInterfaceUtils">autorigs.utils.autoRigsBuilderInterfaceUtils module</a></li>
<li class="toctree-l5"><a class="reference internal" href="autorigs.utils.html#module-autorigs.utils.autoRigsBuilderNameUtils">autorigs.utils.autoRigsBuilderNameUtils module</a></li>
<li class="toctree-l5"><a class="reference internal" href="autorigs.utils.html#module-autorigs.utils.autoRigsBuilderUtils">autorigs.utils.autoRigsBuilderUtils module</a></li>
<li class="toctree-l5"><a class="reference internal" href="autorigs.utils.html#module-autorigs.utils.autoRigsColors">autorigs.utils.autoRigsColors module</a></li>
<li class="toctree-l5"><a class="reference internal" href="autorigs.utils.html#module-autorigs.utils.buildGuideHelper">autorigs.utils.buildGuideHelper module</a></li>
<li class="toctree-l5"><a class="reference internal" href="autorigs.utils.html#module-autorigs.utils.captureutils">autorigs.utils.captureutils module</a></li>
<li class="toctree-l5"><a class="reference internal" href="autorigs.utils.html#module-autorigs.utils.faceutils">autorigs.utils.faceutils module</a></li>
<li class="toctree-l5"><a class="reference internal" href="autorigs.utils.html#module-autorigs.utils.fkcontrols">autorigs.utils.fkcontrols module</a></li>
<li class="toctree-l5"><a class="reference internal" href="autorigs.utils.html#module-autorigs.utils.geometryutils">autorigs.utils.geometryutils module</a></li>
<li class="toctree-l5"><a class="reference internal" href="autorigs.utils.html#module-autorigs.utils.guideOptionsHelper">autorigs.utils.guideOptionsHelper module</a></li>
<li class="toctree-l5"><a class="reference internal" href="autorigs.utils.html#module-autorigs.utils.guideParamsHelper">autorigs.utils.guideParamsHelper module</a></li>
<li class="toctree-l5"><a class="reference internal" href="autorigs.utils.html#module-autorigs.utils.iktwistcontrols">autorigs.utils.iktwistcontrols module</a></li>
<li class="toctree-l5"><a class="reference internal" href="autorigs.utils.html#module-autorigs.utils.rigutils">autorigs.utils.rigutils module</a></li>
<li class="toctree-l5"><a class="reference internal" href="autorigs.utils.html#module-autorigs.utils">Module contents</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="autorigs.html#submodules">Submodules</a></li>
<li class="toctree-l3"><a class="reference internal" href="autorigs.html#module-autorigs.arglobals">autorigs.arglobals module</a></li>
<li class="toctree-l3"><a class="reference internal" href="autorigs.html#autorigs-maingui-module">autorigs.mainGUI module</a></li>
<li class="toctree-l3"><a class="reference internal" href="autorigs.html#module-autorigs">Module contents</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="bakeanimation.html">bakeanimation module</a></li>
<li class="toctree-l2"><a class="reference internal" href="bookish.html">bookish package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="bookish.html#subpackages">Subpackages</a><ul>
<li class="toctree-l4"><a class="reference internal" href="bookish.avenue.html">bookish.avenue package</a><ul>
<li class="toctree-l5"><a class="reference internal" href="bookish.avenue.html#submodules">Submodules</a></li>
<li class="toctree-l5"><a class="reference internal" href="bookish.avenue.html#module-bookish.avenue.avenue">bookish.avenue.avenue module</a></li>
<li class="toctree-l5"><a class="reference internal" href="bookish.avenue.html#module-bookish.avenue.patterns">bookish.avenue.patterns module</a></li>
<li class="toctree-l5"><a class="reference internal" href="bookish.avenue.html#module-bookish.avenue">Module contents</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="bookish.edit.html">bookish.edit package</a><ul>
<li class="toctree-l5"><a class="reference internal" href="bookish.edit.html#submodules">Submodules</a></li>
<li class="toctree-l5"><a class="reference internal" href="bookish.edit.html#module-bookish.edit.checkpoints">bookish.edit.checkpoints module</a></li>
<li class="toctree-l5"><a class="reference internal" href="bookish.edit.html#module-bookish.edit">Module contents</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="bookish.grammars.html">bookish.grammars package</a><ul>
<li class="toctree-l5"><a class="reference internal" href="bookish.grammars.html#submodules">Submodules</a></li>
<li class="toctree-l5"><a class="reference internal" href="bookish.grammars.html#module-bookish.grammars.avenue">bookish.grammars.avenue module</a></li>
<li class="toctree-l5"><a class="reference internal" href="bookish.grammars.html#module-bookish.grammars.meta">bookish.grammars.meta module</a></li>
<li class="toctree-l5"><a class="reference internal" href="bookish.grammars.html#module-bookish.grammars.wiki">bookish.grammars.wiki module</a></li>
<li class="toctree-l5"><a class="reference internal" href="bookish.grammars.html#module-bookish.grammars">Module contents</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="bookish.parser.html">bookish.parser package</a><ul>
<li class="toctree-l5"><a class="reference internal" href="bookish.parser.html#submodules">Submodules</a></li>
<li class="toctree-l5"><a class="reference internal" href="bookish.parser.html#module-bookish.parser.bootstrap">bookish.parser.bootstrap module</a></li>
<li class="toctree-l5"><a class="reference internal" href="bookish.parser.html#module-bookish.parser.builder">bookish.parser.builder module</a></li>
<li class="toctree-l5"><a class="reference internal" href="bookish.parser.html#module-bookish.parser.rules">bookish.parser.rules module</a></li>
<li class="toctree-l5"><a class="reference internal" href="bookish.parser.html#module-bookish.parser">Module contents</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="bookish.text.html">bookish.text package</a><ul>
<li class="toctree-l5"><a class="reference internal" href="bookish.text.html#submodules">Submodules</a></li>
<li class="toctree-l5"><a class="reference internal" href="bookish.text.html#module-bookish.text.convert">bookish.text.convert module</a></li>
<li class="toctree-l5"><a class="reference internal" href="bookish.text.html#module-bookish.text.textify">bookish.text.textify module</a></li>
<li class="toctree-l5"><a class="reference internal" href="bookish.text.html#module-bookish.text">Module contents</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="bookish.wiki.html">bookish.wiki package</a><ul>
<li class="toctree-l5"><a class="reference internal" href="bookish.wiki.html#submodules">Submodules</a></li>
<li class="toctree-l5"><a class="reference internal" href="bookish.wiki.html#module-bookish.wiki.config">bookish.wiki.config module</a></li>
<li class="toctree-l5"><a class="reference internal" href="bookish.wiki.html#module-bookish.wiki.includes">bookish.wiki.includes module</a></li>
<li class="toctree-l5"><a class="reference internal" href="bookish.wiki.html#module-bookish.wiki.langpaths">bookish.wiki.langpaths module</a></li>
<li class="toctree-l5"><a class="reference internal" href="bookish.wiki.html#module-bookish.wiki.pipeline">bookish.wiki.pipeline module</a></li>
<li class="toctree-l5"><a class="reference internal" href="bookish.wiki.html#module-bookish.wiki.styles">bookish.wiki.styles module</a></li>
<li class="toctree-l5"><a class="reference internal" href="bookish.wiki.html#module-bookish.wiki.wikipages">bookish.wiki.wikipages module</a></li>
<li class="toctree-l5"><a class="reference internal" href="bookish.wiki.html#module-bookish.wiki">Module contents</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="bookish.html#submodules">Submodules</a></li>
<li class="toctree-l3"><a class="reference internal" href="bookish.html#module-bookish.coloring">bookish.coloring module</a></li>
<li class="toctree-l3"><a class="reference internal" href="bookish.html#module-bookish.compat">bookish.compat module</a></li>
<li class="toctree-l3"><a class="reference internal" href="bookish.html#module-bookish.config">bookish.config module</a></li>
<li class="toctree-l3"><a class="reference internal" href="bookish.html#module-bookish.flaskapp">bookish.flaskapp module</a></li>
<li class="toctree-l3"><a class="reference internal" href="bookish.html#module-bookish.flasksupport">bookish.flasksupport module</a></li>
<li class="toctree-l3"><a class="reference internal" href="bookish.html#module-bookish.functions">bookish.functions module</a></li>
<li class="toctree-l3"><a class="reference internal" href="bookish.html#module-bookish.i18n">bookish.i18n module</a></li>
<li class="toctree-l3"><a class="reference internal" href="bookish.html#module-bookish.paths">bookish.paths module</a></li>
<li class="toctree-l3"><a class="reference internal" href="bookish.html#module-bookish.search">bookish.search module</a></li>
<li class="toctree-l3"><a class="reference internal" href="bookish.html#module-bookish.stores">bookish.stores module</a></li>
<li class="toctree-l3"><a class="reference internal" href="bookish.html#module-bookish.testing">bookish.testing module</a></li>
<li class="toctree-l3"><a class="reference internal" href="bookish.html#module-bookish.util">bookish.util module</a></li>
<li class="toctree-l3"><a class="reference internal" href="bookish.html#module-bookish">Module contents</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="bvhviewer.html">bvhviewer package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="bvhviewer.html#submodules">Submodules</a></li>
<li class="toctree-l3"><a class="reference internal" href="bvhviewer.html#module-bvhviewer.box">bvhviewer.box module</a></li>
<li class="toctree-l3"><a class="reference internal" href="bvhviewer.html#module-bvhviewer.bvhtree">bvhviewer.bvhtree module</a></li>
<li class="toctree-l3"><a class="reference internal" href="bvhviewer.html#module-bvhviewer.bvhviewer">bvhviewer.bvhviewer module</a></li>
<li class="toctree-l3"><a class="reference internal" href="bvhviewer.html#module-bvhviewer.colormanager">bvhviewer.colormanager module</a></li>
<li class="toctree-l3"><a class="reference internal" href="bvhviewer.html#module-bvhviewer">Module contents</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="canvaseventtypes.html">canvaseventtypes module</a></li>
<li class="toctree-l2"><a class="reference internal" href="channelwranglesnippet.html">channelwranglesnippet module</a></li>
<li class="toctree-l2"><a class="reference internal" href="charactertoolutils.html">charactertoolutils module</a></li>
<li class="toctree-l2"><a class="reference internal" href="charpicker.html">charpicker package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="charpicker.html#submodules">Submodules</a></li>
<li class="toctree-l3"><a class="reference internal" href="charpicker.html#charpicker-controlbutton-module">charpicker.controlbutton module</a></li>
<li class="toctree-l3"><a class="reference internal" href="charpicker.html#charpicker-controlslider-module">charpicker.controlslider module</a></li>
<li class="toctree-l3"><a class="reference internal" href="charpicker.html#charpicker-cpglobals-module">charpicker.cpglobals module</a></li>
<li class="toctree-l3"><a class="reference internal" href="charpicker.html#module-charpicker.gridsnap">charpicker.gridsnap module</a></li>
<li class="toctree-l3"><a class="reference internal" href="charpicker.html#charpicker-mainwidget-module">charpicker.mainwidget module</a></li>
<li class="toctree-l3"><a class="reference internal" href="charpicker.html#charpicker-tabview-module">charpicker.tabview module</a></li>
<li class="toctree-l3"><a class="reference internal" href="charpicker.html#charpicker-tabwindow-module">charpicker.tabwindow module</a></li>
<li class="toctree-l3"><a class="reference internal" href="charpicker.html#module-charpicker">Module contents</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="chopnettoolutils.html">chopnettoolutils module</a></li>
<li class="toctree-l2"><a class="reference internal" href="choptoolutils.html">choptoolutils module</a></li>
<li class="toctree-l2"><a class="reference internal" href="cloud.html">cloud module</a></li>
<li class="toctree-l2"><a class="reference internal" href="cloudEULA.html">cloudEULA module</a></li>
<li class="toctree-l2"><a class="reference internal" href="cloudsubmit.html">cloudsubmit module</a></li>
<li class="toctree-l2"><a class="reference internal" href="cloudtoolutils.html">cloudtoolutils module</a></li>
<li class="toctree-l2"><a class="reference internal" href="colorschemeutils.html">colorschemeutils module</a></li>
<li class="toctree-l2"><a class="reference internal" href="contextoptionseditor.html">contextoptionseditor module</a></li>
<li class="toctree-l2"><a class="reference internal" href="cop2toolutils.html">cop2toolutils module</a></li>
<li class="toctree-l2"><a class="reference internal" href="copnettoolutils.html">copnettoolutils module</a></li>
<li class="toctree-l2"><a class="reference internal" href="crowds.html">crowds package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="crowds.html#submodules">Submodules</a></li>
<li class="toctree-l3"><a class="reference internal" href="crowds.html#crowds-bakeagentdialog-module">crowds.bakeagentdialog module</a></li>
<li class="toctree-l3"><a class="reference internal" href="crowds.html#module-crowds">Module contents</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="crowdstoolutils.html">crowdstoolutils module</a></li>
<li class="toctree-l2"><a class="reference internal" href="dbg.html">dbg module</a></li>
<li class="toctree-l2"><a class="reference internal" href="defaultstatetools.html">defaultstatetools module</a></li>
<li class="toctree-l2"><a class="reference internal" href="defaulttoolmenus.html">defaulttoolmenus module</a></li>
<li class="toctree-l2"><a class="reference internal" href="defaulttools.html">defaulttools module</a></li>
<li class="toctree-l2"><a class="reference internal" href="digitalassetsupport.html">digitalassetsupport module</a></li>
<li class="toctree-l2"><a class="reference internal" href="displaymessage.html">displaymessage module</a></li>
<li class="toctree-l2"><a class="reference internal" href="dopclothproxy.html">dopclothproxy module</a></li>
<li class="toctree-l2"><a class="reference internal" href="dopclothtoolutils.html">dopclothtoolutils module</a></li>
<li class="toctree-l2"><a class="reference internal" href="dopfetoolutils.html">dopfetoolutils module</a></li>
<li class="toctree-l2"><a class="reference internal" href="dopgeofiltertoolutils.html">dopgeofiltertoolutils module</a></li>
<li class="toctree-l2"><a class="reference internal" href="dopinstance.html">dopinstance module</a></li>
<li class="toctree-l2"><a class="reference internal" href="dopparticlefluidtoolutils.html">dopparticlefluidtoolutils module</a></li>
<li class="toctree-l2"><a class="reference internal" href="doppoptoolutils.html">doppoptoolutils module</a></li>
<li class="toctree-l2"><a class="reference internal" href="doppyrotoolutils.html">doppyrotoolutils module</a></li>
<li class="toctree-l2"><a class="reference internal" href="doprbdtoolutils.html">doprbdtoolutils module</a></li>
<li class="toctree-l2"><a class="reference internal" href="dopreltoolutils.html">dopreltoolutils module</a></li>
<li class="toctree-l2"><a class="reference internal" href="dopsbdtoolutils.html">dopsbdtoolutils module</a></li>
<li class="toctree-l2"><a class="reference internal" href="dopsmoketoolutils.html">dopsmoketoolutils module</a></li>
<li class="toctree-l2"><a class="reference internal" href="dopstatictoolutils.html">dopstatictoolutils module</a></li>
<li class="toctree-l2"><a class="reference internal" href="doptoolutils.html">doptoolutils module</a></li>
<li class="toctree-l2"><a class="reference internal" href="dopwiretoolutils.html">dopwiretoolutils module</a></li>
<li class="toctree-l2"><a class="reference internal" href="dragdroputils.html">dragdroputils module</a></li>
<li class="toctree-l2"><a class="reference internal" href="drivertoolutils.html">drivertoolutils module</a></li>
<li class="toctree-l2"><a class="reference internal" href="expression_functions.html">expression_functions package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="expression_functions.html#submodules">Submodules</a></li>
<li class="toctree-l3"><a class="reference internal" href="expression_functions.html#module-expression_functions.exprhelper">expression_functions.exprhelper module</a></li>
<li class="toctree-l3"><a class="reference internal" href="expression_functions.html#module-expression_functions.matrix">expression_functions.matrix module</a></li>
<li class="toctree-l3"><a class="reference internal" href="expression_functions.html#module-expression_functions.opdigits">expression_functions.opdigits module</a></li>
<li class="toctree-l3"><a class="reference internal" href="expression_functions.html#module-expression_functions.vector">expression_functions.vector module</a></li>
<li class="toctree-l3"><a class="reference internal" href="expression_functions.html#module-expression_functions">Module contents</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="fileutils.html">fileutils module</a></li>
<li class="toctree-l2"><a class="reference internal" href="furtoolutils.html">furtoolutils module</a></li>
<li class="toctree-l2"><a class="reference internal" href="furutils.html">furutils module</a></li>
<li class="toctree-l2"><a class="reference internal" href="gasresizedynamic.html">gasresizedynamic module</a></li>
<li class="toctree-l2"><a class="reference internal" href="generateHDAToolsForOTL.html">generateHDAToolsForOTL module</a></li>
<li class="toctree-l2"><a class="reference internal" href="generate_proto.html">generate_proto module</a></li>
<li class="toctree-l2"><a class="reference internal" href="hdefereval.html">hdefereval module</a></li>
<li class="toctree-l2"><a class="reference internal" href="hjsonrpc.html">hjsonrpc module</a></li>
<li class="toctree-l2"><a class="reference internal" href="hotkeys.html">hotkeys package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="hotkeys.html#submodules">Submodules</a></li>
<li class="toctree-l3"><a class="reference internal" href="hotkeys.html#hotkeys-mainwidget-module">hotkeys.mainwidget module</a></li>
<li class="toctree-l3"><a class="reference internal" href="hotkeys.html#hotkeys-widgets-module">hotkeys.widgets module</a></li>
<li class="toctree-l3"><a class="reference internal" href="hotkeys.html#module-hotkeys">Module contents</a></li>
</ul>
</li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">hou module</a></li>
<li class="toctree-l2"><a class="reference internal" href="houdiniInterpreter.html">houdiniInterpreter module</a></li>
<li class="toctree-l2"><a class="reference internal" href="houdiniengineutils.html">houdiniengineutils module</a></li>
<li class="toctree-l2"><a class="reference internal" href="houdinihelp.html">houdinihelp package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="houdinihelp.html#submodules">Submodules</a></li>
<li class="toctree-l3"><a class="reference internal" href="houdinihelp.html#module-houdinihelp.api">houdinihelp.api module</a></li>
<li class="toctree-l3"><a class="reference internal" href="houdinihelp.html#houdinihelp-cli-module">houdinihelp.cli module</a></li>
<li class="toctree-l3"><a class="reference internal" href="houdinihelp.html#module-houdinihelp.examples">houdinihelp.examples module</a></li>
<li class="toctree-l3"><a class="reference internal" href="houdinihelp.html#module-houdinihelp.hcoloring">houdinihelp.hcoloring module</a></li>
<li class="toctree-l3"><a class="reference internal" href="houdinihelp.html#module-houdinihelp.hconfig">houdinihelp.hconfig module</a></li>
<li class="toctree-l3"><a class="reference internal" href="houdinihelp.html#module-houdinihelp.hotkeys">houdinihelp.hotkeys module</a></li>
<li class="toctree-l3"><a class="reference internal" href="houdinihelp.html#module-houdinihelp.hpages">houdinihelp.hpages module</a></li>
<li class="toctree-l3"><a class="reference internal" href="houdinihelp.html#module-houdinihelp.hsearch">houdinihelp.hsearch module</a></li>
<li class="toctree-l3"><a class="reference internal" href="houdinihelp.html#module-houdinihelp.hstores">houdinihelp.hstores module</a></li>
<li class="toctree-l3"><a class="reference internal" href="houdinihelp.html#module-houdinihelp.htextify">houdinihelp.htextify module</a></li>
<li class="toctree-l3"><a class="reference internal" href="houdinihelp.html#module-houdinihelp.server">houdinihelp.server module</a></li>
<li class="toctree-l3"><a class="reference internal" href="houdinihelp.html#module-houdinihelp.vex">houdinihelp.vex module</a></li>
<li class="toctree-l3"><a class="reference internal" href="houdinihelp.html#module-houdinihelp">Module contents</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="houdiniinternals.html">houdiniinternals module</a></li>
<li class="toctree-l2"><a class="reference internal" href="houpythonportion.html">houpythonportion package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="houpythonportion.html#subpackages">Subpackages</a><ul>
<li class="toctree-l4"><a class="reference internal" href="houpythonportion.qt.html">houpythonportion.qt package</a><ul>
<li class="toctree-l5"><a class="reference internal" href="houpythonportion.qt.html#submodules">Submodules</a></li>
<li class="toctree-l5"><a class="reference internal" href="houpythonportion.qt.html#houpythonportion-qt-colorfield-module">houpythonportion.qt.ColorField module</a></li>
<li class="toctree-l5"><a class="reference internal" href="houpythonportion.qt.html#houpythonportion-qt-colorswatchbutton-module">houpythonportion.qt.ColorSwatchButton module</a></li>
<li class="toctree-l5"><a class="reference internal" href="houpythonportion.qt.html#houpythonportion-qt-combobox-module">houpythonportion.qt.ComboBox module</a></li>
<li class="toctree-l5"><a class="reference internal" href="houpythonportion.qt.html#houpythonportion-qt-dialog-module">houpythonportion.qt.Dialog module</a></li>
<li class="toctree-l5"><a class="reference internal" href="houpythonportion.qt.html#houpythonportion-qt-fieldlabel-module">houpythonportion.qt.FieldLabel module</a></li>
<li class="toctree-l5"><a class="reference internal" href="houpythonportion.qt.html#houpythonportion-qt-filechooserbutton-module">houpythonportion.qt.FileChooserButton module</a></li>
<li class="toctree-l5"><a class="reference internal" href="houpythonportion.qt.html#houpythonportion-qt-gridlayout-module">houpythonportion.qt.GridLayout module</a></li>
<li class="toctree-l5"><a class="reference internal" href="houpythonportion.qt.html#houpythonportion-qt-helpbutton-module">houpythonportion.qt.HelpButton module</a></li>
<li class="toctree-l5"><a class="reference internal" href="houpythonportion.qt.html#houpythonportion-qt-icon-module">houpythonportion.qt.Icon module</a></li>
<li class="toctree-l5"><a class="reference internal" href="houpythonportion.qt.html#houpythonportion-qt-inputfield-module">houpythonportion.qt.InputField module</a></li>
<li class="toctree-l5"><a class="reference internal" href="houpythonportion.qt.html#houpythonportion-qt-menu-module">houpythonportion.qt.Menu module</a></li>
<li class="toctree-l5"><a class="reference internal" href="houpythonportion.qt.html#houpythonportion-qt-menubar-module">houpythonportion.qt.MenuBar module</a></li>
<li class="toctree-l5"><a class="reference internal" href="houpythonportion.qt.html#houpythonportion-qt-menubutton-module">houpythonportion.qt.MenuButton module</a></li>
<li class="toctree-l5"><a class="reference internal" href="houpythonportion.qt.html#houpythonportion-qt-nodechooserbutton-module">houpythonportion.qt.NodeChooserButton module</a></li>
<li class="toctree-l5"><a class="reference internal" href="houpythonportion.qt.html#houpythonportion-qt-parmchooserbutton-module">houpythonportion.qt.ParmChooserButton module</a></li>
<li class="toctree-l5"><a class="reference internal" href="houpythonportion.qt.html#houpythonportion-qt-parmtuplechooserbutton-module">houpythonportion.qt.ParmTupleChooserButton module</a></li>
<li class="toctree-l5"><a class="reference internal" href="houpythonportion.qt.html#houpythonportion-qt-separator-module">houpythonportion.qt.Separator module</a></li>
<li class="toctree-l5"><a class="reference internal" href="houpythonportion.qt.html#houpythonportion-qt-tooltip-module">houpythonportion.qt.ToolTip module</a></li>
<li class="toctree-l5"><a class="reference internal" href="houpythonportion.qt.html#houpythonportion-qt-trackchooserbutton-module">houpythonportion.qt.TrackChooserButton module</a></li>
<li class="toctree-l5"><a class="reference internal" href="houpythonportion.qt.html#houpythonportion-qt-window-module">houpythonportion.qt.Window module</a></li>
<li class="toctree-l5"><a class="reference internal" href="houpythonportion.qt.html#module-contents">Module contents</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="houpythonportion.html#submodules">Submodules</a></li>
<li class="toctree-l3"><a class="reference internal" href="houpythonportion.html#module-houpythonportion.Agent">houpythonportion.Agent module</a></li>
<li class="toctree-l3"><a class="reference internal" href="houpythonportion.html#module-houpythonportion.AgentClip">houpythonportion.AgentClip module</a></li>
<li class="toctree-l3"><a class="reference internal" href="houpythonportion.html#module-houpythonportion.AgentLayer">houpythonportion.AgentLayer module</a></li>
<li class="toctree-l3"><a class="reference internal" href="houpythonportion.html#module-houpythonportion.AgentRig">houpythonportion.AgentRig module</a></li>
<li class="toctree-l3"><a class="reference internal" href="houpythonportion.html#module-houpythonportion.AgentShapeBinding">houpythonportion.AgentShapeBinding module</a></li>
<li class="toctree-l3"><a class="reference internal" href="houpythonportion.html#module-houpythonportion.AgentShapeLibrary">houpythonportion.AgentShapeLibrary module</a></li>
<li class="toctree-l3"><a class="reference internal" href="houpythonportion.html#module-houpythonportion.AgentTransformGroup">houpythonportion.AgentTransformGroup module</a></li>
<li class="toctree-l3"><a class="reference internal" href="houpythonportion.html#module-houpythonportion.Geometry">houpythonportion.Geometry module</a></li>
<li class="toctree-l3"><a class="reference internal" href="houpythonportion.html#module-houpythonportion.HDADefinition">houpythonportion.HDADefinition module</a></li>
<li class="toctree-l3"><a class="reference internal" href="houpythonportion.html#module-houpythonportion.Keyframe">houpythonportion.Keyframe module</a></li>
<li class="toctree-l3"><a class="reference internal" href="houpythonportion.html#module-houpythonportion.NetworkDot">houpythonportion.NetworkDot module</a></li>
<li class="toctree-l3"><a class="reference internal" href="houpythonportion.html#module-houpythonportion.NetworkEditor">houpythonportion.NetworkEditor module</a></li>
<li class="toctree-l3"><a class="reference internal" href="houpythonportion.html#module-houpythonportion.NetworkMovableItem">houpythonportion.NetworkMovableItem module</a></li>
<li class="toctree-l3"><a class="reference internal" href="houpythonportion.html#module-houpythonportion.Node">houpythonportion.Node module</a></li>
<li class="toctree-l3"><a class="reference internal" href="houpythonportion.html#module-houpythonportion.Parm">houpythonportion.Parm module</a></li>
<li class="toctree-l3"><a class="reference internal" href="houpythonportion.html#module-houpythonportion.ParmTuple">houpythonportion.ParmTuple module</a></li>
<li class="toctree-l3"><a class="reference internal" href="houpythonportion.html#module-houpythonportion.PerfMonProfile">houpythonportion.PerfMonProfile module</a></li>
<li class="toctree-l3"><a class="reference internal" href="houpythonportion.html#module-houpythonportion.Prim">houpythonportion.Prim module</a></li>
<li class="toctree-l3"><a class="reference internal" href="houpythonportion.html#module-houpythonportion.StringKeyframe">houpythonportion.StringKeyframe module</a></li>
<li class="toctree-l3"><a class="reference internal" href="houpythonportion.html#module-houpythonportion.TopNode">houpythonportion.TopNode module</a></li>
<li class="toctree-l3"><a class="reference internal" href="houpythonportion.html#module-houpythonportion.hda">houpythonportion.hda module</a></li>
<li class="toctree-l3"><a class="reference internal" href="houpythonportion.html#houpythonportion-ui-module">houpythonportion.ui module</a></li>
<li class="toctree-l3"><a class="reference internal" href="houpythonportion.html#module-houpythonportion">Module contents</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="houxmlrpc.html">houxmlrpc module</a></li>
<li class="toctree-l2"><a class="reference internal" href="hqrop.html">hqrop module</a></li>
<li class="toctree-l2"><a class="reference internal" href="hqueue.html">hqueue package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="hqueue.html#submodules">Submodules</a></li>
<li class="toctree-l3"><a class="reference internal" href="hqueue.html#module-hqueue.houdini">hqueue.houdini module</a></li>
<li class="toctree-l3"><a class="reference internal" href="hqueue.html#module-hqueue.rendertrackerrpc">hqueue.rendertrackerrpc module</a></li>
<li class="toctree-l3"><a class="reference internal" href="hqueue.html#module-hqueue.server">hqueue.server module</a></li>
<li class="toctree-l3"><a class="reference internal" href="hqueue.html#module-hqueue.utils">hqueue.utils module</a></li>
<li class="toctree-l3"><a class="reference internal" href="hqueue.html#module-hqueue">Module contents</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="hrpyc.html">hrpyc module</a></li>
<li class="toctree-l2"><a class="reference internal" href="hscp.html">hscp module</a></li>
<li class="toctree-l2"><a class="reference internal" href="husd.html">husd package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="husd.html#subpackages">Subpackages</a><ul>
<li class="toctree-l4"><a class="reference internal" href="husd.UsdHoudini.html">husd.UsdHoudini package</a><ul>
<li class="toctree-l5"><a class="reference internal" href="husd.UsdHoudini.html#module-contents">Module contents</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="husd.UsdMantra.html">husd.UsdMantra package</a><ul>
<li class="toctree-l5"><a class="reference internal" href="husd.UsdMantra.html#module-husd.UsdMantra">Module contents</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="husd.html#submodules">Submodules</a></li>
<li class="toctree-l3"><a class="reference internal" href="husd.html#module-husd.attrutils">husd.attrutils module</a></li>
<li class="toctree-l3"><a class="reference internal" href="husd.html#module-husd.parmutils">husd.parmutils module</a></li>
<li class="toctree-l3"><a class="reference internal" href="husd.html#module-husd.primpicker">husd.primpicker module</a></li>
<li class="toctree-l3"><a class="reference internal" href="husd.html#module-husd.propcreator">husd.propcreator module</a></li>
<li class="toctree-l3"><a class="reference internal" href="husd.html#module-husd.proppicker">husd.proppicker module</a></li>
<li class="toctree-l3"><a class="reference internal" href="husd.html#module-husd.scenegraphdetails">husd.scenegraphdetails module</a></li>
<li class="toctree-l3"><a class="reference internal" href="husd.html#module-husd.textviewer">husd.textviewer module</a></li>
<li class="toctree-l3"><a class="reference internal" href="husd.html#module-husd.typeutils">husd.typeutils module</a></li>
<li class="toctree-l3"><a class="reference internal" href="husd.html#module-husd.utils">husd.utils module</a></li>
<li class="toctree-l3"><a class="reference internal" href="husd.html#module-husd">Module contents</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="husdshadertranslators.html">husdshadertranslators package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="husdshadertranslators.html#submodules">Submodules</a></li>
<li class="toctree-l3"><a class="reference internal" href="husdshadertranslators.html#module-husdshadertranslators.default">husdshadertranslators.default module</a></li>
<li class="toctree-l3"><a class="reference internal" href="husdshadertranslators.html#module-husdshadertranslators.display">husdshadertranslators.display module</a></li>
<li class="toctree-l3"><a class="reference internal" href="husdshadertranslators.html#module-husdshadertranslators.modulelister">husdshadertranslators.modulelister module</a></li>
<li class="toctree-l3"><a class="reference internal" href="husdshadertranslators.html#module-husdshadertranslators.ris">husdshadertranslators.ris module</a></li>
<li class="toctree-l3"><a class="reference internal" href="husdshadertranslators.html#module-husdshadertranslators.usd">husdshadertranslators.usd module</a></li>
<li class="toctree-l3"><a class="reference internal" href="husdshadertranslators.html#module-husdshadertranslators">Module contents</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="hutil.html">hutil package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="hutil.html#submodules">Submodules</a></li>
<li class="toctree-l3"><a class="reference internal" href="hutil.html#module-hutil.Qt">hutil.Qt module</a></li>
<li class="toctree-l3"><a class="reference internal" href="hutil.html#module-hutil.api">hutil.api module</a></li>
<li class="toctree-l3"><a class="reference internal" href="hutil.html#module-hutil.cppinline">hutil.cppinline module</a></li>
<li class="toctree-l3"><a class="reference internal" href="hutil.html#module-hutil.daemon">hutil.daemon module</a></li>
<li class="toctree-l3"><a class="reference internal" href="hutil.html#module-hutil.debug">hutil.debug module</a></li>
<li class="toctree-l3"><a class="reference internal" href="hutil.html#module-hutil.enum">hutil.enum module</a></li>
<li class="toctree-l3"><a class="reference internal" href="hutil.html#module-hutil.file">hutil.file module</a></li>
<li class="toctree-l3"><a class="reference internal" href="hutil.html#module-hutil.ipaddress">hutil.ipaddress module</a></li>
<li class="toctree-l3"><a class="reference internal" href="hutil.html#module-hutil.json">hutil.json module</a></li>
<li class="toctree-l3"><a class="reference internal" href="hutil.html#module-hutil.log">hutil.log module</a></li>
<li class="toctree-l3"><a class="reference internal" href="hutil.html#module-hutil.parsecppsig">hutil.parsecppsig module</a></li>
<li class="toctree-l3"><a class="reference internal" href="hutil.html#module-hutil.pbkdf2">hutil.pbkdf2 module</a></li>
<li class="toctree-l3"><a class="reference internal" href="hutil.html#module-hutil.pidfile">hutil.pidfile module</a></li>
<li class="toctree-l3"><a class="reference internal" href="hutil.html#module-hutil.pyrpc">hutil.pyrpc module</a></li>
<li class="toctree-l3"><a class="reference internal" href="hutil.html#module-hutil.username">hutil.username module</a></li>
<li class="toctree-l3"><a class="reference internal" href="hutil.html#module-hutil.web">hutil.web module</a></li>
<li class="toctree-l3"><a class="reference internal" href="hutil.html#module-hutil">Module contents</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="images2gif.html">images2gif module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="images2gif.html#acknowledgements">Acknowledgements</a></li>
<li class="toctree-l3"><a class="reference internal" href="images2gif.html#usefull-links">Usefull links</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="inlinecpp.html">inlinecpp module</a></li>
<li class="toctree-l2"><a class="reference internal" href="introspect.html">introspect module</a></li>
<li class="toctree-l2"><a class="reference internal" href="karmautils.html">karmautils module</a></li>
<li class="toctree-l2"><a class="reference internal" href="lightpanel.html">lightpanel package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="lightpanel.html#submodules">Submodules</a></li>
<li class="toctree-l3"><a class="reference internal" href="lightpanel.html#lightpanel-lightpanel-module">lightpanel.lightpanel module</a></li>
<li class="toctree-l3"><a class="reference internal" href="lightpanel.html#lightpanel-lightpanel2-module">lightpanel.lightpanel2 module</a></li>
<li class="toctree-l3"><a class="reference internal" href="lightpanel.html#lightpanel-model-module">lightpanel.model module</a></li>
<li class="toctree-l3"><a class="reference internal" href="lightpanel.html#lightpanel-widgets-module">lightpanel.widgets module</a></li>
<li class="toctree-l3"><a class="reference internal" href="lightpanel.html#module-lightpanel">Module contents</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="loadHelpcardOTLExample.html">loadHelpcardOTLExample module</a></li>
<li class="toctree-l2"><a class="reference internal" href="loptoolutils.html">loptoolutils module</a></li>
<li class="toctree-l2"><a class="reference internal" href="loputils.html">loputils module</a></li>
<li class="toctree-l2"><a class="reference internal" href="metaexpr.html">metaexpr module</a></li>
<li class="toctree-l2"><a class="reference internal" href="mssbuild.html">mssbuild module</a></li>
<li class="toctree-l2"><a class="reference internal" href="muscletoolutils.html">muscletoolutils module</a></li>
<li class="toctree-l2"><a class="reference internal" href="mvexportutils.html">mvexportutils module</a></li>
<li class="toctree-l2"><a class="reference internal" href="nodegraph.html">nodegraph module</a></li>
<li class="toctree-l2"><a class="reference internal" href="nodegraphalign.html">nodegraphalign module</a></li>
<li class="toctree-l2"><a class="reference internal" href="nodegraphautoscroll.html">nodegraphautoscroll module</a></li>
<li class="toctree-l2"><a class="reference internal" href="nodegraphbase.html">nodegraphbase module</a></li>
<li class="toctree-l2"><a class="reference internal" href="nodegraphconnect.html">nodegraphconnect module</a></li>
<li class="toctree-l2"><a class="reference internal" href="nodegraphdisplay.html">nodegraphdisplay module</a></li>
<li class="toctree-l2"><a class="reference internal" href="nodegraphdispopts.html">nodegraphdispopts module</a></li>
<li class="toctree-l2"><a class="reference internal" href="nodegraphedittext.html">nodegraphedittext module</a></li>
<li class="toctree-l2"><a class="reference internal" href="nodegraphfastfind.html">nodegraphfastfind module</a></li>
<li class="toctree-l2"><a class="reference internal" href="nodegraphflags.html">nodegraphflags module</a></li>
<li class="toctree-l2"><a class="reference internal" href="nodegraphfurutils.html">nodegraphfurutils module</a></li>
<li class="toctree-l2"><a class="reference internal" href="nodegraphgestures.html">nodegraphgestures module</a></li>
<li class="toctree-l2"><a class="reference internal" href="nodegraphhooks.html">nodegraphhooks module</a></li>
<li class="toctree-l2"><a class="reference internal" href="nodegraphhotkeys.html">nodegraphhotkeys module</a></li>
<li class="toctree-l2"><a class="reference internal" href="nodegraphinfo.html">nodegraphinfo module</a></li>
<li class="toctree-l2"><a class="reference internal" href="nodegraphlayout.html">nodegraphlayout module</a></li>
<li class="toctree-l2"><a class="reference internal" href="nodegraphpalettes.html">nodegraphpalettes module</a></li>
<li class="toctree-l2"><a class="reference internal" href="nodegraphpopupmenus.html">nodegraphpopupmenus module</a></li>
<li class="toctree-l2"><a class="reference internal" href="nodegraphprefs.html">nodegraphprefs module</a></li>
<li class="toctree-l2"><a class="reference internal" href="nodegraphrename.html">nodegraphrename module</a></li>
<li class="toctree-l2"><a class="reference internal" href="nodegraphselectpos.html">nodegraphselectpos module</a></li>
<li class="toctree-l2"><a class="reference internal" href="nodegraphselectposhooks.html">nodegraphselectposhooks module</a></li>
<li class="toctree-l2"><a class="reference internal" href="nodegraphsnap.html">nodegraphsnap module</a></li>
<li class="toctree-l2"><a class="reference internal" href="nodegraphstates.html">nodegraphstates module</a></li>
<li class="toctree-l2"><a class="reference internal" href="nodegraphtitle.html">nodegraphtitle module</a></li>
<li class="toctree-l2"><a class="reference internal" href="nodegraphtopui.html">nodegraphtopui module</a></li>
<li class="toctree-l2"><a class="reference internal" href="nodegraphui.html">nodegraphui module</a></li>
<li class="toctree-l2"><a class="reference internal" href="nodegraphutils.html">nodegraphutils module</a></li>
<li class="toctree-l2"><a class="reference internal" href="nodegraphvellumutils.html">nodegraphvellumutils module</a></li>
<li class="toctree-l2"><a class="reference internal" href="nodegraphview.html">nodegraphview module</a></li>
<li class="toctree-l2"><a class="reference internal" href="nodesearch.html">nodesearch package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="nodesearch.html#submodules">Submodules</a></li>
<li class="toctree-l3"><a class="reference internal" href="nodesearch.html#module-nodesearch.matchers">nodesearch.matchers module</a></li>
<li class="toctree-l3"><a class="reference internal" href="nodesearch.html#module-nodesearch.parser">nodesearch.parser module</a></li>
<li class="toctree-l3"><a class="reference internal" href="nodesearch.html#module-nodesearch.query">nodesearch.query module</a></li>
<li class="toctree-l3"><a class="reference internal" href="nodesearch.html#module-nodesearch.test_nodesearch">nodesearch.test_nodesearch module</a></li>
<li class="toctree-l3"><a class="reference internal" href="nodesearch.html#module-nodesearch">Module contents</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="nodeselectionutil.html">nodeselectionutil module</a></li>
<li class="toctree-l2"><a class="reference internal" href="nodethemes.html">nodethemes module</a></li>
<li class="toctree-l2"><a class="reference internal" href="nodeutils.html">nodeutils module</a></li>
<li class="toctree-l2"><a class="reference internal" href="objecttoolutils.html">objecttoolutils module</a></li>
<li class="toctree-l2"><a class="reference internal" href="opnode_sum.html">opnode_sum module</a></li>
<li class="toctree-l2"><a class="reference internal" href="optixdownload.html">optixdownload module</a></li>
<li class="toctree-l2"><a class="reference internal" href="paginate.html">paginate module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="paginate.html#paginate-helps-split-up-large-collections-into-individual-pages">paginate: helps split up large collections into individual pages</a><ul>
<li class="toctree-l4"><a class="reference internal" href="paginate.html#what-is-pagination">What is pagination?</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="parmutils.html">parmutils module</a></li>
<li class="toctree-l2"><a class="reference internal" href="particletoolutils.html">particletoolutils module</a></li>
<li class="toctree-l2"><a class="reference internal" href="pdg.html">pdg package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="pdg.html#subpackages">Subpackages</a><ul>
<li class="toctree-l4"><a class="reference internal" href="pdg.hda.html">pdg.hda package</a><ul>
<li class="toctree-l5"><a class="reference internal" href="pdg.hda.html#submodules">Submodules</a></li>
<li class="toctree-l5"><a class="reference internal" href="pdg.hda.html#module-pdg.hda.hdaParms_pb2">pdg.hda.hdaParms_pb2 module</a></li>
<li class="toctree-l5"><a class="reference internal" href="pdg.hda.html#module-pdg.hda.savehda">pdg.hda.savehda module</a></li>
<li class="toctree-l5"><a class="reference internal" href="pdg.hda.html#module-pdg.hda">Module contents</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="pdg.job.html">pdg.job package</a><ul>
<li class="toctree-l5"><a class="reference internal" href="pdg.job.html#submodules">Submodules</a></li>
<li class="toctree-l5"><a class="reference internal" href="pdg.job.html#module-pdg.job.callbackserver">pdg.job.callbackserver module</a></li>
<li class="toctree-l5"><a class="reference internal" href="pdg.job.html#pdg-job-changelist-module">pdg.job.changelist module</a></li>
<li class="toctree-l5"><a class="reference internal" href="pdg.job.html#pdg-job-ffmpeg-module">pdg.job.ffmpeg module</a></li>
<li class="toctree-l5"><a class="reference internal" href="pdg.job.html#pdg-job-imagemagick-module">pdg.job.imagemagick module</a></li>
<li class="toctree-l5"><a class="reference internal" href="pdg.job.html#pdg-job-jsondata-module">pdg.job.jsondata module</a></li>
<li class="toctree-l5"><a class="reference internal" href="pdg.job.html#pdg-job-mantrarender-module">pdg.job.mantrarender module</a></li>
<li class="toctree-l5"><a class="reference internal" href="pdg.job.html#module-pdg.job.parmset_pb2">pdg.job.parmset_pb2 module</a></li>
<li class="toctree-l5"><a class="reference internal" href="pdg.job.html#module-pdg.job.rop">pdg.job.rop module</a></li>
<li class="toctree-l5"><a class="reference internal" href="pdg.job.html#module-pdg.job.shotgunclient">pdg.job.shotgunclient module</a></li>
<li class="toctree-l5"><a class="reference internal" href="pdg.job.html#module-pdg.job.status_pb2">pdg.job.status_pb2 module</a></li>
<li class="toctree-l5"><a class="reference internal" href="pdg.job.html#module-pdg.job.top">pdg.job.top module</a></li>
<li class="toctree-l5"><a class="reference internal" href="pdg.job.html#module-pdg.job.workitem_pb2">pdg.job.workitem_pb2 module</a></li>
<li class="toctree-l5"><a class="reference internal" href="pdg.job.html#module-pdg.job">Module contents</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="pdg.testing.html">pdg.testing package</a><ul>
<li class="toctree-l5"><a class="reference internal" href="pdg.testing.html#submodules">Submodules</a></li>
<li class="toctree-l5"><a class="reference internal" href="pdg.testing.html#module-pdg.testing.fake_shotgun_api3">pdg.testing.fake_shotgun_api3 module</a></li>
<li class="toctree-l5"><a class="reference internal" href="pdg.testing.html#module-pdg.testing">Module contents</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="pdg.html#submodules">Submodules</a></li>
<li class="toctree-l3"><a class="reference internal" href="pdg.html#module-pdg.callback">pdg.callback module</a></li>
<li class="toctree-l3"><a class="reference internal" href="pdg.html#module-pdg.dependency">pdg.dependency module</a></li>
<li class="toctree-l3"><a class="reference internal" href="pdg.html#module-pdg.depthfirstcook">pdg.depthfirstcook module</a></li>
<li class="toctree-l3"><a class="reference internal" href="pdg.html#module-pdg.mapper">pdg.mapper module</a></li>
<li class="toctree-l3"><a class="reference internal" href="pdg.html#module-pdg.node">pdg.node module</a></li>
<li class="toctree-l3"><a class="reference internal" href="pdg.html#module-pdg.parms">pdg.parms module</a></li>
<li class="toctree-l3"><a class="reference internal" href="pdg.html#module-pdg.partitioner">pdg.partitioner module</a></li>
<li class="toctree-l3"><a class="reference internal" href="pdg.html#module-pdg.processor">pdg.processor module</a></li>
<li class="toctree-l3"><a class="reference internal" href="pdg.html#module-pdg.scheduler">pdg.scheduler module</a></li>
<li class="toctree-l3"><a class="reference internal" href="pdg.html#module-pdg.staticcook">pdg.staticcook module</a></li>
<li class="toctree-l3"><a class="reference internal" href="pdg.html#module-pdg.utils">pdg.utils module</a></li>
<li class="toctree-l3"><a class="reference internal" href="pdg.html#module-pdg.workitem">pdg.workitem module</a></li>
<li class="toctree-l3"><a class="reference internal" href="pdg.html#module-pdg">Module contents</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="pdgjob.html">pdgjob package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="pdgjob.html#submodules">Submodules</a></li>
<li class="toctree-l3"><a class="reference internal" href="pdgjob.html#module-pdgjob.mayarpc">pdgjob.mayarpc module</a></li>
<li class="toctree-l3"><a class="reference internal" href="pdgjob.html#module-pdgjob.pdgcmd">pdgjob.pdgcmd module</a></li>
<li class="toctree-l3"><a class="reference internal" href="pdgjob.html#module-pdgjob.sharedserver">pdgjob.sharedserver module</a></li>
<li class="toctree-l3"><a class="reference internal" href="pdgjob.html#pdgjob-shotgunrpc-module">pdgjob.shotgunrpc module</a></li>
<li class="toctree-l3"><a class="reference internal" href="pdgjob.html#module-pdgjob">Module contents</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="perfmon_sum.html">perfmon_sum module</a></li>
<li class="toctree-l2"><a class="reference internal" href="poptoolutils.html">poptoolutils module</a></li>
<li class="toctree-l2"><a class="reference internal" href="poselib.html">poselib package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="poselib.html#submodules">Submodules</a></li>
<li class="toctree-l3"><a class="reference internal" href="poselib.html#poselib-applywidget-module">poselib.applywidget module</a></li>
<li class="toctree-l3"><a class="reference internal" href="poselib.html#poselib-capturewidget-module">poselib.capturewidget module</a></li>
<li class="toctree-l3"><a class="reference internal" href="poselib.html#poselib-character-module">poselib.character module</a></li>
<li class="toctree-l3"><a class="reference internal" href="poselib.html#poselib-chopdata-module">poselib.chopdata module</a></li>
<li class="toctree-l3"><a class="reference internal" href="poselib.html#poselib-helpers-module">poselib.helpers module</a></li>
<li class="toctree-l3"><a class="reference internal" href="poselib.html#poselib-infowindow-module">poselib.infowindow module</a></li>
<li class="toctree-l3"><a class="reference internal" href="poselib.html#poselib-itembrowser-module">poselib.itembrowser module</a></li>
<li class="toctree-l3"><a class="reference internal" href="poselib.html#poselib-itemgrid-module">poselib.itemgrid module</a></li>
<li class="toctree-l3"><a class="reference internal" href="poselib.html#poselib-itemlibrary-module">poselib.itemlibrary module</a></li>
<li class="toctree-l3"><a class="reference internal" href="poselib.html#poselib-itemnavigator-module">poselib.itemnavigator module</a></li>
<li class="toctree-l3"><a class="reference internal" href="poselib.html#poselib-plglobals-module">poselib.plglobals module</a></li>
<li class="toctree-l3"><a class="reference internal" href="poselib.html#poselib-pose-module">poselib.pose module</a></li>
<li class="toctree-l3"><a class="reference internal" href="poselib.html#poselib-posebrowser-module">poselib.posebrowser module</a></li>
<li class="toctree-l3"><a class="reference internal" href="poselib.html#poselib-posegrid-module">poselib.posegrid module</a></li>
<li class="toctree-l3"><a class="reference internal" href="poselib.html#poselib-poselib-module">poselib.poselib module</a></li>
<li class="toctree-l3"><a class="reference internal" href="poselib.html#poselib-posemodel-module">poselib.posemodel module</a></li>
<li class="toctree-l3"><a class="reference internal" href="poselib.html#module-poselib.settings">poselib.settings module</a></li>
<li class="toctree-l3"><a class="reference internal" href="poselib.html#module-poselib">Module contents</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="posespacedeform.html">posespacedeform package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="posespacedeform.html#subpackages">Subpackages</a><ul>
<li class="toctree-l4"><a class="reference internal" href="posespacedeform.ui.html">posespacedeform.ui package</a><ul>
<li class="toctree-l5"><a class="reference internal" href="posespacedeform.ui.html#submodules">Submodules</a></li>
<li class="toctree-l5"><a class="reference internal" href="posespacedeform.ui.html#posespacedeform-ui-uiactions-module">posespacedeform.ui.uiActions module</a></li>
<li class="toctree-l5"><a class="reference internal" href="posespacedeform.ui.html#posespacedeform-ui-uilineedit-module">posespacedeform.ui.uiLineEdit module</a></li>
<li class="toctree-l5"><a class="reference internal" href="posespacedeform.ui.html#posespacedeform-ui-uilineeditlist-module">posespacedeform.ui.uiLineEditList module</a></li>
<li class="toctree-l5"><a class="reference internal" href="posespacedeform.ui.html#posespacedeform-ui-uinavigation-module">posespacedeform.ui.uiNavigation module</a></li>
<li class="toctree-l5"><a class="reference internal" href="posespacedeform.ui.html#module-posespacedeform.ui.uiParamLabelButton">posespacedeform.ui.uiParamLabelButton module</a></li>
<li class="toctree-l5"><a class="reference internal" href="posespacedeform.ui.html#module-posespacedeform.ui.uiParamName">posespacedeform.ui.uiParamName module</a></li>
<li class="toctree-l5"><a class="reference internal" href="posespacedeform.ui.html#module-posespacedeform.ui.uiParamString">posespacedeform.ui.uiParamString module</a></li>
<li class="toctree-l5"><a class="reference internal" href="posespacedeform.ui.html#posespacedeform-ui-uitogglebutton-module">posespacedeform.ui.uiToggleButton module</a></li>
<li class="toctree-l5"><a class="reference internal" href="posespacedeform.ui.html#module-posespacedeform.ui">Module contents</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="posespacedeform.utils.html">posespacedeform.utils package</a><ul>
<li class="toctree-l5"><a class="reference internal" href="posespacedeform.utils.html#module-posespacedeform.utils">Module contents</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="posespacedeform.html#submodules">Submodules</a></li>
<li class="toctree-l3"><a class="reference internal" href="posespacedeform.html#posespacedeform-builder-module">posespacedeform.Builder module</a></li>
<li class="toctree-l3"><a class="reference internal" href="posespacedeform.html#posespacedeform-buildgui-module">posespacedeform.buildGUI module</a></li>
<li class="toctree-l3"><a class="reference internal" href="posespacedeform.html#posespacedeform-defaults-module">posespacedeform.defaults module</a></li>
<li class="toctree-l3"><a class="reference internal" href="posespacedeform.html#posespacedeform-driversgui-module">posespacedeform.driversGUI module</a></li>
<li class="toctree-l3"><a class="reference internal" href="posespacedeform.html#posespacedeform-editgui-module">posespacedeform.editGUI module</a></li>
<li class="toctree-l3"><a class="reference internal" href="posespacedeform.html#posespacedeform-initgui-module">posespacedeform.initGUI module</a></li>
<li class="toctree-l3"><a class="reference internal" href="posespacedeform.html#posespacedeform-maingui-module">posespacedeform.mainGUI module</a></li>
<li class="toctree-l3"><a class="reference internal" href="posespacedeform.html#posespacedeform-namegui-module">posespacedeform.nameGUI module</a></li>
<li class="toctree-l3"><a class="reference internal" href="posespacedeform.html#posespacedeform-opengui-module">posespacedeform.openGUI module</a></li>
<li class="toctree-l3"><a class="reference internal" href="posespacedeform.html#posespacedeform-poseshapegui-module">posespacedeform.poseshapeGUI module</a></li>
<li class="toctree-l3"><a class="reference internal" href="posespacedeform.html#posespacedeform-psdgui-module">posespacedeform.psdGUI module</a></li>
<li class="toctree-l3"><a class="reference internal" href="posespacedeform.html#posespacedeform-qtextendedclasses-module">posespacedeform.qtExtendedClasses module</a></li>
<li class="toctree-l3"><a class="reference internal" href="posespacedeform.html#module-posespacedeform">Module contents</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="poster.html">poster package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="poster.html#submodules">Submodules</a></li>
<li class="toctree-l3"><a class="reference internal" href="poster.html#module-poster.encode">poster.encode module</a></li>
<li class="toctree-l3"><a class="reference internal" href="poster.html#module-poster.streaminghttp">poster.streaminghttp module</a></li>
<li class="toctree-l3"><a class="reference internal" href="poster.html#module-poster">Module contents</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="pyro2.html">pyro2 module</a></li>
<li class="toctree-l2"><a class="reference internal" href="quickplanes.html">quickplanes module</a></li>
<li class="toctree-l2"><a class="reference internal" href="radialmenu.html">radialmenu module</a></li>
<li class="toctree-l2"><a class="reference internal" href="rendertracker.html">rendertracker module</a></li>
<li class="toctree-l2"><a class="reference internal" href="rigtoolutils.html">rigtoolutils package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="rigtoolutils.html#submodules">Submodules</a></li>
<li class="toctree-l3"><a class="reference internal" href="rigtoolutils.html#module-rigtoolutils.boneiktwisttool">rigtoolutils.boneiktwisttool module</a></li>
<li class="toctree-l3"><a class="reference internal" href="rigtoolutils.html#module-rigtoolutils.boneiktwistuserinput">rigtoolutils.boneiktwistuserinput module</a></li>
<li class="toctree-l3"><a class="reference internal" href="rigtoolutils.html#module-rigtoolutils.fkcontrols">rigtoolutils.fkcontrols module</a></li>
<li class="toctree-l3"><a class="reference internal" href="rigtoolutils.html#module-rigtoolutils.fkikinterfacecontrol">rigtoolutils.fkikinterfacecontrol module</a></li>
<li class="toctree-l3"><a class="reference internal" href="rigtoolutils.html#module-rigtoolutils.ikbonestretch">rigtoolutils.ikbonestretch module</a></li>
<li class="toctree-l3"><a class="reference internal" href="rigtoolutils.html#module-rigtoolutils.iktwistcontrols">rigtoolutils.iktwistcontrols module</a></li>
<li class="toctree-l3"><a class="reference internal" href="rigtoolutils.html#module-rigtoolutils.iktwistnaming">rigtoolutils.iktwistnaming module</a></li>
<li class="toctree-l3"><a class="reference internal" href="rigtoolutils.html#module-rigtoolutils.iktwistnetworkeditor">rigtoolutils.iktwistnetworkeditor module</a></li>
<li class="toctree-l3"><a class="reference internal" href="rigtoolutils.html#module-rigtoolutils.iktwisttool">rigtoolutils.iktwisttool module</a></li>
<li class="toctree-l3"><a class="reference internal" href="rigtoolutils.html#module-rigtoolutils.iktwistuserinput">rigtoolutils.iktwistuserinput module</a></li>
<li class="toctree-l3"><a class="reference internal" href="rigtoolutils.html#module-rigtoolutils.randomnulls">rigtoolutils.randomnulls module</a></li>
<li class="toctree-l3"><a class="reference internal" href="rigtoolutils.html#module-rigtoolutils.rigutils">rigtoolutils.rigutils module</a></li>
<li class="toctree-l3"><a class="reference internal" href="rigtoolutils.html#module-rigtoolutils">Module contents</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="rmands.html">rmands module</a></li>
<li class="toctree-l2"><a class="reference internal" href="roptoolutils.html">roptoolutils module</a></li>
<li class="toctree-l2"><a class="reference internal" href="sas.html">sas package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="sas.html#submodules">Submodules</a></li>
<li class="toctree-l3"><a class="reference internal" href="sas.html#module-sas.inspectasset">sas.inspectasset module</a></li>
<li class="toctree-l3"><a class="reference internal" href="sas.html#module-sas.localassets">sas.localassets module</a></li>
<li class="toctree-l3"><a class="reference internal" href="sas.html#module-sas.webresponder">sas.webresponder module</a></li>
<li class="toctree-l3"><a class="reference internal" href="sas.html#module-sas">Module contents</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="shadingutils.html">shadingutils module</a></li>
<li class="toctree-l2"><a class="reference internal" href="shelfutils.html">shelfutils module</a></li>
<li class="toctree-l2"><a class="reference internal" href="shopclerks.html">shopclerks package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="shopclerks.html#submodules">Submodules</a></li>
<li class="toctree-l3"><a class="reference internal" href="shopclerks.html#module-shopclerks.clerkloader">shopclerks.clerkloader module</a></li>
<li class="toctree-l3"><a class="reference internal" href="shopclerks.html#module-shopclerks.clerkutil">shopclerks.clerkutil module</a></li>
<li class="toctree-l3"><a class="reference internal" href="shopclerks.html#module-shopclerks.i3dclerk">shopclerks.i3dclerk module</a></li>
<li class="toctree-l3"><a class="reference internal" href="shopclerks.html#module-shopclerks.ifdclerk">shopclerks.ifdclerk module</a></li>
<li class="toctree-l3"><a class="reference internal" href="shopclerks.html#module-shopclerks.ribclerk">shopclerks.ribclerk module</a></li>
<li class="toctree-l3"><a class="reference internal" href="shopclerks.html#module-shopclerks.ribvstruct">shopclerks.ribvstruct module</a></li>
<li class="toctree-l3"><a class="reference internal" href="shopclerks.html#module-shopclerks">Module contents</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="shoptoolutils.html">shoptoolutils module</a></li>
<li class="toctree-l2"><a class="reference internal" href="simtracker.html">simtracker module</a></li>
<li class="toctree-l2"><a class="reference internal" href="skytoolutils.html">skytoolutils module</a></li>
<li class="toctree-l2"><a class="reference internal" href="soptoolutils.html">soptoolutils module</a></li>
<li class="toctree-l2"><a class="reference internal" href="soputils.html">soputils module</a></li>
<li class="toctree-l2"><a class="reference internal" href="stateutils.html">stateutils module</a></li>
<li class="toctree-l2"><a class="reference internal" href="stroketoolutils.html">stroketoolutils module</a></li>
<li class="toctree-l2"><a class="reference internal" href="terraintoolutils.html">terraintoolutils module</a></li>
<li class="toctree-l2"><a class="reference internal" href="toolprompts.html">toolprompts module</a></li>
<li class="toctree-l2"><a class="reference internal" href="toolutils.html">toolutils module</a></li>
<li class="toctree-l2"><a class="reference internal" href="toptoolutils.html">toptoolutils module</a></li>
<li class="toctree-l2"><a class="reference internal" href="uiutils.html">uiutils module</a></li>
<li class="toctree-l2"><a class="reference internal" href="vexpressionmenu.html">vexpressionmenu module</a></li>
<li class="toctree-l2"><a class="reference internal" href="viewerstate.html">viewerstate package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="viewerstate.html#submodules">Submodules</a></li>
<li class="toctree-l3"><a class="reference internal" href="viewerstate.html#module-viewerstate.interface">viewerstate.interface module</a></li>
<li class="toctree-l3"><a class="reference internal" href="viewerstate.html#module-viewerstate.utils">viewerstate.utils module</a></li>
<li class="toctree-l3"><a class="reference internal" href="viewerstate.html#module-viewerstate">Module contents</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="volumetoolutils.html">volumetoolutils module</a></li>
<li class="toctree-l2"><a class="reference internal" href="vopcallbacks.html">vopcallbacks module</a></li>
<li class="toctree-l2"><a class="reference internal" href="vopfxmenu.html">vopfxmenu module</a></li>
<li class="toctree-l2"><a class="reference internal" href="vopnettoolutils.html">vopnettoolutils module</a></li>
<li class="toctree-l2"><a class="reference internal" href="voptoolutils.html">voptoolutils module</a></li>
<li class="toctree-l2"><a class="reference internal" href="whoosh.html">whoosh package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="whoosh.html#subpackages">Subpackages</a><ul>
<li class="toctree-l4"><a class="reference internal" href="whoosh.analysis.html">whoosh.analysis package</a><ul>
<li class="toctree-l5"><a class="reference internal" href="whoosh.analysis.html#submodules">Submodules</a></li>
<li class="toctree-l5"><a class="reference internal" href="whoosh.analysis.html#module-whoosh.analysis.acore">whoosh.analysis.acore module</a></li>
<li class="toctree-l5"><a class="reference internal" href="whoosh.analysis.html#module-whoosh.analysis.analyzers">whoosh.analysis.analyzers module</a></li>
<li class="toctree-l5"><a class="reference internal" href="whoosh.analysis.html#module-whoosh.analysis.filters">whoosh.analysis.filters module</a></li>
<li class="toctree-l5"><a class="reference internal" href="whoosh.analysis.html#module-whoosh.analysis.intraword">whoosh.analysis.intraword module</a></li>
<li class="toctree-l5"><a class="reference internal" href="whoosh.analysis.html#module-whoosh.analysis.morph">whoosh.analysis.morph module</a></li>
<li class="toctree-l5"><a class="reference internal" href="whoosh.analysis.html#module-whoosh.analysis.ngrams">whoosh.analysis.ngrams module</a></li>
<li class="toctree-l5"><a class="reference internal" href="whoosh.analysis.html#module-whoosh.analysis.tokenizers">whoosh.analysis.tokenizers module</a></li>
<li class="toctree-l5"><a class="reference internal" href="whoosh.analysis.html#module-whoosh.analysis">Module contents</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="whoosh.automata.html">whoosh.automata package</a><ul>
<li class="toctree-l5"><a class="reference internal" href="whoosh.automata.html#submodules">Submodules</a></li>
<li class="toctree-l5"><a class="reference internal" href="whoosh.automata.html#module-whoosh.automata.fsa">whoosh.automata.fsa module</a></li>
<li class="toctree-l5"><a class="reference internal" href="whoosh.automata.html#module-whoosh.automata.glob">whoosh.automata.glob module</a></li>
<li class="toctree-l5"><a class="reference internal" href="whoosh.automata.html#module-whoosh.automata.lev">whoosh.automata.lev module</a></li>
<li class="toctree-l5"><a class="reference internal" href="whoosh.automata.html#module-whoosh.automata.nfa">whoosh.automata.nfa module</a></li>
<li class="toctree-l5"><a class="reference internal" href="whoosh.automata.html#module-whoosh.automata.reg">whoosh.automata.reg module</a></li>
<li class="toctree-l5"><a class="reference internal" href="whoosh.automata.html#module-whoosh.automata">Module contents</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="whoosh.codec.html">whoosh.codec package</a><ul>
<li class="toctree-l5"><a class="reference internal" href="whoosh.codec.html#submodules">Submodules</a></li>
<li class="toctree-l5"><a class="reference internal" href="whoosh.codec.html#module-whoosh.codec.base">whoosh.codec.base module</a></li>
<li class="toctree-l5"><a class="reference internal" href="whoosh.codec.html#module-whoosh.codec.memory">whoosh.codec.memory module</a></li>
<li class="toctree-l5"><a class="reference internal" href="whoosh.codec.html#module-whoosh.codec.plaintext">whoosh.codec.plaintext module</a></li>
<li class="toctree-l5"><a class="reference internal" href="whoosh.codec.html#module-whoosh.codec.whoosh3">whoosh.codec.whoosh3 module</a></li>
<li class="toctree-l5"><a class="reference internal" href="whoosh.codec.html#module-whoosh.codec">Module contents</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="whoosh.filedb.html">whoosh.filedb package</a><ul>
<li class="toctree-l5"><a class="reference internal" href="whoosh.filedb.html#submodules">Submodules</a></li>
<li class="toctree-l5"><a class="reference internal" href="whoosh.filedb.html#module-whoosh.filedb.compound">whoosh.filedb.compound module</a></li>
<li class="toctree-l5"><a class="reference internal" href="whoosh.filedb.html#module-whoosh.filedb.filestore">whoosh.filedb.filestore module</a></li>
<li class="toctree-l5"><a class="reference internal" href="whoosh.filedb.html#module-whoosh.filedb.filetables">whoosh.filedb.filetables module</a></li>
<li class="toctree-l5"><a class="reference internal" href="whoosh.filedb.html#module-whoosh.filedb.gae">whoosh.filedb.gae module</a></li>
<li class="toctree-l5"><a class="reference internal" href="whoosh.filedb.html#module-whoosh.filedb.structfile">whoosh.filedb.structfile module</a></li>
<li class="toctree-l5"><a class="reference internal" href="whoosh.filedb.html#module-whoosh.filedb">Module contents</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="whoosh.lang.html">whoosh.lang package</a><ul>
<li class="toctree-l5"><a class="reference internal" href="whoosh.lang.html#subpackages">Subpackages</a><ul>
<li class="toctree-l6"><a class="reference internal" href="whoosh.lang.snowball.html">whoosh.lang.snowball package</a></li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="whoosh.lang.html#submodules">Submodules</a></li>
<li class="toctree-l5"><a class="reference internal" href="whoosh.lang.html#module-whoosh.lang.dmetaphone">whoosh.lang.dmetaphone module</a></li>
<li class="toctree-l5"><a class="reference internal" href="whoosh.lang.html#module-whoosh.lang.isri">whoosh.lang.isri module</a></li>
<li class="toctree-l5"><a class="reference internal" href="whoosh.lang.html#module-whoosh.lang.lovins">whoosh.lang.lovins module</a></li>
<li class="toctree-l5"><a class="reference internal" href="whoosh.lang.html#module-whoosh.lang.morph_en">whoosh.lang.morph_en module</a></li>
<li class="toctree-l5"><a class="reference internal" href="whoosh.lang.html#module-whoosh.lang.paicehusk">whoosh.lang.paicehusk module</a></li>
<li class="toctree-l5"><a class="reference internal" href="whoosh.lang.html#module-whoosh.lang.phonetic">whoosh.lang.phonetic module</a></li>
<li class="toctree-l5"><a class="reference internal" href="whoosh.lang.html#module-whoosh.lang.porter">whoosh.lang.porter module</a></li>
<li class="toctree-l5"><a class="reference internal" href="whoosh.lang.html#module-whoosh.lang.porter2">whoosh.lang.porter2 module</a></li>
<li class="toctree-l5"><a class="reference internal" href="whoosh.lang.html#module-whoosh.lang.stopwords">whoosh.lang.stopwords module</a></li>
<li class="toctree-l5"><a class="reference internal" href="whoosh.lang.html#module-whoosh.lang.wordnet">whoosh.lang.wordnet module</a></li>
<li class="toctree-l5"><a class="reference internal" href="whoosh.lang.html#module-whoosh.lang">Module contents</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="whoosh.matching.html">whoosh.matching package</a><ul>
<li class="toctree-l5"><a class="reference internal" href="whoosh.matching.html#submodules">Submodules</a></li>
<li class="toctree-l5"><a class="reference internal" href="whoosh.matching.html#module-whoosh.matching.binary">whoosh.matching.binary module</a></li>
<li class="toctree-l5"><a class="reference internal" href="whoosh.matching.html#module-whoosh.matching.combo">whoosh.matching.combo module</a></li>
<li class="toctree-l5"><a class="reference internal" href="whoosh.matching.html#module-whoosh.matching.mcore">whoosh.matching.mcore module</a></li>
<li class="toctree-l5"><a class="reference internal" href="whoosh.matching.html#module-whoosh.matching.wrappers">whoosh.matching.wrappers module</a></li>
<li class="toctree-l5"><a class="reference internal" href="whoosh.matching.html#module-whoosh.matching">Module contents</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="whoosh.qparser.html">whoosh.qparser package</a><ul>
<li class="toctree-l5"><a class="reference internal" href="whoosh.qparser.html#submodules">Submodules</a></li>
<li class="toctree-l5"><a class="reference internal" href="whoosh.qparser.html#module-whoosh.qparser.common">whoosh.qparser.common module</a></li>
<li class="toctree-l5"><a class="reference internal" href="whoosh.qparser.html#module-whoosh.qparser.dateparse">whoosh.qparser.dateparse module</a></li>
<li class="toctree-l5"><a class="reference internal" href="whoosh.qparser.html#module-whoosh.qparser.default">whoosh.qparser.default module</a></li>
<li class="toctree-l5"><a class="reference internal" href="whoosh.qparser.html#module-whoosh.qparser.plugins">whoosh.qparser.plugins module</a></li>
<li class="toctree-l5"><a class="reference internal" href="whoosh.qparser.html#module-whoosh.qparser.syntax">whoosh.qparser.syntax module</a></li>
<li class="toctree-l5"><a class="reference internal" href="whoosh.qparser.html#module-whoosh.qparser.taggers">whoosh.qparser.taggers module</a></li>
<li class="toctree-l5"><a class="reference internal" href="whoosh.qparser.html#module-whoosh.qparser">Module contents</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="whoosh.query.html">whoosh.query package</a><ul>
<li class="toctree-l5"><a class="reference internal" href="whoosh.query.html#submodules">Submodules</a></li>
<li class="toctree-l5"><a class="reference internal" href="whoosh.query.html#module-whoosh.query.compound">whoosh.query.compound module</a></li>
<li class="toctree-l5"><a class="reference internal" href="whoosh.query.html#module-whoosh.query.nested">whoosh.query.nested module</a></li>
<li class="toctree-l5"><a class="reference internal" href="whoosh.query.html#module-whoosh.query.positional">whoosh.query.positional module</a></li>
<li class="toctree-l5"><a class="reference internal" href="whoosh.query.html#module-whoosh.query.qcolumns">whoosh.query.qcolumns module</a></li>
<li class="toctree-l5"><a class="reference internal" href="whoosh.query.html#module-whoosh.query.qcore">whoosh.query.qcore module</a></li>
<li class="toctree-l5"><a class="reference internal" href="whoosh.query.html#module-whoosh.query.ranges">whoosh.query.ranges module</a></li>
<li class="toctree-l5"><a class="reference internal" href="whoosh.query.html#module-whoosh.query.spans">whoosh.query.spans module</a></li>
<li class="toctree-l5"><a class="reference internal" href="whoosh.query.html#module-whoosh.query.terms">whoosh.query.terms module</a></li>
<li class="toctree-l5"><a class="reference internal" href="whoosh.query.html#module-whoosh.query.wrappers">whoosh.query.wrappers module</a></li>
<li class="toctree-l5"><a class="reference internal" href="whoosh.query.html#module-whoosh.query">Module contents</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="whoosh.support.html">whoosh.support package</a><ul>
<li class="toctree-l5"><a class="reference internal" href="whoosh.support.html#submodules">Submodules</a></li>
<li class="toctree-l5"><a class="reference internal" href="whoosh.support.html#module-whoosh.support.base85">whoosh.support.base85 module</a></li>
<li class="toctree-l5"><a class="reference internal" href="whoosh.support.html#module-whoosh.support.bench">whoosh.support.bench module</a></li>
<li class="toctree-l5"><a class="reference internal" href="whoosh.support.html#module-whoosh.support.charset">whoosh.support.charset module</a></li>
<li class="toctree-l5"><a class="reference internal" href="whoosh.support.html#module-whoosh.support.levenshtein">whoosh.support.levenshtein module</a></li>
<li class="toctree-l5"><a class="reference internal" href="whoosh.support.html#module-whoosh.support.relativedelta">whoosh.support.relativedelta module</a></li>
<li class="toctree-l5"><a class="reference internal" href="whoosh.support.html#module-whoosh.support.unicode">whoosh.support.unicode module</a></li>
<li class="toctree-l5"><a class="reference internal" href="whoosh.support.html#module-whoosh.support">Module contents</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="whoosh.util.html">whoosh.util package</a><ul>
<li class="toctree-l5"><a class="reference internal" href="whoosh.util.html#submodules">Submodules</a></li>
<li class="toctree-l5"><a class="reference internal" href="whoosh.util.html#module-whoosh.util.cache">whoosh.util.cache module</a></li>
<li class="toctree-l5"><a class="reference internal" href="whoosh.util.html#module-whoosh.util.filelock">whoosh.util.filelock module</a></li>
<li class="toctree-l5"><a class="reference internal" href="whoosh.util.html#module-whoosh.util.loading">whoosh.util.loading module</a></li>
<li class="toctree-l5"><a class="reference internal" href="whoosh.util.html#module-whoosh.util.numeric">whoosh.util.numeric module</a></li>
<li class="toctree-l5"><a class="reference internal" href="whoosh.util.html#module-whoosh.util.numlists">whoosh.util.numlists module</a></li>
<li class="toctree-l5"><a class="reference internal" href="whoosh.util.html#module-whoosh.util.testing">whoosh.util.testing module</a></li>
<li class="toctree-l5"><a class="reference internal" href="whoosh.util.html#module-whoosh.util.text">whoosh.util.text module</a></li>
<li class="toctree-l5"><a class="reference internal" href="whoosh.util.html#module-whoosh.util.times">whoosh.util.times module</a></li>
<li class="toctree-l5"><a class="reference internal" href="whoosh.util.html#module-whoosh.util.varints">whoosh.util.varints module</a></li>
<li class="toctree-l5"><a class="reference internal" href="whoosh.util.html#module-whoosh.util.versions">whoosh.util.versions module</a></li>
<li class="toctree-l5"><a class="reference internal" href="whoosh.util.html#module-whoosh.util">Module contents</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="whoosh.html#submodules">Submodules</a></li>
<li class="toctree-l3"><a class="reference internal" href="whoosh.html#module-whoosh.classify">whoosh.classify module</a></li>
<li class="toctree-l3"><a class="reference internal" href="whoosh.html#module-whoosh.collectors">whoosh.collectors module</a></li>
<li class="toctree-l3"><a class="reference internal" href="whoosh.html#module-whoosh.columns">whoosh.columns module</a></li>
<li class="toctree-l3"><a class="reference internal" href="whoosh.html#module-whoosh.compat">whoosh.compat module</a></li>
<li class="toctree-l3"><a class="reference internal" href="whoosh.html#module-whoosh.externalsort">whoosh.externalsort module</a></li>
<li class="toctree-l3"><a class="reference internal" href="whoosh.html#module-whoosh.fields">whoosh.fields module</a></li>
<li class="toctree-l3"><a class="reference internal" href="whoosh.html#module-whoosh.formats">whoosh.formats module</a></li>
<li class="toctree-l3"><a class="reference internal" href="whoosh.html#module-whoosh.highlight">whoosh.highlight module</a></li>
<li class="toctree-l3"><a class="reference internal" href="whoosh.html#module-whoosh.idsets">whoosh.idsets module</a></li>
<li class="toctree-l3"><a class="reference internal" href="whoosh.html#module-whoosh.index">whoosh.index module</a></li>
<li class="toctree-l3"><a class="reference internal" href="whoosh.html#module-whoosh.legacy">whoosh.legacy module</a></li>
<li class="toctree-l3"><a class="reference internal" href="whoosh.html#module-whoosh.multiproc">whoosh.multiproc module</a></li>
<li class="toctree-l3"><a class="reference internal" href="whoosh.html#module-whoosh.reading">whoosh.reading module</a></li>
<li class="toctree-l3"><a class="reference internal" href="whoosh.html#module-whoosh.scoring">whoosh.scoring module</a></li>
<li class="toctree-l3"><a class="reference internal" href="whoosh.html#module-whoosh.searching">whoosh.searching module</a></li>
<li class="toctree-l3"><a class="reference internal" href="whoosh.html#module-whoosh.sorting">whoosh.sorting module</a></li>
<li class="toctree-l3"><a class="reference internal" href="whoosh.html#module-whoosh.spelling">whoosh.spelling module</a></li>
<li class="toctree-l3"><a class="reference internal" href="whoosh.html#module-whoosh.system">whoosh.system module</a></li>
<li class="toctree-l3"><a class="reference internal" href="whoosh.html#module-whoosh.writing">whoosh.writing module</a></li>
<li class="toctree-l3"><a class="reference internal" href="whoosh.html#module-whoosh">Module contents</a></li>
</ul>
</li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Houdini Python modules</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
          <li><a href="modules.html">python2.7libs</a> &raquo;</li>
        
      <li>hou module</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/hou.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="module-hou">
<span id="hou-module"></span><h1>hou module<a class="headerlink" href="#module-hou" title="Permalink to this headline"></a></h1>
<p>hou</p>
<p>Module containing all the sub-modules, classes, and functions to access
Houdini.</p>
<p>API</p>
<dl class="class">
<dt id="hou.Agent">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">Agent</code><a class="headerlink" href="#hou.Agent" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.PackedPrim" title="hou.PackedPrim"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.PackedPrim</span></code></a></p>
<p>An agent primitive.</p>
<p>See Crowd Agents for more information.</p>
<dl class="method">
<dt id="hou.Agent.clipCatalog">
<code class="descname">clipCatalog</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.AgentClip<a class="headerlink" href="#hou.Agent.clipCatalog" title="Permalink to this definition"></a></dt>
<dd><p>Returns all of the animation clips that are available. This is
equivalent to definition().clips().</p>
</dd></dl>

<dl class="method">
<dt id="hou.Agent.clipTimes">
<code class="descname">clipTimes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.Agent.clipTimes" title="Permalink to this definition"></a></dt>
<dd><p>clipWeights(self) -&gt; tuple of float</p>
<blockquote>
<div>Returns the blend weights for the agents animation clips.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.Agent.clipWeights">
<code class="descname">clipWeights</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.Agent.clipWeights" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.Agent.clips">
<code class="descname">clips</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.AgentClip<a class="headerlink" href="#hou.Agent.clips" title="Permalink to this definition"></a></dt>
<dd><p>Returns the agents current animation clips.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Agent.collisionLayer">
<code class="descname">collisionLayer</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.AgentLayer<a class="headerlink" href="#hou.Agent.collisionLayer" title="Permalink to this definition"></a></dt>
<dd><p>Returns the current collision layer of the agent.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Agent.currentLayer">
<code class="descname">currentLayer</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.AgentLayer<a class="headerlink" href="#hou.Agent.currentLayer" title="Permalink to this definition"></a></dt>
<dd><p>Returns the current display layer of the agent.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Agent.definition">
<code class="descname">definition</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.AgentDefinition<a class="headerlink" href="#hou.Agent.definition" title="Permalink to this definition"></a></dt>
<dd><p>Returns the shared agent definition.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Agent.layers">
<code class="descname">layers</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.AgentLayer<a class="headerlink" href="#hou.Agent.layers" title="Permalink to this definition"></a></dt>
<dd><p>Returns all of the layers that are available. This is equivalent to
definition().layers().</p>
</dd></dl>

<dl class="method">
<dt id="hou.Agent.localTransform">
<code class="descname">localTransform</code><span class="sig-paren">(</span><em>self</em>, <em>transform</em><span class="sig-paren">)</span> &#x2192; hou.Matrix4<a class="headerlink" href="#hou.Agent.localTransform" title="Permalink to this definition"></a></dt>
<dd><p>Returns the current local space transform of an agent primitives
bone.</p>
<dl class="docutils">
<dt>transform</dt>
<dd>Index of a transform in the agents rig.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hou.Agent.rig">
<code class="descname">rig</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.AgentRig<a class="headerlink" href="#hou.Agent.rig" title="Permalink to this definition"></a></dt>
<dd><p>Returns the agents rig. This is equivalent to definition().rig().</p>
</dd></dl>

<dl class="method">
<dt id="hou.Agent.setClipTimes">
<code class="descname">setClipTimes</code><span class="sig-paren">(</span><em>times</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Agent.setClipTimes" title="Permalink to this definition"></a></dt>
<dd><p>Sets the current times for the agents animation clips.</p>
<p>Raises hou.GeometryPermissionError if this geometry is not
modifiable.</p>
<dl class="docutils">
<dt>times</dt>
<dd>A float sequence.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hou.Agent.setClipWeights">
<code class="descname">setClipWeights</code><span class="sig-paren">(</span><em>weights</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Agent.setClipWeights" title="Permalink to this definition"></a></dt>
<dd><p>Sets the blend weights for the agents animation clips.</p>
<p>Raises hou.GeometryPermissionError if this geometry is not
modifiable.</p>
<dl class="docutils">
<dt>weights</dt>
<dd>A float sequence.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hou.Agent.setClips">
<code class="descname">setClips</code><span class="sig-paren">(</span><em>clips</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Agent.setClips" title="Permalink to this definition"></a></dt>
<dd><p>Sets the agents current animation clips.</p>
<p>Raises hou.GeometryPermissionError if this geometry is not
modifiable.</p>
<dl class="docutils">
<dt>clips</dt>
<dd>A hou.AgentClip sequence.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hou.Agent.setCollisionLayer">
<code class="descname">setCollisionLayer</code><span class="sig-paren">(</span><em>layer</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Agent.setCollisionLayer" title="Permalink to this definition"></a></dt>
<dd><p>Sets the agents current collision layer.</p>
<p>Raises hou.GeometryPermissionError if this geometry is not
modifiable.</p>
<dl class="docutils">
<dt>layer</dt>
<dd>A hou.AgentLayer.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hou.Agent.setCurrentLayer">
<code class="descname">setCurrentLayer</code><span class="sig-paren">(</span><em>layer</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Agent.setCurrentLayer" title="Permalink to this definition"></a></dt>
<dd><p>Sets the agents current display layer.</p>
<p>Raises hou.GeometryPermissionError if this geometry is not
modifiable.</p>
<dl class="docutils">
<dt>layer</dt>
<dd>A hou.AgentLayer.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hou.Agent.setDefinition">
<code class="descname">setDefinition</code><span class="sig-paren">(</span><em>definition</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Agent.setDefinition" title="Permalink to this definition"></a></dt>
<dd><p>Changes the agents definition. If the new definitions rig has a
different number of transforms, the agents current transforms will
be reset. The agents current clips will be reset if the new
definition does not contain clips with the same names.</p>
<p>Raises hou.GeometryPermissionError if this geometry is not
modifiable.</p>
<dl class="docutils">
<dt>definition</dt>
<dd>A hou.AgentDefinition.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hou.Agent.setLocalTransform">
<code class="descname">setLocalTransform</code><span class="sig-paren">(</span><em>xform</em>, <em>index</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Agent.setLocalTransform" title="Permalink to this definition"></a></dt>
<dd><p>Sets the current local space transform of an agent primitives bone.</p>
<p>Raises hou.GeometryPermissionError if this geometry is not
modifiable.</p>
<dl class="docutils">
<dt>xform</dt>
<dd>A hou.Matrix4.</dd>
<dt>index</dt>
<dd>Index of a transform in the agents rig.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hou.Agent.setWorldTransform">
<code class="descname">setWorldTransform</code><span class="sig-paren">(</span><em>xform</em>, <em>index</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Agent.setWorldTransform" title="Permalink to this definition"></a></dt>
<dd><p>Sets the current world space transform of an agent primitives bone.</p>
<p>Raises hou.GeometryPermissionError if this geometry is not
modifiable.</p>
<dl class="docutils">
<dt>xform</dt>
<dd>A hou.Matrix4.</dd>
<dt>index</dt>
<dd>Index of a transform in the agents rig.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hou.Agent.shapeLibrary">
<code class="descname">shapeLibrary</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.AgentShapeLibrary<a class="headerlink" href="#hou.Agent.shapeLibrary" title="Permalink to this definition"></a></dt>
<dd><p>Returns the agents shape library. This is equivalent to
definition().shapeLibrary().</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.Agent.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.Agent.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

<dl class="method">
<dt id="hou.Agent.worldTransform">
<code class="descname">worldTransform</code><span class="sig-paren">(</span><em>self</em>, <em>transform</em><span class="sig-paren">)</span> &#x2192; hou.Matrix4<a class="headerlink" href="#hou.Agent.worldTransform" title="Permalink to this definition"></a></dt>
<dd><p>Returns the current world space transform of an agent primitives
bone.</p>
<dl class="docutils">
<dt>transform</dt>
<dd>Index of a transform in the agents rig.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.AgentClip">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">AgentClip</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.AgentClip" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>An agents animation clip.</p>
<p>See Crowd Animation Clips for more information.</p>
<dl class="method">
<dt id="hou.AgentClip.channelNames">
<code class="descname">channelNames</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of str<a class="headerlink" href="#hou.AgentClip.channelNames" title="Permalink to this definition"></a></dt>
<dd><p>Returns the names of the channels in the clip.</p>
</dd></dl>

<dl class="method">
<dt id="hou.AgentClip.data">
<code class="descname">data</code><span class="sig-paren">(</span><em>self</em>, <em>binary</em>, <em>worldspace = False</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.AgentClip.data" title="Permalink to this definition"></a></dt>
<dd><p>Returns the clip data in ASCII or binary.</p>
<dl class="docutils">
<dt>binary</dt>
<dd>Specifies whether the clip data should be saved in ASCII (.clip)
or binary (.bclip) format.</dd>
<dt>worldspace</dt>
<dd>Specifies whether the transform channels should be saved in
local or world space.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hou.AgentClip.fileName">
<code class="descname">fileName</code><span class="sig-paren">(</span><em>self</em>, <em>expanded = False</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.AgentClip.fileName" title="Permalink to this definition"></a></dt>
<dd><p>If the clip is an external reference, returns the path to the file
on disk.</p>
<dl class="docutils">
<dt>expanded</dt>
<dd>Specifies whether to expand any variables in the path, such as
$HIP.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hou.AgentClip.isExternalReference">
<code class="descname">isExternalReference</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.AgentClip.isExternalReference" title="Permalink to this definition"></a></dt>
<dd><p>Returns a bool indicating whether the clip references a file on
disk.</p>
</dd></dl>

<dl class="method">
<dt id="hou.AgentClip.length">
<code class="descname">length</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#hou.AgentClip.length" title="Permalink to this definition"></a></dt>
<dd><p>Returns the length (in seconds) of the clip.</p>
</dd></dl>

<dl class="method">
<dt id="hou.AgentClip.name">
<code class="descname">name</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.AgentClip.name" title="Permalink to this definition"></a></dt>
<dd><p>Returns the name of the clip.</p>
</dd></dl>

<dl class="method">
<dt id="hou.AgentClip.sample">
<code class="descname">sample</code><span class="sig-paren">(</span><em>self</em>, <em>time</em>, <em>channel_name</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#hou.AgentClip.sample" title="Permalink to this definition"></a></dt>
<dd><dl class="docutils">
<dt>time</dt>
<dd>The time (in seconds) to evaluate the clip at.</dd>
<dt>channel_name</dt>
<dd>Name of a channel in the clip. See hou.AgentClip.channelNames.</dd>
</dl>
<p>Evaluates the clip at the given time and returns the value of the
specified channel. For sampling the clips transforms, use
hou.AgentClip.sampleLocal or hou.AgentClip.sampleWorld.</p>
</dd></dl>

<dl class="method">
<dt id="hou.AgentClip.sampleLocal">
<code class="descname">sampleLocal</code><span class="sig-paren">(</span><em>self</em>, <em>time</em>, <em>transform</em><span class="sig-paren">)</span> &#x2192; hou.Matrix4<a class="headerlink" href="#hou.AgentClip.sampleLocal" title="Permalink to this definition"></a></dt>
<dd><dl class="docutils">
<dt>time</dt>
<dd>The time (in seconds) to evaluate the clip at.</dd>
<dt>transform</dt>
<dd>Index of a transform in the agents rig.</dd>
</dl>
<p>Evaluates the clip at the given time and returns the local
transform.</p>
</dd></dl>

<dl class="method">
<dt id="hou.AgentClip.sampleRate">
<code class="descname">sampleRate</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#hou.AgentClip.sampleRate" title="Permalink to this definition"></a></dt>
<dd><p>Returns the sample rate of the clip.</p>
</dd></dl>

<dl class="method">
<dt id="hou.AgentClip.sampleWorld">
<code class="descname">sampleWorld</code><span class="sig-paren">(</span><em>self</em>, <em>time</em>, <em>transform</em><span class="sig-paren">)</span> &#x2192; hou.Matrix4<a class="headerlink" href="#hou.AgentClip.sampleWorld" title="Permalink to this definition"></a></dt>
<dd><dl class="docutils">
<dt>time</dt>
<dd>The time (in seconds) to evaluate the clip at.</dd>
<dt>transform</dt>
<dd>Index of a transform in the agents rig.</dd>
</dl>
<p>Evaluates the clip at the given time and returns the world
transform.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.AgentClip.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.AgentClip.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.AgentDefinition">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">AgentDefinition</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.AgentDefinition" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>The shared data for an agent primitive.</p>
<p>An agent definition includes a rig, shape library, layers, and clips,
and can be shared between agent primitives. See Agent Primitives for
more information.</p>
<p>Since an agent definition is shared between copies of an agent primitive
(such as agents in an upstream SOPs geometry), the definition returned
by hou.Agent.definition is read-only. The hou.AgentDefinition.freeze
method can be used to create a modifiable copy of an agent definition.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.crowds.findAgentDefinitions</li>
</ul>
</div></blockquote>
<dl class="method">
<dt id="hou.AgentDefinition.addClip">
<code class="descname">addClip</code><span class="sig-paren">(</span><em>self</em>, <em>clip</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.AgentDefinition.addClip" title="Permalink to this definition"></a></dt>
<dd><p>Adds a clip to the agent definition.</p>
<p>Raises hou.GeometryPermissionError if the agent definition is not
modifiable.</p>
<p>Raises hou.OperationFailed if the clip is associated with a
different rig.</p>
<dl class="docutils">
<dt>clip</dt>
<dd>A hou.AgentClip.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hou.AgentDefinition.addLayer">
<code class="descname">addLayer</code><span class="sig-paren">(</span><em>self</em>, <em>layer</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.AgentDefinition.addLayer" title="Permalink to this definition"></a></dt>
<dd><p>Adds a layer to the agent definition.</p>
<p>Raises hou.GeometryPermissionError if the agent definition is not
modifiable.</p>
<p>Raises hou.OperationFailed if the layer is associated with a
different rig or shape library.</p>
<dl class="docutils">
<dt>layer</dt>
<dd>A hou.AgentLayer.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hou.AgentDefinition.addTransformGroup">
<code class="descname">addTransformGroup</code><span class="sig-paren">(</span><em>self</em>, <em>group</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.AgentDefinition.addTransformGroup" title="Permalink to this definition"></a></dt>
<dd><p>Adds a transform group to the agent definition.</p>
<p>Raises hou.GeometryPermissionError if the agent definition is not
modifiable.</p>
<p>Raises hou.OperationFailed if the group is associated with a
different rig.</p>
<dl class="docutils">
<dt>group</dt>
<dd>A hou.AgentTransformGroup.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hou.AgentDefinition.clips">
<code class="descname">clips</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.AgentClip<a class="headerlink" href="#hou.AgentDefinition.clips" title="Permalink to this definition"></a></dt>
<dd><p>Returns a list of the clips in the agent definition.</p>
</dd></dl>

<dl class="method">
<dt id="hou.AgentDefinition.findClip">
<code class="descname">findClip</code><span class="sig-paren">(</span><em>self</em>, <em>name</em><span class="sig-paren">)</span> &#x2192; hou.AgentClip<a class="headerlink" href="#hou.AgentDefinition.findClip" title="Permalink to this definition"></a></dt>
<dd><p>Finds the clip with the specified name, or None if no such clip
exists.</p>
</dd></dl>

<dl class="method">
<dt id="hou.AgentDefinition.findLayer">
<code class="descname">findLayer</code><span class="sig-paren">(</span><em>self</em>, <em>name</em><span class="sig-paren">)</span> &#x2192; hou.AgentLayer<a class="headerlink" href="#hou.AgentDefinition.findLayer" title="Permalink to this definition"></a></dt>
<dd><p>Finds the layer with the specified name, or None if no such layer
exists.</p>
</dd></dl>

<dl class="method">
<dt id="hou.AgentDefinition.findTransformGroup">
<code class="descname">findTransformGroup</code><span class="sig-paren">(</span><em>self</em>, <em>name</em><span class="sig-paren">)</span> &#x2192; hou.AgentTransformGroup<a class="headerlink" href="#hou.AgentDefinition.findTransformGroup" title="Permalink to this definition"></a></dt>
<dd><p>Finds the transform group with the specified name, or None if no
such group exists.</p>
</dd></dl>

<dl class="method">
<dt id="hou.AgentDefinition.freeze">
<code class="descname">freeze</code><span class="sig-paren">(</span><em>self</em>, <em>new_shapelib = None</em><span class="sig-paren">)</span> &#x2192; hou.AgentDefinition<a class="headerlink" href="#hou.AgentDefinition.freeze" title="Permalink to this definition"></a></dt>
<dd><p>Creates a modifiable copy of the agent definition. Use
hou.Agent.setDefinition to change one or more agents to use the new
agent definition.</p>
<dl class="docutils">
<dt>new_shapelib</dt>
<dd>If specified, the copied agent definition and its layers will
reference the new shape library.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hou.AgentDefinition.layers">
<code class="descname">layers</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.AgentLayer<a class="headerlink" href="#hou.AgentDefinition.layers" title="Permalink to this definition"></a></dt>
<dd><p>Returns a list of the layers in the agent definition.</p>
</dd></dl>

<dl class="method">
<dt id="hou.AgentDefinition.rig">
<code class="descname">rig</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.AgentRig<a class="headerlink" href="#hou.AgentDefinition.rig" title="Permalink to this definition"></a></dt>
<dd><p>Returns the agent definitions rig.</p>
</dd></dl>

<dl class="method">
<dt id="hou.AgentDefinition.shapeLibrary">
<code class="descname">shapeLibrary</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.AgentShapeLibrary<a class="headerlink" href="#hou.AgentDefinition.shapeLibrary" title="Permalink to this definition"></a></dt>
<dd><p>Returns the agent definitions shape library.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.AgentDefinition.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.AgentDefinition.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

<dl class="method">
<dt id="hou.AgentDefinition.transformGroups">
<code class="descname">transformGroups</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.AgentTransformGroup<a class="headerlink" href="#hou.AgentDefinition.transformGroups" title="Permalink to this definition"></a></dt>
<dd><p>Returns a list of the transform groups in the agent definition.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.AgentLayer">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">AgentLayer</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.AgentLayer" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>An agents layer.</p>
<p>See Agent Layers for more information.</p>
<dl class="method">
<dt id="hou.AgentLayer.asJSON">
<code class="descname">asJSON</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.AgentLayer.asJSON" title="Permalink to this definition"></a></dt>
<dd><p>Returns a string containing the JSON that represents the layer.</p>
</dd></dl>

<dl class="method">
<dt id="hou.AgentLayer.bindings">
<code class="descname">bindings</code><span class="sig-paren">(</span><em>self</em>, <em>transform = None</em><span class="sig-paren">)</span> &#x2192; tuple of hou.AgentShapeBinding<a class="headerlink" href="#hou.AgentLayer.bindings" title="Permalink to this definition"></a></dt>
<dd><p>Returns the list of shape bindings in the layer.</p>
<dl class="docutils">
<dt>transform</dt>
<dd>Index of a transform in the agents rig. If specified, only the
shape bindings attached to the specified transform will be
returned.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hou.AgentLayer.deformingBindings">
<code class="descname">deformingBindings</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.AgentShapeBinding<a class="headerlink" href="#hou.AgentLayer.deformingBindings" title="Permalink to this definition"></a></dt>
<dd><p>Returns the shape bindings in the layer which reference deforming
shapes.</p>
</dd></dl>

<dl class="method">
<dt id="hou.AgentLayer.fileName">
<code class="descname">fileName</code><span class="sig-paren">(</span><em>self</em>, <em>expanded = False</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.AgentLayer.fileName" title="Permalink to this definition"></a></dt>
<dd><p>If the layer is an external reference, returns the path to the file
on disk.</p>
<dl class="docutils">
<dt>expanded</dt>
<dd>Specifies whether to expand any variables in the path, such as
$HIP.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hou.AgentLayer.isExternalReference">
<code class="descname">isExternalReference</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.AgentLayer.isExternalReference" title="Permalink to this definition"></a></dt>
<dd><p>Returns a bool indicating whether the layer references a file on
disk.</p>
</dd></dl>

<dl class="method">
<dt id="hou.AgentLayer.name">
<code class="descname">name</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.AgentLayer.name" title="Permalink to this definition"></a></dt>
<dd><p>Returns the name of the layer.</p>
</dd></dl>

<dl class="method">
<dt id="hou.AgentLayer.staticBindings">
<code class="descname">staticBindings</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.AgentShapeBinding<a class="headerlink" href="#hou.AgentLayer.staticBindings" title="Permalink to this definition"></a></dt>
<dd><p>Returns the shape bindings in the layer which reference static
shapes.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.AgentLayer.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.AgentLayer.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.AgentRig">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">AgentRig</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.AgentRig" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>The rig of an agent primitive.</p>
<p>See Crowd Agents for more information.</p>
<dl class="method">
<dt id="hou.AgentRig.asJSON">
<code class="descname">asJSON</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.AgentRig.asJSON" title="Permalink to this definition"></a></dt>
<dd><p>Returns a string containing the JSON that represents the rig.</p>
</dd></dl>

<dl class="method">
<dt id="hou.AgentRig.childIndices">
<code class="descname">childIndices</code><span class="sig-paren">(</span><em>self</em>, <em>transform</em><span class="sig-paren">)</span> &#x2192; tuple of int<a class="headerlink" href="#hou.AgentRig.childIndices" title="Permalink to this definition"></a></dt>
<dd><p>Returns the children of the specified transform.</p>
<dl class="docutils">
<dt>transform</dt>
<dd>Index of a transform in the rig.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hou.AgentRig.fileName">
<code class="descname">fileName</code><span class="sig-paren">(</span><em>self</em>, <em>expanded = False</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.AgentRig.fileName" title="Permalink to this definition"></a></dt>
<dd><p>If the rig is an external reference, returns the path to the file on
disk.</p>
<dl class="docutils">
<dt>expanded</dt>
<dd>Specifies whether to expand any variables in the path, such as
$HIP.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hou.AgentRig.findTransform">
<code class="descname">findTransform</code><span class="sig-paren">(</span><em>self</em>, <em>transform_name</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.AgentRig.findTransform" title="Permalink to this definition"></a></dt>
<dd><p>Returns the index of the transform with the given name, or -1 if the
transform name is invalid.</p>
<dl class="docutils">
<dt>transform_name</dt>
<dd>Name of a transform in the rig.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hou.AgentRig.isExternalReference">
<code class="descname">isExternalReference</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.AgentRig.isExternalReference" title="Permalink to this definition"></a></dt>
<dd><p>Returns a bool indicating whether the rig references a file on disk.</p>
</dd></dl>

<dl class="method">
<dt id="hou.AgentRig.name">
<code class="descname">name</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.AgentRig.name" title="Permalink to this definition"></a></dt>
<dd><p>Returns the name or filename of the rig.</p>
</dd></dl>

<dl class="method">
<dt id="hou.AgentRig.parentIndex">
<code class="descname">parentIndex</code><span class="sig-paren">(</span><em>self</em>, <em>transform</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.AgentRig.parentIndex" title="Permalink to this definition"></a></dt>
<dd><p>Returns the parent of the specified transform, or -1 if the
transform is a root of the transform hierarchy.</p>
<dl class="docutils">
<dt>transform</dt>
<dd>Index of a transform in the rig.</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="hou.AgentRig.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.AgentRig.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

<dl class="method">
<dt id="hou.AgentRig.transformCount">
<code class="descname">transformCount</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.AgentRig.transformCount" title="Permalink to this definition"></a></dt>
<dd><p>Returns the number of transforms in the rig.</p>
</dd></dl>

<dl class="method">
<dt id="hou.AgentRig.transformName">
<code class="descname">transformName</code><span class="sig-paren">(</span><em>self</em>, <em>transform</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.AgentRig.transformName" title="Permalink to this definition"></a></dt>
<dd><p>Returns the name of the specified transform.</p>
<dl class="docutils">
<dt>transform</dt>
<dd>Index of a transform in the rig.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.AgentShape">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">AgentShape</code><a class="headerlink" href="#hou.AgentShape" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>An agents shape.</p>
<p>See Crowd Agents for more information.</p>
<dl class="method">
<dt id="hou.AgentShape.geometry">
<code class="descname">geometry</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Geometry<a class="headerlink" href="#hou.AgentShape.geometry" title="Permalink to this definition"></a></dt>
<dd><p>Returns the shapes geometry.</p>
</dd></dl>

<dl class="method">
<dt id="hou.AgentShape.name">
<code class="descname">name</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.AgentShape.name" title="Permalink to this definition"></a></dt>
<dd><p>Returns the shapes name, which is unique within a shape library.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.AgentShape.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.AgentShape.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

<dl class="method">
<dt id="hou.AgentShape.uniqueId">
<code class="descname">uniqueId</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.AgentShape.uniqueId" title="Permalink to this definition"></a></dt>
<dd><p>Returns the shapes globally unique id.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.AgentShapeBinding">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">AgentShapeBinding</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.AgentShapeBinding" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A shape binding in an agents layer.</p>
<p>A shape binding attaches a shape from the agents shape library to a
transform in the agents rig. See Agent Layers for more information.</p>
<dl class="method">
<dt id="hou.AgentShapeBinding.boundsScale">
<code class="descname">boundsScale</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#hou.AgentShapeBinding.boundsScale" title="Permalink to this definition"></a></dt>
<dd><p>Returns the scale factor for the shapes bounding box.</p>
</dd></dl>

<dl class="method">
<dt id="hou.AgentShapeBinding.deformer">
<code class="descname">deformer</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.AgentShapeDeformer<a class="headerlink" href="#hou.AgentShapeBinding.deformer" title="Permalink to this definition"></a></dt>
<dd><p>Returns the deformer used for the shape, or None if the shape
binding is static.</p>
</dd></dl>

<dl class="method">
<dt id="hou.AgentShapeBinding.isAttachedToTransform">
<code class="descname">isAttachedToTransform</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.AgentShapeBinding.isAttachedToTransform" title="Permalink to this definition"></a></dt>
<dd><p>Returns whether the shape is attached to a transform in the agents
rig.</p>
</dd></dl>

<dl class="method">
<dt id="hou.AgentShapeBinding.isDeforming">
<code class="descname">isDeforming</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.AgentShapeBinding.isDeforming" title="Permalink to this definition"></a></dt>
<dd><p>Returns whether the shape is static or deforming.</p>
</dd></dl>

<dl class="method">
<dt id="hou.AgentShapeBinding.shape">
<code class="descname">shape</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.AgentShape<a class="headerlink" href="#hou.AgentShapeBinding.shape" title="Permalink to this definition"></a></dt>
<dd><p>Returns the referenced shape.</p>
</dd></dl>

<dl class="method">
<dt id="hou.AgentShapeBinding.shapeId">
<code class="descname">shapeId</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.AgentShapeBinding.shapeId" title="Permalink to this definition"></a></dt>
<dd><p>Returns the unique id of the shape. This is equivalent to
shape().uniqueId().</p>
</dd></dl>

<dl class="method">
<dt id="hou.AgentShapeBinding.shapeName">
<code class="descname">shapeName</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.AgentShapeBinding.shapeName" title="Permalink to this definition"></a></dt>
<dd><p>Returns the name of the shape. This is equivalent to shape().name().</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.AgentShapeBinding.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.AgentShapeBinding.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

<dl class="method">
<dt id="hou.AgentShapeBinding.transformId">
<code class="descname">transformId</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.AgentShapeBinding.transformId" title="Permalink to this definition"></a></dt>
<dd><p>Returns the index of the transform in the agents rig that the shape
is attached to.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.AgentShapeDeformer">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">AgentShapeDeformer</code><a class="headerlink" href="#hou.AgentShapeDeformer" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A deformer for agent shapes.</p>
<p>Agent shape deformers are used to provide different deformation methods
for shapes, such as linear skinning or dual quaternion skinning. Each
shape binding can specify the deformer that should be used. The
hou.crowds.shapeDeformers method provides a list of the available
deformers.</p>
<dl class="method">
<dt id="hou.AgentShapeDeformer.name">
<code class="descname">name</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.AgentShapeDeformer.name" title="Permalink to this definition"></a></dt>
<dd><p>Returns the unique name for the deformer.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.AgentShapeDeformer.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.AgentShapeDeformer.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.AgentShapeLibrary">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">AgentShapeLibrary</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.AgentShapeLibrary" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>The shape library of an agent primitive.</p>
<p>See Crowd Agents for more information.</p>
<dl class="method">
<dt id="hou.AgentShapeLibrary.addShape">
<code class="descname">addShape</code><span class="sig-paren">(</span><em>self</em>, <em>name</em>, <em>geometry</em><span class="sig-paren">)</span> &#x2192; hou.AgentShape<a class="headerlink" href="#hou.AgentShapeLibrary.addShape" title="Permalink to this definition"></a></dt>
<dd><p>Adds a new shape to the shape library.</p>
<p>Raises hou.GeometryPermissionError if the shape library is not
modifiable.</p>
<dl class="docutils">
<dt>name</dt>
<dd>The name for the new shape.</dd>
<dt>geometry</dt>
<dd>A hou.Geometry containing the shapes geometry.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hou.AgentShapeLibrary.data">
<code class="descname">data</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Geometry<a class="headerlink" href="#hou.AgentShapeLibrary.data" title="Permalink to this definition"></a></dt>
<dd><p>Returns the geometry representation of the shape library, which can
be saved to disk.</p>
</dd></dl>

<dl class="method">
<dt id="hou.AgentShapeLibrary.fileName">
<code class="descname">fileName</code><span class="sig-paren">(</span><em>self</em>, <em>expanded = False</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.AgentShapeLibrary.fileName" title="Permalink to this definition"></a></dt>
<dd><p>If the shape library is an external reference, returns the path to
the file on disk.</p>
<dl class="docutils">
<dt>expanded</dt>
<dd>Specifies whether to expand any variables in the path, such as
$HIP.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hou.AgentShapeLibrary.findShape">
<code class="descname">findShape</code><span class="sig-paren">(</span><em>self</em>, <em>shape_name</em><span class="sig-paren">)</span> &#x2192; hou.AgentShape<a class="headerlink" href="#hou.AgentShapeLibrary.findShape" title="Permalink to this definition"></a></dt>
<dd><p>Finds the shape with the specified name, or None if no such shape
exists.</p>
</dd></dl>

<dl class="method">
<dt id="hou.AgentShapeLibrary.freeze">
<code class="descname">freeze</code><span class="sig-paren">(</span><em>self</em>, <em>keep_external_ref = False</em><span class="sig-paren">)</span> &#x2192; hou.AgentShapeLibrary<a class="headerlink" href="#hou.AgentShapeLibrary.freeze" title="Permalink to this definition"></a></dt>
<dd><p>Creates a modifiable copy of the shape library.</p>
<dl class="docutils">
<dt>keep_external_ref</dt>
<dd>If the original shape library referenced a file on disk,
specifies whether the new shape library should be marked as
_including_ the original library. In this situation, saving out
the new shape library will only write out shapes that were not
included from the original library, along with the path to the
included shape library. Otherwise, saving out the new shape
library will produce a standalone library containing all of the
shapes.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hou.AgentShapeLibrary.isExternalReference">
<code class="descname">isExternalReference</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.AgentShapeLibrary.isExternalReference" title="Permalink to this definition"></a></dt>
<dd><p>Returns a bool indicating whether the shape library references a
file on disk.</p>
</dd></dl>

<dl class="method">
<dt id="hou.AgentShapeLibrary.name">
<code class="descname">name</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.AgentShapeLibrary.name" title="Permalink to this definition"></a></dt>
<dd><p>Returns the name or filename of the shape library.</p>
</dd></dl>

<dl class="method">
<dt id="hou.AgentShapeLibrary.shapes">
<code class="descname">shapes</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.AgentShape<a class="headerlink" href="#hou.AgentShapeLibrary.shapes" title="Permalink to this definition"></a></dt>
<dd><p>Returns a list of all shapes in the shape library.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.AgentShapeLibrary.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.AgentShapeLibrary.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.AgentTransformGroup">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">AgentTransformGroup</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.AgentTransformGroup" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A group of transforms in an agents rig.</p>
<p>See Crowd Agents for more information.</p>
<dl class="method">
<dt id="hou.AgentTransformGroup.asJSON">
<code class="descname">asJSON</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.AgentTransformGroup.asJSON" title="Permalink to this definition"></a></dt>
<dd><p>Returns a string containing the JSON representation of the group.</p>
</dd></dl>

<dl class="method">
<dt id="hou.AgentTransformGroup.fileName">
<code class="descname">fileName</code><span class="sig-paren">(</span><em>self</em>, <em>expanded = False</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.AgentTransformGroup.fileName" title="Permalink to this definition"></a></dt>
<dd><p>If the transform group is an external reference, returns the path to
the file on disk.</p>
<dl class="docutils">
<dt>expanded</dt>
<dd>Specifies whether to expand any variables in the path, such as
$HIP.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hou.AgentTransformGroup.isExternalReference">
<code class="descname">isExternalReference</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.AgentTransformGroup.isExternalReference" title="Permalink to this definition"></a></dt>
<dd><p>Returns a bool indicating whether the transform group references a
file on disk.</p>
</dd></dl>

<dl class="method">
<dt id="hou.AgentTransformGroup.name">
<code class="descname">name</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.AgentTransformGroup.name" title="Permalink to this definition"></a></dt>
<dd><p>Returns the name of the transform group.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.AgentTransformGroup.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.AgentTransformGroup.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

<dl class="method">
<dt id="hou.AgentTransformGroup.transformIndices">
<code class="descname">transformIndices</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of int<a class="headerlink" href="#hou.AgentTransformGroup.transformIndices" title="Permalink to this definition"></a></dt>
<dd><p>Returns a list containing the index of each transform in the group.</p>
</dd></dl>

<dl class="method">
<dt id="hou.AgentTransformGroup.weights">
<code class="descname">weights</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of float<a class="headerlink" href="#hou.AgentTransformGroup.weights" title="Permalink to this definition"></a></dt>
<dd><p>Returns a list containing the weight of each transform in the group.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.AssetBrowser">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">AssetBrowser</code><a class="headerlink" href="#hou.AssetBrowser" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.PathBasedPaneTab" title="hou.PathBasedPaneTab"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.PathBasedPaneTab</span></code></a></p>
<dl class="method">
<dt id="hou.AssetBrowser.installRequiredDefinitionsForNodeTypeName">
<code class="descname">installRequiredDefinitionsForNodeTypeName</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.AssetBrowser.installRequiredDefinitionsForNodeTypeName" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.AssetBrowser.reload">
<code class="descname">reload</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.AssetBrowser.reload" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.AssetBrowser.storeSyncSessionKey">
<code class="descname">storeSyncSessionKey</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.AssetBrowser.storeSyncSessionKey" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.AssetBrowser.storeUpdateSessionKey">
<code class="descname">storeUpdateSessionKey</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.AssetBrowser.storeUpdateSessionKey" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.AssetBrowser.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.AssetBrowser.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

<dl class="method">
<dt id="hou.AssetBrowser.updateAssetDownloadFraction">
<code class="descname">updateAssetDownloadFraction</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.AssetBrowser.updateAssetDownloadFraction" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.Attrib">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">Attrib</code><a class="headerlink" href="#hou.Attrib" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>This class stores information about a Geometry attribute.</p>
<p>An attribute describes extra data you can attach to different elements
of geometry. The attribute values are the individual instances of that
data, and for each attribute there is exactly one attribute value per
geometry element. For example, if you look at the points in Houdinis
geometry spreadsheet, the point numbers are listed down the side, the
point attributes are listed across the top, and the point attribute
values are contained in the table.</p>
<p>The attribute specifies which elements store the attribute values:
points, primitives, or vertices. An attribute can also be global (also
known as a detail attribute), in which case there is one instance of the
attribute value in the geometry.</p>
<p>The attribute also specifies the data type of the attribute values.</p>
<p>To look up existing attributes, use hou.Geometry.findPointAttrib,
hou.Geometry.findPrimAttrib, hou.Geometry.findVertexAttrib, and
hou.Geometry.findGlobalAttrib. To add a new attribute, use
hou.Geometry.addAttrib.</p>
<dl class="docutils">
<dt>NOTE</dt>
<dd>Point positions are stored in a point attribute named P and point
weights are stored in Pw. See hou.Point.position and
hou.Point.weight for more information.</dd>
</dl>
<dl class="method">
<dt id="hou.Attrib.boostAnyDefaultValue">
<code class="descname">boostAnyDefaultValue</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.Attrib.boostAnyDefaultValue" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.Attrib.dataType">
<code class="descname">dataType</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.attribData enum value<a class="headerlink" href="#hou.Attrib.dataType" title="Permalink to this definition"></a></dt>
<dd><p>Return the attributes data type (int, float or string).</p>
<p>The size of the attribute also determines the format of the
attribute values. For example, if the data type is int and the size
is 3, the attribute value will be a tuple of 3 ints. If the size was
1, the attribute value would simply be an int.</p>
<p>Note that a string attributes size must be 1.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Attrib.defaultValue">
<code class="descname">defaultValue</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; int or float or str or tuple<a class="headerlink" href="#hou.Attrib.defaultValue" title="Permalink to this definition"></a></dt>
<dd><p>Return the attributes default value. Returns a single
int/float/string for attributes of size 1 and a tuple of values for
attributes with more than one component.</p>
<p>This method is useful when duplicating an attribute. See
hou.Geometry.addAttrib for an example.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Attrib.destroy">
<code class="descname">destroy</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Attrib.destroy" title="Permalink to this definition"></a></dt>
<dd><p>Remove this attribute from the geometry. You would typically call
this method from the code of a Python-defined SOP.</p>
<p>Raises hou.GeometryPermissionError if this geometry is not
modifiable.</p>
<p>Raises hou.OperationFailed if you try to destroy the P or Pw point
attributes.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Attrib.geometry">
<code class="descname">geometry</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Geometry<a class="headerlink" href="#hou.Attrib.geometry" title="Permalink to this definition"></a></dt>
<dd><p>Return the Geometry object containing this attribute.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Attrib.indexPairPropertyTables">
<code class="descname">indexPairPropertyTables</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.IndexPairPropertyTable<a class="headerlink" href="#hou.Attrib.indexPairPropertyTables" title="Permalink to this definition"></a></dt>
<dd><p>Return the property tables for this attribute. If the attribute is
not an index pair, returns an empty tuple.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Attrib.isArrayType">
<code class="descname">isArrayType</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.Attrib.isArrayType" title="Permalink to this definition"></a></dt>
<dd><p>Return True if the attribute is a type that contains array data
(i.e. Float Array, Integer Array, String Array) and False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Attrib.isTransformedAsNormal">
<code class="descname">isTransformedAsNormal</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.Attrib.isTransformedAsNormal" title="Permalink to this definition"></a></dt>
<dd><p>Return whether attribute values in the geometry are automatically
transformed as a normal when Houdini transforms (e.g. rotates) the
geometry.</p>
<p>For more information, see the hou.Geometry.addAttrib, in the
transform_as_normal parameter documentation.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Attrib.isTransformedAsVector">
<code class="descname">isTransformedAsVector</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.Attrib.isTransformedAsVector" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.Attrib.name">
<code class="descname">name</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.Attrib.name" title="Permalink to this definition"></a></dt>
<dd><p>Return the attributes name. Each attribute in the geometry has a
unique name.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Attrib.option">
<code class="descname">option</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.Attrib.option" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.Attrib.optionType">
<code class="descname">optionType</code><span class="sig-paren">(</span><em>self</em>, <em>name</em><span class="sig-paren">)</span> &#x2192; hou.fieldType enum value<a class="headerlink" href="#hou.Attrib.optionType" title="Permalink to this definition"></a></dt>
<dd><p>Return a hou.fieldType enumerated value that describes the type of
data stored in an option. Returns hou.fieldType.NoSuchField if no
field exists with that name.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Attrib.options">
<code class="descname">options</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.Attrib.options" title="Permalink to this definition"></a></dt>
<dd><p>option(self, name) -&gt; bool, int, float, str, hou.Vector2, hou.Vector3,
hou.Vector4, hou.Quaternion, hou.Matrix3, hou.Matrix4, tuple of int, or
tuple of float</p>
<blockquote>
<div><p>Return the value of an individual option, on None if no such option
exists.</p>
<p>See also hou.Attrib.options, hou.Attrib.setOption and
hou.Attrib.removeOption.</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.Attrib.qualifier">
<code class="descname">qualifier</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.Attrib.qualifier" title="Permalink to this definition"></a></dt>
<dd><p>Return the attributes type qualifier. The qualifier is a
description of the data contained in the attribute. An empty string
is returned if the attribute has no numeric representation or if the
attribute is the pseudo Pw point attribute.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Attrib.removeOption">
<code class="descname">removeOption</code><span class="sig-paren">(</span><em>self</em>, <em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Attrib.removeOption" title="Permalink to this definition"></a></dt>
<dd><p>Remove an entry in the dictionary of options. See hou.Attrib.options
for more information.</p>
<p>Raises hou.OperationFailed if there is no entry in the dictionary
with this name.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Attrib.setOption">
<code class="descname">setOption</code><span class="sig-paren">(</span><em>self</em>, <em>name</em>, <em>value</em>, <em>type_hint = hou.fieldType::NoSuchField</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Attrib.setOption" title="Permalink to this definition"></a></dt>
<dd><p>Set an entry in the dictionary of options. See hou.Attrib.options
for more information.</p>
<dl class="docutils">
<dt>name</dt>
<dd>The name of the option to set.</dd>
<dt>value</dt>
<dd>An integer, float, string, hou.Vector2, hou.Vector3,
hou.Vector4, hou.Quaternion, hou.Matrix3, hou.matrix4, or
sequence of numbers.</dd>
<dt>type_hint</dt>
<dd>Used to determine the exact hou.fieldType desired when the
specified value type is not enough to unambiguously determine
it.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hou.Attrib.setSize">
<code class="descname">setSize</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Attrib.setSize" title="Permalink to this definition"></a></dt>
<dd><p>Sets the number of data components in the attribute value. See
hou.Attrib.dataType for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Attrib.size">
<code class="descname">size</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.Attrib.size" title="Permalink to this definition"></a></dt>
<dd><p>Return the number of data components in the attribute value. See
hou.Attrib.dataType for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Attrib.strings">
<code class="descname">strings</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of str<a class="headerlink" href="#hou.Attrib.strings" title="Permalink to this definition"></a></dt>
<dd><p>Return the string table for this attribute. If the attribute is not
a string, returns an empty tuple.</p>
<p>A string attribute does not store each string value inside the
attribute element (i.e. point, primitive, etc.). Instead, the unique
string attribute values are stored in a table inside the attribute,
and each attribute value stores an index to that string.</p>
<p>For example, suppose this attribute stores strings on points. If all
points have the attribute value foo then the string table will be
just (foo,) and each point will store the index 0. When you set
some points values to bar, Houdini adds sets the string table to
(foo, bar) and sets stores the index 1 in those points. When you
set one of those points back to foo, Houdini leaves the string
table unchanged and stores the index 0 in that point.</p>
<p>When using string attribute values, this implementation is hidden
from you, and you get and set those attributes as strings. This
method is provided only in case you need access to the string table.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.Attrib.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.Attrib.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

<dl class="method">
<dt id="hou.Attrib.type">
<code class="descname">type</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.attribType enum value<a class="headerlink" href="#hou.Attrib.type" title="Permalink to this definition"></a></dt>
<dd><p>Return the type of attribute (point, primitive, vertex, or global).</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.BaseKeyframe">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">BaseKeyframe</code><a class="headerlink" href="#hou.BaseKeyframe" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Abstract base class for all keyframe class.</p>
<p>REPLACES</p>
<blockquote>
<div><ul class="simple">
<li>chkey</li>
<li>chkeyls</li>
<li>chkey</li>
<li>chround</li>
<li>chsraw()</li>
<li>lock()</li>
<li>opscript</li>
</ul>
</div></blockquote>
<dl class="method">
<dt id="hou.BaseKeyframe.asCode">
<code class="descname">asCode</code><span class="sig-paren">(</span><em>self</em>, <em>brief=False</em>, <em>save_keys_in_frames=False</em>, <em>function_name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.BaseKeyframe.asCode" title="Permalink to this definition"></a></dt>
<dd><p>-&gt; str</p>
<blockquote>
<div><p>Returns a script of Python statements that can be executed to create
the keyframe. To run the script, use either Pythons exec or
execfile functions.</p>
<dl class="docutils">
<dt>brief</dt>
<dd>When &lt;brief&gt; is True, the output script omits commands for
setting unused values, slopes and accelerations. This parameter
only applies to non-string keyframes. The value of &lt;brief&gt; must
be either True or False.</dd>
<dt>save_keys_in_frames</dt>
<dd>When &lt;save_keys_in_frames&gt; is True, asCode outputs commands for
setting channel and key times in samples (frames) instead of
seconds. The value of &lt;save_keys_in_frames&gt; must be either True
or False.</dd>
<dt>function_name</dt>
<dd><p class="first">If &lt;function_name&gt; is specified, then the output script is
wrapped in a Python function definition with the given name.
&lt;function_name&gt; must be a non-zero length string consisting of
only alphanumeric and underscore characters. Any invalid
characters are internally converted to underscores.</p>
<p class="last">The function returns a reference to the newly created keyframe
object.</p>
</dd>
</dl>
<p>Here is an example of saving the output to a file and then loading
it back into Houdini:</p>
</div></blockquote>
<p>&gt; # Get a reference to the target keyframe.
&gt; tx_parm = hou.parm(/obj/geo1/tx)
&gt; key = tx_parm.keyframes()[0]
&gt; 
&gt; # Execute asCode and write the output script to file.
&gt; script = key.asCode()
&gt; f = open(create_key.py, w)
&gt; f.write(script)
&gt; f.close()
&gt; 
&gt; # Execute the script.  The new keyframe will be stored 
&gt; # in the hou_keyframe variable.
&gt; execfile(create_key.py)
&gt; 
&gt; # Commit the keyframe back into the node parameter.
&gt; tx_parm.setKeyframe(hou_keyframe)</p>
<blockquote>
<div>Here is an example of saving the output into a function and then
calling it in Houdini:</div></blockquote>
<p>&gt; # Get a reference to the target keyframe.
&gt; tx_parm = hou.Node(/obj/geo1).Parm(tx)
&gt; key = tx_parm.keyframes()[0]
&gt; 
&gt; # Execute asCode and write the function definition to file.
&gt; func = key.asCode(function_name=createKeyframe)
&gt; f = open(keylib.py, w)
&gt; f.write(func)
&gt; f.close()
&gt; 
&gt; # Call the function definition.
&gt; import keylib
&gt; hou_keyframe = keylib.createKeyframe()
&gt; 
&gt; # Commit the keyframe back into the node parameter.
&gt; tx_parm.setKeyframe(hou_keyframe)</p>
</dd></dl>

<dl class="method">
<dt id="hou.BaseKeyframe.evaluatedType">
<code class="descname">evaluatedType</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.parmData enum value<a class="headerlink" href="#hou.BaseKeyframe.evaluatedType" title="Permalink to this definition"></a></dt>
<dd><p>Returns the type that the keyframe evaluates to.</p>
</dd></dl>

<dl class="method">
<dt id="hou.BaseKeyframe.expression">
<code class="descname">expression</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.BaseKeyframe.expression" title="Permalink to this definition"></a></dt>
<dd><p>Returns the keyframes expression. For example, in cases where the
keyframe has had two values set the interpolating function is
returned e.g. bezier(), spline() etc.</p>
<p>This function raises hou.KeyframeValueNotSet if an expression has
not been set.</p>
<p>See setExpression() and isExpressionSet().</p>
</dd></dl>

<dl class="method">
<dt id="hou.BaseKeyframe.expressionLanguage">
<code class="descname">expressionLanguage</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.exprLanguage enum value<a class="headerlink" href="#hou.BaseKeyframe.expressionLanguage" title="Permalink to this definition"></a></dt>
<dd><p>Returns the keyframes expressions language.</p>
<p>This function raises hou.KeyframeValueNotSet if an expression
language has not ben set.</p>
<p>See setExpression(), and isExpressionLanguageSet().</p>
</dd></dl>

<dl class="method">
<dt id="hou.BaseKeyframe.frame">
<code class="descname">frame</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; double<a class="headerlink" href="#hou.BaseKeyframe.frame" title="Permalink to this definition"></a></dt>
<dd><p>Returns the keyframes frame number.</p>
<p>This function raises hou.KeyframeValueNotSet if the frame or time
has not been set.</p>
<p>See setFrame() and setTime().</p>
</dd></dl>

<dl class="method">
<dt id="hou.BaseKeyframe.isExpressionLanguageSet">
<code class="descname">isExpressionLanguageSet</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.BaseKeyframe.isExpressionLanguageSet" title="Permalink to this definition"></a></dt>
<dd><p>Returns whether the keyframe expressions language is set.</p>
<p>See setExpression() and expressionLanguage().</p>
</dd></dl>

<dl class="method">
<dt id="hou.BaseKeyframe.isExpressionSet">
<code class="descname">isExpressionSet</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.BaseKeyframe.isExpressionSet" title="Permalink to this definition"></a></dt>
<dd><p>Returns whether the keyframes expression is set.</p>
<p>See setExpression() and expression().</p>
</dd></dl>

<dl class="method">
<dt id="hou.BaseKeyframe.isTimeSet">
<code class="descname">isTimeSet</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.BaseKeyframe.isTimeSet" title="Permalink to this definition"></a></dt>
<dd><p>Returns whether the keyframes time is set.</p>
<p>See setTime() and time().</p>
</dd></dl>

<dl class="method">
<dt id="hou.BaseKeyframe.setExpression">
<code class="descname">setExpression</code><span class="sig-paren">(</span><em>self</em>, <em>expression</em>, <em>language=None</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.BaseKeyframe.setExpression" title="Permalink to this definition"></a></dt>
<dd><p>Sets the keyframes expression and language.</p>
<p>This function raises hou.TypeError if language is not a value from
hou.exprLanguage.</p>
<p>See expression(), expressionLanguage(), isExpressionSet(),
isExpressionLanguageSet().</p>
</dd></dl>

<dl class="method">
<dt id="hou.BaseKeyframe.setFrame">
<code class="descname">setFrame</code><span class="sig-paren">(</span><em>self</em>, <em>frame</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.BaseKeyframe.setFrame" title="Permalink to this definition"></a></dt>
<dd><p>Sets the keyframes frame number. Using the number of frames per
second (hou.fps), setting the frame number also sets the time. For
example, with an fps of 24, then setting the frame number to 49 will
set the time to 2 seconds.</p>
<p>See frame().</p>
</dd></dl>

<dl class="method">
<dt id="hou.BaseKeyframe.setTime">
<code class="descname">setTime</code><span class="sig-paren">(</span><em>self</em>, <em>time</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.BaseKeyframe.setTime" title="Permalink to this definition"></a></dt>
<dd><p>Sets the keyframes time in seconds. Using the number of frames per
second (hou.fps), setting the time also sets the frame number. For
example, with an fps of 24, then setting the time to 2 seconds will
set the frame number to 49.</p>
<p>See time().</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.BaseKeyframe.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.BaseKeyframe.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

<dl class="method">
<dt id="hou.BaseKeyframe.time">
<code class="descname">time</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; double<a class="headerlink" href="#hou.BaseKeyframe.time" title="Permalink to this definition"></a></dt>
<dd><p>Returns the keyframes time in seconds.</p>
<p>This function raises hou.KeyframeValueNotSet if the time or frame
has not been set.</p>
<p>See setTime() and setFrame().</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.BoundingBox">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">BoundingBox</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.BoundingBox" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>An axis-aligned 3D rectangular region.</p>
<p>For example, a bounding box might describe a piece of geometrys minimum
and maximum values on each of the coordinate axes. See
hou.Geometry.boundingBox for an example of a function that returns a
bounding box.</p>
<dl class="method">
<dt id="hou.BoundingBox.almostEqual">
<code class="descname">almostEqual</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.BoundingBox.almostEqual" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.BoundingBox.center">
<code class="descname">center</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Vector3<a class="headerlink" href="#hou.BoundingBox.center" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Return the position of the center of the bounding box.</p>
<p>This method can be implemented as follows:</p>
</div></blockquote>
<p>&gt; def sizevec(self):
&gt;     return (self.minvec() + self.maxvec()) * 0.5</p>
</dd></dl>

<dl class="method">
<dt id="hou.BoundingBox.contains">
<code class="descname">contains</code><span class="sig-paren">(</span><em>self</em>, <em>point</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.BoundingBox.contains" title="Permalink to this definition"></a></dt>
<dd><p>Given a sequence of 3 floats (such as a hou.Vector3) describing a
position, return whether the position is inside the box.</p>
</dd></dl>

<dl class="method">
<dt id="hou.BoundingBox.enlargeToContain">
<code class="descname">enlargeToContain</code><span class="sig-paren">(</span><em>self</em>, <em>point_or_bbox</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.BoundingBox.enlargeToContain" title="Permalink to this definition"></a></dt>
<dd><p>Enlarge the bounding box to contain the given element. The element
may be a sequence of 3 floats (such as a hou.Vector3) describing a
position or another bounding box. If this box does not need to grow
because it already completely contains the element, it wont be
modified.</p>
</dd></dl>

<dl class="method">
<dt id="hou.BoundingBox.isAlmostEqual">
<code class="descname">isAlmostEqual</code><span class="sig-paren">(</span><em>self</em>, <em>bbox</em>, <em>tolerance=0.00001</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.BoundingBox.isAlmostEqual" title="Permalink to this definition"></a></dt>
<dd><p>Returns whether this bounding box is equal to another, subject to
numerical tolerances.</p>
</dd></dl>

<dl class="method">
<dt id="hou.BoundingBox.isValid">
<code class="descname">isValid</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.BoundingBox.isValid" title="Permalink to this definition"></a></dt>
<dd><p>Returns whether this bounding box is valid.</p>
</dd></dl>

<dl class="method">
<dt id="hou.BoundingBox.maxvec">
<code class="descname">maxvec</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Vector3<a class="headerlink" href="#hou.BoundingBox.maxvec" title="Permalink to this definition"></a></dt>
<dd><p>Return a vector describing the corner of the box with the largest x,
y, and z values.</p>
</dd></dl>

<dl class="method">
<dt id="hou.BoundingBox.minvec">
<code class="descname">minvec</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Vector3<a class="headerlink" href="#hou.BoundingBox.minvec" title="Permalink to this definition"></a></dt>
<dd><p>Return a vector describing the corner of the box with the smallest
x, y, and z values.</p>
</dd></dl>

<dl class="method">
<dt id="hou.BoundingBox.setTo">
<code class="descname">setTo</code><span class="sig-paren">(</span><em>self</em>, <em>bounds_sequence</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.BoundingBox.setTo" title="Permalink to this definition"></a></dt>
<dd><p>Given a sequence of (xmin, ymin, zmin, xmax, ymax, zmax) values, set
the position of the bounding box.</p>
<p>Raises hou.InvalidSize if the tuple does not contain six elements.</p>
</dd></dl>

<dl class="method">
<dt id="hou.BoundingBox.sizevec">
<code class="descname">sizevec</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Vector3<a class="headerlink" href="#hou.BoundingBox.sizevec" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Return a vector describing the size of the box in each of the x, y,
and z axes.</p>
<p>This method can be implemented as follows:</p>
</div></blockquote>
<p>&gt; def sizevec(self):
&gt;     return self.maxvec() - self.minvec()</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.BoundingBox.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.BoundingBox.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.BoundingRect">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">BoundingRect</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.BoundingRect" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>An axis-aligned 2D rectangular region.</p>
<p>A bounding rectangle can describe the size and location of a node in a
network, or the visible area or a network editor pane.</p>
<dl class="method">
<dt id="hou.BoundingRect.center">
<code class="descname">center</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Vector2<a class="headerlink" href="#hou.BoundingRect.center" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Return the position of the center of the bounding rectangle.</p>
<p>This method can be implemented as follows:</p>
</div></blockquote>
<p>&gt; def center(self):
&gt;     return (self.min() + self.max()) * 0.5</p>
</dd></dl>

<dl class="method">
<dt id="hou.BoundingRect.closestPoint">
<code class="descname">closestPoint</code><span class="sig-paren">(</span><em>self</em>, <em>point</em><span class="sig-paren">)</span> &#x2192; hou.Vector2<a class="headerlink" href="#hou.BoundingRect.closestPoint" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Given a sequence of 2 floats (such as a hou.Vector2) describing a
position, return the position inside the rectangle that is closest
to the provided point.</div></blockquote>
<p>&gt; &gt;&gt;&gt; unitrect = hou.BoundingRect(0, 0, 1, 1)
&gt; &gt;&gt;&gt; unitrect.closestPoint((0.5, 0.5))
&gt; &lt;hou.Vector2 [0.5, 0.5]&gt;
&gt; &gt;&gt;&gt; unitrect.closestPoint((100, 0.5))
&gt; &lt;hou.Vector2 [1.0, 0.5]&gt;
&gt; &gt;&gt;&gt; unitrect.closestPoint((-10, -5))
&gt; &lt;hou.Vector2 [0, 0]&gt;</p>
</dd></dl>

<dl class="method">
<dt id="hou.BoundingRect.contains">
<code class="descname">contains</code><span class="sig-paren">(</span><em>self</em>, <em>rect</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.BoundingRect.contains" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Given a hou.BoundingRect object, return whether that rectangle is
inside the one described by this object.</div></blockquote>
<p>&gt; &gt;&gt;&gt; unitrect = hou.BoundingRect(0, 0, 1, 1)
&gt; &gt;&gt;&gt; unitrect.contains(hou.BoundingRect(0.5, 0.5, 1.0, 1.0))
&gt; True
&gt; &gt;&gt;&gt; unitrect.contains(hou.BoundingRect(0.5, 0.5, 1.5, 1.5))
&gt; False</p>
</dd></dl>

<dl class="method">
<dt id="hou.BoundingRect.enlargeToContain">
<code class="descname">enlargeToContain</code><span class="sig-paren">(</span><em>self</em>, <em>point_or_rect</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.BoundingRect.enlargeToContain" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Enlarge the bounding rectangle to contain the given element. The
element may be a sequence of 2 floats (such as a hou.Vector2)
describing a position or another bounding rectangle. If this
rectangle does not need to grow because it already completely
contains the element, it wont be modified.</div></blockquote>
<p>&gt; &gt;&gt;&gt; unitrect = hou.BoundingRect(0, 0, 1, 1)
&gt; &gt;&gt;&gt; unitrect.enlargeToContain((2, 0.5))
&gt; &gt;&gt;&gt; unitrect
&gt; &lt;hou.BoundingRect [0, 0, 2, 1]&gt;
&gt; &gt;&gt;&gt; unitrect = hou.BoundingRect(0, 0, 1, 1)
&gt; &gt;&gt;&gt; unitrect.enlargeToContain(hou.BoundingRect(0.5, 0.5, 2, 1.5))
&gt; &gt;&gt;&gt; unitrect
&gt; &lt;hou.BoundingRect [0, 0, 2, 1.5]&gt;</p>
</dd></dl>

<dl class="method">
<dt id="hou.BoundingRect.expand">
<code class="descname">expand</code><span class="sig-paren">(</span><em>self</em>, <em>offset</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.BoundingRect.expand" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Moves the edges of the rectangle away from its center by the
distances specified in the two float tuple or hou.Vector2 passed as
the offset parameter. The offset is applied to both sides of the
rectangle so actually changes the width and height of the rectangle
by twice the passed in values.</p>
<p>Negative values can be passed into the offset to shrink the
rectangle, but shrinking the rectangle by more than its current size
will result in an invliad rectangle.</p>
</div></blockquote>
<p>&gt; &gt;&gt;&gt; rect = hou.BoundingRect(1, 1, 2, 2)
&gt; &gt;&gt;&gt; rect.expand((1, 1))
&gt; &gt;&gt;&gt; rect
&gt; &lt;hou.BoundingRect [0, 0, 3, 3]&gt;
&gt; &gt;&gt;&gt; rect.expand((0, -2))
&gt; &gt;&gt;&gt; rect
&gt; &lt;hou.BoundingRect [0, 2, 3, 1]&gt;
&gt; &gt;&gt;&gt; rect.isValid()
&gt; False</p>
</dd></dl>

<dl class="method">
<dt id="hou.BoundingRect.getOffsetToAvoid">
<code class="descname">getOffsetToAvoid</code><span class="sig-paren">(</span><em>self</em>, <em>bounds</em>, <em>direction = None</em><span class="sig-paren">)</span> &#x2192; hou.Vector2<a class="headerlink" href="#hou.BoundingRect.getOffsetToAvoid" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Return a vector describing the minimum distance this rectangle must
be translated to avoid any overlap with the bounds rectangle. If
direction is provided as a hou.Vector2, it indicates the specific
direction the returned offset should be. If the rectangles do not
overlap, the result will be hou.Vector2(0.0, 0.0).</div></blockquote>
<p>&gt; &gt;&gt;&gt; unitrect = hou.BoundingRect(0, 0, 1, 1)
&gt; &gt;&gt;&gt; subrect = hou.BoundingRect(0.2, 0.4, 0.8, 0.6)
&gt; &gt;&gt;&gt; unitrect.getOffsetToAvoid(subrect)
&gt; &lt;hou.Vector2 [0, 0.6]&gt;
&gt; &gt;&gt;&gt; unitrect.getOffsetToAvoid(subrect, hou.Vector2(1.0, 0.0))
&gt; &lt;hou.Vector2 [0.8, 0]&gt;
&gt; &gt;&gt;&gt; unitrect.getOffsetToAvoid(subrect, hou.Vector2(1.0, 1.0))
&gt; &lt;hou.Vector2 [0.6, 0.6]&gt;</p>
</dd></dl>

<dl class="method">
<dt id="hou.BoundingRect.intersect">
<code class="descname">intersect</code><span class="sig-paren">(</span><em>self</em>, <em>rect</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.BoundingRect.intersect" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Given a hou.BoundingRect object, updates the rectangle in this
object to be the region where the two rectangles overlap.</div></blockquote>
<p>&gt; &gt;&gt;&gt; rect = hou.BoundingRect(0, 0, 1, 1)
&gt; &gt;&gt;&gt; rect.intersect(hou.BoundingRect(0.5, 0.5, 1.5, 1.5))
&gt; &gt;&gt;&gt; rect
&gt; &lt;hou.BoundingRect [0.5, 0.5, 1, 1]&gt;</p>
</dd></dl>

<dl class="method">
<dt id="hou.BoundingRect.intersects">
<code class="descname">intersects</code><span class="sig-paren">(</span><em>self</em>, <em>rect</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.BoundingRect.intersects" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Given a hou.BoundingRect object, return whether that rectangle
partially or fully overlaps the one described by this object.</div></blockquote>
<p>&gt; &gt;&gt;&gt; unitrect = hou.BoundingRect(0, 0, 1, 1)
&gt; &gt;&gt;&gt; unitrect.intersects(hou.BoundingRect(0.5, 0.5, 1.0, 1.0))
&gt; True
&gt; &gt;&gt;&gt; unitrect.intersects(hou.BoundingRect(0.5, 0.5, 1.5, 1.5))
&gt; True
&gt; &gt;&gt;&gt; unitrect.intersects(hou.BoundingRect(1.5, 1.5, 2.5, 2.5))
&gt; False</p>
</dd></dl>

<dl class="method">
<dt id="hou.BoundingRect.isAlmostEqual">
<code class="descname">isAlmostEqual</code><span class="sig-paren">(</span><em>self</em>, <em>rect</em>, <em>tolerance=0.00001</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.BoundingRect.isAlmostEqual" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Returns whether this bounding rectangle is equal to another, subject
to numerical tolerances.</div></blockquote>
<p>&gt; &gt;&gt;&gt; unitrect = hou.BoundingRect(0, 0, 1, 1)
&gt; &gt;&gt;&gt; subrect = hou.BoundingRect(0.001, 0.001, 0.999, 1.001)
&gt; &gt;&gt;&gt; unitrect.isAlmostEqual(subrect)
&gt; False
&gt; &gt;&gt;&gt; unitrect.isAlmostEqual(subrect, 0.01)
&gt; True</p>
</dd></dl>

<dl class="method">
<dt id="hou.BoundingRect.isValid">
<code class="descname">isValid</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.BoundingRect.isValid" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Returns whether this bounding rectangle is valid, indicating it has
been initialized in any way.</div></blockquote>
<p>&gt; &gt;&gt;&gt; hou.BoundingRect().isValid()
&gt; False
&gt; &gt;&gt;&gt; hou.BoundingRect(0, 0, 0, 0).isValid()
&gt; True
&gt; &gt;&gt;&gt; hou.BoundingRect(0, 0, 0, 0).isValid()
&gt; True</p>
</dd></dl>

<dl class="method">
<dt id="hou.BoundingRect.max">
<code class="descname">max</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Vector2<a class="headerlink" href="#hou.BoundingRect.max" title="Permalink to this definition"></a></dt>
<dd><p>Return a vector describing the corner of the rectangle with the
largest x and y values.</p>
</dd></dl>

<dl class="method">
<dt id="hou.BoundingRect.min">
<code class="descname">min</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Vector2<a class="headerlink" href="#hou.BoundingRect.min" title="Permalink to this definition"></a></dt>
<dd><p>Return a vector describing the corner of the rectangle with the
smallest x and y values.</p>
</dd></dl>

<dl class="method">
<dt id="hou.BoundingRect.scale">
<code class="descname">scale</code><span class="sig-paren">(</span><em>self</em>, <em>scale</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.BoundingRect.scale" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Scales this rectangle by the amount specified in the two float tuple
or hou.Vector2 passed as the scale parameter. Note that scaling the
rectangle by a negative value will result in an invlalid rectangle
where the lower left corner is above or to the right of the upper
right corner.</div></blockquote>
<p>&gt; &gt;&gt;&gt; rect = hou.BoundingRect(1, 1, 2, 2)
&gt; &gt;&gt;&gt; rect.scale(hou.Vector2(2, 3))
&gt; &gt;&gt;&gt; rect
&gt; &lt;hou.BoundingRect [2, 3, 4, 6]&gt;
&gt; &gt;&gt;&gt; rect.scale((-1, -1))
&gt; &gt;&gt;&gt; rect
&gt; &lt;hou.BoundingRect [-2, -3, -4, -6]&gt;
&gt; &gt;&gt;&gt; rect.isValid()
&gt; False</p>
</dd></dl>

<dl class="method">
<dt id="hou.BoundingRect.setTo">
<code class="descname">setTo</code><span class="sig-paren">(</span><em>self</em>, <em>bounds_sequence</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.BoundingRect.setTo" title="Permalink to this definition"></a></dt>
<dd><p>Given a sequence of (xmin, ymin, xmax, ymax) values, set the
position of the bounding rectangle.</p>
<p>Raises hou.InvalidSize if the tuple does not contain four elements.</p>
</dd></dl>

<dl class="method">
<dt id="hou.BoundingRect.size">
<code class="descname">size</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Vector2<a class="headerlink" href="#hou.BoundingRect.size" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Return a vector describing the size of the rectangle in each of the
x and y axes.</p>
<p>This method can be implemented as follows:</p>
</div></blockquote>
<p>&gt; def size(self):
&gt;     return self.max() - self.min()</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.BoundingRect.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.BoundingRect.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

<dl class="method">
<dt id="hou.BoundingRect.translate">
<code class="descname">translate</code><span class="sig-paren">(</span><em>self</em>, <em>offset</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.BoundingRect.translate" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Moves this rectangle by the amount specified in the two float tuple
or hou.Vector2 passed as the offset parameter.</div></blockquote>
<p>&gt; &gt;&gt;&gt; rect = hou.BoundingRect(1, 1, 2, 2)
&gt; &gt;&gt;&gt; rect.translate(hou.Vector2(1, -1))
&gt; &gt;&gt;&gt; rect
&gt; &lt;hou.BoundingRect [2, 0, 3, 1]&gt;</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.Bundle">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">Bundle</code><a class="headerlink" href="#hou.Bundle" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>hou.NodeBundle</p>
<p>A named set of nodes whose contents can be from different networks. A
bundles contents may be fixed or may be determined from a pattern, and
the contents may be filtered by node type.</p>
<p>Unlike node groups, the nodes in a bundle may be from different node
networks. For example, the same bundle may contain /obj/geo1 and
/obj/subnet1/geo2. Node groups are primarily used to organize and
display very large networks, while node bundles are normally used to
track which objects are lit by a light, which objects are visible in a
scene, etc.</p>
<p>There are two types of node bundles: regular and smart. You can add and
remove individual nodes to and from a regular bundle. The nodes in a
smart bundle, on the other hand, are determined from a pattern stored in
the bundle. As nodes matching the pattern are created or deleted in
Houdini, the contents of the bundle will update automatically. You can
use hou.NodeBundle.pattern to determine if the bundle is a smart bundle
or a regular one.</p>
<p>When a node matches the pattern in a smart bundle, that node and its
children will be added to the bundle. For example, if the pattern in
/obj/<em> and /obj/box_object1 is a geometry object, all the nodes inside
/obj/box_object1 will be added to the bundle, recursively. Carets (^) in
the pattern can be used to remove nodes; for example, /obj/</em>
^/obj/geo1 will match everything in /obj except for /obj/geo1.</p>
<p>A bundle may also have a filter to specify what types of nodes may be in
the bundle. See hou.nodeTypeFilter for the possible filters. If you try
to add a node to a regular bundle but the node does not match the
filter, Houdini will fail to add the node. For smart bundles, the filter
is applied after doing any pattern matching. For example, if the pattern
is /obj/<a href="#id1"><span class="problematic" id="id2">*</span></a> and the filter is hou.nodeTypeFilter.Obj, the bundle will
contain only the objects in /obj, without any SOPs, etc. inside them.
Because the pattern is applied recursively, however, any objects inside
object subnets will also be in the bundle.</p>
<p>To specify a bundle in a node parameter that expects a list of nodes,
prefix the bundle name with &#64;. For example, you can enter &#64;bundle1 in
the light mask parameter of an object so it is lit by the nodes inside
the bundle named bundle1.</p>
<p>You can view and edit node bundles in Houdinis Bundle List pane. Use
<a href="#id51"><span class="problematic" id="id52">hou.nodeBundle_</span></a> and hou.nodeBundles to access existing node bundles, and
hou.addNodeBundle to create a new bundle.</p>
<dl class="method">
<dt id="hou.Bundle.addNode">
<code class="descname">addNode</code><span class="sig-paren">(</span><em>self</em>, <em>node</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Bundle.addNode" title="Permalink to this definition"></a></dt>
<dd><p>Add a node to the bundle.</p>
<p>Raises hou.OperationFailed if this bundle is a smart bundle, since
the contents of smart bundles are automatically determined by their
pattern.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Bundle.clear">
<code class="descname">clear</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Bundle.clear" title="Permalink to this definition"></a></dt>
<dd><p>Remove all nodes from the bundle.</p>
<p>Raises hou.OperationFailed if this bundle is a smart bundle, since
the contents of smart bundles are automatically determined by their
pattern.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Bundle.containsNode">
<code class="descname">containsNode</code><span class="sig-paren">(</span><em>self</em>, <em>node</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.Bundle.containsNode" title="Permalink to this definition"></a></dt>
<dd><p>Return True if the node is in the bundle and False otherwise. node
must be a hou.Node object.</p>
<p>This method is a shortcut for node in bundle.nodes(). For bundles
with many nodes, this method will be slightly faster.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Bundle.convertToNormalBundle">
<code class="descname">convertToNormalBundle</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Bundle.convertToNormalBundle" title="Permalink to this definition"></a></dt>
<dd><p>Convert the bundle into a normal bundle. The smart bundle pattern is
removed.</p>
<p>Do nothing if the bundle is already a normal bundle.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Bundle.convertToSmartBundle">
<code class="descname">convertToSmartBundle</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Bundle.convertToSmartBundle" title="Permalink to this definition"></a></dt>
<dd><p>Convert the bundle into a smart bundle. A regular expression is
constructed from the contents of the bundle and then set as the
bundle pattern.</p>
<p>Do nothing if the bundle is already a smart bundle.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Bundle.destroy">
<code class="descname">destroy</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Bundle.destroy" title="Permalink to this definition"></a></dt>
<dd><p>Remove this bundle.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Bundle.filter">
<code class="descname">filter</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.nodeTypeFilter enum value<a class="headerlink" href="#hou.Bundle.filter" title="Permalink to this definition"></a></dt>
<dd><p>Return the bundles filter. For smart bundles, the filter is applied
after matching nodes to the pattern, and nodes whose types do not
match the filter are removed from the bundle.</p>
<p>See hou.nodeTypeFilter for the possible filters.
hou.nodeTypeFilter.NoFilter is a special value to indicate that
there is no filtering.</p>
<p>See the class documentation for more information about filtering.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Bundle.findBestFilter">
<code class="descname">findBestFilter</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.nodeTypeFilter enum value<a class="headerlink" href="#hou.Bundle.findBestFilter" title="Permalink to this definition"></a></dt>
<dd><p>Return the most restrictive bundle filter that matches all the nodes
in the bundle.</p>
<p>See hou.nodeTypeFilter for the possible filters.
hou.nodeTypeFilter.NoFilter is a special value to indicate that
there is no filtering.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Bundle.isSelected">
<code class="descname">isSelected</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.Bundle.isSelected" title="Permalink to this definition"></a></dt>
<dd><p>Return True if the bundle is selected in the bundle list pane and
False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Bundle.name">
<code class="descname">name</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.Bundle.name" title="Permalink to this definition"></a></dt>
<dd><p>Return the name of the bundle.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Bundle.nodes">
<code class="descname">nodes</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.Node<a class="headerlink" href="#hou.Bundle.nodes" title="Permalink to this definition"></a></dt>
<dd><p>Return a tuple of the nodes in this bundle.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Bundle.pattern">
<code class="descname">pattern</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str or None<a class="headerlink" href="#hou.Bundle.pattern" title="Permalink to this definition"></a></dt>
<dd><p>Return None if this bundle is a regular bundle, or a string pattern
if the bundle is a smart bundle.</p>
<p>See the class documentation for more information on smart bundles.
Note that if a node matches the pattern, all its subchildren will be
in the bundle, as long as they match the filter. For example, if the
pattern is /obj/<a href="#id3"><span class="problematic" id="id4">*</span></a> and the filter is hou.nodeTypeFilter.NoFilter,
the bundle will contain all nodes under /obj, recursively.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Bundle.removeNode">
<code class="descname">removeNode</code><span class="sig-paren">(</span><em>self</em>, <em>node</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Bundle.removeNode" title="Permalink to this definition"></a></dt>
<dd><p>Remove a node from the bundle.</p>
<p>Raises hou.OperationFailed if this bundle is a smart bundle, since
the contents of smart bundles are automatically determined by their
pattern.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Bundle.setFilter">
<code class="descname">setFilter</code><span class="sig-paren">(</span><em>self</em>, <em>node_type_filter</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Bundle.setFilter" title="Permalink to this definition"></a></dt>
<dd><p>Set this bundles filter to a hou.nodeTypeFilter enumerated value.
Use hou.nodeTypeFilter.NoFilter to clear the filter.</p>
<p>See hou.NodeBundle.filter and the class documentation for more
information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Bundle.setName">
<code class="descname">setName</code><span class="sig-paren">(</span><em>self</em>, <em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Bundle.setName" title="Permalink to this definition"></a></dt>
<dd><p>Change the name of the bundle.</p>
<p>Raises hou.OperationFailed if the name contains non-alphanumeric
characters other than _, or if a bundle with that name already
exists.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Bundle.setPattern">
<code class="descname">setPattern</code><span class="sig-paren">(</span><em>self</em>, <em>pattern_or_none</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Bundle.setPattern" title="Permalink to this definition"></a></dt>
<dd><p>Change the pattern of this bundle.</p>
<p>Setting the pattern to None changes the bundle into a regular
bundle. In this case, the bundles contents are unchanged, but
Houdini will no longer do pattern matching to determine the bundles
contents.</p>
<p>If the pattern is a string, the bundle becomes a smart bundle and
its contents immediately change to match the pattern. The bundles
contents will update as nodes are created and deleted in Houdini.</p>
<p>See hou.NodeBundle.pattern and the class documentation for more
information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Bundle.setSelected">
<code class="descname">setSelected</code><span class="sig-paren">(</span><em>self</em>, <em>on</em>, <em>clear_all_selected=false</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Bundle.setSelected" title="Permalink to this definition"></a></dt>
<dd><p>Select this bundle in the bundle list pane. If clear_all_selected is
True, only this bundle will remain selected. Otherwise, this bundle
will be added to the existing selection.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.Bundle.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.Bundle.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.ButtonParmTemplate">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">ButtonParmTemplate</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ButtonParmTemplate" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.ParmTemplate" title="hou.ParmTemplate"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.ParmTemplate</span></code></a></p>
<p>Describes a parameter tuple containing a button.</p>
<dl class="attribute">
<dt id="hou.ButtonParmTemplate.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.ButtonParmTemplate.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.ChannelEditorPane">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">ChannelEditorPane</code><a class="headerlink" href="#hou.ChannelEditorPane" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.PaneTab" title="hou.PaneTab"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.PaneTab</span></code></a></p>
<p>REPLACES</p>
<blockquote>
<div><ul class="simple">
<li>chanlist</li>
<li>chaneditor</li>
</ul>
</div></blockquote>
<dl class="method">
<dt id="hou.ChannelEditorPane.channelListSplitFraction">
<code class="descname">channelListSplitFraction</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; double<a class="headerlink" href="#hou.ChannelEditorPane.channelListSplitFraction" title="Permalink to this definition"></a></dt>
<dd><p>Return the width of the embedded channel list as fraction (0-1
value) of the panes width.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ChannelEditorPane.colorsCallback">
<code class="descname">colorsCallback</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; string<a class="headerlink" href="#hou.ChannelEditorPane.colorsCallback" title="Permalink to this definition"></a></dt>
<dd><p>Return the active channel colors callback name.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ChannelEditorPane.colorsCallbacks">
<code class="descname">colorsCallbacks</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of string<a class="headerlink" href="#hou.ChannelEditorPane.colorsCallbacks" title="Permalink to this definition"></a></dt>
<dd><p>Return the list of registered channel colors callback.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ChannelEditorPane.displayFilter">
<code class="descname">displayFilter</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; string<a class="headerlink" href="#hou.ChannelEditorPane.displayFilter" title="Permalink to this definition"></a></dt>
<dd><p>Return the filter pattern for which channels are displayed.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ChannelEditorPane.editorMode">
<code class="descname">editorMode</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.channelEditorMode enum value<a class="headerlink" href="#hou.ChannelEditorPane.editorMode" title="Permalink to this definition"></a></dt>
<dd><p>Return the animation editor mode.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ChannelEditorPane.graph">
<code class="descname">graph</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.ChannelGraph<a class="headerlink" href="#hou.ChannelEditorPane.graph" title="Permalink to this definition"></a></dt>
<dd><p>Return the channel graph for this pane.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ChannelEditorPane.registerColorsCallback">
<code class="descname">registerColorsCallback</code><span class="sig-paren">(</span><em>self</em>, <em>callback_name</em>, <em>callback_object</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.ChannelEditorPane.registerColorsCallback" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Registers a callback to generate custom channel colors based on the
node and parameter names.</p>
<dl class="docutils">
<dt>callback_name</dt>
<dd>A name for the custom color scheme. You can use this to remove
the callback with the unregisterColorsCallback method.</dd>
<dt>callback_object</dt>
<dd><blockquote class="first">
<div>A Python object with a getChannelColor method. For example:</div></blockquote>
<p>&gt; 
&gt; class MyChannelColors(object):
&gt;     def getChannelColor(self, node_path, channel_name):
&gt;         return 0, 0, 0</p>
<blockquote class="last">
<div>The node argument is the path to the node (for example,
/obj/table). The parm argument is the internal name of the
channel (for example, tx). The method must return a 3-tuple
representing normalized (0-1, not 0-255) red, green, and blue
values. If the method returns (0, 0, 0) Houdini uses the default
channel color.</div></blockquote>
</dd>
</dl>
<p>You should register the callback in a session-independent startup
script. When you register the callback, Houdini will call it once
with empty string arguments to make sure it returns a triple. Your
getChannelColor() method needs to handle this case.</p>
<p>The following example object uses the custom color tint of a node to
color its channels:</p>
</div></blockquote>
<p>&gt; 
&gt; import hou
&gt; 
&gt; class NodeColors:
&gt;     
&gt;     Use hue variants of a nodes color for parameter names 
&gt;     ending in x, y or z.
&gt;     
&gt; 
&gt;     def getChannelColor(self, node_path, channel_name):
&gt;         # Handle the empty string case
&gt;         if not node_path:
&gt;             return 0, 0, 0
&gt; 
&gt;         # Get a Node object from the path
&gt;         n = hou.node(node_path)
&gt;         # Get the nodes color as a hou.Color object
&gt;         color = n.color()
&gt;         # Get the colors HSV values as a triple
&gt;         hue, sat, val = n.color().hsv()
&gt; 
&gt;         # If the color is gray, use the default
&gt;         if not sat:
&gt;             return 0, 0, 0
&gt; 
&gt;         # Hue-shift the node color for X, Y, and Z channels:
&gt;         if channel_name.endswith(x):
&gt;             color.setHSV(hue - 50, sat * 2, val * 1.2)
&gt;         elif channel_name.endswith(y):
&gt;             color.setHSV(hue, sat * 2, val * 1.2)
&gt;         elif channel_name.endswith(z):
&gt;             color.setHSV(hue + 50, sat * 2, val * 1.2)
&gt; 
&gt;         # Return the color as normalized (r, g, b)
&gt;         return color.rgb()</p>
</dd></dl>

<dl class="method">
<dt id="hou.ChannelEditorPane.setChannelListSplitFraction">
<code class="descname">setChannelListSplitFraction</code><span class="sig-paren">(</span><em>self</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ChannelEditorPane.setChannelListSplitFraction" title="Permalink to this definition"></a></dt>
<dd><p>Set the width of the embedded channel list as fraction (0-1 value)
of the panes width.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ChannelEditorPane.setColorsCallback">
<code class="descname">setColorsCallback</code><span class="sig-paren">(</span><em>self</em>, <em>callback_name</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.ChannelEditorPane.setColorsCallback" title="Permalink to this definition"></a></dt>
<dd><p>Set the active channel colors callback name. If the callback name is
invalid, the active callback will be reset to default. Return True
if the callback was successfully changed. Return False if the
callback name was invalid.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ChannelEditorPane.setDisplayFilter">
<code class="descname">setDisplayFilter</code><span class="sig-paren">(</span><em>self</em>, <em>filter</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ChannelEditorPane.setDisplayFilter" title="Permalink to this definition"></a></dt>
<dd><p>Set the filter pattern for which channels are displayed. The channel
name is used to match against the pattern.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ChannelEditorPane.setEditorMode">
<code class="descname">setEditorMode</code><span class="sig-paren">(</span><em>self</em>, <em>mode</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ChannelEditorPane.setEditorMode" title="Permalink to this definition"></a></dt>
<dd><p>Set the animation editor mode.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ChannelEditorPane.setTemplateFilter">
<code class="descname">setTemplateFilter</code><span class="sig-paren">(</span><em>self</em>, <em>filter</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ChannelEditorPane.setTemplateFilter" title="Permalink to this definition"></a></dt>
<dd><p>Set the filter pattern for which channels are templated. The channel
name is used to match against the pattern.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ChannelEditorPane.templateFilter">
<code class="descname">templateFilter</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; string<a class="headerlink" href="#hou.ChannelEditorPane.templateFilter" title="Permalink to this definition"></a></dt>
<dd><p>Return the filter pattern for which channels are templated.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.ChannelEditorPane.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.ChannelEditorPane.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

<dl class="method">
<dt id="hou.ChannelEditorPane.unregisterColorsCallback">
<code class="descname">unregisterColorsCallback</code><span class="sig-paren">(</span><em>self</em>, <em>callback_name</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.ChannelEditorPane.unregisterColorsCallback" title="Permalink to this definition"></a></dt>
<dd><p>Unregister a callback by name. It also resets the active callback if
the callback to remove was the active one. Return True if the
callback was successfully removed. Return False if the callback name
was invalid.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.ChannelGraph">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">ChannelGraph</code><a class="headerlink" href="#hou.ChannelGraph" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>REPLACES</p>
<blockquote>
<div><ul class="simple">
<li>chaneditor</li>
</ul>
</div></blockquote>
<dl class="method">
<dt id="hou.ChannelGraph.selectedKeyframes">
<code class="descname">selectedKeyframes</code><span class="sig-paren">(</span><em>self) -&gt; dictionary of (</em>, <em>tuple of hou.BaseKeyframe</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ChannelGraph.selectedKeyframes" title="Permalink to this definition"></a></dt>
<dd><p>pairs</p>
<blockquote>
<div>Returns a dictionary of (hou.Parm, keyframes) which are currently
selected in the playbar. TIP: Here is an example of how to scale the
selected key values by 2:</div></blockquote>
<p>&gt; keyframes = hou.playbar.selectedKeyframes()
&gt; for parm in keyframes.keys():
&gt;     for key in keyframes[parm]:
&gt;         key.setValue(2 * key.value())
&gt;         parm.setKeyframe(key)</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.ChannelGraph.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.ChannelGraph.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.ChopNode">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">ChopNode</code><a class="headerlink" href="#hou.ChopNode" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.Node" title="hou.Node"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.Node</span></code></a></p>
<p>Class representing a CHOP node.</p>
<p>REPLACES</p>
<blockquote>
<div><ul class="simple">
<li>chopls</li>
<li>opget</li>
<li>opsave</li>
<li>opset</li>
<li>chop()</li>
<li>chope()</li>
<li>chopn()</li>
<li>chopr()</li>
<li>chops()</li>
<li>ic()</li>
<li>ice()</li>
<li>icl()</li>
<li>icmax()</li>
<li>icmin()</li>
<li>icn()</li>
<li>icr()</li>
<li>ics()</li>
<li>oc()</li>
<li>opflag()</li>
</ul>
</div></blockquote>
<dl class="method">
<dt id="hou.ChopNode.bypass">
<code class="descname">bypass</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ChopNode.bypass" title="Permalink to this definition"></a></dt>
<dd><p>Turn the nodes bypass flag on or off, making this node have no
effect.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ChopNode.clipData">
<code class="descname">clipData</code><span class="sig-paren">(</span><em>self</em>, <em>binary</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.ChopNode.clipData" title="Permalink to this definition"></a></dt>
<dd><p>Returns the clip data for the CHOP node in ASCII or binary,
depending on the value of the binary parameter.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ChopNode.frameToSamples">
<code class="descname">frameToSamples</code><span class="sig-paren">(</span><em>self</em>, <em>frame</em><span class="sig-paren">)</span> &#x2192; double<a class="headerlink" href="#hou.ChopNode.frameToSamples" title="Permalink to this definition"></a></dt>
<dd><p>Converts a value expressed as frames to a value expressed in
samples.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ChopNode.isAudioFlagSet">
<code class="descname">isAudioFlagSet</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.ChopNode.isAudioFlagSet" title="Permalink to this definition"></a></dt>
<dd><p>Returns whether the nodes audio flag is on.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ChopNode.isBypassed">
<code class="descname">isBypassed</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.ChopNode.isBypassed" title="Permalink to this definition"></a></dt>
<dd><p>Returns whether the nodes bypass flag is on.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ChopNode.isCurrentFlagSet">
<code class="descname">isCurrentFlagSet</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.ChopNode.isCurrentFlagSet" title="Permalink to this definition"></a></dt>
<dd><p>Returns whether the nodes current flag is on.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ChopNode.isDisplayFlagSet">
<code class="descname">isDisplayFlagSet</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.ChopNode.isDisplayFlagSet" title="Permalink to this definition"></a></dt>
<dd><p>Returns whether the nodes display flag is on.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ChopNode.isExportFlagSet">
<code class="descname">isExportFlagSet</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.ChopNode.isExportFlagSet" title="Permalink to this definition"></a></dt>
<dd><p>Returns whether the nodes export flag is on.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ChopNode.isLocked">
<code class="descname">isLocked</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.ChopNode.isLocked" title="Permalink to this definition"></a></dt>
<dd><p>Returns whether this nodes lock flag is on.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ChopNode.isUnloadFlagSet">
<code class="descname">isUnloadFlagSet</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.ChopNode.isUnloadFlagSet" title="Permalink to this definition"></a></dt>
<dd><p>Returns whether the nodes unload flag is on.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ChopNode.sampleRange">
<code class="descname">sampleRange</code><span class="sig-paren">(</span><em>self) -&gt; (start</em>, <em>end</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ChopNode.sampleRange" title="Permalink to this definition"></a></dt>
<dd><p>Return a 2-tuple containing the start and end values of the sample
range. The number of samples for each track in this node is start-
end+1. Note that samples start from 0, not 1.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ChopNode.sampleRate">
<code class="descname">sampleRate</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; double<a class="headerlink" href="#hou.ChopNode.sampleRate" title="Permalink to this definition"></a></dt>
<dd><p>Returns the sample rate used by this node in number of samples per
second.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ChopNode.samplesToFrame">
<code class="descname">samplesToFrame</code><span class="sig-paren">(</span><em>self</em>, <em>samples</em><span class="sig-paren">)</span> &#x2192; double<a class="headerlink" href="#hou.ChopNode.samplesToFrame" title="Permalink to this definition"></a></dt>
<dd><p>Converts a value expressed as samples to a value expressed in
frames.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ChopNode.samplesToTime">
<code class="descname">samplesToTime</code><span class="sig-paren">(</span><em>self</em>, <em>samples</em><span class="sig-paren">)</span> &#x2192; double<a class="headerlink" href="#hou.ChopNode.samplesToTime" title="Permalink to this definition"></a></dt>
<dd><p>Converts a value expressed as samples to a value expressed in
seconds.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ChopNode.saveClip">
<code class="descname">saveClip</code><span class="sig-paren">(</span><em>self</em>, <em>file_name</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ChopNode.saveClip" title="Permalink to this definition"></a></dt>
<dd><p>Saves the nodes output clip to a file. The filename extension
determines the file format to use.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ChopNode.setAudioFlag">
<code class="descname">setAudioFlag</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ChopNode.setAudioFlag" title="Permalink to this definition"></a></dt>
<dd><p>Turns the nodes audio flag on or off.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ChopNode.setClipData">
<code class="descname">setClipData</code><span class="sig-paren">(</span><em>self</em>, <em>data</em>, <em>binary</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ChopNode.setClipData" title="Permalink to this definition"></a></dt>
<dd><p>Sets the clip data for the CHOP node. Should only be called on
locked nodes.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ChopNode.setCurrentFlag">
<code class="descname">setCurrentFlag</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ChopNode.setCurrentFlag" title="Permalink to this definition"></a></dt>
<dd><p>Turns the nodes audio flag on or off.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ChopNode.setDisplayFlag">
<code class="descname">setDisplayFlag</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ChopNode.setDisplayFlag" title="Permalink to this definition"></a></dt>
<dd><p>Turns the nodes display flag to on or off.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ChopNode.setExportFlag">
<code class="descname">setExportFlag</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ChopNode.setExportFlag" title="Permalink to this definition"></a></dt>
<dd><p>Turns the nodes export flag to on or off.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ChopNode.setLocked">
<code class="descname">setLocked</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ChopNode.setLocked" title="Permalink to this definition"></a></dt>
<dd><p>Turn this nodes lock flag on or off. Locking a node saves its
current cooked channel data into the node. If you unlock a locked
node, it will discard its locked channel data and recook, computing
its channel data from its inputs and parameters.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ChopNode.setUnloadFlag">
<code class="descname">setUnloadFlag</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ChopNode.setUnloadFlag" title="Permalink to this definition"></a></dt>
<dd><p>Turns the nodes unload flag to on or off.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.ChopNode.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.ChopNode.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

<dl class="method">
<dt id="hou.ChopNode.timeToSamples">
<code class="descname">timeToSamples</code><span class="sig-paren">(</span><em>self</em>, <em>time</em><span class="sig-paren">)</span> &#x2192; double<a class="headerlink" href="#hou.ChopNode.timeToSamples" title="Permalink to this definition"></a></dt>
<dd><p>Converts a value expressed in seconds to a value expressed in
samples.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ChopNode.track">
<code class="descname">track</code><span class="sig-paren">(</span><em>self</em>, <em>track_name</em><span class="sig-paren">)</span> &#x2192; hou.Track or None<a class="headerlink" href="#hou.ChopNode.track" title="Permalink to this definition"></a></dt>
<dd><p>Return the track of the given name, or None if it doesnt exist.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ChopNode.tracks">
<code class="descname">tracks</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of Tracks<a class="headerlink" href="#hou.ChopNode.tracks" title="Permalink to this definition"></a></dt>
<dd><p>Returns a tuple of all the tracks in this node.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.Color">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">Color</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Color" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Represents a color value.</p>
<p>You can get and set the internal values using different color
representations such as RGB and L*a*b*.</p>
<p>Note that the constructor takes a single _tuple_ of RGB values, not
three arguments. So, for example, to create red you would say:</p>
<p>&gt; red = hou.Color((1.0, 0, 0))</p>
<p>You can set the color in one color space and get the color in a
different color space to convert between spaces.</p>
<p>See HSL and HSV, Lab color space, CIE 1931 color space, and Color
temperature for an introduction to the concepts the methods are based
on.</p>
<p>REPLACES</p>
<blockquote>
<div><ul class="simple">
<li>rgb()</li>
</ul>
</div></blockquote>
<dl class="method">
<dt id="hou.Color.hsl">
<code class="descname">hsl</code><span class="sig-paren">(</span><em>self) -&gt; (float</em>, <em>float</em>, <em>float</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Color.hsl" title="Permalink to this definition"></a></dt>
<dd><p>Returns the color as a tuple of (hue, saturation, lightness), where
hue is 0 - 360, and saturation and lightness are 0.0 - 1.0.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Color.hsv">
<code class="descname">hsv</code><span class="sig-paren">(</span><em>self) -&gt; (float</em>, <em>float</em>, <em>float</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Color.hsv" title="Permalink to this definition"></a></dt>
<dd><p>Returns the color as a tuple of (hue, saturation, value), where hue
is 0 - 360, and saturation and value are 0.0 - 1.0.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Color.lab">
<code class="descname">lab</code><span class="sig-paren">(</span><em>self) -&gt; (float</em>, <em>float</em>, <em>float</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Color.lab" title="Permalink to this definition"></a></dt>
<dd><p>Returns the color as a tuple of (L, a, b) as defined in the L*a*b*
model, where L is 0 - 100, and a and b are unbound. (Note that a and
b are restricted to -128 - 127 in TIFF files).</p>
</dd></dl>

<dl class="staticmethod">
<dt id="hou.Color.ocio_spaces">
<em class="property">static </em><code class="descname">ocio_spaces</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.Color.ocio_spaces" title="Permalink to this definition"></a></dt>
<dd><p>Returns a list of the color spaces defined in the Open Color IO
configuration in Houdini.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Color.rgb">
<code class="descname">rgb</code><span class="sig-paren">(</span><em>self) -&gt; (float</em>, <em>float</em>, <em>float</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Color.rgb" title="Permalink to this definition"></a></dt>
<dd><p>Returns the color as a tuple of (red, green, blue) floating point
values, where each value is in the range 0.0 to 1.0.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Color.setHSL">
<code class="descname">setHSL</code><span class="sig-paren">(</span><em>self</em>, <em>tuple</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Color.setHSL" title="Permalink to this definition"></a></dt>
<dd><p>Sets the color as a tuple of (hue, saturation, lightness). See the
hsl() method.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Color.setHSV">
<code class="descname">setHSV</code><span class="sig-paren">(</span><em>self</em>, <em>tuple</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Color.setHSV" title="Permalink to this definition"></a></dt>
<dd><p>Sets the color as a tuple of (hue, saturation, value). See the hsv()
method.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Color.setLAB">
<code class="descname">setLAB</code><span class="sig-paren">(</span><em>self</em>, <em>tuple</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Color.setLAB" title="Permalink to this definition"></a></dt>
<dd><p>Sets the color as a tuple of (L, a, b) as defined in the L*a*b*
model. See the lab() method.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Color.setRGB">
<code class="descname">setRGB</code><span class="sig-paren">(</span><em>self</em>, <em>tuple</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Color.setRGB" title="Permalink to this definition"></a></dt>
<dd><p>Sets the color using a tuple of (red, green, blue) floating point
values. See the rgb() method.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Color.setTMI">
<code class="descname">setTMI</code><span class="sig-paren">(</span><em>self</em>, <em>tuple</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Color.setTMI" title="Permalink to this definition"></a></dt>
<dd><p>Sets the color as a tuple of (temperature, magenta, intensity). See
the tmi() method.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Color.setXYZ">
<code class="descname">setXYZ</code><span class="sig-paren">(</span><em>self</em>, <em>tuple</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Color.setXYZ" title="Permalink to this definition"></a></dt>
<dd><p>Sets the color as a tuple of (x, y, z) tristimulus values. See the
xyz() method.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.Color.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.Color.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

<dl class="method">
<dt id="hou.Color.tmi">
<code class="descname">tmi</code><span class="sig-paren">(</span><em>self) -&gt; (float</em>, <em>float</em>, <em>float</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Color.tmi" title="Permalink to this definition"></a></dt>
<dd><p>Returns the color as a tuple of (temperature, magenta, intensity),
where each component is -1.0 to 1.0.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Color.xyz">
<code class="descname">xyz</code><span class="sig-paren">(</span><em>self) -&gt; (float</em>, <em>float</em>, <em>float</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Color.xyz" title="Permalink to this definition"></a></dt>
<dd><p>Returns the color as a tuple of (x, y, z) tristimulus values,
where each component is 0.0 to 1.0 (but may go out of bounds from
conversion).</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="hou.Color_ocio_spaces">
<code class="descclassname">hou.</code><code class="descname">Color_ocio_spaces</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Color_ocio_spaces" title="Permalink to this definition"></a></dt>
<dd><p>ocio_spaces()</p>
<blockquote>
<div>Returns a list of the color spaces defined in the Open Color IO
configuration in Houdini.</div></blockquote>
</dd></dl>

<dl class="class">
<dt id="hou.CompositorViewer">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">CompositorViewer</code><a class="headerlink" href="#hou.CompositorViewer" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.PathBasedPaneTab" title="hou.PathBasedPaneTab"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.PathBasedPaneTab</span></code></a></p>
<p>Minimal class representing a compositing view pane.</p>
<p>This class is currently very simple, implementing a minimal number of
methods necessary to support compositing shelf tools. It does not
currently allow programmatic control of most functions available in the
UI.</p>
<p>You should probably avoid using this object. If you are writing custom
tools for the compositing view, the higher-level functions in the
cop2toolutils module are more useful.</p>
<dl class="method">
<dt id="hou.CompositorViewer.currentState">
<code class="descname">currentState</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.CompositorViewer.currentState" title="Permalink to this definition"></a></dt>
<dd><p>Returns the name of the tool currently in use in the view. This is
an internal, undocumented designation but usually corresponds to the
name of a node. You can change to a different tool using
setCurrentState.</p>
</dd></dl>

<dl class="method">
<dt id="hou.CompositorViewer.enterViewState">
<code class="descname">enterViewState</code><span class="sig-paren">(</span><em>self</em>, <em>wait_for_exit=False</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.CompositorViewer.enterViewState" title="Permalink to this definition"></a></dt>
<dd><p>Switch to the view tool.</p>
</dd></dl>

<dl class="method">
<dt id="hou.CompositorViewer.setCurrentState">
<code class="descname">setCurrentState</code><span class="sig-paren">(</span><em>self</em>, <em>state</em>, <em>wait_for_exit=False</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.CompositorViewer.setCurrentState" title="Permalink to this definition"></a></dt>
<dd><p>Sets the currently active tool in the view. state is a string
containing an internal, undocumented designation. See
currentState().</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.CompositorViewer.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.CompositorViewer.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.ConstructionPlane">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">ConstructionPlane</code><a class="headerlink" href="#hou.ConstructionPlane" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>The grid (a.k.a. construction plane) in the scene viewer pane tab.</p>
<p>REPLACES</p>
<blockquote>
<div><ul class="simple">
<li>cplane</li>
</ul>
</div></blockquote>
<dl class="method">
<dt id="hou.ConstructionPlane.cellSize">
<code class="descname">cellSize</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of float<a class="headerlink" href="#hou.ConstructionPlane.cellSize" title="Permalink to this definition"></a></dt>
<dd><p>Return the x and y sizes (width and height) of one cell in the grid
of cells. The return value is a tuple of two floats.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ConstructionPlane.isVisible">
<code class="descname">isVisible</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.ConstructionPlane.isVisible" title="Permalink to this definition"></a></dt>
<dd><p>Return whether the grid is visible in the viewer.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ConstructionPlane.numberOfCells">
<code class="descname">numberOfCells</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of int<a class="headerlink" href="#hou.ConstructionPlane.numberOfCells" title="Permalink to this definition"></a></dt>
<dd><p>Return the number of cells in the x and y directions of the grid. In
other words, return the number of columns and rows.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ConstructionPlane.numberOfCellsPerRulerLine">
<code class="descname">numberOfCellsPerRulerLine</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of int<a class="headerlink" href="#hou.ConstructionPlane.numberOfCellsPerRulerLine" title="Permalink to this definition"></a></dt>
<dd><p>Return the number of cells in the x and y directions between ruler
lines. Ruler lines are darker than the normal lines drawn between
grid cells.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ConstructionPlane.sceneViewer">
<code class="descname">sceneViewer</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.SceneViewer<a class="headerlink" href="#hou.ConstructionPlane.sceneViewer" title="Permalink to this definition"></a></dt>
<dd><p>Return the scene viewer containing this plane.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ConstructionPlane.setCellSize">
<code class="descname">setCellSize</code><span class="sig-paren">(</span><em>self</em>, <em>size</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ConstructionPlane.setCellSize" title="Permalink to this definition"></a></dt>
<dd><p>Change the x and y sizes (width and height) of each cell in the grid
of cells. size is a sequence of two floats.</p>
<p>Changing the size of each cell will change the total size of the
grid.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ConstructionPlane.setIsVisible">
<code class="descname">setIsVisible</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ConstructionPlane.setIsVisible" title="Permalink to this definition"></a></dt>
<dd><p>Make this grid visible or invisible in the viewer.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ConstructionPlane.setNumberOfCells">
<code class="descname">setNumberOfCells</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.ConstructionPlane.setNumberOfCells" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.ConstructionPlane.setNumberOfCellsPerRulerLine">
<code class="descname">setNumberOfCellsPerRulerLine</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.ConstructionPlane.setNumberOfCellsPerRulerLine" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.ConstructionPlane.setTransform">
<code class="descname">setTransform</code><span class="sig-paren">(</span><em>self</em>, <em>matrix</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ConstructionPlane.setTransform" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Set the transformation matrix for this plane to a hou.Matrix4.</p>
<p>This matrix is used to translate and rotate the plane. See the
transform method for more information.</p>
<p>Note that scale information inside the transformation matrix is
ignored. Use the setCellSize and setNumberOfCells methods to adjust
the size of the plane.</p>
<p>The following function will change the position of the center of the
plane:</p>
</div></blockquote>
<p>&gt; def set_origin(construction_plane, new_origin):
&gt;     translation = hou.hmath.buildTranslate(hou.Vector3(new_origin) - origin(construction_plane))
&gt;     construction_plane.setTransform(construction_plane.transform() * translation)
&gt; 
&gt; def origin(construction_plane):
&gt;     return hou.Vector3(0, 0, 0) * construction_plane.transform()</p>
<blockquote>
<div>The following function will change the normal of the plane:</div></blockquote>
<p>&gt; def set_normal(construction_plane, normal_vector):
&gt;     existing_rotation = hou.Matrix4(construction_plane.transform().extractRotationMatrix3())
&gt;     rotation = existing_rotation * normal(construction_plane).matrixToRotateTo(normal_vector)
&gt;     translation = hou.hmath.buildTranslate(origin(construction_plane))
&gt;     construction_plane.setTransform(rotation * translation)
&gt; 
&gt; def normal(construction_plane):
&gt;     return hou.Vector3(0, 0, 1) * construction_plane.transform().inverted().transposed()
&gt; 
&gt; def origin(construction_plane):
&gt;     return hou.Vector3(0, 0, 0) * construction_plane.transform()</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.ConstructionPlane.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.ConstructionPlane.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

<dl class="method">
<dt id="hou.ConstructionPlane.transform">
<code class="descname">transform</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Matrix4<a class="headerlink" href="#hou.ConstructionPlane.transform" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Return the transformation matrix for this plane.</p>
<p>When the transformation matrix is the identity matrix, the planes
bottom-left corner is at the origin and it sits in the XY plane. In
this orientation, increasing the number of cells in x or the size of
a cell in x grows the plane outward from the origin along the
x-axis. Similarly, increasing the number of cells or size of a cell
in y grows the plane along the y-axis.</p>
<p>Note that the transformation matrix does not contain any scale
information. Use the cellSize and numberOfCells methods to get the
size of the plane.</p>
<p>The following function will return the position of the center of the
plane:</p>
</div></blockquote>
<p>&gt; def origin(construction_plane):
&gt;     return hou.Vector3(0, 0, 0) * construction_plane.transform()</p>
<blockquote>
<div>The following function will return the normal of the plane:</div></blockquote>
<p>&gt; def normal(construction_plane):
&gt;     return hou.Vector3(0, 0, 1) * construction_plane.transform().inverted().transposed()</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.ContextViewer">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">ContextViewer</code><a class="headerlink" href="#hou.ContextViewer" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.PathBasedPaneTab" title="hou.PathBasedPaneTab"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.PathBasedPaneTab</span></code></a></p>
<p>A class representing a context viewer pane tab.</p>
<dl class="method">
<dt id="hou.ContextViewer.compositorViewer">
<code class="descname">compositorViewer</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.CompositorViewer<a class="headerlink" href="#hou.ContextViewer.compositorViewer" title="Permalink to this definition"></a></dt>
<dd><p>Returns a CompositorViewer if the ContextViewer is displaying a
compositor viewer. If not, returns None.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ContextViewer.sceneViewer">
<code class="descname">sceneViewer</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.SceneViewer<a class="headerlink" href="#hou.ContextViewer.sceneViewer" title="Permalink to this definition"></a></dt>
<dd><p>Returns a SceneViewer if the ContextViewer is displaying a scene
viewer. If not, returns None.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.ContextViewer.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.ContextViewer.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.CopNode">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">CopNode</code><a class="headerlink" href="#hou.CopNode" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.Node" title="hou.Node"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.Node</span></code></a></p>
<p>Represents a compositing node.</p>
<p>REPLACES</p>
<blockquote>
<div><ul class="simple">
<li>pic()</li>
<li>picni()</li>
<li>opflag()</li>
<li>opget</li>
<li>opsave</li>
<li>opset</li>
<li>res()</li>
<li>seqanim()</li>
<li>seqend()</li>
<li>seqlength()</li>
<li>seqstart()</li>
<li>copmeta()</li>
<li>copmetas()</li>
</ul>
</div></blockquote>
<dl class="method">
<dt id="hou.CopNode.allPixels">
<code class="descname">allPixels</code><span class="sig-paren">(</span><em>self</em>, <em>plane=&quot;C&quot;</em>, <em>component=None</em>, <em>interleaved=True</em>, <em>time=-1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.CopNode.allPixels" title="Permalink to this definition"></a></dt>
<dd><p>-&gt; tuple of float</p>
<p>Return a tuple of floats containing all pixel values for a
particular image plane. The pixels in the bottom scanline of the
image are first in the result, followed by the second-last scanline,
etc. Floating point values in the color plane (C), for example,
are typically in the range 0.0 to 1.0.</p>
<dl class="docutils">
<dt>plane</dt>
<dd>The name of the image plane to return. All images have C
(color) and A (alpha) planes. Deep raster images may contain
other planes, such as Pz (depth), N (normal), etc.</dd>
<dt>component</dt>
<dd>A particular subcomponent of the plane. For example, for the C
plane you could specify one of the r, g, or b
subcomponents. Specify None to indicate all components.</dd>
<dt>interleaved</dt>
<dd>Whether the different components of the plane are interleaved in
the result. For example, if the plane is C, the interleaved
result would be organized as rgbrgbrgb while the
uninterleaved result would be rrrgggbbb. This parameter
has no effect when a particular component is specified.</dd>
<dt>time</dt>
<dd><p class="first">The time at which to cook the COP node. If this value is
negative, Houdini uses the current time.</p>
<p class="last">Note that this argument does not apply if allPixels is called
from a Python COP that is cooking. In that case allPixels
evaluates at the current cooking time.</p>
</dd>
</dl>
<p>This method does not accept a depth parameter like allPixelsAsString
does. The values are converted to floating point data, regardless of
the actual depth of the image plane.</p>
<p>Raises hou.OperationFailed if the time argument is set to a value
greater than or equal to 0.0 and allPixels is called from a cooking
Python COP.</p>
</dd></dl>

<dl class="method">
<dt id="hou.CopNode.allPixelsAsString">
<code class="descname">allPixelsAsString</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.CopNode.allPixelsAsString" title="Permalink to this definition"></a></dt>
<dd><p>allPixelsAsString(self, plane=C, component=None, interleaved=True,
time=-1.0, depth=None) -&gt; str</p>
<blockquote>
<div><blockquote>
<div><p>Return a binary string representation of the floats containing all
the values of all voxels. This method is faster than
hou.CopNode.allPixels, and you can use the array module to convert
the string into a Python sequence. Note that this method returns
binary float data, so there are 4 bytes per R, G, and B component,
not 1 byte.</p>
<p>If depth is hou.imageDepth.Float32, this method provides a faster
implementation of the following:</p>
</div></blockquote>
<p>&gt; import array
&gt; def allPixelsAsString(self):
&gt;     return array.array(f, self.allPixels()).tostring()</p>
<blockquote>
<div><p>If depth is None and this method is called from the code
implementing a Python COP to get an input plane, the depth will be
the same as the planes native depth. If depth is None and this
method is called from outside a Python COP, the depth will be
hou.imageDepth.Float32. Otherwise, if depth is a hou.imageDepth
enumerated value the result will be converted to the specified
depth.</p>
<p>See hou.CopNode.allPixels for more information. See also
hou.Volume.setVoxelSliceFromString.</p>
<p>Raises hou.OperationFailed if the time argument is set to a value
greater than or equal to 0.0 and allPixelsAsString is called from a
cooking Python COP.</p>
</div></blockquote>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.CopNode.bypass">
<code class="descname">bypass</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.CopNode.bypass" title="Permalink to this definition"></a></dt>
<dd><p>Turns the nodes bypass flag on or off. When the bypass flag is on,
the node will have no effect on the scene. The value of the on
argument must be True or False.</p>
<p>Raises hou.PermissionError if the node is unwritable.</p>
</dd></dl>

<dl class="method">
<dt id="hou.CopNode.components">
<code class="descname">components</code><span class="sig-paren">(</span><em>self</em>, <em>plane</em><span class="sig-paren">)</span> &#x2192; tuple of str<a class="headerlink" href="#hou.CopNode.components" title="Permalink to this definition"></a></dt>
<dd><p>Returns a tuple of component names for the specified plane in the
nodes image sequence. The value of the plane argument must be a
plane name.</p>
<p>Raises ValueError if plane is None or empty. Raises
hou.OperationFailed if the node could not be cooked or opened for
processing. Raises hou.OperationFailed if the given plane does not
exist.</p>
</dd></dl>

<dl class="method">
<dt id="hou.CopNode.depth">
<code class="descname">depth</code><span class="sig-paren">(</span><em>self</em>, <em>plane</em><span class="sig-paren">)</span> &#x2192; hou.imageDepth enum value<a class="headerlink" href="#hou.CopNode.depth" title="Permalink to this definition"></a></dt>
<dd><p>Return the data format used to represent one component of one pixel
in the given image plane.</p>
<p>For example, if the depth of the C (color) plane is
hou.imageDepth.Int8, each of the red, green, and blue components is
stored as an (unsigned) 8-bit integer, occupying one byte. If, for
example, it is instead hou.imageDepth.Float32, each of the red,
green, and blue components is a 32-bit float and occupies 4 bytes
(12 bytes total for all 3 components combined).</p>
</dd></dl>

<dl class="method">
<dt id="hou.CopNode.getMetaDataFloat">
<code class="descname">getMetaDataFloat</code><span class="sig-paren">(</span><em>self</em>, <em>metadata_name</em>, <em>index=0</em><span class="sig-paren">)</span> &#x2192; double<a class="headerlink" href="#hou.CopNode.getMetaDataFloat" title="Permalink to this definition"></a></dt>
<dd><p>Returns numeric metadata as a single double precision value. In the
case of vectors, matrices and arrays, index indicates the component
to fetch.</p>
</dd></dl>

<dl class="method">
<dt id="hou.CopNode.getMetaDataFloatArray">
<code class="descname">getMetaDataFloatArray</code><span class="sig-paren">(</span><em>self</em>, <em>metadata_name</em><span class="sig-paren">)</span> &#x2192; tuple of double<a class="headerlink" href="#hou.CopNode.getMetaDataFloatArray" title="Permalink to this definition"></a></dt>
<dd><p>Returns numeric metadata as an array of double-precision values.</p>
</dd></dl>

<dl class="method">
<dt id="hou.CopNode.getMetaDataInt">
<code class="descname">getMetaDataInt</code><span class="sig-paren">(</span><em>self</em>, <em>metadata_name</em>, <em>index=0</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.CopNode.getMetaDataInt" title="Permalink to this definition"></a></dt>
<dd><p>Returns numeric metadata as a single integer. In the case of
vectors, matrices and arrays, index indicates the component to
fetch. Floating point metadata will be truncated.</p>
</dd></dl>

<dl class="method">
<dt id="hou.CopNode.getMetaDataIntArray">
<code class="descname">getMetaDataIntArray</code><span class="sig-paren">(</span><em>self</em>, <em>metadata_name</em><span class="sig-paren">)</span> &#x2192; tuple of int<a class="headerlink" href="#hou.CopNode.getMetaDataIntArray" title="Permalink to this definition"></a></dt>
<dd><p>Returns numeric metadata as an array of integers. Floating point
metadata values will be truncated.</p>
</dd></dl>

<dl class="method">
<dt id="hou.CopNode.getMetaDataString">
<code class="descname">getMetaDataString</code><span class="sig-paren">(</span><em>self</em>, <em>metadata_name</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.CopNode.getMetaDataString" title="Permalink to this definition"></a></dt>
<dd><p>Returns string metadata from metadata_name.</p>
</dd></dl>

<dl class="method">
<dt id="hou.CopNode.getPixelByUV">
<code class="descname">getPixelByUV</code><span class="sig-paren">(</span><em>self</em>, <em>plane</em>, <em>u</em>, <em>v</em>, <em>component=None</em>, <em>interpolate=True</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.CopNode.getPixelByUV" title="Permalink to this definition"></a></dt>
<dd><p>tuple of float</p>
<p>Returns plane values for a single pixel in the nodes image. The
plane is defined by the plane argument which must be set to the
planes name. The pixel is defined by (u, v) coordinates where u and
v are values between 0.0 and 1.0. If the optional component argument
is specified, then the value for that particular component is
returned. Otherwise, all of the planes component values are
returned. The value of component should be the components name
(i.e. r, g, b, etc.).</p>
<p>If the (u, v) coordinates do not fall exactly on a pixel, then the
return values are calculated by linear blending of the values for
the surrounding pixels. This can be disabled by setting the
interpolate argument to False, in which case the values of the pixel
located immediately to the bottom-left of (u, v) are returned.</p>
<p>Note that the returned values are for the nodes image at the
current frame.</p>
<p>Raises ValueError if either u or v is outside of the 0.0-1.0 range.
Raises ValueError if plane is None or empty. Raises
hou.OperationFailed if the node could not be cooked or opened for
processing. Raises hou.OperationFailed if the given plane does not
exist. Raises hou.OperationFailed if the given component does not
exist in the plane.</p>
</dd></dl>

<dl class="method">
<dt id="hou.CopNode.getPixelHSVByUV">
<code class="descname">getPixelHSVByUV</code><span class="sig-paren">(</span><em>self</em>, <em>u</em>, <em>v</em>, <em>interpolate=True</em><span class="sig-paren">)</span> &#x2192; tuple of float<a class="headerlink" href="#hou.CopNode.getPixelHSVByUV" title="Permalink to this definition"></a></dt>
<dd><p>Returns a 3-tuple containing the hue, saturation and value for a
single pixel in the nodes image. The pixel is defined by (u, v)
coordinates where u and v are values between 0.0 and 1.0.</p>
<p>If the (u, v) coordinates do not fall exactly on a pixel, then the
return values are calculated by linear blending of the values for
the surrounding pixels. This can be disabled by setting the
interpolate argument to False, in which case the values of the pixel
located immediately to the bottom-left of (u, v) are returned.</p>
<p>Note that the returned hue, saturation and value are for the nodes
image at the current frame.</p>
<p>Raises ValueError if either u or v is outside of the 0.0-1.0 range.
Raises hou.OperationFailed if the node could not be cooked or opened
for processing.</p>
</dd></dl>

<dl class="method">
<dt id="hou.CopNode.getPixelLuminanceByUV">
<code class="descname">getPixelLuminanceByUV</code><span class="sig-paren">(</span><em>self</em>, <em>u</em>, <em>v</em>, <em>interpolate=True</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#hou.CopNode.getPixelLuminanceByUV" title="Permalink to this definition"></a></dt>
<dd><p>Returns the luminance value for a single pixel in the nodes image.
The pixel is defined by (u, v) coordinates where u and v are values
between 0.0 and 1.0.</p>
<p>If the (u, v) coordinates do not fall exactly on a pixel, then the
luminance is calculated by linear blending of the luminance values
for the surrounding pixels. This can be disabled by setting the
interpolate argument to False, in which case the luminance of the
pixel located immediately to the bottom-left of (u, v) is returned.</p>
<p>Note that the returned luminance value is for the nodes image at
the current frame.</p>
<p>Raises ValueError if either u or v is outside of the 0.0-1.0 range.
Raises hou.OperationFailed if the node could not be cooked or opened
for processing.</p>
</dd></dl>

<dl class="method">
<dt id="hou.CopNode.hasMetaData">
<code class="descname">hasMetaData</code><span class="sig-paren">(</span><em>self</em>, <em>metadata_name</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.CopNode.hasMetaData" title="Permalink to this definition"></a></dt>
<dd><p>Returns True if the metadata with name metadata_name exists, False
otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="hou.CopNode.imageBounds">
<code class="descname">imageBounds</code><span class="sig-paren">(</span><em>self</em>, <em>plane=&quot;C&quot;</em><span class="sig-paren">)</span> &#x2192; tuple of int<a class="headerlink" href="#hou.CopNode.imageBounds" title="Permalink to this definition"></a></dt>
<dd><p>Returns the x and y boundaries of the given plane in the form of
(xmin, ymin, xmax, ymax). The value of the plane argument is the
plane name. By default, the image bounds of the color plane is
returned.</p>
<p>Note that the image bounds is not the same as the image resolution.
For example, the image bounds for a Font COP is the bounding
rectangle around the displayed letters while the resolution is the
size of the nodes image.</p>
<p>Note that the returned image bounds is for the current frame.</p>
<p>Raises ValueError if plane is None or empty. Raises
hou.OperationFailed if the node could not be cooked or opened for
processing. Raises hou.OperationFailed if the given plane does not
exist.</p>
</dd></dl>

<dl class="method">
<dt id="hou.CopNode.isBypassed">
<code class="descname">isBypassed</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.CopNode.isBypassed" title="Permalink to this definition"></a></dt>
<dd><p>Returns True if the nodes bypass flag is turned on. Returns False
otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="hou.CopNode.isCompressFlagSet">
<code class="descname">isCompressFlagSet</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.CopNode.isCompressFlagSet" title="Permalink to this definition"></a></dt>
<dd><p>Returns True if the nodes compress flag is turned on. Returns False
otherwise. The compress flag controls whether or not a preview image
is shown for this node in the Network View.</p>
</dd></dl>

<dl class="method">
<dt id="hou.CopNode.isDisplayFlagSet">
<code class="descname">isDisplayFlagSet</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.CopNode.isDisplayFlagSet" title="Permalink to this definition"></a></dt>
<dd><p>Returns True if the nodes display flag is turned on. Returns False
otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="hou.CopNode.isRenderFlagSet">
<code class="descname">isRenderFlagSet</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.CopNode.isRenderFlagSet" title="Permalink to this definition"></a></dt>
<dd><p>Returns True if the nodes render flag is turned on. Returns False
otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="hou.CopNode.isSingleImage">
<code class="descname">isSingleImage</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.CopNode.isSingleImage" title="Permalink to this definition"></a></dt>
<dd><p>Returns True if the node has a single image. Returns False if the
node has an image sequence.</p>
</dd></dl>

<dl class="method">
<dt id="hou.CopNode.isTemplateFlagSet">
<code class="descname">isTemplateFlagSet</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.CopNode.isTemplateFlagSet" title="Permalink to this definition"></a></dt>
<dd><p>Returns True if the nodes template flag is turned on. Returns False
otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="hou.CopNode.maskInputIndex">
<code class="descname">maskInputIndex</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.CopNode.maskInputIndex" title="Permalink to this definition"></a></dt>
<dd><p>Return the input index of the mask input for this node. Return -1 if
this node type does not provide a mask input.</p>
</dd></dl>

<dl class="method">
<dt id="hou.CopNode.planes">
<code class="descname">planes</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of strings<a class="headerlink" href="#hou.CopNode.planes" title="Permalink to this definition"></a></dt>
<dd><p>Returns a tuple of plane names in the nodes image sequence.</p>
<p>Raises hou.OperationFailed if the node could not be cooked or opened
for processing.</p>
</dd></dl>

<dl class="method">
<dt id="hou.CopNode.saveImage">
<code class="descname">saveImage</code><span class="sig-paren">(</span><em>self</em>, <em>file_name</em>, <em>frame_range=()</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.CopNode.saveImage" title="Permalink to this definition"></a></dt>
<dd><p>Saves the nodes cooked image sequence to disk. For multiple images,
make sure that the file_name argument contains $F so that the
sequence is written to multiple files.</p>
<p>The optional frame_range argument can be specified to write only a
subset of frames in the image sequence. frame_range must be a
2-tuple or a 3-tuple, where the first element is the start frame,
the second element is the end frame and the third element is the
frame increment. If frame_range is not given, then every frame in
the image sequence is saved to disk.</p>
<p>Raises ValueError if the frame increment in frame_range is 0. Raises
hou.InvalidSize if the size of frame_range is not 0, 2 or 3. Raises
hou.OperationFailed if the node could not be cooked or opened for
processing. Raises hou.OperationFailed if the image could not be
saved to disk.</p>
</dd></dl>

<dl class="method">
<dt id="hou.CopNode.sequenceEndFrame">
<code class="descname">sequenceEndFrame</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#hou.CopNode.sequenceEndFrame" title="Permalink to this definition"></a></dt>
<dd><p>Returns the last frame in the nodes image sequence.</p>
<p>Raises hou.OperationFailed if the node could not be cooked or opened
for processing.</p>
</dd></dl>

<dl class="method">
<dt id="hou.CopNode.sequenceFrameLength">
<code class="descname">sequenceFrameLength</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#hou.CopNode.sequenceFrameLength" title="Permalink to this definition"></a></dt>
<dd><p>Returns the frame length of the nodes image sequence.</p>
<p>Raises hou.OperationFailed if the node could not be cooked or opened
for processing.</p>
</dd></dl>

<dl class="method">
<dt id="hou.CopNode.sequenceStartFrame">
<code class="descname">sequenceStartFrame</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#hou.CopNode.sequenceStartFrame" title="Permalink to this definition"></a></dt>
<dd><p>Returns the start frame in the nodes image sequence.</p>
<p>Raises hou.OperationFailed if the node could not be cooked or opened
for processing.</p>
</dd></dl>

<dl class="method">
<dt id="hou.CopNode.setCompressFlag">
<code class="descname">setCompressFlag</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.CopNode.setCompressFlag" title="Permalink to this definition"></a></dt>
<dd><p>Turns the nodes compress flag on or off. If the compress flag is
True, this node will not show a preview image in the Network View.
If the compress flag is False, a preview image will be shown in the
Network View. The value of the on argument must be True or False.</p>
<p>Raises hou.PermissionError if the node is unwritable.</p>
</dd></dl>

<dl class="method">
<dt id="hou.CopNode.setDisplayFlag">
<code class="descname">setDisplayFlag</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.CopNode.setDisplayFlag" title="Permalink to this definition"></a></dt>
<dd><p>Turns the nodes display flag on or off. When the display flag is
on, the nodes image will appear in the image viewport. The value of
the on argument must be True or False.</p>
<p>Raises hou.PermissionError if the node is unwritable.</p>
</dd></dl>

<dl class="method">
<dt id="hou.CopNode.setPixelsOfCookingPlane">
<code class="descname">setPixelsOfCookingPlane</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.CopNode.setPixelsOfCookingPlane" title="Permalink to this definition"></a></dt>
<dd><p>setPixelsOfCookingPlane(self, values, component=None, interleaved=True,
flip_vertically=False)</p>
<blockquote>
<div><p>Set the pixels of the plane being cooked by the currently-running
Python COP.</p>
<dl class="docutils">
<dt>values</dt>
<dd><p class="first">A sequence of floats, organized with the contents of the bottom
scanline first.</p>
<p class="last">If component is None, the length of the sequence of floats must
be the number of pixels in the image times the number of
components. Otherwise, it must be the number of pixels in the
image.</p>
</dd>
<dt>component</dt>
<dd>Either the name of one component in the plane being cooked, or
None. If a component name is given, values will contain only the
values for that component. Otherwise, it will contain the values
for all components of all pixels in the plane.</dd>
<dt>interleaved</dt>
<dd><p class="first">If component is None and interleaved is True, values is contains
the first component of the first pixel, followed by the second
component of the first pixel, until the last component of the
first pixel, then the first component of the second pixel, etc.
If it is False, values contains all the values of the first
component for all pixels, followed by all the values of the
second component, etc.</p>
<p>For example, if the plane is C and interleaved is True, the
values will be organized as rgbrgbrgb. If it is not
interleaved, it will be organized as rrrgggbbb.</p>
<p class="last">If component is not None, this parameter is ignored.</p>
</dd>
<dt>flip_vertically</dt>
<dd>The default value for this parameter is False, so the first
scanline in the values array is assumed to be the bottom
scanline. If flip_vertically is True, the input values are
assumed to oriented starting at the top scanline.</dd>
</dl>
<p>If you call this method from outside the cook function in a Python
COP, raises hou.OperationFailed.</p>
<p>See also hou.CopNode.allPixels and
hou.CopNode.setPixelsOfCookingPlaneFromString. Also see the HOM
cookbook and the Python COP documentation for examples.</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.CopNode.setPixelsOfCookingPlaneFromString">
<code class="descname">setPixelsOfCookingPlaneFromString</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.CopNode.setPixelsOfCookingPlaneFromString" title="Permalink to this definition"></a></dt>
<dd><p>setPixelsOfCookingPlaneFromString(self, values, component=None,
interleaved=True, depth=None, flip_vertically=False)</p>
<blockquote>
<div><p>Set the pixels of the plane being cooked by the currently-running
Python COP. This method is like hou.CopNode.setPixelsOfCookingPlane
except values contains a binary string representation of the data
instead of a sequence of floats. Consequently, this method is
faster.</p>
<p>The depth parameter specifies how to interpret the values in the
binary string, and is a hou.imageDepth enumerated value. If depth is
None, the depth is assumed to be in the depth of the plane being
cooked. Note that, by specifying depth explicitly, you can provide
data in any depth, regardless of the actual depth stored by the COP.</p>
<p>Note that this method can accept more types that just a string: it
can receive any Python object that supports the buffer interface. In
particular, arrays from the array and numpy Python modules are
supported, so there is no need to first construct strings from those
arrays.</p>
<p>See hou.CopNode.setPixelsOfCookingPlane and
hou.CopNode.allPixelsAsString for more information.</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.CopNode.setRenderFlag">
<code class="descname">setRenderFlag</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.CopNode.setRenderFlag" title="Permalink to this definition"></a></dt>
<dd><p>Turns the nodes render flag on or off. The render flag controls
which node in a compositing network will be rendered to or to disk.
The value of the on argument must be True or False.</p>
<p>Raises hou.PermissionError if the node is unwritable.</p>
</dd></dl>

<dl class="method">
<dt id="hou.CopNode.setTemplateFlag">
<code class="descname">setTemplateFlag</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.CopNode.setTemplateFlag" title="Permalink to this definition"></a></dt>
<dd><p>Turns the nodes template flag on or off. The value of the on
argument must be True or False.</p>
<p>Raises hou.PermissionError if the node is unwritable.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.CopNode.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.CopNode.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

<dl class="method">
<dt id="hou.CopNode.xRes">
<code class="descname">xRes</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.CopNode.xRes" title="Permalink to this definition"></a></dt>
<dd><p>Returns the x-resolution of the nodes image for the current frame.</p>
<p>Raises hou.OperationFailed if the node could not be cooked or opened
for processing.</p>
</dd></dl>

<dl class="method">
<dt id="hou.CopNode.yRes">
<code class="descname">yRes</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.CopNode.yRes" title="Permalink to this definition"></a></dt>
<dd><p>Returns the y-resolution of the nodes image for the current frame.</p>
<p>Raises hou.OperationFailed if the node could not be cooked or opened
for processing.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.DataParmTemplate">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">DataParmTemplate</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.DataParmTemplate" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.ParmTemplate" title="hou.ParmTemplate"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.ParmTemplate</span></code></a></p>
<p>Describes a parameter tuple containing data values.</p>
<dl class="method">
<dt id="hou.DataParmTemplate.dataParmType">
<code class="descname">dataParmType</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.dataParmType enum value<a class="headerlink" href="#hou.DataParmTemplate.dataParmType" title="Permalink to this definition"></a></dt>
<dd><p>Return the type of this data parameter. This type determines whether
the parameter stores geometry data or a JSON map structure.</p>
<p>See hou.dataParmType for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.DataParmTemplate.defaultExpression">
<code class="descname">defaultExpression</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of strings<a class="headerlink" href="#hou.DataParmTemplate.defaultExpression" title="Permalink to this definition"></a></dt>
<dd><p>Return the default expression for new parameter instances.</p>
<p>The default expression takes precendence over the default value. If
a component has no default expression (i.e. an empty string), then
the default value is used for new parameter instances.</p>
<p>Note that the default expression language is needed to interpret the
meaning of the default expression.</p>
<p>For example, suppose this parm template is named t, the naming
scheme is XYZW, it has 3 components, the default value is (1.0, 2.0,
3.0), the default expression is ($F, hou.frame(), ) and the
default expression language is (hou.scriptLanguage.Hscript,
hou.scriptLanguage.Python, hou.scriptLanguage.Hscript). Then the
corresponding parm tuple instance on a node would be named t and
would contain parameters tx, ty, tz. When the node is created,
tx would have a default Hscript expression of $F, ty would
have a default Python expression of hou.frame(), and tz would
have a default value of 3.0.</p>
</dd></dl>

<dl class="method">
<dt id="hou.DataParmTemplate.defaultExpressionLanguage">
<code class="descname">defaultExpressionLanguage</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.scriptLanguage<a class="headerlink" href="#hou.DataParmTemplate.defaultExpressionLanguage" title="Permalink to this definition"></a></dt>
<dd><p>Return the default expression language for new parameter instances.</p>
<p>The default expression language only applies if the default
expression is set. If the default expression of a component is not
set, then the expression language is set to
hou.scriptLanguage.Hscript.</p>
</dd></dl>

<dl class="method">
<dt id="hou.DataParmTemplate.setDataParmType">
<code class="descname">setDataParmType</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.DataParmTemplate.setDataParmType" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.DataParmTemplate.setDefaultExpression">
<code class="descname">setDefaultExpression</code><span class="sig-paren">(</span><em>self</em>, <em>default_expression</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.DataParmTemplate.setDefaultExpression" title="Permalink to this definition"></a></dt>
<dd><p>Set the default expression for new parameter instances to a sequence
of strings.</p>
<p>See the hou.DataParmTemplate.defaultExpression method for more
information. Note that if the number of strings in the sequence is
different from the number of components in the parm template, any
extra values will be discarded and any missing expressions will
become the empty string.</p>
</dd></dl>

<dl class="method">
<dt id="hou.DataParmTemplate.setDefaultExpressionLanguage">
<code class="descname">setDefaultExpressionLanguage</code><span class="sig-paren">(</span><em>self</em>, <em>default_expression_language</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.DataParmTemplate.setDefaultExpressionLanguage" title="Permalink to this definition"></a></dt>
<dd><p>Set the default expression language for new parameter instances to a
sequence of hou.scriptLanguage values.</p>
<p>See the defaultExpressionLanguage method for more information. Note
that if the number of hou.scriptLanguage values in the sequence is
different from the number of components in the parm template, any
extra values will be discarded and any missing expression languages
will become hou.scriptLanguage.Hscript.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.DataParmTemplate.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.DataParmTemplate.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.DataTree">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">DataTree</code><a class="headerlink" href="#hou.DataTree" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.PaneTab" title="hou.PaneTab"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.PaneTab</span></code></a></p>
<p>Represents a Data Tree panetab.</p>
<dl class="method">
<dt id="hou.DataTree.clearCurrentPath">
<code class="descname">clearCurrentPath</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.DataTree.clearCurrentPath" title="Permalink to this definition"></a></dt>
<dd><p>Clears the node(s) currently selected in the tree.</p>
</dd></dl>

<dl class="method">
<dt id="hou.DataTree.currentPath">
<code class="descname">currentPath</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.DataTree.currentPath" title="Permalink to this definition"></a></dt>
<dd><p>Returns the path to the current node in the tree.</p>
</dd></dl>

<dl class="method">
<dt id="hou.DataTree.setCurrentNodeExpanded">
<code class="descname">setCurrentNodeExpanded</code><span class="sig-paren">(</span><em>self</em>, <em>expanded</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.DataTree.setCurrentNodeExpanded" title="Permalink to this definition"></a></dt>
<dd><p>Sets the expanded state of the currently selected node in the tree.
If there is no selected node the method has no effect on the tree.</p>
</dd></dl>

<dl class="method">
<dt id="hou.DataTree.setCurrentPath">
<code class="descname">setCurrentPath</code><span class="sig-paren">(</span><em>self</em>, <em>path</em>, <em>multi=False</em>, <em>index=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.DataTree.setCurrentPath" title="Permalink to this definition"></a></dt>
<dd><p>Sets the currently selected node in the tree. If the provided path
does not match a node in the tree, the tree will still attempt to
set the current node to the best possible match of the provided
path.</p>
<p>If multi is set to True, the previous selection will not be cleared
before selecting the new the node. This allows multiple nodes to be
selected in the tree.</p>
</dd></dl>

<dl class="method">
<dt id="hou.DataTree.setCurrentPaths">
<code class="descname">setCurrentPaths</code><span class="sig-paren">(</span><em>self</em>, <em>paths</em>, <em>expand</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.DataTree.setCurrentPaths" title="Permalink to this definition"></a></dt>
<dd><p>Selects mutliple nodes in the data tree based on the array of paths
passed in. If the expand flag is set to True the tree nodes will be
expanded after selection.</p>
</dd></dl>

<dl class="method">
<dt id="hou.DataTree.setTreeExpanded">
<code class="descname">setTreeExpanded</code><span class="sig-paren">(</span><em>self</em>, <em>expanded</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.DataTree.setTreeExpanded" title="Permalink to this definition"></a></dt>
<dd><p>Recursively sets the expanded state of the entire data tree.</p>
</dd></dl>

<dl class="method">
<dt id="hou.DataTree.setTreeType">
<code class="descname">setTreeType</code><span class="sig-paren">(</span><em>self</em>, <em>tree_type</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.DataTree.setTreeType" title="Permalink to this definition"></a></dt>
<dd><p>Changes the tree type being displayed in the Data Tree. Valid values
are any strings returned by the treeTypes function. Returns True if
the tree type was successfully changed, otherwise False.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.DataTree.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.DataTree.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

<dl class="method">
<dt id="hou.DataTree.treeType">
<code class="descname">treeType</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.DataTree.treeType" title="Permalink to this definition"></a></dt>
<dd><p>Returns the current tree type being shown in the Data Tree. This
function may return an empty string if no tree type has been chosen
yet.</p>
</dd></dl>

<dl class="method">
<dt id="hou.DataTree.treeTypes">
<code class="descname">treeTypes</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of str<a class="headerlink" href="#hou.DataTree.treeTypes" title="Permalink to this definition"></a></dt>
<dd><p>Returns a tuple of strings that represent the different tree types
that can be shown in the Data Tree pane.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.Desktop">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">Desktop</code><a class="headerlink" href="#hou.Desktop" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Class representing a Houdini desktop (a pane layout).</p>
<p>A desktop contains one or more panes. Each pane contains one or more
pane tabs of various types (scene viewer, parameters, network editor,
etc.) The main desktop window can be split horizontally or vertically
into two panes, and each pane can itself be split horizontally or
vertically.</p>
<p>Note that a floating panel also contains one or more panes and a
floating panel may optionally be attached to a desktop.</p>
<p>The methods in this class that return pane tabs, panes, and floating
panels only return those objects that are attached to (i.e. saved with)
the desktop. To access all the visible pane tabs, panes, and floating
panels, including those not attached to any desktop, use the functions
in hou.ui.</p>
<p>See also hou.ui.curDesktop, hou.ui.desktops, hou.Pane, hou.PaneTab, and
hou.FloatingPanel.</p>
<dl class="method">
<dt id="hou.Desktop.createFloatingPane">
<code class="descname">createFloatingPane</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Desktop.createFloatingPane" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.Desktop.createFloatingPaneTab">
<code class="descname">createFloatingPaneTab</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Desktop.createFloatingPaneTab" title="Permalink to this definition"></a></dt>
<dd><p>createFloatingPaneTab(self, pane_tab_type, position=(), size=(),
python_panel_interface=None) -&gt; hou.PaneTab</p>
<blockquote>
<div><blockquote>
<div><p>Create and return a new floating window containing a single pane
tab. Note that this method creates a floating panel with a single
pane tab, and the graphical interface to add more tabs or split the
pane inside the panel is not exposed.</p>
<dl class="docutils">
<dt>pane_tab_type</dt>
<dd>A hou.paneTabType enumerated variable.</dd>
<dt>position</dt>
<dd>A tuple of two floats specifying the X and Y positions of the
new window, respectively. The window will open near this
position, not necessarily exactly at this position. If this
value is an empty tuple, Houdini will choose a default location.</dd>
<dt>size</dt>
<dd>A tuple of two floats specifying the width and height of the new
window, respectively. If this value is an empty tuple, Houdini
will choose a default size.</dd>
<dt>python_panel_interface</dt>
<dd><p class="first">The name of the Python Panel interface to be displayed in the
floating pane tab. Specifying the interface name additionally
hides the Python Panel toolbar. If python_panel_interface is
None or points to an interface that does not exist then the
default Python Panel pane tab is displayed along with the
toolbar.</p>
<p class="last">This argument is ignored if pane_tab_type is not set to
hou.paneTabType.PythonPanel.</p>
</dd>
</dl>
<p>Also note that the floating panel containing the new pane tab does
not contain any panes: calling hou.PaneTab.pane on the pane tab
returns None, and calling hou.FloatingPanel.panes on its floating
panel returns an empty tuple. See hou.FloatingPanel for more
information on these stripped down floating panels.</p>
<p>See also hou.Desktop.createFloatingPanel.</p>
<p>The following example function takes a hou.Node and opens a floating
parameter pane pinned to that node.</p>
</div></blockquote>
<p>&gt; def openParmPane(node):
&gt;     Open a floating parameter pane for a particular node.
&gt;     pane_tab = hou.ui.curDesktop().createFloatingPaneTab(hou.paneTabType.Parm)
&gt;     pane_tab.setCurrentNode(node)
&gt;     pane_tab.setPin(True)
&gt;     return pane_tab</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.Desktop.createFloatingPanel">
<code class="descname">createFloatingPanel</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Desktop.createFloatingPanel" title="Permalink to this definition"></a></dt>
<dd><p>createFloatingPanel(self, pane_tab_type, position=(), size=(),
python_panel_interface=None) -&gt; hou.FloatingPanel</p>
<blockquote>
<div><blockquote>
<div><p>Create a floating panel and return it. The returned floating panel
contains one pane which contains one pane tab of the desired type.</p>
<p>See hou.Desktop.createFloatingPaneTab for a description of the
parameters. This method differs from createFloatingPaneTab in two
ways: First, it returns the floating panel instead of the pane tab.
Second, the floating panel that is created from this method is not
locked down, and the user can add more pane tabs and split the
panes.</p>
<p>The following example creates a floating panel with a parameters
pane tab and a channel viewer (motion viewer) pane tab:</p>
</div></blockquote>
<p>&gt; panel = hou.ui.curDesktop().createFloatingPanel(hou.paneTabType.Parm)
&gt; pane1 = panel.panes()[0]
&gt; pane2 = pane1.splitVertically()
&gt; pane2.tabs()[0].setType(hou.paneTabType.ChannelViewer)</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.Desktop.currentPaneTabs">
<code class="descname">currentPaneTabs</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.PaneTab<a class="headerlink" href="#hou.Desktop.currentPaneTabs" title="Permalink to this definition"></a></dt>
<dd><p>Return the pane tabs that are contained in this desktop or are in
floating panels attached to this desktop and are currently selected
in their containing panes.</p>
<p>This method does not return floating pane tabs that are not attached
to this desktop. Use hou.ui.currentPaneTabs to get all the selected
pane tabs, regardless of whether they are attached to this desktop.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Desktop.displayHelp">
<code class="descname">displayHelp</code><span class="sig-paren">(</span><em>self</em>, <em>node_type</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Desktop.displayHelp" title="Permalink to this definition"></a></dt>
<dd><p>Loads the help for the specified node type in the last opened help
browser pane tab. Creates a help browser pane tab if no such pane
tab already exists.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Desktop.displayHelpPath">
<code class="descname">displayHelpPath</code><span class="sig-paren">(</span><em>self</em>, <em>help_path</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Desktop.displayHelpPath" title="Permalink to this definition"></a></dt>
<dd><p>Loads the help for the specified help path in the last opened help
browser pane tab. Creates a help browser pane tab if no such pane
tab already exists. The path can either be a Houdini help URL (i.e.
op:Sop/copy, tool:curve) or a raw help path (i.e. /nodes/sop/copy,
shelf/curve).</p>
</dd></dl>

<dl class="method">
<dt id="hou.Desktop.displayHelpPyPanel">
<code class="descname">displayHelpPyPanel</code><span class="sig-paren">(</span><em>self</em>, <em>interface_name</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Desktop.displayHelpPyPanel" title="Permalink to this definition"></a></dt>
<dd><p>Loads the help for the python panel with the specified name in the
last opened help browser pane tab. Creates a help browser pane tab
if no such pane tab already exists.</p>
<p>Raises HOM_Error if the interface name is invalid.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Desktop.displaySideHelp">
<code class="descname">displaySideHelp</code><span class="sig-paren">(</span><em>self</em>, <em>show=True</em><span class="sig-paren">)</span> &#x2192; hou.PaneTab<a class="headerlink" href="#hou.Desktop.displaySideHelp" title="Permalink to this definition"></a></dt>
<dd><p>Show or hide the side help pane.</p>
<p>If show is set to True (default) this method displays the help pane
and returns a help browser pane tab. If set to False then this
method hides the help browser pane at the side of the desktop and
returns None.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Desktop.findPane">
<code class="descname">findPane</code><span class="sig-paren">(</span><em>self</em>, <em>pane_id</em><span class="sig-paren">)</span> &#x2192; hou.Pane or None<a class="headerlink" href="#hou.Desktop.findPane" title="Permalink to this definition"></a></dt>
<dd><p>Return the pane with the given unique id, or None if no such pane
exists. Like hou.Desktop.panes, this method searches panes in the
desktop or in floating panels attached to the desktop.</p>
<p>Use hou.ui.findPane to search all the visible panes, regardless of
whether they are attached to this desktop.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Desktop.findPaneTab">
<code class="descname">findPaneTab</code><span class="sig-paren">(</span><em>self</em>, <em>name</em><span class="sig-paren">)</span> &#x2192; hou.PaneTab or None<a class="headerlink" href="#hou.Desktop.findPaneTab" title="Permalink to this definition"></a></dt>
<dd><p>Return the pane tab with the given name, or None if no such tab
exists. Like hou.Desktop.paneTabs, this method searches pane tabs in
the desktop or in floating panels attached to the desktop.</p>
<p>The name may optionally be prefixed by the desktop name and a
period.</p>
<p>Use hou.ui.findPaneTab to search all the visible pane tabs,
regardless of whether they are attached to this desktop.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Desktop.floatingPaneTabs">
<code class="descname">floatingPaneTabs</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.PaneTab<a class="headerlink" href="#hou.Desktop.floatingPaneTabs" title="Permalink to this definition"></a></dt>
<dd><p>Return all the pane tabs in floating panels that are attached to
this desktop.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Desktop.floatingPanels">
<code class="descname">floatingPanels</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.FloatingPanel<a class="headerlink" href="#hou.Desktop.floatingPanels" title="Permalink to this definition"></a></dt>
<dd><p>Return all the floating panels attached to this desktop.</p>
<p>Use hou.ui.floatingPanels to get all the visible floating panels,
including those not attached to this desktop.</p>
<p>See also hou.Desktop.floatingPaneTabs.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Desktop.name">
<code class="descname">name</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.Desktop.name" title="Permalink to this definition"></a></dt>
<dd><p>Return the desktops name.</p>
<p>Each desktop has a unique name. The desktops name cannot be changed
through either the scripting interface or through Houdini.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Desktop.paneTabOfType">
<code class="descname">paneTabOfType</code><span class="sig-paren">(</span><em>self</em>, <em>type</em>, <em>index=0</em><span class="sig-paren">)</span> &#x2192; hou.PaneTab or None<a class="headerlink" href="#hou.Desktop.paneTabOfType" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Find and return the pane tab with the desired type. If no such tab
exists, return None. Like hou.Desktop.paneTabs, this method searches
pane tabs in the desktop or in floating panels attached to the
desktop.</p>
<p>Use hou.ui.paneTabOfType to search all the visible pane tabs,
regardless of whether they are attached to this desktop.</p>
<dl class="docutils">
<dt>type</dt>
<dd>A hou.paneTabType enumerated variable.</dd>
<dt>index</dt>
<dd>If there are multiple tabs with the desired type, this parameter
determines which one is returned. Use index=0 to return the
first found tab, index=1 to return the second found tab, etc. By
default, index is 0.</dd>
</dl>
<p>This method can be approximately implemented as follows:</p>
</div></blockquote>
<p>&gt; def paneTabOfType(self, tab_type, index=0):
&gt;     pane_tabs = [t for t in self.paneTabs() if t.type() == tab_type]
&gt; 
&gt;     if max(index, 0) &gt; len(pane_tabs):
&gt;         return None
&gt;     return pane_tabs[max(index, 0)]</p>
</dd></dl>

<dl class="method">
<dt id="hou.Desktop.paneTabUnderCursor">
<code class="descname">paneTabUnderCursor</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Desktop.paneTabUnderCursor" title="Permalink to this definition"></a></dt>
<dd><p>Similar to hou.Desktop.paneUnderCursor but return the hou.PaneTab
object instead located under the mouse cursor. Return None if no
pane tab is located under the mouse cursor.</p>
<p>This method does not search floating pane tabs that are not attached
to this desktop. Use hou.ui.paneTabUnderCursor to search all the
visible pane tabs, regardless of whether they are attached to this
desktop.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Desktop.paneTabs">
<code class="descname">paneTabs</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.PaneTab<a class="headerlink" href="#hou.Desktop.paneTabs" title="Permalink to this definition"></a></dt>
<dd><p>Return the pane tabs that are contained in this desktop or are in
floating panels attached to this desktop.</p>
<p>This method does not return floating pane tabs that are not attached
to this desktop. Use hou.ui.paneTabs to get all the visible pane
tabs, regardless of whether they are attached to this desktop.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Desktop.paneUnderCursor">
<code class="descname">paneUnderCursor</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Desktop.paneUnderCursor" title="Permalink to this definition"></a></dt>
<dd><p>Return the hou.Pane object located under the mouse cursor. Return
None if no pane is located under the mouse cursor.</p>
<p>This method does not search floating panes that are not attached to
this desktop. Use hou.ui.paneUnderCursor to search all the visible
panes, regardless of whether they are attached to this desktop.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Desktop.panes">
<code class="descname">panes</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.Pane<a class="headerlink" href="#hou.Desktop.panes" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Return the panes inside this desktop. Note that the result includes
panes in floating panels as long as they are attached to the
desktop.</p>
<p>The following function will return all visible panes, regardless of
whether or not they are attached to a desktop:</p>
</div></blockquote>
<p>&gt; def allPanes():
&gt;     Return a tuple of all visible panes, regardless of whether or not
&gt;        they are attached to a desktop.
&gt;     # Loop through all the pane tabs and add each tabs pane to the result
&gt;     # if its not already there.  Note that the only way to uniquely
&gt;     # identify a pane is using its id.
&gt;     ids_to_panes = {}
&gt;     for pane_tab in hou.ui.paneTabs():
&gt;         pane = pane_tab.pane()
&gt;         if pane.id() not in ids_to_panes:
&gt;             ids_to_panes[pane.id()] = pane
&gt;     return ids_to_panes.values()</p>
</dd></dl>

<dl class="method">
<dt id="hou.Desktop.setAsCurrent">
<code class="descname">setAsCurrent</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Desktop.setAsCurrent" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Make this desktop the currently selected one. See also
hou.ui.desktops.</p>
<p>This example changes to the animate desktop:</p>
</div></blockquote>
<p>&gt; desktops_dict = dict((d.name(), d) for d in hou.ui.desktops())
&gt; desktops_dict[Animate].setAsCurrent()</p>
</dd></dl>

<dl class="method">
<dt id="hou.Desktop.shelfDock">
<code class="descname">shelfDock</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.ShelfDock<a class="headerlink" href="#hou.Desktop.shelfDock" title="Permalink to this definition"></a></dt>
<dd><p>Return the shelf dock for the current desktop.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.Desktop.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.Desktop.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.Dialog">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">Dialog</code><a class="headerlink" href="#hou.Dialog" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Class representing a Houdini dialog.</p>
<p>This class represents only dialogs created by hou..ui.createDialog.</p>
<p>Custom dialogs can be created with Houdinis User Interface Script
Language. An overview of the language can be found in the Houdini
Development Kit (HDK) documentation, specifically in the Houdini User
Interface -&gt; The .ui Script Language section.</p>
<dl class="method">
<dt id="hou.Dialog.addCallback">
<code class="descname">addCallback</code><span class="sig-paren">(</span><em>self</em>, <em>name</em>, <em>callback</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Dialog.addCallback" title="Permalink to this definition"></a></dt>
<dd><p>Register a callback function for the specified UI variable.</p>
<p>The function is invoked when the value of the UI variable changes
and receives no arguments.</p>
<p>Raises hou.TypeError if name is None. Raises hou.OperationFailed if
no UI variable with the specified name exists.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Dialog.callbacks">
<code class="descname">callbacks</code><span class="sig-paren">(</span><em>self</em>, <em>name</em><span class="sig-paren">)</span> &#x2192; tuple of callbacks<a class="headerlink" href="#hou.Dialog.callbacks" title="Permalink to this definition"></a></dt>
<dd><p>Return all callback functions registered with the given UI variable.</p>
<p>Raises hou.TypeError if name is None. Raises hou.OperationFailed if
no UI variable with the specified name exists.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Dialog.destroy">
<code class="descname">destroy</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Dialog.destroy" title="Permalink to this definition"></a></dt>
<dd><p>Delete this dialog.</p>
<p>If you call methods on a Dialog instance after it has been
destroyed, Houdini will raise hou.ObjectWasDeleted.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Dialog.enableValue">
<code class="descname">enableValue</code><span class="sig-paren">(</span><em>self</em>, <em>name</em>, <em>onoff</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Dialog.enableValue" title="Permalink to this definition"></a></dt>
<dd><p>Enable or disable the specified UI variable.</p>
<p>Set onoff to True to enable the variable. Set onoff to False to
disable the variable.</p>
<p>Raises hou.TypeError if either name is None. Raises
hou.OperationFailed if no UI variable with the specified name
exists.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Dialog.menuItems">
<code class="descname">menuItems</code><span class="sig-paren">(</span><em>self</em>, <em>name</em><span class="sig-paren">)</span> &#x2192; tuple of str<a class="headerlink" href="#hou.Dialog.menuItems" title="Permalink to this definition"></a></dt>
<dd><p>Return the menu entries for the specified UI variable.</p>
<p>Raises hou.TypeError if name is None. Raises hou.OperationFailed if
no UI variable with the specified name exists. Raises
hou.OperationFailed if the UI variable does not point to a menu.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Dialog.removeCallback">
<code class="descname">removeCallback</code><span class="sig-paren">(</span><em>self</em>, <em>name</em>, <em>callback</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Dialog.removeCallback" title="Permalink to this definition"></a></dt>
<dd><p>Remove the specified callback function from the UI variable.</p>
<p>Raises hou.TypeError if name is None. Raises hou.OperationFailed if
no UI variable with the specified name exists. Raises
hou.OperationFailed if the specified callback is not registered with
the UI variable.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Dialog.setMenuItems">
<code class="descname">setMenuItems</code><span class="sig-paren">(</span><em>self</em>, <em>name</em>, <em>items</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Dialog.setMenuItems" title="Permalink to this definition"></a></dt>
<dd><p>Set the menu entries in the specified UI variable.</p>
<p>Raises hou.TypeError if name is None. Raises hou.OperationFailed if
no UI variable with the specified name exists. Raises
hou.OperationFailed if the UI variable does not point to a menu.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Dialog.setValue">
<code class="descname">setValue</code><span class="sig-paren">(</span><em>self</em>, <em>name</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Dialog.setValue" title="Permalink to this definition"></a></dt>
<dd><p>Set the value of the specified UI variable.</p>
<p>Raises hou.TypeError if either name or value is None. Raises
hou.OperationFailed if no UI variable with the specified name
exists.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.Dialog.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.Dialog.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

<dl class="method">
<dt id="hou.Dialog.value">
<code class="descname">value</code><span class="sig-paren">(</span><em>self</em>, <em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Dialog.value" title="Permalink to this definition"></a></dt>
<dd><p>Return the value of the given UI variable.</p>
<p>Raises hou.TypeError if name is None. Raises hou.OperationFailed if
no UI variable with the specified name exists.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Dialog.waitForValueToChangeTo">
<code class="descname">waitForValueToChangeTo</code><span class="sig-paren">(</span><em>self</em>, <em>name</em>, <em>new_value</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Dialog.waitForValueToChangeTo" title="Permalink to this definition"></a></dt>
<dd><p>Wait for the specified UI variable to change its value to new_value.</p>
<p>This is a blocking call. The method will return execution when the
variable has changed to the desired value. Note that Houdini will
remain responsive even when this method is blocked waiting.</p>
<p>If the variables current value is already set to new_value then
this method will return immediately.</p>
<p>Raises hou.TypeError if name is None. Raises hou.OperationFailed if
no UI variable with the specified name exists.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.DopData">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">DopData</code><a class="headerlink" href="#hou.DopData" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A piece of data stored inside a DOP networks simulation.</p>
<p>Each DOP network builds a tree of data, and then Houdini examines and
updates this tree when it runs the simulation. DOP data elements can be
DOP objects, geometry, volumes, forces, solvers, etc. The data is
arranged in a tree structure, where child nodes are called subdata and
are said to be attached to their parent nodes. Under the root of the
tree are usually the DOP objects and data describing their
relationships.</p>
<p>Note that the same piece of data can appear in the tree in multiple
locations, with different names. DopData objects thus do not store their
name, and the name of a piece of data in the tree is instead stored with
its parent data(s).</p>
<p>By default, DopData objects store the path within the tree to the data.
As a consequence, if the time changes and the solvers within the
simulation change the contents of the tree of data, the Python DopData
object will update to refer to the simulations new state. If the data
path no longer refers to valid data, Houdini raises hou.ObjectWasDeleted
when you try to access the DopData object from Python.</p>
<p>If you do not want the DopData to update with changes to the simulation,
you can call hou.DopData.freeze. freeze returns another DopData object
that refers the simulations state at the current time, and will not
change when the simulation time changes.</p>
<p>Each piece of data can contain records, and each record stores a list of
name and value pairs called fields. Each record has a name, but its
possible for multiple records with the same name to exist in the same
piece of data. In this case, the record also has an index, and you can
think of the records as rows of a spreadsheet.</p>
<dl class="method">
<dt id="hou.DopData.attachSubData">
<code class="descname">attachSubData</code><span class="sig-paren">(</span><em>self</em>, <em>data</em>, <em>new_data_name</em>, <em>avoid_name_collisions=False</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.DopData.attachSubData" title="Permalink to this definition"></a></dt>
<dd><p>Make existing data become subdata of this data. Houdini does not
create a duplicate of the data. Instead, the datas parent(s) and
this data will both refer to the same instance of subdata. You would
call this method from a script solver DOP.</p>
<dl class="docutils">
<dt>data</dt>
<dd>The DopData that will become subdata of this data.</dd>
<dt>new_data_name</dt>
<dd>The name of the new subdata.</dd>
<dt>avoid_name_collisions</dt>
<dd>If True and data with the specified name exists, Houdini will
create a unique name that does not conflict with any existing
data.</dd>
</dl>
<p>Raises hou.OperationFailed if data with this name already exists. If
you want to replace existing data it is up to you to first call
hou.DopData.removeData.</p>
<p>Raises hou.PermissionError if called from outside a script solver
DOP.</p>
<p>See hou.DopData.copyContentsFrom for an example of how to create a
copy of existing data.</p>
</dd></dl>

<dl class="method">
<dt id="hou.DopData.copyContentsFrom">
<code class="descname">copyContentsFrom</code><span class="sig-paren">(</span><em>self</em>, <em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.DopData.copyContentsFrom" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Copy the contents of the given DopData into this one, adapting the
data if it is of a different type. You would call this method from a
script solver DOP.</p>
<p>Raises hou.PermissionError if called from outside a script solver
DOP.</p>
<p>Use this method along with hou.DopData.createSubData to copy
existing subdata:</p>
</div></blockquote>
<p>&gt; def copySubData(new_parent_data, data_to_copy, new_data_name, avoid_name_collisions=False):
&gt;     Create a copy of data and attach it to other data.
&gt;     new_data = new_parent_data.createSubData(new_data_name, data_to_copy.dataType(), avoid_name_collisions)
&gt;     new_data.copyContentsFrom(data_to_copy)
&gt;     return new_data</p>
</dd></dl>

<dl class="method">
<dt id="hou.DopData.createSubData">
<code class="descname">createSubData</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.DopData.createSubData" title="Permalink to this definition"></a></dt>
<dd><p>createSubData(self, data_name, data_type=SIM_EmptyData,
avoid_name_collisions=False) -&gt; hou.DopData</p>
<blockquote>
<div><p>Create subdata under this data with the specified name and type. You
would call this method from a script solver DOP.</p>
<dl class="docutils">
<dt>data_name</dt>
<dd>The name of the new data. Note that this name may contain
slashes to create subdata on existing data.</dd>
<dt>data_type</dt>
<dd>Either the name of the data type to create or a hou.DopDataType
instance. If you simply want something containing an empty
options record, use SIM_EmptyData.</dd>
<dt>avoid_name_collisions</dt>
<dd>If True and data with the specified name exists, Houdini will
create a unique name that does not conflict with any existing
data.</dd>
</dl>
<p>Raises hou.OperationFailed if data with this name already exists. If
you want to replace existing data it is up to you to first call
hou.DopData.removeData.</p>
<p>Raises hou.PermissionError if called from outside a script solver
DOP.</p>
<p>Use hou.DopData.attachSubData to create a reference to existing
data. See hou.DopData.copyContentsFrom for an example of how to
create a copy of existing data.</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.DopData.creator">
<code class="descname">creator</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.DopNode<a class="headerlink" href="#hou.DopData.creator" title="Permalink to this definition"></a></dt>
<dd><p>Return the DOP node that created this DOP data inside the DOP
network.</p>
</dd></dl>

<dl class="method">
<dt id="hou.DopData.dataType">
<code class="descname">dataType</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.DopData.dataType" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Return a string describing the type of data this object contains.</div></blockquote>
<p>&gt; &gt;&gt;&gt; obj = hou.node(/obj/AutoDopNetwork).simulation().objects()[0]
&gt; &gt;&gt;&gt; obj.dataType()
&gt; SIM_Object</p>
<blockquote>
<div>See also hou.DopData.dataTypeObject.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.DopData.dopNetNode">
<code class="descname">dopNetNode</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Node<a class="headerlink" href="#hou.DopData.dopNetNode" title="Permalink to this definition"></a></dt>
<dd><p>Return the DOP network node containing this DOP data.</p>
</dd></dl>

<dl class="method">
<dt id="hou.DopData.findAllSubData">
<code class="descname">findAllSubData</code><span class="sig-paren">(</span><em>self</em>, <em>data_spec</em>, <em>recurse=False</em><span class="sig-paren">)</span> &#x2192; dict of str to<a class="headerlink" href="#hou.DopData.findAllSubData" title="Permalink to this definition"></a></dt>
<dd><p>hou.DopData</p>
<blockquote>
<div>Given a pattern, return a dictionary mapping subdata paths to DOP
data instances for all the subdatas whose name matches the pattern.
If recurse is True, all grandchildren subdata will be added to the
result.</div></blockquote>
<p>&gt; # The following code assumes you have created a box from the shelf and used
&gt; # Rigid Bodies &gt; RBD Object on the shelf to make it a rigid body.
&gt; &gt;&gt;&gt; obj = hou.node(/obj/AutoDopNetwork).simulation().objects()[0]
&gt; &gt;&gt;&gt; obj.findAllSubData(S*).keys()
&gt; [SolverParms, Solver]
&gt; &gt;&gt;&gt; obj.findAllSubData(S*, recurse=True).keys()
&gt; [SolverParms, Solver/Random, SolverParms/ActiveValue, Solver]
&gt; &gt;&gt;&gt; obj.findAllSubData(S*/<a href="#id5"><span class="problematic" id="id6">*</span></a>, recurse=True).keys()
&gt; [SolverParms/ActiveValue, Solver/Random]</p>
</dd></dl>

<dl class="method">
<dt id="hou.DopData.findSubData">
<code class="descname">findSubData</code><span class="sig-paren">(</span><em>self</em>, <em>data_spec</em><span class="sig-paren">)</span> &#x2192; hou.DopData or None<a class="headerlink" href="#hou.DopData.findSubData" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Return the DOP data with the given name that is attached to this DOP
data, or None if no such data exists. Note that the name may also be
a slash-separated path to nested subdata.</p>
<p>See hou.DopData.subData for an example.</p>
<p>This method can be approximately implemented as follows:</p>
</div></blockquote>
<p>&gt; def findSubData(self, data_spec):
&gt;     data = self
&gt;     for name in data_spec.split(/):
&gt;         if name not in data.subData():
&gt;             return None
&gt;         data = data.subData()[name]
&gt;     return data</p>
</dd></dl>

<dl class="method">
<dt id="hou.DopData.freeze">
<code class="descname">freeze</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.DopData<a class="headerlink" href="#hou.DopData.freeze" title="Permalink to this definition"></a></dt>
<dd><p>Return a frozen version of this DopData. Frozen versions of the data
will not update when the simulation updates. Instead, they will
refer to the state of the simulation at the time they were frozen.</p>
<p>It is ok to call this method on a DopData object that is already
frozen.</p>
</dd></dl>

<dl class="method">
<dt id="hou.DopData.id">
<code class="descname">id</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.DopData.id" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Return the globally unique identifier (GUID) for this DOP data. This
method is a shortcut for self.record(Basic).field(uniqueid).</p>
<p>If you want an objects index, hou.DopObject.objid.</p>
</div></blockquote>
<p>&gt; &gt;&gt;&gt; obj = hou.node(/obj/AutoDopNetwork).simulation().objects()[0]
&gt; &gt;&gt;&gt; obj.id()
&gt; 0xD011E41C-0x000034AE-0x494C12E4-0x000018B9
&gt; &gt;&gt;&gt; obj.objid()
&gt; 0</p>
</dd></dl>

<dl class="method">
<dt id="hou.DopData.isFrozen">
<code class="descname">isFrozen</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.DopData.isFrozen" title="Permalink to this definition"></a></dt>
<dd><p>Return whether or not this data is frozen.</p>
<p>See hou.DopData.freeze for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.DopData.options">
<code class="descname">options</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.DopRecord<a class="headerlink" href="#hou.DopData.options" title="Permalink to this definition"></a></dt>
<dd><p>Return the Options record. This method is a shortcut for
self.record(Options).</p>
</dd></dl>

<dl class="method">
<dt id="hou.DopData.path">
<code class="descname">path</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.DopData.path" title="Permalink to this definition"></a></dt>
<dd><p>Return the path to this object within the tree of DOP data. This
path includes the DOP object or relationship as the first part of
the path.</p>
<p>Note that the same piece of DOP data can exist in multiple places of
the tree. The path returned is the path stored inside this Python
DopData object, since the Python object uses the path to look up the
underlying data each time you call a method on it.</p>
<p>Note that the path is only available for unfrozen objects. If you
call this method on a frozen DopData object it raises
hou.OperationFailed.</p>
</dd></dl>

<dl class="method">
<dt id="hou.DopData.record">
<code class="descname">record</code><span class="sig-paren">(</span><em>self</em>, <em>record_type</em>, <em>record_index=0</em><span class="sig-paren">)</span> &#x2192; hou.DopRecord<a class="headerlink" href="#hou.DopData.record" title="Permalink to this definition"></a></dt>
<dd><p>Given a record type name return that record, or None if no record
exists with that name. If this DOP data contains multiple records
with this record type name you can think of each record as a row in
a spreadsheet, and record_index determines which one is returned.
Use len(self.records(record_type)) to determine how many records of
this type are in this DOP data.</p>
<p>Use hou.DopData.recordTypes to get a tuple of record types in a DOP
data. See also hou.DopData.records for an example, and see
hou.DopData.options for a way to easily access the Options record.</p>
</dd></dl>

<dl class="method">
<dt id="hou.DopData.recordTypes">
<code class="descname">recordTypes</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of str<a class="headerlink" href="#hou.DopData.recordTypes" title="Permalink to this definition"></a></dt>
<dd><p>Return a tuple of strings containing the record types stored inside
this DOP data. Each DOP data contains records named Basic and
Options, and some types of DOP data contain additional records.</p>
</dd></dl>

<dl class="method">
<dt id="hou.DopData.records">
<code class="descname">records</code><span class="sig-paren">(</span><em>self</em>, <em>record_type</em><span class="sig-paren">)</span> &#x2192; tuple of hou.DopRecord<a class="headerlink" href="#hou.DopData.records" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Return a tuple of all the records of this record type. See also
hou.DopData.record.</p>
<p>This example lists the input affectors for a rigid body box that
collides with a ground plane:</p>
</div></blockquote>
<p>&gt; &gt;&gt;&gt; obj = hou.node(/obj/AutoDopNetwork).simulation().objects()[-1]
&gt; &gt;&gt;&gt; obj.records(RelInAffectors)
&gt; (&lt;hou.DopRecord of type RelInAffectors index 0&gt;, &lt;hou.DopRecord of type RelInAffectors index 1&gt;)
&gt; &gt;&gt;&gt; [record.field(relname) for record in obj.records(RelInAffectors)]
&gt; [merge1, staticsolver1_staticsolver1]
&gt; &gt;&gt;&gt; obj.record(RelInAffectors, 1).field(relname)
&gt; staticsolver1_staticsolver1</p>
</dd></dl>

<dl class="method">
<dt id="hou.DopData.removeSubData">
<code class="descname">removeSubData</code><span class="sig-paren">(</span><em>self</em>, <em>data_spec</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.DopData.removeSubData" title="Permalink to this definition"></a></dt>
<dd><p>Remove subdata with the given name. Raises hou.PermissionError if
called from outside a script solver DOP.</p>
<p>Raises hou.OperationFailed if data with that name already exists.</p>
</dd></dl>

<dl class="method">
<dt id="hou.DopData.selectionPath">
<code class="descname">selectionPath</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.DopData.selectionPath" title="Permalink to this definition"></a></dt>
<dd><p>For DopData objects returned from a hou.SceneViewer.selectDynamics
function call, this will return the a string that contains both the
path to the DOP Network that created the data, and the path within
the DOP data tree which uniquely identifies this DopData. This
string is specifically intended to be passed in the
prior_selection_paths argument of the hou.SceneViewer selection
methods.</p>
</dd></dl>

<dl class="method">
<dt id="hou.DopData.simulation">
<code class="descname">simulation</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.DopSimulation<a class="headerlink" href="#hou.DopData.simulation" title="Permalink to this definition"></a></dt>
<dd><p>Return the DOP simulation containing this DOP data. This method is a
shortcut for self.dopNetNode().simulation().</p>
</dd></dl>

<dl class="method">
<dt id="hou.DopData.subData">
<code class="descname">subData</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; dict of str to hou.DopData<a class="headerlink" href="#hou.DopData.subData" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Return a dictionary mapping names to DOP data instances for the
subdata attached to this data.</div></blockquote>
<p>&gt; # The following code assumes you have created a box from the shelf and used
&gt; # Rigid Bodies &gt; RBD Object on the shelf to make it a rigid body.
&gt; &gt;&gt;&gt; obj = hou.node(/obj/AutoDopNetwork).simulation().objects()[0]
&gt; &gt;&gt;&gt; obj
&gt; &lt;hou.DopObject box_object1 id 0&gt;
&gt; &gt;&gt;&gt; obj.recordTypes()
&gt; (Basic, Options, RelInGroup, RelInAffectors)
&gt; &gt;&gt;&gt; record = obj.record(Options)
&gt; &gt;&gt;&gt; record.fieldNames()
&gt; (name, groups, affectors, affectorids, objid)
&gt; &gt;&gt;&gt; record.field(name)
&gt; box_object1
&gt; 
&gt; &gt;&gt;&gt; obj.subData().keys()
&gt; [PhysicalParms, ODE_Body, Solver, Geometry, SolverParms, ODE_Geometry, Forces, Position, Colliders]
&gt; &gt;&gt;&gt; obj.findSubData(Forces/Gravity_gravity1)
&gt; &lt;hou.DopData of type SIM_ForceGravity&gt;
&gt; &gt;&gt;&gt; obj.findSubData(Forces/Gravity_gravity1).options().field(force)
&gt; &lt;hou.Vector3 [0, -9.80665, 0]&gt;</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.DopData.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.DopData.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.DopNode">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">DopNode</code><a class="headerlink" href="#hou.DopNode" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.Node" title="hou.Node"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.Node</span></code></a></p>
<p>Represents a dynamics node.</p>
<dl class="method">
<dt id="hou.DopNode.bypass">
<code class="descname">bypass</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.DopNode.bypass" title="Permalink to this definition"></a></dt>
<dd><p>Turn the nodes bypass flag on or off, making this node have no
effect.</p>
</dd></dl>

<dl class="method">
<dt id="hou.DopNode.createdObjects">
<code class="descname">createdObjects</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.DopObject<a class="headerlink" href="#hou.DopNode.createdObjects" title="Permalink to this definition"></a></dt>
<dd><p>Return a tuple of DOP objects that this DOP node creates.</p>
</dd></dl>

<dl class="method">
<dt id="hou.DopNode.displayNode">
<code class="descname">displayNode</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Node or None<a class="headerlink" href="#hou.DopNode.displayNode" title="Permalink to this definition"></a></dt>
<dd><p>If this node is a subnet (i.e. it contains child nodes), return the
child that has its display flag set, or None if there are no
children. Otherwise, return None.</p>
</dd></dl>

<dl class="method">
<dt id="hou.DopNode.dopNetNode">
<code class="descname">dopNetNode</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Node<a class="headerlink" href="#hou.DopNode.dopNetNode" title="Permalink to this definition"></a></dt>
<dd><p>Return the DOP network node that contains this DOP node.</p>
</dd></dl>

<dl class="method">
<dt id="hou.DopNode.isBypassed">
<code class="descname">isBypassed</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.DopNode.isBypassed" title="Permalink to this definition"></a></dt>
<dd><p>Returns whether the nodes bypass flag is on.</p>
</dd></dl>

<dl class="method">
<dt id="hou.DopNode.isDisplayFlagSet">
<code class="descname">isDisplayFlagSet</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.DopNode.isDisplayFlagSet" title="Permalink to this definition"></a></dt>
<dd><p>Return whether this nodes display flag is on. This is the orange
Output flag in the interface.</p>
</dd></dl>

<dl class="method">
<dt id="hou.DopNode.isTemplateFlagSet">
<code class="descname">isTemplateFlagSet</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.DopNode.isTemplateFlagSet" title="Permalink to this definition"></a></dt>
<dd><p>Returns whether this nodes template flag is on. This is the brown
Hidden flag in the interface.</p>
</dd></dl>

<dl class="method">
<dt id="hou.DopNode.objectsToProcess">
<code class="descname">objectsToProcess</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.DopObject<a class="headerlink" href="#hou.DopNode.objectsToProcess" title="Permalink to this definition"></a></dt>
<dd><p>Return a tuple of DOP objects that this node should process. Raises
hou.PermissionError if called from outside a DOP implemented in
Python.</p>
</dd></dl>

<dl class="method">
<dt id="hou.DopNode.processedObjects">
<code class="descname">processedObjects</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.DopObject<a class="headerlink" href="#hou.DopNode.processedObjects" title="Permalink to this definition"></a></dt>
<dd><p>Return a tuple of DOP objects that this DOP node processes.</p>
</dd></dl>

<dl class="method">
<dt id="hou.DopNode.pythonSolverData">
<code class="descname">pythonSolverData</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.DopData<a class="headerlink" href="#hou.DopNode.pythonSolverData" title="Permalink to this definition"></a></dt>
<dd><p>If this node is a Python DOP solver, return the solver data added to
the DOP network by this node. Otherwise, raises hou.PermissionError.</p>
<p>This method is called from Python DOP solvers when the solver is not
running, to copy data from the DOP parameters into the solver data.</p>
<p>See also hou.dop.scriptSolverData.</p>
</dd></dl>

<dl class="method">
<dt id="hou.DopNode.renderNode">
<code class="descname">renderNode</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.DopNode.renderNode" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.DopNode.setDisplayFlag">
<code class="descname">setDisplayFlag</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.DopNode.setDisplayFlag" title="Permalink to this definition"></a></dt>
<dd><p>Turn the nodes display flag on or off. This the orange Output flag
in the interface.</p>
</dd></dl>

<dl class="method">
<dt id="hou.DopNode.setTemplateFlag">
<code class="descname">setTemplateFlag</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.DopNode.setTemplateFlag" title="Permalink to this definition"></a></dt>
<dd><p>Turns this nodes template flag on or off. This is the brown Hidden
flag in the interface.</p>
</dd></dl>

<dl class="method">
<dt id="hou.DopNode.simulation">
<code class="descname">simulation</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.DopSimulation<a class="headerlink" href="#hou.DopNode.simulation" title="Permalink to this definition"></a></dt>
<dd><p>Return the simulation that this node contributes to. This method is
a shortcut for self.dopNetNode().simulation().</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.DopNode.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.DopNode.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.DopObject">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">DopObject</code><a class="headerlink" href="#hou.DopObject" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.DopData" title="hou.DopData"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.DopData</span></code></a></p>
<p>A type of DOP data that contains an object in the simulation.</p>
<p>This object might be a rigid body, a fluid, cloth, etc. The type and
properties of the DOP object are determined by the subdata attached to
the object.</p>
<dl class="method">
<dt id="hou.DopObject.editableGeometry">
<code class="descname">editableGeometry</code><span class="sig-paren">(</span><em>self</em>, <em>name=&quot;Geometry&quot;</em><span class="sig-paren">)</span> &#x2192; hou.EditableDopGeometryGuard<a class="headerlink" href="#hou.DopObject.editableGeometry" title="Permalink to this definition"></a></dt>
<dd><p>or None</p>
<blockquote>
<div><p>If this method is called from a Python solver DOP and it has
SIM_Geometry (or SIM_GeometryCopy) subdata with the given name, it
returns a Python guard object that can be used with the with
statement to access and modify the corresponding hou.Geometry
object.</p>
<p>In Python 2.5, the with statement is not enabled by default. To
enable it, you need to add the following line at the beginning of
your script/module:</p>
</div></blockquote>
<p>&gt; from __future__ import with_statement</p>
<blockquote>
<div>For example, the following code in a Python solver DOP will add a
point at the origin of the geometry:</div></blockquote>
<p>&gt; with dop_object.editableGeometry() as geo:
&gt;     geo.createPoint()</p>
<blockquote>
<div>Raises hou.PermissionError if not called from a Python solver DOP.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.DopObject.geometry">
<code class="descname">geometry</code><span class="sig-paren">(</span><em>self</em>, <em>name=&quot;Geometry&quot;</em><span class="sig-paren">)</span> &#x2192; hou.Geometry or None<a class="headerlink" href="#hou.DopObject.geometry" title="Permalink to this definition"></a></dt>
<dd><p>If this DOP object has SIM_Geometry subdata with the given name,
return its corresponding read-only hou.Geometry object. Otherwise,
this method returns None.</p>
</dd></dl>

<dl class="method">
<dt id="hou.DopObject.matches">
<code class="descname">matches</code><span class="sig-paren">(</span><em>self</em>, <em>pattern</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.DopObject.matches" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Return whether or not this objects name matches a pattern. * will
match any number of characters and ? will match any single
character. The pattern string contains only one pattern, so spaces
in the pattern will be compared against the object name.</div></blockquote>
<p>&gt; &gt;&gt;&gt; obj = hou.node(/obj/AutoDopNetwork).simulation().objects()[0]
&gt; &gt;&gt;&gt; obj.name()
&gt; box_object1
&gt; &gt;&gt;&gt; obj.matches(box*)
&gt; True
&gt; &gt;&gt;&gt; obj.matches(c*)
&gt; False
&gt; &gt;&gt;&gt; obj.matches(box* b*)
&gt; False
&gt; &gt;&gt;&gt; obj.matches(b?x_object1)
&gt; True</p>
</dd></dl>

<dl class="method">
<dt id="hou.DopObject.name">
<code class="descname">name</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.DopObject.name" title="Permalink to this definition"></a></dt>
<dd><p>Return the name of this DOP object.</p>
</dd></dl>

<dl class="method">
<dt id="hou.DopObject.objid">
<code class="descname">objid</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.DopObject.objid" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Return the index of this object in the output from
hou.DopSimulation.objects. This method is a shortcut for
self.options().field(objid).</p>
<p>See hou.DopData.id for an example.</p>
<p>Some fields in DOP records store an objid to refer to other objects.
The following function looks up an object by objid:</p>
</div></blockquote>
<p>&gt; def findObjectByObjid(dopnet_node, objid):
&gt;     return dopnet_node.simulation().objects()[objid]</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.DopObject.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.DopObject.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

<dl class="method">
<dt id="hou.DopObject.transform">
<code class="descname">transform</code><span class="sig-paren">(</span><em>self</em>, <em>include_geometry_transform=True</em><span class="sig-paren">)</span> &#x2192; hou.Matrix4<a class="headerlink" href="#hou.DopObject.transform" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Return the transformation matrix for this object. If
include_geometry_transform is False, the result is determined only
by the objects Position data. Otherwise, it is the transform in the
objects Geometry data, followed by the position transform.</p>
<p>For simple DopData types, this method can be approximately
implemented as follows:</p>
</div></blockquote>
<p>&gt; def transform(self, include_geometry_transform=True):
&gt;     result = hou.hmath.identityTransform()
&gt; 
&gt;     geometry = self.findSubData(Geometry)
&gt;     if include_geometry_transform and geometry is not None:
&gt;         result <a href="#id7"><span class="problematic" id="id8">*</span></a>= geometry.record(Transform).field(transform)
&gt; 
&gt;     # Retrieve the position.  If there is Geometry data, use its
&gt;     # positionpath field to get the SIM_Position subdata.  If not, look
&gt;     # for data named Position.
&gt;     position = None
&gt;     if geometry is not None:
&gt;         position = geometry.findSubData(
&gt;             geometry.options().field(positionpath))
&gt;     if position is None:
&gt;         position = self.findSubData(Position)
&gt; 
&gt;     # If we found position data, build a transformation from the pivot,
&gt;     # rotation quaternion, and translate.
&gt;     if position is not None:
&gt;         options = position.options()
&gt;         rotation = hou.Matrix4(options.field(orient).extractRotationMatrix3())
&gt;         result <a href="#id9"><span class="problematic" id="id10">*</span></a>= (hou.hmath.buildTranslate(-options.field(p)) *
&gt;             rotation *
&gt;             hou.hmath.buildTranslate(options.field(p)) *
&gt;             hou.hmath.buildTranslate(options.field(t)))
&gt; 
&gt;     return result</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.DopRecord">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">DopRecord</code><a class="headerlink" href="#hou.DopRecord" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A table of values stored inside a DopData.</p>
<p>See hou.DopData for a description of DOP data, records, and fields.</p>
<dl class="method">
<dt id="hou.DopRecord.field">
<code class="descname">field</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; int, bool, float, str, hou.Vector2, hou.Vector3,<a class="headerlink" href="#hou.DopRecord.field" title="Permalink to this definition"></a></dt>
<dd><p>hou.Vector4, hou.Quaternion, hou.Matrix3, or hou.Matrix4</p>
<blockquote>
<div><p>Return the value of a field inside this record, or None if no such
field exists.</p>
<p>Note that you can add the suffixes x, y, and z to a vector
fields name to access the individual float values.</p>
</div></blockquote>
<p>&gt; # The following code assumes you have created a box from the shelf and used
&gt; # Rigid Bodies &gt; RBD Object on the shelf to make it a rigid body.
&gt; &gt;&gt;&gt; record = hou.node(/obj/AutoDopNetwork).simulation().findData(box_object1/Forces/Gravity_gravity1).options()
&gt; &gt;&gt;&gt; record.fieldNames()
&gt; (force, handlepos)
&gt; &gt;&gt;&gt; record.field(force)
&gt; &lt;hou.Vector3 [0, -9.80665, 0]&gt;
&gt; &gt;&gt;&gt; record.field(forcey)
&gt; -9.8066501617431641
&gt; &gt;&gt;&gt; record.fieldType(force)
&gt; fieldType.Vector3
&gt; &gt;&gt;&gt; record.fieldType(forcey)
&gt; fieldType.Float</p>
<blockquote>
<div>This example function creates a dict out of a record:</div></blockquote>
<p>&gt; def recordAsDict(record):
&gt;     return dict((field_name, record.field(field_name))
&gt;         for field_name in record.fieldNames())</p>
<blockquote>
<div>The following function returns the geometry transform of an object:</div></blockquote>
<p>&gt; def dopGeometryTransform(dopnet_node, object_name):
&gt;     subdata = dopnet_node.simulation().findObject(object_name).findSubData(Geometry)
&gt;     return subdata.record(Transform).field(transform)</p>
</dd></dl>

<dl class="method">
<dt id="hou.DopRecord.fieldNames">
<code class="descname">fieldNames</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of str<a class="headerlink" href="#hou.DopRecord.fieldNames" title="Permalink to this definition"></a></dt>
<dd><p>Return the names of all the fields inside this record. See
hou.DopRecord.field for an example.</p>
</dd></dl>

<dl class="method">
<dt id="hou.DopRecord.fieldType">
<code class="descname">fieldType</code><span class="sig-paren">(</span><em>self</em>, <em>field_name</em><span class="sig-paren">)</span> &#x2192; hou.fieldType enum value<a class="headerlink" href="#hou.DopRecord.fieldType" title="Permalink to this definition"></a></dt>
<dd><p>Return a hou.fieldType enumerated value that describes the type of
data stored in a field. Returns hou.fieldType.NoSuchField if no
field exists with that name.</p>
<p>See hou.DopRecord.field for an example.</p>
</dd></dl>

<dl class="method">
<dt id="hou.DopRecord.recordIndex">
<code class="descname">recordIndex</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.DopRecord.recordIndex" title="Permalink to this definition"></a></dt>
<dd><p>Return the index of this record. See hou.DopData.record and
hou.DopData.records for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.DopRecord.recordType">
<code class="descname">recordType</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.DopRecord.recordType" title="Permalink to this definition"></a></dt>
<dd><p>Return the name of this record. See hou.DopData.recordTypes for more
information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.DopRecord.setField">
<code class="descname">setField</code><span class="sig-paren">(</span><em>self</em>, <em>field_name</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.DopRecord.setField" title="Permalink to this definition"></a></dt>
<dd><p>Set a field to the specified value. You would call this method from
a script solver DOP. value may be an int, float, str, hou.Vector2,
hou.Vector3, hou.Vector4, hou.Quaternion, hou.Matrix3, or
hou.Matrix4.</p>
<p>Unfortunately, this method cannot be used to set a field to a
boolean (True or False) value. If you pass a boolean to this method,
it will set the field to the integer 1 or 0. To properly set it to a
boolean value, use hou.DopRecord.setFieldBool.</p>
<p>Raises hou.PermissionError if called from outside a script solver
DOP.</p>
</dd></dl>

<dl class="method">
<dt id="hou.DopRecord.setFieldBool">
<code class="descname">setFieldBool</code><span class="sig-paren">(</span><em>self</em>, <em>field_name</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.DopRecord.setFieldBool" title="Permalink to this definition"></a></dt>
<dd><p>Set a field to the specified boolean value. You would call this
method from a script solver DOP.</p>
<p>To set a field to a different type, use hou.DopRecord.setField.</p>
<p>Raises hou.PermissionError if called from outside a script solver
DOP.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.DopRecord.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.DopRecord.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.DopRelationship">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">DopRelationship</code><a class="headerlink" href="#hou.DopRelationship" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.DopData" title="hou.DopData"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.DopData</span></code></a></p>
<p>A type of DOP data that stores which DOP objects affect one another.</p>
<p>In addition to the Basic and Options records, a DopRelationship
contains ObjInAffectors and ObjInGroup records. The former contains
the objects doing the affecting and the latter contains the objects
being affected.</p>
<p>See hou.DopSimulation.relationships for an example.</p>
<dl class="method">
<dt id="hou.DopRelationship.matches">
<code class="descname">matches</code><span class="sig-paren">(</span><em>self</em>, <em>pattern</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.DopRelationship.matches" title="Permalink to this definition"></a></dt>
<dd><p>Return whether or not this relationships name matches a pattern.
See hou.DopObject.matches for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.DopRelationship.name">
<code class="descname">name</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.DopRelationship.name" title="Permalink to this definition"></a></dt>
<dd><p>Return the name of this DOP relationship.</p>
</dd></dl>

<dl class="method">
<dt id="hou.DopRelationship.setAffectorGroup">
<code class="descname">setAffectorGroup</code><span class="sig-paren">(</span><em>self</em>, <em>objects</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.DopRelationship.setAffectorGroup" title="Permalink to this definition"></a></dt>
<dd><p>Sets the list of objects that are doing the affecting. This
corresponds to the ObjInAffectors record.</p>
<p>objects: A list of DOP objects.</p>
<p>Raises hou.PermissionError if called from outside a Python DOP.</p>
</dd></dl>

<dl class="method">
<dt id="hou.DopRelationship.setGroup">
<code class="descname">setGroup</code><span class="sig-paren">(</span><em>self</em>, <em>objects</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.DopRelationship.setGroup" title="Permalink to this definition"></a></dt>
<dd><p>Sets the list of objects that are being affected. This corresponds
to the ObjInGroup record.</p>
<p>objects: A list of DOP objects.</p>
<p>Raises hou.PermissionError if called from outside a Python DOP.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.DopRelationship.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.DopRelationship.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.DopSimulation">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">DopSimulation</code><a class="headerlink" href="#hou.DopSimulation" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A dynamics simulation contained inside a DOP network node.</p>
<p>See hou.DopData for more information about the contents of a DOP
simulation. Note that methods of this class implicitly use the
simulation data from the current frame.</p>
<dl class="method">
<dt id="hou.DopSimulation.createObject">
<code class="descname">createObject</code><span class="sig-paren">(</span><em>self</em>, <em>name</em>, <em>solve_on_creation_frame</em><span class="sig-paren">)</span> &#x2192; hou.DopObject<a class="headerlink" href="#hou.DopSimulation.createObject" title="Permalink to this definition"></a></dt>
<dd><p>Create and return a new DOP object, or return None if the object was
not created successfully.</p>
<dl class="docutils">
<dt>name</dt>
<dd>The name of the new object.</dd>
<dt>solve_on_creation_frame</dt>
<dd>If True, the object will be solved on its first frame of
existance.</dd>
</dl>
<p>Raises hou.PermissionError if called from outside a Python DOP.</p>
<p>Use hou.DopData.copyContentsFrom to clone data from an existing
object.</p>
</dd></dl>

<dl class="method">
<dt id="hou.DopSimulation.createRelationship">
<code class="descname">createRelationship</code><span class="sig-paren">(</span><em>self</em>, <em>name</em><span class="sig-paren">)</span> &#x2192; hou.DopRelationship<a class="headerlink" href="#hou.DopSimulation.createRelationship" title="Permalink to this definition"></a></dt>
<dd><p>Create and return a new DOP relationship, or return None if the
relationship was not created successfully.</p>
<dl class="docutils">
<dt>name</dt>
<dd>The name of the new relationship.</dd>
</dl>
<p>Raises hou.PermissionError if called from outside a Python DOP.</p>
<p>Use hou.DopData.copyContentsFrom to clone data from an existing
relationship, and use hou.DopRelationship.setGroup and
hou.DopRelationship.setAffectorGroup to update the ObjInGroup and
ObjInAffectors records.</p>
</dd></dl>

<dl class="method">
<dt id="hou.DopSimulation.dopNetNode">
<code class="descname">dopNetNode</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Node<a class="headerlink" href="#hou.DopSimulation.dopNetNode" title="Permalink to this definition"></a></dt>
<dd><p>Return the DOP network node containing this simulation.</p>
</dd></dl>

<dl class="method">
<dt id="hou.DopSimulation.findAllData">
<code class="descname">findAllData</code><span class="sig-paren">(</span><em>self</em>, <em>data_spec</em><span class="sig-paren">)</span> &#x2192; tuple of hou.DopData<a class="headerlink" href="#hou.DopSimulation.findAllData" title="Permalink to this definition"></a></dt>
<dd><p>Given a pattern, return a tuple of DOP data whose names match the
pattern. See also hou.DopSimulation.findData.</p>
</dd></dl>

<dl class="method">
<dt id="hou.DopSimulation.findAllObjects">
<code class="descname">findAllObjects</code><span class="sig-paren">(</span><em>self</em>, <em>obj_spec</em><span class="sig-paren">)</span> &#x2192; tuple of hou.DopObject<a class="headerlink" href="#hou.DopSimulation.findAllObjects" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Given a pattern, return a tuple of DOP objects whose names match the
pattern.</div></blockquote>
<p>&gt; &gt;&gt;&gt; simulation = hou.node(/obj/AutoDopNetwork).simulation()
&gt; &gt;&gt;&gt; [obj.name() for obj in simulation.findAllObjects(box_object?)]
&gt; [box_object1, box_object2]
&gt; &gt;&gt;&gt; [obj.name() for obj in simulation.findAllObjects(o* b*)]
&gt; [obj1, obj2, box_object1, box_object2]</p>
</dd></dl>

<dl class="method">
<dt id="hou.DopSimulation.findAllRelationships">
<code class="descname">findAllRelationships</code><span class="sig-paren">(</span><em>self</em>, <em>rel_spec</em><span class="sig-paren">)</span> &#x2192; tuple of hou.DopRelationship<a class="headerlink" href="#hou.DopSimulation.findAllRelationships" title="Permalink to this definition"></a></dt>
<dd><p>Return a tuple of hou.DopRelationship objects whose names match a
pattern. See also hou.DopSimulation.relationships and
hou.DopSimulation.findRelationship.</p>
</dd></dl>

<dl class="method">
<dt id="hou.DopSimulation.findData">
<code class="descname">findData</code><span class="sig-paren">(</span><em>self</em>, <em>data_spec</em><span class="sig-paren">)</span> &#x2192; hou.DopData or None<a class="headerlink" href="#hou.DopSimulation.findData" title="Permalink to this definition"></a></dt>
<dd><p>Return the DOP data with the given name. Note that the name may also
be a slash-separated path to nested subdata.</p>
<p>If the data path refers to a DOP object, this method returns a
hou.DopObject instance. If it refers to a DOP relationship, it
returns a hou.DopRelationship instance. Otherwise, it returns a
hou.DopData instance.</p>
<p>Note this method implicitly uses the simulation data from the
current frame.</p>
<p>See also hou.DopData.findSubData.</p>
</dd></dl>

<dl class="method">
<dt id="hou.DopSimulation.findObject">
<code class="descname">findObject</code><span class="sig-paren">(</span><em>self</em>, <em>obj_spec</em><span class="sig-paren">)</span> &#x2192; hou.DopObject or None<a class="headerlink" href="#hou.DopSimulation.findObject" title="Permalink to this definition"></a></dt>
<dd><p>Return the DOP object with the given name, or None if no object
exists with that name. See also hou.DopSimulation.findData and
hou.DopSimulation.objects.</p>
</dd></dl>

<dl class="method">
<dt id="hou.DopSimulation.findRelationship">
<code class="descname">findRelationship</code><span class="sig-paren">(</span><em>self</em>, <em>rel_spec</em><span class="sig-paren">)</span> &#x2192; hou.DopRelationship<a class="headerlink" href="#hou.DopSimulation.findRelationship" title="Permalink to this definition"></a></dt>
<dd><p>Find a DOP relationship by name. Return None if no such relationship
with that name exists. See also hou.DopSimulation.relationships.</p>
</dd></dl>

<dl class="method">
<dt id="hou.DopSimulation.memoryUsage">
<code class="descname">memoryUsage</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.DopSimulation.memoryUsage" title="Permalink to this definition"></a></dt>
<dd><p>Return the simulations total memory usage.</p>
</dd></dl>

<dl class="method">
<dt id="hou.DopSimulation.objects">
<code class="descname">objects</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.DopData<a class="headerlink" href="#hou.DopSimulation.objects" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Return a tuple of all the DOP objects in the simulation.</p>
<p>You cannot index into this list using the object ID (see
hou.DopObject.objid). To create a dictionary mapping object IDs to
hou.DopObjects, do this:</p>
</div></blockquote>
<p>&gt; id_dict = dict((obj.objid(), obj) for obj in simulation.objects())</p>
</dd></dl>

<dl class="method">
<dt id="hou.DopSimulation.relationships">
<code class="descname">relationships</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.DopRelationship<a class="headerlink" href="#hou.DopSimulation.relationships" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Return a tuple of hou.DopRelationship objects for all the DOP
relationships in the simulation.</div></blockquote>
<p>&gt; # The following example assumes you have created two box objects and made
&gt; # them rigid bodies.
&gt; &gt;&gt;&gt; simulation = hou.node(/obj/AutoDopNetwork).simulation()
&gt; &gt;&gt;&gt; relationship = simulation.relationships()[1]
&gt; &gt;&gt;&gt; affecting_objects = [
&gt;      simulation.objects()[record.field(objid)]
&gt;      for record in relationship.records(ObjInAffectors)]
&gt; &gt;&gt;&gt; [obj.name() for obj in affecting_objects]
&gt; [box_object1]
&gt; &gt;&gt;&gt; affected_objects = [
&gt;      simulation.objects()[record.field(objid)]
&gt;      for record in relationship.records(ObjInGroup)]
&gt; &gt;&gt;&gt; [obj.name() for obj in affected_objects]
&gt; [box_object2]</p>
</dd></dl>

<dl class="method">
<dt id="hou.DopSimulation.removeObject">
<code class="descname">removeObject</code><span class="sig-paren">(</span><em>self</em>, <em>object</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.DopSimulation.removeObject" title="Permalink to this definition"></a></dt>
<dd><p>Remove the given DOP object from the simulation.</p>
<dl class="docutils">
<dt>object</dt>
<dd>The hou.DopObject to remove.</dd>
</dl>
<p>Raises hou.PermissionError if called from outside a Python DOP.</p>
</dd></dl>

<dl class="method">
<dt id="hou.DopSimulation.removeRelationship">
<code class="descname">removeRelationship</code><span class="sig-paren">(</span><em>self</em>, <em>rel</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.DopSimulation.removeRelationship" title="Permalink to this definition"></a></dt>
<dd><p>Remove the given DOP relationship from the simulation.</p>
<dl class="docutils">
<dt>rel</dt>
<dd>The hou.DopRelationship to remove.</dd>
</dl>
<p>Raises hou.PermissionError if called from outside a Python DOP.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.DopSimulation.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.DopSimulation.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

<dl class="method">
<dt id="hou.DopSimulation.time">
<code class="descname">time</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.DopSimulation.time" title="Permalink to this definition"></a></dt>
<dd><p>Return the simulations current time. This value is often the same
as hou.time, unless it is called from a Python solver DOP or the
Time Scale or Offset Time parameters of the DOP network have been
changed from their default values.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.Drawable">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">Drawable</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Drawable" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Represents extra geometry to draw in the viewer alongside user content
(for example, as guide geometry).</p>
<p>OVERVIEW</p>
<blockquote>
<div><blockquote>
<div>You can attach geometry to a viewer in a Drawable object, causing
the geometry to appear in the viewer even though the geometry is not
actually part of the scene. This is useful to show _guide <a href="#id53"><span class="problematic" id="id54">geometry_</span></a>
in a custom Python state.</div></blockquote>
<p>&gt; import hou
&gt; # Create an empty geometry object
&gt; geo = hou.Geometry()
&gt; # Get the verb from the Box node
&gt; box_verb = hou.sopNodeTypeCategory().nodeVerb(box)
&gt; # Set the verbs parameters
&gt; box_verb.setParms({
&gt;     t: hou.Vector3(0.5, 0.5, -0.5),
&gt;     scale: 0.5,
&gt; })
&gt; # Execute the verb and put its output in the Geometry object
&gt; box_verb.execute(geo, [])
&gt; 
&gt; # Grab a reference to the viewer
&gt; scene_viewer = hou.ui.paneTabOfType(hou.paneTabType.SceneViewer)
&gt; # Create a Drawable object
&gt; drawable = hou.Drawable(scene_viewer, geo, my_guide)
&gt; # Set the Drawable display mode as wireframe (this is the default)
&gt; drawable.setDisplayMode(hou.drawableDisplayMode.WireframeMode)
&gt; # Enable and show the drawable geometry
&gt; drawable.enable(True)
&gt; drawable.show(True)
&gt; # Tumble the view to see the geometry
&gt; import hou
&gt; # Create a geometry from the Sphere node
&gt; sphere_verb = hou.sopNodeTypeCategory().nodeVerb(sphere)
&gt; geo = hou.Geometry()
&gt; sphere_verb.execute(geo, [])
&gt; 
&gt; # Add color and alpha attributes to the sphere
&gt; color_attrib = geo.addAttrib(hou.attribType.Prim, Cd, (1.0, 1.0, 1.0))
&gt; alpha_attrib = geo.addAttrib(hou.attribType.Prim, Alpha, 1.0)
&gt; 
&gt; color = hou.Color(1.0, 0.0, 0.0)
&gt; for prim in geo.prims():
&gt;     prim.setAttribValue(color_attrib, color.rgb())
&gt;     prim.setAttribValue(alpha_attrib, 0.7)
&gt; 
&gt; # Create a Drawable object
&gt; scene_viewer = hou.ui.paneTabOfType(hou.paneTabType.SceneViewer)
&gt; drawable = hou.Drawable(scene_viewer, geo, my_sphere)   
&gt; # Set the Drawable display mode with the current viewport shading mode
&gt; drawable.setDisplayMode(hou.drawableDisplayMode.CurrentViewportMode)
&gt; # Set the size of the sphere
&gt; drawable.setTransform(hou.hmath.buildScale(0.5, 0.5, 0.5))
&gt; drawable.enable(True)
&gt; drawable.show(True)</p>
</div></blockquote>
<p>TIPS AND NOTES</p>
<blockquote>
<div><ul>
<li><p class="first">The Drawable object keeps a reference to the Geometry object you
pass. You can change the Geometry objects contents and the next
time the viewer redraws it will draw the new contents.</p>
</li>
<li><p class="first">When you create the Drawable object, it is disabled and hidden. You
need to call enable(True) and then show(True) for the geometry to
appear.</p>
</li>
<li><p class="first">Even after they are activated and shown, Drawable geometry does not
appear in the viewer until the next redraw (for example, when the
user changes the view).</p>
<blockquote>
<div><blockquote>
<div><p>You can force an individual viewport to redraw using
hou.GeometryViewport.draw.</p>
</div></blockquote>
<p>&gt; scene_viewer.curViewport().draw()</p>
</div></blockquote>
</li>
<li><p class="first">You can generate the contents of a Geometry object from scratch
using verbs, or grab a copy of the output of a SOP node using
hou.SopNode.geometry.</p>
</li>
<li><p class="first">You can also use hou.drawablePrimitive to specify a built-in shape
to generate the content of a Drawable object.</p>
</li>
<li><p class="first">enabling/disabling a drawable may cause performances issues if
performed too often, especially with large geometries. Its good
practice to use show instead of enable for hiding and showing a
drawable.</p>
</li>
<li><p class="first">Its also good practice to disable drawables when they are not
actively used in a viewer.</p>
</li>
<li><p class="first">The drawable geometry will appear in the viewer until you disable
it, or the Drawable object is deleted. If there are no references to
the object, Python will automatically delete it during garbage
collection, and the guide geometry will disappear. So, you need to
make sure to keep a live reference to the object as long as you want
it to appear.</p>
<blockquote>
<div><p>If youre using Drawable to draw guide geometry for a custom
state, you will generally store a reference to the Drawable
object on the state implementation object.</p>
</div></blockquote>
</li>
</ul>
</div></blockquote>
<dl class="method">
<dt id="hou.Drawable.displayMode">
<code class="descname">displayMode</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.Drawable.displayMode" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.Drawable.enable">
<code class="descname">enable</code><span class="sig-paren">(</span><em>self</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Drawable.enable" title="Permalink to this definition"></a></dt>
<dd><p>Enables or disables the drawing of the geometry.</p>
<dl class="docutils">
<dt>value</dt>
<dd>True to enable or False to disable the drawing.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hou.Drawable.name">
<code class="descname">name</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Drawable.name" title="Permalink to this definition"></a></dt>
<dd><p>The name of this drawable.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Drawable.setDisplayMode">
<code class="descname">setDisplayMode</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.Drawable.setDisplayMode" title="Permalink to this definition"></a></dt>
<dd><p>displayMode(self): -&gt; hou.drawableDisplayMode</p>
<blockquote>
<div>Returns the display mode of the geometry.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.Drawable.setTransform">
<code class="descname">setTransform</code><span class="sig-paren">(</span><em>self</em>, <em>xform</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Drawable.setTransform" title="Permalink to this definition"></a></dt>
<dd><p>Sets the transform matrix of the geometry. The changes will appear
the next time the viewer redraws.</p>
<dl class="docutils">
<dt>xform</dt>
<dd>A hou.Matrix4 transformation matrix to set the geometrys
tranlation, rotation, and scale.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hou.Drawable.setWireframeColor">
<code class="descname">setWireframeColor</code><span class="sig-paren">(</span><em>self</em>, <em>color</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Drawable.setWireframeColor" title="Permalink to this definition"></a></dt>
<dd><p>Updates the color of the geometry when the drawable display mode is
set to hou.drawableDisplayMode.WireframeMode. The change will appear
the next time the viewer redraws.</p>
<dl class="docutils">
<dt>color</dt>
<dd>A hou.Color value to specify the primitive color.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hou.Drawable.show">
<code class="descname">show</code><span class="sig-paren">(</span><em>self</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Drawable.show" title="Permalink to this definition"></a></dt>
<dd><p>Displays or hides the geometry in the viewport. The object must be
enabled first. It will appear the next time the viewer redraws.</p>
<dl class="docutils">
<dt>value</dt>
<dd>True to show the geometry or False to hide it.</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="hou.Drawable.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.Drawable.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

<dl class="method">
<dt id="hou.Drawable.transform">
<code class="descname">transform</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.Drawable.transform" title="Permalink to this definition"></a></dt>
<dd><p>transform(self): -&gt; hou.Matrix4</p>
<blockquote>
<div>Returns the geometry transform matrix.</div></blockquote>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.Edge">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">Edge</code><a class="headerlink" href="#hou.Edge" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Each Edge object resides inside a Geometry object and stores an edge.
Edges are reprsented as pairs of points.</p>
<dl class="method">
<dt id="hou.Edge.edgeId">
<code class="descname">edgeId</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.Edge.edgeId" title="Permalink to this definition"></a></dt>
<dd><p>Return a string such as p8-9 that identifies the edge</p>
</dd></dl>

<dl class="method">
<dt id="hou.Edge.geometry">
<code class="descname">geometry</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.Edge.geometry" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.Edge.length">
<code class="descname">length</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#hou.Edge.length" title="Permalink to this definition"></a></dt>
<dd><p>Returns the length of this edge</p>
</dd></dl>

<dl class="method">
<dt id="hou.Edge.points">
<code class="descname">points</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.Point<a class="headerlink" href="#hou.Edge.points" title="Permalink to this definition"></a></dt>
<dd><p>Return a tuple of the points that make up this edge.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Edge.prims">
<code class="descname">prims</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.Prim<a class="headerlink" href="#hou.Edge.prims" title="Permalink to this definition"></a></dt>
<dd><p>Return a tuple of the prims that has this edge</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.Edge.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.Edge.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.EdgeGroup">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">EdgeGroup</code><a class="headerlink" href="#hou.EdgeGroup" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A named group of edges inside a Geometry object.</p>
<p>Edge groups reside inside the geometry, and each edge group has a unique
name.</p>
<p>See hou.Edge for more information about edges. See also hou.PrimGroup
and hou.PointGroup.</p>
<p>REPLACES</p>
<dl class="method">
<dt id="hou.EdgeGroup.add">
<code class="descname">add</code><span class="sig-paren">(</span><em>self</em>, <em>edge_or_list_or_edge_group</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.EdgeGroup.add" title="Permalink to this definition"></a></dt>
<dd><p>If given a hou.Edge or a list of hou.Edges, add the edge(s) to the
group. If given a hou.EdgeGroup, merge the contents of the other
edge group with this group (the other group is unaffected). You
would typically call this method from the code of a Python-defined
SOP.</p>
<p>It is ok to add edges to the group that were already in the group.</p>
<p>Raises hou.GeometryPermissionError if this geometry is not
modifiable.</p>
<p>Raises hou.OperationFailed if the edge or edge group belong to a
different geometry object than this group.</p>
</dd></dl>

<dl class="method">
<dt id="hou.EdgeGroup.clear">
<code class="descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.EdgeGroup.clear" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.EdgeGroup.contains">
<code class="descname">contains</code><span class="sig-paren">(</span><em>self</em>, <em>edge</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.EdgeGroup.contains" title="Permalink to this definition"></a></dt>
<dd><p>Return whether or not an edge is in this group.</p>
<p>Raises hou.OperationFailed if the edge belongs to a different
geometry object than this group.</p>
</dd></dl>

<dl class="method">
<dt id="hou.EdgeGroup.destroy">
<code class="descname">destroy</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.EdgeGroup.destroy" title="Permalink to this definition"></a></dt>
<dd><p>Remove this group from the geometry. You would typically call this
method from the code of a Python-defined SOP.</p>
<p>Raises hou.GeometryPermissionError if this geometry is not
modifiable.</p>
</dd></dl>

<dl class="method">
<dt id="hou.EdgeGroup.edges">
<code class="descname">edges</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.Edge<a class="headerlink" href="#hou.EdgeGroup.edges" title="Permalink to this definition"></a></dt>
<dd><p>Return the contents of this group.</p>
</dd></dl>

<dl class="method">
<dt id="hou.EdgeGroup.geometry">
<code class="descname">geometry</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Geometry<a class="headerlink" href="#hou.EdgeGroup.geometry" title="Permalink to this definition"></a></dt>
<dd><p>Return the geometry object containing this group.</p>
</dd></dl>

<dl class="method">
<dt id="hou.EdgeGroup.name">
<code class="descname">name</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.EdgeGroup.name" title="Permalink to this definition"></a></dt>
<dd><p>Return the name of the group. Each edge group has a unique name.</p>
</dd></dl>

<dl class="method">
<dt id="hou.EdgeGroup.remove">
<code class="descname">remove</code><span class="sig-paren">(</span><em>self</em>, <em>edge_or_list_or_edge_group</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.EdgeGroup.remove" title="Permalink to this definition"></a></dt>
<dd><p>If given a hou.Edge or a list of hou.Edges, remove the edge(s) from
the group. If given a hou.EdgeGroup, remove all edges in the other
group from this group (the other group is unaffected). You would
typically call this method from the code of a Python-defined SOP.</p>
<p>It is not an error to try to remove an edge from the group that
wasnt already in the group.</p>
<p>Raises hou.GeometryPermissionError if this geometry is not
modifiable.</p>
<p>Raises hou.OperationFailed if the edge belongs to a different
geometry object than this group.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.EdgeGroup.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.EdgeGroup.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.EditableDopGeometryGuard">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">EditableDopGeometryGuard</code><a class="headerlink" href="#hou.EditableDopGeometryGuard" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="attribute">
<dt id="hou.EditableDopGeometryGuard.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.EditableDopGeometryGuard.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.EnumValue">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">EnumValue</code><a class="headerlink" href="#hou.EnumValue" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>This class is the base class for an enumeration value. It cannot be
instanced and is not meant to be used directly by the user.</p>
<p>All the built-in HOM enumeration values are derived from this class such
as hou.paneTabType.*, hou.severityType.*, and hou.connectivityType.*.</p>
<dl class="method">
<dt id="hou.EnumValue.name">
<code class="descname">name</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; string<a class="headerlink" href="#hou.EnumValue.name" title="Permalink to this definition"></a></dt>
<dd><p>Returns the name of the enumeration value.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.EnumValue.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.EnumValue.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.Error">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">Error</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Error" title="Permalink to this definition"></a></dt>
<dd><p>Base class for all exceptions in the hou module.</p>
<p>You can check if an exception instance is a Houdini-specific exception
using isinstance(ex, hou.Error).</p>
<dl class="method">
<dt id="hou.Error.description">
<code class="descname">description</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.Error.description" title="Permalink to this definition"></a></dt>
<dd><p>Return a description of the class of exception. The description is
not related to the exception instance.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Error.exceptionTypeName">
<code class="descname">exceptionTypeName</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.Error.exceptionTypeName" title="Permalink to this definition"></a></dt>
<dd><p>Return the name of the exception type. Instances of different
subclasses of hou.Error will return different names. Instances of
the base class will return Error.</p>
<p>You can also use str(e.__class__) to get the name of the subclass.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Error.instanceMessage">
<code class="descname">instanceMessage</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.Error.instanceMessage" title="Permalink to this definition"></a></dt>
<dd><p>Return a message specific to the exception instance.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.Face">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">Face</code><a class="headerlink" href="#hou.Face" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.Prim" title="hou.Prim"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.Prim</span></code></a></p>
<p>A Face is a kind of geometry primitive (Prim object) that contains a
sequence of vertices (Vertex objects). How these vertices are used
depends on the type of face; polygons, for example, use the vertices to
define the edges of the polygon, while NURBS curves use them as control
points.</p>
<p>A hou.Surface, on the other hand, stores a two dimension grid of
vertices, and might be a NURBS surface, Bezier surface, or quadrilateral
mesh.</p>
<dl class="method">
<dt id="hou.Face.addVertex">
<code class="descname">addVertex</code><span class="sig-paren">(</span><em>self</em>, <em>point</em><span class="sig-paren">)</span> &#x2192; hou.Vertex<a class="headerlink" href="#hou.Face.addVertex" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Create a new vertex inside this face, adding it to the end of the
vertex list. You would typically call this method from the code of a
Python-defined SOP.</p>
<p>point is a hou.Point object that the new vertex will refer to. See
hou.Vertex for information on the relationship between points and
vertices.</p>
<p>Raises hou.GeometryPermissionError if this geometry is not
modifiable.</p>
</div></blockquote>
<p>&gt; # These arrays define point positions and a set of polygons composed
&gt; # of those points.  Note that the point positions could also be floating
&gt; # point values.
&gt; point_positions = ((0,0,0), (1,0,0), (1,1,0), (0,1,0))
&gt; poly_point_indices = ((0,1,2), (2,3,0))
&gt; 
&gt; geo = hou.pwd().geometry()
&gt; 
&gt; # Create all the points.
&gt; points = []
&gt; for position in point_positions:
&gt;     points.append(geo.createPoint())
&gt;     points[-1].setPosition(position)
&gt; 
&gt; # Now create the polygons, adding vertices that refer to the points.
&gt; for point_indices in poly_point_indices:
&gt;     poly = geo.createPolygon()
&gt;     for point_index in point_indices:
&gt;         poly.addVertex(points[point_index])</p>
<blockquote>
<div>See also:</div></blockquote>
<ul class="simple">
<li>hou.Geometry.createPoint</li>
<li>hou.Geometry.createPolygon</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="hou.Face.arcLength">
<code class="descname">arcLength</code><span class="sig-paren">(</span><em>self</em>, <em>u_start</em>, <em>u_stop</em>, <em>divs=10</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#hou.Face.arcLength" title="Permalink to this definition"></a></dt>
<dd><p>Given normalized (i.e. from 0 to 1) u_start and u_stop values,
return the length of the arc of curve. divs represents the number of
divisions per spans. Increasing it increases the precision of the
computation.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Face.attribValueAt">
<code class="descname">attribValueAt</code><span class="sig-paren">(</span><em>self</em>, <em>attrib_or_name</em>, <em>u</em>, <em>du=0</em><span class="sig-paren">)</span> &#x2192; int, float, str or tuple<a class="headerlink" href="#hou.Face.attribValueAt" title="Permalink to this definition"></a></dt>
<dd><p>Return an attribute value at a normalized u parametric position on
the curve. If du is 0, returns the interpolated attribute value;
otherwise, returns the derivative of the attribute value.</p>
<p>Raises hou.OperationFailed if the attribute is not a point or vertex
attribute. If you want a primitive attribute value, it doesnt vary
across the surface, so use hou.Prim.attribValue.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Face.closed">
<code class="descname">closed</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Face.closed" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.Face.isClosed">
<code class="descname">isClosed</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.Face.isClosed" title="Permalink to this definition"></a></dt>
<dd><p>Return whether the first and last vertex are connected.</p>
<p>An open face forms a multi-segment line or curve, since the first
and last vertices are not connected. A closed face forms a very thin
surface.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Face.normal">
<code class="descname">normal</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Vector3<a class="headerlink" href="#hou.Face.normal" title="Permalink to this definition"></a></dt>
<dd><p>Return the vector thats perpendicular to the face.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Face.positionAt">
<code class="descname">positionAt</code><span class="sig-paren">(</span><em>self</em>, <em>u</em><span class="sig-paren">)</span> &#x2192; hou.Vector3<a class="headerlink" href="#hou.Face.positionAt" title="Permalink to this definition"></a></dt>
<dd><p>Given a normalized (i.e. from 0 to 1) u value, return the position
of the curve at that parametric location.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Face.setIsClosed">
<code class="descname">setIsClosed</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Face.setIsClosed" title="Permalink to this definition"></a></dt>
<dd><p>Set whether the face is open or closed. See hou.Face.isClosed for
more information. You would typically call this method from the code
of a Python-defined SOP.</p>
<p>Note that this method will raise hou.OperationFailed on a Bezier
curve. See hou.Geometry.createBezierCurve for more information.</p>
<p>Raises hou.GeometryPermissionError if this geometry is not
modifiable.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.Face.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.Face.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

<dl class="method">
<dt id="hou.Face.vertex">
<code class="descname">vertex</code><span class="sig-paren">(</span><em>self</em>, <em>index</em><span class="sig-paren">)</span> &#x2192; hou.Vertex<a class="headerlink" href="#hou.Face.vertex" title="Permalink to this definition"></a></dt>
<dd><p>A shortcut for self.vertices()[index]. You probably dont need to
call this method.</p>
<p>This method supports negative indices to index from the end, just
like self.vertices()[index] would. Also, like Pythons indexing
operator, it will raise IndexError when the index is out of range.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.FlipbookSettings">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">FlipbookSettings</code><a class="headerlink" href="#hou.FlipbookSettings" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A collection of options for the viewport flipbook dialog.</p>
<p>The viewport flipbook has a set of options beyond the Display Options
provided by the viewport itself. This object contains all these
settings.</p>
<blockquote>
<div><ul class="simple">
<li>Use hou.SceneViewer.flipbookSettings to get this object representing
the current flipbook settings for the viewer. Changing the options
on this object changes the settings for future interactive flipbooks
generated from the viewer.</li>
<li>You can also pass the settings object directly to
hou.SceneViewer.flipbook to generate a flipbook using the current
settings.</li>
<li>To generate a flipbook using custom settings, first use
hou.SceneViewer.flipbookSettings to get the current settings, and
call hou.FlipbookSettings.stash to create a copy (so changing the
options wont affect the viewers interactive options). Then modify
the settings and pass the object to hou.SceneViewer.flipbook.</li>
</ul>
<p>&gt; # Copy the viewers current flipbook settings
&gt; flipbook_options = scene.flipbookSettings().stash()
&gt; 
&gt; # Change the settings however you need
&gt; # (for example, set the frame range and output filename)
&gt; flipbook_options.frameRange( (frame, frame) )
&gt; flipbook_options.output(filename)
&gt; 
&gt; # Generate the flipbook using the modified settings
&gt; scene.flipbook(scene.curViewport(), flip_options)</p>
</div></blockquote>
<dl class="method">
<dt id="hou.FlipbookSettings.LUT">
<code class="descname">LUT</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.FlipbookSettings.LUT" title="Permalink to this definition"></a></dt>
<dd><p>The current LUT used for flipbooking.</p>
</dd></dl>

<dl class="method">
<dt id="hou.FlipbookSettings.antialias">
<code class="descname">antialias</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.flipbookAntialias<a class="headerlink" href="#hou.FlipbookSettings.antialias" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Query the current flipbook antialiasing setting:</div></blockquote>
<ul class="simple">
<li>hou.flipbookAntialias.UseViewportSetting: Use the current viewport
setting.</li>
<li>hou.flipbookAntialias.Off: No antialiasing.</li>
<li>hou.flipbookAntialias.Fast: Minimal 2-sample antialiasing.</li>
<li>hou.flipbookAntialias.Good: 4-sample antialiasing.</li>
<li>hou.flipbookAntialias.HighQuality: 8-sample antialiasing.</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="hou.FlipbookSettings.aperture">
<code class="descname">aperture</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; double<a class="headerlink" href="#hou.FlipbookSettings.aperture" title="Permalink to this definition"></a></dt>
<dd><p>Query the default aperture setting.</p>
</dd></dl>

<dl class="method">
<dt id="hou.FlipbookSettings.appendFramesToCurrent">
<code class="descname">appendFramesToCurrent</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.FlipbookSettings.appendFramesToCurrent" title="Permalink to this definition"></a></dt>
<dd><p>The current state of the flipbook append mode, either Append (True)
or Overwrite (False).</p>
</dd></dl>

<dl class="method">
<dt id="hou.FlipbookSettings.audioFilename">
<code class="descname">audioFilename</code><span class="sig-paren">(</span><em>self</em>, <em>audio_file</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.FlipbookSettings.audioFilename" title="Permalink to this definition"></a></dt>
<dd><p>The current audio file used by the flipbook.</p>
</dd></dl>

<dl class="method">
<dt id="hou.FlipbookSettings.audioFrameStart">
<code class="descname">audioFrameStart</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; double<a class="headerlink" href="#hou.FlipbookSettings.audioFrameStart" title="Permalink to this definition"></a></dt>
<dd><p>The frame where the audio will be playing audioTimeOffset seconds.</p>
</dd></dl>

<dl class="method">
<dt id="hou.FlipbookSettings.audioTimeOffset">
<code class="descname">audioTimeOffset</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; double<a class="headerlink" href="#hou.FlipbookSettings.audioTimeOffset" title="Permalink to this definition"></a></dt>
<dd><p>The audio time that will be playing at audioFrameStart frames.</p>
</dd></dl>

<dl class="method">
<dt id="hou.FlipbookSettings.backgroundImage">
<code class="descname">backgroundImage</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.FlipbookSettings.backgroundImage" title="Permalink to this definition"></a></dt>
<dd><p>The pathname of the background image or images.</p>
</dd></dl>

<dl class="method">
<dt id="hou.FlipbookSettings.beautyPassOnly">
<code class="descname">beautyPassOnly</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.FlipbookSettings.beautyPassOnly" title="Permalink to this definition"></a></dt>
<dd><p>The current state of the beauty pass render flag.</p>
</dd></dl>

<dl class="method">
<dt id="hou.FlipbookSettings.blockEditing">
<code class="descname">blockEditing</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.FlipbookSettings.blockEditing" title="Permalink to this definition"></a></dt>
<dd><p>The current state of block editing mode.</p>
</dd></dl>

<dl class="method">
<dt id="hou.FlipbookSettings.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>self</em>, <em>from_settings</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.FlipbookSettings.copy" title="Permalink to this definition"></a></dt>
<dd><p>Copy all settings in from_settings into this object.</p>
</dd></dl>

<dl class="method">
<dt id="hou.FlipbookSettings.cropOutMaskOverlay">
<code class="descname">cropOutMaskOverlay</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.FlipbookSettings.cropOutMaskOverlay" title="Permalink to this definition"></a></dt>
<dd><p>Query if the resulting image will be cropped to the camera area.</p>
</dd></dl>

<dl class="method">
<dt id="hou.FlipbookSettings.depthOfFieldFromCamera">
<code class="descname">depthOfFieldFromCamera</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.FlipbookSettings.depthOfFieldFromCamera" title="Permalink to this definition"></a></dt>
<dd><p>Query if the depth of field parameters (focusDistance, aperture,
fStop) are sourced from a camera (True) or the flipbook dialog
settings</p>
</dd></dl>

<dl class="method">
<dt id="hou.FlipbookSettings.depthOfFieldQuality">
<code class="descname">depthOfFieldQuality</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; double<a class="headerlink" href="#hou.FlipbookSettings.depthOfFieldQuality" title="Permalink to this definition"></a></dt>
<dd><p>Return the number of images rendered to simulate depth of field
blur.</p>
</dd></dl>

<dl class="method">
<dt id="hou.FlipbookSettings.fStop">
<code class="descname">fStop</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; double<a class="headerlink" href="#hou.FlipbookSettings.fStop" title="Permalink to this definition"></a></dt>
<dd><p>Query the f-stop setting.</p>
</dd></dl>

<dl class="method">
<dt id="hou.FlipbookSettings.focusDistance">
<code class="descname">focusDistance</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; double<a class="headerlink" href="#hou.FlipbookSettings.focusDistance" title="Permalink to this definition"></a></dt>
<dd><p>Query the focus distance setting, the distance from the camera where
objects are perfectly in focus.</p>
</dd></dl>

<dl class="method">
<dt id="hou.FlipbookSettings.frameIncrement">
<code class="descname">frameIncrement</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.FlipbookSettings.frameIncrement" title="Permalink to this definition"></a></dt>
<dd><p>The current frame increment of the flipbook.</p>
</dd></dl>

<dl class="method">
<dt id="hou.FlipbookSettings.frameRange">
<code class="descname">frameRange</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of double<a class="headerlink" href="#hou.FlipbookSettings.frameRange" title="Permalink to this definition"></a></dt>
<dd><p>The current frame range of the flipbook, as a tuple of 2 ints
(start, end).</p>
</dd></dl>

<dl class="method">
<dt id="hou.FlipbookSettings.gamma">
<code class="descname">gamma</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; double<a class="headerlink" href="#hou.FlipbookSettings.gamma" title="Permalink to this definition"></a></dt>
<dd><p>The current gamma value.</p>
</dd></dl>

<dl class="method">
<dt id="hou.FlipbookSettings.initializeSimulations">
<code class="descname">initializeSimulations</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.FlipbookSettings.initializeSimulations" title="Permalink to this definition"></a></dt>
<dd><p>The current state of simulation initialization. True indicates that
simulations will be reset, and False indicates that any cached
results will be used.</p>
</dd></dl>

<dl class="method">
<dt id="hou.FlipbookSettings.leaveFrameAtEnd">
<code class="descname">leaveFrameAtEnd</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.FlipbookSettings.leaveFrameAtEnd" title="Permalink to this definition"></a></dt>
<dd><p>Query if the playbar frame is being left at the last frame (True) or
restored to the previous frame (False).</p>
</dd></dl>

<dl class="method">
<dt id="hou.FlipbookSettings.motionBlurFrameRange">
<code class="descname">motionBlurFrameRange</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.flipbookMotionBlurBias<a class="headerlink" href="#hou.FlipbookSettings.motionBlurFrameRange" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Query the subframe range for motion blur:</div></blockquote>
<ul class="simple">
<li>hou.flipbookMotionBlurBias.Centered: Subframe range is centered
around the currently rendering frame.</li>
<li>hou.flipbookMotionBlurBias.Forward: Subframe range starts at the
currently rendering frame.</li>
<li>hou.flipbookMotionBlurBias.Previous: Subframe range ends at the
currently rendering frame.</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="hou.FlipbookSettings.motionBlurSegments">
<code class="descname">motionBlurSegments</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.FlipbookSettings.motionBlurSegments" title="Permalink to this definition"></a></dt>
<dd><p>Query the number of subframes currently used for motion blur.</p>
</dd></dl>

<dl class="method">
<dt id="hou.FlipbookSettings.output">
<code class="descname">output</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.FlipbookSettings.output" title="Permalink to this definition"></a></dt>
<dd><p>The current output destination for flipbooking.</p>
</dd></dl>

<dl class="method">
<dt id="hou.FlipbookSettings.outputToMPlay">
<code class="descname">outputToMPlay</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.FlipbookSettings.outputToMPlay" title="Permalink to this definition"></a></dt>
<dd><p>Query if images are being sent to an interactive MPlay sesion.</p>
</dd></dl>

<dl class="method">
<dt id="hou.FlipbookSettings.outputZoom">
<code class="descname">outputZoom</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.FlipbookSettings.outputZoom" title="Permalink to this definition"></a></dt>
<dd><p>Query the output zoom level. Valid settings are 100, 75, 50, and 25.</p>
</dd></dl>

<dl class="method">
<dt id="hou.FlipbookSettings.overrideGamma">
<code class="descname">overrideGamma</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.FlipbookSettings.overrideGamma" title="Permalink to this definition"></a></dt>
<dd><p>The current state of the gamma override.</p>
</dd></dl>

<dl class="method">
<dt id="hou.FlipbookSettings.overrideLUT">
<code class="descname">overrideLUT</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.FlipbookSettings.overrideLUT" title="Permalink to this definition"></a></dt>
<dd><p>The current state of the LUT override.</p>
</dd></dl>

<dl class="method">
<dt id="hou.FlipbookSettings.renderAllViewports">
<code class="descname">renderAllViewports</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.FlipbookSettings.renderAllViewports" title="Permalink to this definition"></a></dt>
<dd><p>Render all visible viewports (True), or only the currently selected
one.</p>
</dd></dl>

<dl class="method">
<dt id="hou.FlipbookSettings.resolution">
<code class="descname">resolution</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of int<a class="headerlink" href="#hou.FlipbookSettings.resolution" title="Permalink to this definition"></a></dt>
<dd><p>Returns a 2-tuple of ints representing the width and height of the
flipbook dialog image output resolution. This is not used unless
useResolution is enabled.</p>
</dd></dl>

<dl class="method">
<dt id="hou.FlipbookSettings.scopeChannelKeyframesOnly">
<code class="descname">scopeChannelKeyframesOnly</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.FlipbookSettings.scopeChannelKeyframesOnly" title="Permalink to this definition"></a></dt>
<dd><p>The current state of scoped keyframe mode.</p>
</dd></dl>

<dl class="method">
<dt id="hou.FlipbookSettings.sessionLabel">
<code class="descname">sessionLabel</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.FlipbookSettings.sessionLabel" title="Permalink to this definition"></a></dt>
<dd><p>The current flipbook session label.</p>
</dd></dl>

<dl class="method">
<dt id="hou.FlipbookSettings.shutter">
<code class="descname">shutter</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; double<a class="headerlink" href="#hou.FlipbookSettings.shutter" title="Permalink to this definition"></a></dt>
<dd><p>Query the current camera shutter for motion blur.</p>
</dd></dl>

<dl class="method">
<dt id="hou.FlipbookSettings.shutterFromCamera">
<code class="descname">shutterFromCamera</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.FlipbookSettings.shutterFromCamera" title="Permalink to this definition"></a></dt>
<dd><p>Query if the shutter is sourced from the camera or the flipbook
dialog.</p>
</dd></dl>

<dl class="method">
<dt id="hou.FlipbookSettings.stash">
<code class="descname">stash</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.FlipbookSettings<a class="headerlink" href="#hou.FlipbookSettings.stash" title="Permalink to this definition"></a></dt>
<dd><p>Return a new copy of this FlipbookSettings object. Changes to this
new object will not update the flipbook dialog, but can be passed to
hou.SceneViewer.flipbook() as the settings to use.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.FlipbookSettings.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.FlipbookSettings.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

<dl class="method">
<dt id="hou.FlipbookSettings.useDepthOfField">
<code class="descname">useDepthOfField</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.FlipbookSettings.useDepthOfField" title="Permalink to this definition"></a></dt>
<dd><p>Query if depth of field rendering is on.</p>
</dd></dl>

<dl class="method">
<dt id="hou.FlipbookSettings.useMotionBlur">
<code class="descname">useMotionBlur</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.FlipbookSettings.useMotionBlur" title="Permalink to this definition"></a></dt>
<dd><p>Query if motion blur is enabled.</p>
</dd></dl>

<dl class="method">
<dt id="hou.FlipbookSettings.useResolution">
<code class="descname">useResolution</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.FlipbookSettings.useResolution" title="Permalink to this definition"></a></dt>
<dd><p>Query if the resolution is defined by the flipbook dialog (True) or
by the current size of the viewport (False).</p>
</dd></dl>

<dl class="method">
<dt id="hou.FlipbookSettings.visibleObjects">
<code class="descname">visibleObjects</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.FlipbookSettings.visibleObjects" title="Permalink to this definition"></a></dt>
<dd><p>The current visibility list for objects to be rendered.</p>
</dd></dl>

<dl class="method">
<dt id="hou.FlipbookSettings.visibleTypes">
<code class="descname">visibleTypes</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.flipbookObjectType<a class="headerlink" href="#hou.FlipbookSettings.visibleTypes" title="Permalink to this definition"></a></dt>
<dd><p>The current visible object types.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.FloatParmTemplate">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">FloatParmTemplate</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.FloatParmTemplate" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.ParmTemplate" title="hou.ParmTemplate"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.ParmTemplate</span></code></a></p>
<p>Describes a parameter tuple containing floating point values.</p>
<dl class="method">
<dt id="hou.FloatParmTemplate.defaultExpression">
<code class="descname">defaultExpression</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of strings<a class="headerlink" href="#hou.FloatParmTemplate.defaultExpression" title="Permalink to this definition"></a></dt>
<dd><p>Return the default expression for new parameter instances.</p>
<p>The default expression takes precendence over the default value. If
a component has no default expression (i.e. an empty string), then
the default value is used for new parameter instances.</p>
<p>Note that the default expression language is needed to interpret the
meaning of the default expression.</p>
<p>For example, suppose this parm template is named t, the naming
scheme is XYZW, it has 3 components, the default value is (1.0, 2.0,
3.0), the default expression is ($F, hou.frame(), ) and the
default expression language is (hou.scriptLanguage.Hscript,
hou.scriptLanguage.Python, hou.scriptLanguage.Hscript). Then the
corresponding parm tuple instance on a node would be named t and
would contain parameters tx, ty, tz. When the node is created,
tx would have a default Hscript expression of $F, ty would
have a default Python expression of hou.frame(), and tz would
have a default value of 3.0.</p>
</dd></dl>

<dl class="method">
<dt id="hou.FloatParmTemplate.defaultExpressionLanguage">
<code class="descname">defaultExpressionLanguage</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.scriptLanguage<a class="headerlink" href="#hou.FloatParmTemplate.defaultExpressionLanguage" title="Permalink to this definition"></a></dt>
<dd><p>Return the default expression language for new parameter instances.</p>
<p>The default expression language only applies if the default
expression is set. If the default expression of a component is not
set, then the expression language is set to
hou.scriptLanguage.Hscript.</p>
</dd></dl>

<dl class="method">
<dt id="hou.FloatParmTemplate.defaultValue">
<code class="descname">defaultValue</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of float<a class="headerlink" href="#hou.FloatParmTemplate.defaultValue" title="Permalink to this definition"></a></dt>
<dd><p>Return the default value for new parameter instances.</p>
<p>For example, suppose this parm template is named t, the naming
scheme is XYZW, it has 3 components, and the default value is (1.0,
2.0, 3.0). The corresponding parm tuple instance on a node would be
named t and would contain parameters tx, ty, and tz. When
the node is created, tx would be 1.0, ty would be 2.0, and tz
would be 3.0.</p>
</dd></dl>

<dl class="method">
<dt id="hou.FloatParmTemplate.maxIsStrict">
<code class="descname">maxIsStrict</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.FloatParmTemplate.maxIsStrict" title="Permalink to this definition"></a></dt>
<dd><p>Return whether the maximum value is strictly enforced.</p>
<p>See the minIsStrict method for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.FloatParmTemplate.maxValue">
<code class="descname">maxValue</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#hou.FloatParmTemplate.maxValue" title="Permalink to this definition"></a></dt>
<dd><p>Return the minimum value of the parameter.</p>
<p>See also the minIsStrict method.</p>
</dd></dl>

<dl class="method">
<dt id="hou.FloatParmTemplate.minIsStrict">
<code class="descname">minIsStrict</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.FloatParmTemplate.minIsStrict" title="Permalink to this definition"></a></dt>
<dd><p>Return whether the minimum value is strictly enforced.</p>
<p>If a minimum value is not strictly enforced, the slider will not let
you change the value below the minimum, but you can set the value to
be lower than the minimum by typing it in, changing it via
hou.Parm.setValue, or using the ladder handle.</p>
<p>If it is strictly enforced and you try to change it below the
minimum value using any mechanism, Houdini will set it to the
minimum value.</p>
<p>See also the minValue method.</p>
</dd></dl>

<dl class="method">
<dt id="hou.FloatParmTemplate.minValue">
<code class="descname">minValue</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#hou.FloatParmTemplate.minValue" title="Permalink to this definition"></a></dt>
<dd><p>Return the minimum value of the parameter.</p>
<p>See also the minIsStrict method.</p>
</dd></dl>

<dl class="method">
<dt id="hou.FloatParmTemplate.setDefaultExpression">
<code class="descname">setDefaultExpression</code><span class="sig-paren">(</span><em>self</em>, <em>default_expression</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.FloatParmTemplate.setDefaultExpression" title="Permalink to this definition"></a></dt>
<dd><p>Set the default expression for new parameter instances to a sequence
of strings.</p>
<p>See the hou.FloatParmTemplate.defaultExpression method for more
information. Note that if the number of strings in the sequence is
different from the number of components in the parm template, any
extra values will be discarded and any missing expressions will
become the empty string.</p>
</dd></dl>

<dl class="method">
<dt id="hou.FloatParmTemplate.setDefaultExpressionLanguage">
<code class="descname">setDefaultExpressionLanguage</code><span class="sig-paren">(</span><em>self</em>, <em>default_expression_language</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.FloatParmTemplate.setDefaultExpressionLanguage" title="Permalink to this definition"></a></dt>
<dd><p>Set the default expression language for new parameter instances to a
sequence of hou.scriptLanguage values.</p>
<p>See the defaultExpressionLanguage method for more information. Note
that if the number of hou.scriptLanguage values in the sequence is
different from the number of components in the parm template, any
extra values will be discarded and any missing expression languages
will become hou.scriptLanguage.Hscript.</p>
</dd></dl>

<dl class="method">
<dt id="hou.FloatParmTemplate.setDefaultValue">
<code class="descname">setDefaultValue</code><span class="sig-paren">(</span><em>self</em>, <em>default_value</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.FloatParmTemplate.setDefaultValue" title="Permalink to this definition"></a></dt>
<dd><p>Set the default value for new parameter instances to a sequence of
floats.</p>
<p>See the defaultValue method for more information. Note that if the
number of floats in the sequence is different from the number of
components in the parm template, any extra values will be discarded
and any missing values will become zeros.</p>
</dd></dl>

<dl class="method">
<dt id="hou.FloatParmTemplate.setMaxIsStrict">
<code class="descname">setMaxIsStrict</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.FloatParmTemplate.setMaxIsStrict" title="Permalink to this definition"></a></dt>
<dd><p>Set whether the maximum value is strictly enforced.</p>
<p>See the maxIsStrict method for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.FloatParmTemplate.setMaxValue">
<code class="descname">setMaxValue</code><span class="sig-paren">(</span><em>self</em>, <em>max_value</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.FloatParmTemplate.setMaxValue" title="Permalink to this definition"></a></dt>
<dd><p>Set the maximum value of the parameter.</p>
<p>See the maxValue method for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.FloatParmTemplate.setMinIsStrict">
<code class="descname">setMinIsStrict</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.FloatParmTemplate.setMinIsStrict" title="Permalink to this definition"></a></dt>
<dd><p>Set whether the minimum value is strictly enforced.</p>
<p>See the minIsStrict method for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.FloatParmTemplate.setMinValue">
<code class="descname">setMinValue</code><span class="sig-paren">(</span><em>self</em>, <em>min_value</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.FloatParmTemplate.setMinValue" title="Permalink to this definition"></a></dt>
<dd><p>Set the minimum value of the parameter.</p>
<p>See the minValue method for more information.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.FloatParmTemplate.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.FloatParmTemplate.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.FloatingPanel">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">FloatingPanel</code><a class="headerlink" href="#hou.FloatingPanel" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A floating window that contains one or more panes.</p>
<p>Much like a desktop, a floating panel contains panes. A floating panel
may be attached to a desktop, in which case it is saved with the
desktop, hidden when the desktop is closed, and shown when the desktop
is opened. You can use floating panels to create desktops that span
multiple monitors.</p>
<p>When you create a new floating panel, for example, it contains a single
pane, which in turn contains a single pane tab showing the network
editor.</p>
<p>Note that a floating panel may be locked to one particular pane tab.
These stripped down panels do not display the interface for adding new
pane tabs or splitting panes. In fact, these stripped down floating
panels do not contain any panes at all, and hou.FloatingPanel.panes will
return an empty tuple. You can create such a stripped down floating
panel with hou.Desktop.createFloatingPaneTab.</p>
<p>See hou.Desktop for more information about panes and pane tabs.</p>
<dl class="method">
<dt id="hou.FloatingPanel.attachToDesktop">
<code class="descname">attachToDesktop</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.FloatingPanel.attachToDesktop" title="Permalink to this definition"></a></dt>
<dd><p>Attach this panel to the desktop. See
hou.FloatingPanel.isAttachedToDesktop for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.FloatingPanel.close">
<code class="descname">close</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.FloatingPanel.close" title="Permalink to this definition"></a></dt>
<dd><p>Close the floating panels window, closing all the pane tabs inside
it.</p>
</dd></dl>

<dl class="method">
<dt id="hou.FloatingPanel.containsMenuBar">
<code class="descname">containsMenuBar</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.FloatingPanel.containsMenuBar" title="Permalink to this definition"></a></dt>
<dd><p>Return whether or not this panel contains Houdinis main menu bar.</p>
<p>See also hou.FloatingPanel.setContainsMenuBar.</p>
</dd></dl>

<dl class="method">
<dt id="hou.FloatingPanel.containsPlaybar">
<code class="descname">containsPlaybar</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.FloatingPanel.containsPlaybar" title="Permalink to this definition"></a></dt>
<dd><p>Return whether or not this panel contains Houdinis playbar.</p>
<p>See also hou.FloatingPanel.setContainsPlaybar.</p>
</dd></dl>

<dl class="method">
<dt id="hou.FloatingPanel.containsShelf">
<code class="descname">containsShelf</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.FloatingPanel.containsShelf" title="Permalink to this definition"></a></dt>
<dd><p>Return whether or not this panel contains Houdinis shelf.</p>
<p>See also hou.FloatingPanel.setContainsShelf.</p>
</dd></dl>

<dl class="method">
<dt id="hou.FloatingPanel.containsStatusBar">
<code class="descname">containsStatusBar</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.FloatingPanel.containsStatusBar" title="Permalink to this definition"></a></dt>
<dd><p>Return whether or not this panel contains Houdinis status bar (the
bar at the bottom of the desktop for status messages).</p>
<p>See also hou.FloatingPanel.setContainsStatusBar.</p>
</dd></dl>

<dl class="method">
<dt id="hou.FloatingPanel.findPaneTab">
<code class="descname">findPaneTab</code><span class="sig-paren">(</span><em>self</em>, <em>name</em><span class="sig-paren">)</span> &#x2192; hou.PaneTab or None<a class="headerlink" href="#hou.FloatingPanel.findPaneTab" title="Permalink to this definition"></a></dt>
<dd><p>Return the pane tab with the given name, or None if no such tab
exists.</p>
</dd></dl>

<dl class="method">
<dt id="hou.FloatingPanel.isAttachedToDesktop">
<code class="descname">isAttachedToDesktop</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.FloatingPanel.isAttachedToDesktop" title="Permalink to this definition"></a></dt>
<dd><p>Return whether or not this panel is attached to the desktop. Panels
attached to the desktop are saved with the desktop and are opened
when the desktop is opened and closed when the desktop is closed.</p>
<p>See also hou.FloatingPanel.attachToDesktop.</p>
</dd></dl>

<dl class="method">
<dt id="hou.FloatingPanel.isFullscreen">
<code class="descname">isFullscreen</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.FloatingPanel.isFullscreen" title="Permalink to this definition"></a></dt>
<dd><p>Return whether or not this panel is in full screen mode.</p>
<p>See also hou.FloatingPanel.setIsFullscreen.</p>
</dd></dl>

<dl class="method">
<dt id="hou.FloatingPanel.name">
<code class="descname">name</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.FloatingPanel.name" title="Permalink to this definition"></a></dt>
<dd><p>Return the name of the floating panel. The panels name is displayed
in its windows title.</p>
</dd></dl>

<dl class="method">
<dt id="hou.FloatingPanel.paneTabOfType">
<code class="descname">paneTabOfType</code><span class="sig-paren">(</span><em>self</em>, <em>type</em>, <em>index=0</em><span class="sig-paren">)</span> &#x2192; hou.PaneTab or None<a class="headerlink" href="#hou.FloatingPanel.paneTabOfType" title="Permalink to this definition"></a></dt>
<dd><p>Find and return the pane tab with the desired type or None if no
such pane tab exists.</p>
<dl class="docutils">
<dt>type</dt>
<dd>A hou.paneTabType enumerated variable.</dd>
<dt>index</dt>
<dd>If there are multiple tabs with the desired type, this parameter
determines which one is returned. Use index=0 to return the
first found tab, index=1 to return the second found tab, etc. By
default, index is 0.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hou.FloatingPanel.paneTabs">
<code class="descname">paneTabs</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.PaneTab<a class="headerlink" href="#hou.FloatingPanel.paneTabs" title="Permalink to this definition"></a></dt>
<dd><p>Return all the pane tabs that are in this floating panel, regardless
of which pane they are in.</p>
</dd></dl>

<dl class="method">
<dt id="hou.FloatingPanel.panes">
<code class="descname">panes</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.Pane<a class="headerlink" href="#hou.FloatingPanel.panes" title="Permalink to this definition"></a></dt>
<dd><p>Return all the panes inside the panel. As mentioned in the
documentation for this class, a floating panel may be stripped down
and locked to one particular pane tab, and these stripped down
floating panels do not contain any panes.</p>
</dd></dl>

<dl class="method">
<dt id="hou.FloatingPanel.position">
<code class="descname">position</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Vector2<a class="headerlink" href="#hou.FloatingPanel.position" title="Permalink to this definition"></a></dt>
<dd><p>Return the desktop position (in pixels) of the floating panel
window.</p>
</dd></dl>

<dl class="method">
<dt id="hou.FloatingPanel.setContainsMenuBar">
<code class="descname">setContainsMenuBar</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.FloatingPanel.setContainsMenuBar" title="Permalink to this definition"></a></dt>
<dd><p>If on is True, move Houdinis main menu bar to this panel.
Otherwise, move it back to the main desktop window.</p>
<p>See also hou.FloatingPanel.containsMenuBar.</p>
</dd></dl>

<dl class="method">
<dt id="hou.FloatingPanel.setContainsPlaybar">
<code class="descname">setContainsPlaybar</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.FloatingPanel.setContainsPlaybar" title="Permalink to this definition"></a></dt>
<dd><p>If on is True, move Houdinis playbar to this panel. Otherwise, move
it back to the main desktop window.</p>
<p>See also hou.FloatingPanel.containsPlaybar.</p>
</dd></dl>

<dl class="method">
<dt id="hou.FloatingPanel.setContainsShelf">
<code class="descname">setContainsShelf</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.FloatingPanel.setContainsShelf" title="Permalink to this definition"></a></dt>
<dd><p>If on is True, move Houdinis shelf to this panel. Otherwise, move
it back to the main desktop window.</p>
<p>See also hou.FloatingPanel.containsShelf.</p>
</dd></dl>

<dl class="method">
<dt id="hou.FloatingPanel.setContainsStatusBar">
<code class="descname">setContainsStatusBar</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.FloatingPanel.setContainsStatusBar" title="Permalink to this definition"></a></dt>
<dd><p>If on is True, move Houdinis status bar to this panel. Otherwise,
move it back to the main desktop window.</p>
<p>See also hou.FloatingPanel.containsStatusBar.</p>
</dd></dl>

<dl class="method">
<dt id="hou.FloatingPanel.setIsFullscreen">
<code class="descname">setIsFullscreen</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.FloatingPanel.setIsFullscreen" title="Permalink to this definition"></a></dt>
<dd><p>Set whether or not this panel is in full screen mode.</p>
<p>See also hou.FloatingPanel.isFullscreen.</p>
</dd></dl>

<dl class="method">
<dt id="hou.FloatingPanel.setName">
<code class="descname">setName</code><span class="sig-paren">(</span><em>self</em>, <em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.FloatingPanel.setName" title="Permalink to this definition"></a></dt>
<dd><p>Set this panels name. Any characters in the name that are not
letters, numbers, or underscores are replaced with underscores.</p>
<p>Raises hou.OperationFailed if the name is an empty string.</p>
</dd></dl>

<dl class="method">
<dt id="hou.FloatingPanel.setPosition">
<code class="descname">setPosition</code><span class="sig-paren">(</span><em>self</em>, <em>position</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.FloatingPanel.setPosition" title="Permalink to this definition"></a></dt>
<dd><p>Move the floating panel window to the specified desktop position (in
pixels).</p>
<p>Raise hou.TypeError if position does not contain exactly two values.</p>
</dd></dl>

<dl class="method">
<dt id="hou.FloatingPanel.setSize">
<code class="descname">setSize</code><span class="sig-paren">(</span><em>self</em>, <em>size</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.FloatingPanel.setSize" title="Permalink to this definition"></a></dt>
<dd><p>Resize the floating panel window (in pixels).</p>
<p>Raise hou.TypeError if size does not contain exactly two values.
Raise hou.TypeError if size contains a value that is less than or
equal to zero.</p>
</dd></dl>

<dl class="method">
<dt id="hou.FloatingPanel.size">
<code class="descname">size</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Vector2<a class="headerlink" href="#hou.FloatingPanel.size" title="Permalink to this definition"></a></dt>
<dd><p>Return the floating panel windows size (in pixels).</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.FloatingPanel.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.FloatingPanel.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.FolderParmTemplate">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">FolderParmTemplate</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.FolderParmTemplate" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.ParmTemplate" title="hou.ParmTemplate"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.ParmTemplate</span></code></a></p>
<p>Describes a folder in a parameter dialog.</p>
<p>Unlike all other hou.ParmTemplate subclasses, a folder does not
correspond to an individual hou.ParmTuple. Instead, the set of adjacent
folders form a folder set, and there is one parameter for this set that
controls which folder is currently visible. These folder sets correspond
to hou.FolderSetParmTemplate objects.</p>
<p>Folder parm template objects are useful when manipulating the parameter
interface of a node or a digital asset definition. Unlike folder set
parm templates, they contain the parm templates inside the folder. They
also let you add, remove, or hide an individual folder or move it from
set one to another using hou.ParmTemplateGroup objects. Doing these
individual folder-level operations is not possible with folder set parm
templates.</p>
<p>Note that folder parm templates are also used to represent multiparm
blocks, much like the &lt;Type Properties&gt; dialog does. The folder parm
templates hou.folderType determines whether it is a folder or a
multiparm block. Unlike folder parm templates, which do not correspond
directly to parameter instances, a multiparm parm template does
correspond to an integer parameter that controls the number of instances
of the multiparm.</p>
<dl class="method">
<dt id="hou.FolderParmTemplate.addParmTemplate">
<code class="descname">addParmTemplate</code><span class="sig-paren">(</span><em>self</em>, <em>parm_template</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.FolderParmTemplate.addParmTemplate" title="Permalink to this definition"></a></dt>
<dd><p>Append a parm template to the end of the list of parm templates
inside the folder.</p>
<p>Note that hou.ParmTemplateGroup provides a number of methods to
insert parm templates inside folders, including
hou.ParmTemplateGroup.appendToFolder.</p>
</dd></dl>

<dl class="method">
<dt id="hou.FolderParmTemplate.defaultValue">
<code class="descname">defaultValue</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.FolderParmTemplate.defaultValue" title="Permalink to this definition"></a></dt>
<dd><p>Return the integer default value.</p>
<p>The default value is only used for folders that are multiparm
blocks, and controls the default number of multiparm instances in
newly created nodes.</p>
</dd></dl>

<dl class="method">
<dt id="hou.FolderParmTemplate.endsTabGroup">
<code class="descname">endsTabGroup</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.FolderParmTemplate.endsTabGroup" title="Permalink to this definition"></a></dt>
<dd><p>Return whether this folder will be the last in the folder set, even
if the next parameter is also a folder. In that case, the next
parameter will begin a new folder set.</p>
<p>This parameter only has meaning if the parm template is for an
actual folder and not for a multiparm block.</p>
</dd></dl>

<dl class="method">
<dt id="hou.FolderParmTemplate.folderStyle">
<code class="descname">folderStyle</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.FolderParmTemplate.folderStyle" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.FolderParmTemplate.folderType">
<code class="descname">folderType</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.folderType enum value<a class="headerlink" href="#hou.FolderParmTemplate.folderType" title="Permalink to this definition"></a></dt>
<dd><p>Return the type of folder. Note that the folder may actually be a
multiparm block.</p>
</dd></dl>

<dl class="method">
<dt id="hou.FolderParmTemplate.isActualFolder">
<code class="descname">isActualFolder</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.FolderParmTemplate.isActualFolder" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Return whether or not this parm template corresponds to an actual
folder, as opposed to a multiparm or import block.</p>
<p>This method can be implemented as follows:</p>
</div></blockquote>
<p>&gt; def isActualFolder(self):
&gt;     return self.folderType() in (
&gt;         hou.folderType.Tabs, hou.folderType.RadioButtons)</p>
</dd></dl>

<dl class="method">
<dt id="hou.FolderParmTemplate.parmTemplates">
<code class="descname">parmTemplates</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.ParmTemplate<a class="headerlink" href="#hou.FolderParmTemplate.parmTemplates" title="Permalink to this definition"></a></dt>
<dd><p>Return a tuple of copies of the parm templates stored inside this
folder.</p>
<p>Because copies are returned, you cannot change the contents of the
parm templates inside this folder by modifying the parm templates
returned. Instead, use methods in hou.ParmTemplateGroup to modify
parm templates in this folder.</p>
</dd></dl>

<dl class="method">
<dt id="hou.FolderParmTemplate.setDefaultValue">
<code class="descname">setDefaultValue</code><span class="sig-paren">(</span><em>self</em>, <em>default_value</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.FolderParmTemplate.setDefaultValue" title="Permalink to this definition"></a></dt>
<dd><p>Set the default value to an integer.</p>
<p>The default value is only used for folders that are multiparm
blocks. See the defaultValue method for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.FolderParmTemplate.setEndsTabGroup">
<code class="descname">setEndsTabGroup</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.FolderParmTemplate.setEndsTabGroup" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.FolderParmTemplate.setFolderType">
<code class="descname">setFolderType</code><span class="sig-paren">(</span><em>self</em>, <em>folder_type</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.FolderParmTemplate.setFolderType" title="Permalink to this definition"></a></dt>
<dd><p>Set the type of folder to a hou.folderType enum value.</p>
</dd></dl>

<dl class="method">
<dt id="hou.FolderParmTemplate.setParmTemplates">
<code class="descname">setParmTemplates</code><span class="sig-paren">(</span><em>self</em>, <em>parm_templates</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.FolderParmTemplate.setParmTemplates" title="Permalink to this definition"></a></dt>
<dd><p>Replace the parm templates inside this folder with a new sequence of
parm templates.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.FolderParmTemplate.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.FolderParmTemplate.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.FolderSetParmTemplate">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">FolderSetParmTemplate</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.FolderSetParmTemplate" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.ParmTemplate" title="hou.ParmTemplate"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.ParmTemplate</span></code></a></p>
<p>Describes a set of folders.</p>
<p>A folder set is a group of adjacent folders, and only one of those
folders can be displayed at a time. A folder set corresponds to one
parameter, and the value of that parameter determines which folder is
displayed.</p>
<p>Note that there is also a hou.FolderParmTemplate class. Folder sets are
used when there is a mapping to a parameter; for example, asking a
hou.ParmTuple for its parm template may return a folder set, but it will
never return a folder. Folder parm templates are used by
hou.ParmTemplateGroup because they easily let you add, remove, and move
individual folders, and they let you easily place parameters inside
folders. Attempting to place folder set parm templates in
hou.ParmTemplateGroup objects will raise hou.OperationFailed.</p>
<dl class="method">
<dt id="hou.FolderSetParmTemplate.folderNames">
<code class="descname">folderNames</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.FolderSetParmTemplate.folderNames" title="Permalink to this definition"></a></dt>
<dd><p>setFolderNames(self, folder_names)</p>
<blockquote>
<div><p>Set the names of the folders in this set to the given sequence of
strings.</p>
<p>See the folderNames method for more information.</p>
<p>Raises hou.OperationFailed if folder_names is an empty sequence.</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.FolderSetParmTemplate.folderStyle">
<code class="descname">folderStyle</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.folderType enum value<a class="headerlink" href="#hou.FolderSetParmTemplate.folderStyle" title="Permalink to this definition"></a></dt>
<dd><p>This method is deprecated. It is an alias for the folderType method.</p>
</dd></dl>

<dl class="method">
<dt id="hou.FolderSetParmTemplate.folderType">
<code class="descname">folderType</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.folderType enum value<a class="headerlink" href="#hou.FolderSetParmTemplate.folderType" title="Permalink to this definition"></a></dt>
<dd><p>Return the type of folder.</p>
</dd></dl>

<dl class="method">
<dt id="hou.FolderSetParmTemplate.setFolderNames">
<code class="descname">setFolderNames</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.FolderSetParmTemplate.setFolderNames" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.FolderSetParmTemplate.setFolderType">
<code class="descname">setFolderType</code><span class="sig-paren">(</span><em>self</em>, <em>folder_type</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.FolderSetParmTemplate.setFolderType" title="Permalink to this definition"></a></dt>
<dd><p>Set the type of folder to a hou.folderType enum value.</p>
<p>Raises TypeError if the folder type is for a multiparm or import
block.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.FolderSetParmTemplate.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.FolderSetParmTemplate.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.Gallery">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">Gallery</code><a class="headerlink" href="#hou.Gallery" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A collection of gallery entries that can be applied to operator nodes to
set their parameters to predefined values.</p>
<p>In Houdini, a gallery is a collection of node templates and their
parameter presets, which are represented by a hou.GalleryEntry. A
gallery corresponds to a file where such templates are saved. Galleries
can be managed with a hou.galleries module.</p>
<dl class="method">
<dt id="hou.Gallery.createEntry">
<code class="descname">createEntry</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.Gallery.createEntry" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.Gallery.deleteEntry">
<code class="descname">deleteEntry</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.Gallery.deleteEntry" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.Gallery.galleryEntries">
<code class="descname">galleryEntries</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Gallery.galleryEntries" title="Permalink to this definition"></a></dt>
<dd><p>galleryEntries(self, name_pattern=None, label_pattern=None,
keyword_pattern=None, category=None, node_type=None) -&gt; tuple of
hou.GalleryEntry</p>
<blockquote>
<div><p>Return a tuple of entries that are stored in the gallery. See also
hou.galleries.galleryEntries.</p>
<dl class="docutils">
<dt>name_pattern</dt>
<dd>A pattern that the gallery entry name must match to be included
in the returned tuple. The pattern can contain ? to match a
single character, * to match any number of characters, and 
to match any character in the set. If None, all gallery entries
are considered to match it.</dd>
<dt>label_pattern</dt>
<dd>A pattern that the gallery entry label must match to be included
in the returned tuple. See the name_pattern above for special
characters in the pattern. If None, all gallery entries are
considered to match it.</dd>
<dt>keyword_pattern</dt>
<dd>A pattern that any of the the gallery entry keywords needs to
match for the entry to be included in the returned tuple. See
the name_pattern above for special characters in the pattern. If
None, all gallery entries are considered to match it.</dd>
<dt>category</dt>
<dd>If not None, only gallery entries in the specified category will
be included in the returned tuple.</dd>
<dt>node_type</dt>
<dd>If not None, only gallery entries for a given node type will be
included in the returned tuple.</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="attribute">
<dt id="hou.Gallery.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.Gallery.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.GalleryEntry">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">GalleryEntry</code><a class="headerlink" href="#hou.GalleryEntry" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A gallery entry that can be applied to operator nodes to set their
parameters to predefined values.</p>
<p>A gallery entry is an entity containing data about an operator node
setup. It has information about the nodes parameter values, any
additional spare parameters, channels, and for subnet nodes the
information about the children, etc. Thus, a gallery entry is like a
node template or a parameter preset. Such templates can be created from
and applied to existing nodes.</p>
<p>A gallery entry is identified by a unique, and has a non-unique label,
and is usually associated with a specific hou.NodeType (or several node
types) of the nodes to which it applies. In addition to the node
information, gallery entries can have own categories that organize them
into manageable sets and also can have keywords that identify their
purpose. For more information about gallery entries, please see a
gallery entry editor.</p>
<p>In order for your gallery entries to appear in the Material Palette
pane, they must satisfy two conditions. First, the node category must be
set to indicate the gallery entry creates a SHOP node. Use code like:</p>
<p>&gt; hou.galleries.galleryEntries(entry_name)[0].setNodeTypeCategory(hou.shopNodeTypeCategory())</p>
<p>The second condition is that the entry must contain one or more keywords
that indicate what renderer the SHOP works with. This affects whether
the gallery entry appears when a specific renderer is chosen in the
Material Palette renderer menu. Even if All is chosen in that menu,
the gallery entry must contain a keyword that matches one of the
renderers that appears in that menu. To associate a gallery entry with
the Mantra renderer, do the following:</p>
<p>&gt; hou.galleries.galleryEntries(entry_name)[0].setKeywords((Mantra,))</p>
<p>In HOM the gallery entries can be managed using hou.Gallery.</p>
<dl class="method">
<dt id="hou.GalleryEntry.allowIconRegeneration">
<code class="descname">allowIconRegeneration</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GalleryEntry.allowIconRegeneration" title="Permalink to this definition"></a></dt>
<dd><p>Return True if this gallery entry wants to let Houdini regenerate
the icon for it automatically using an appropriate renderer. Only
applies to material gallery entries.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GalleryEntry.applyToNode">
<code class="descname">applyToNode</code><span class="sig-paren">(</span><em>self</em>, <em>node</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GalleryEntry.applyToNode" title="Permalink to this definition"></a></dt>
<dd><p>Apply the gallery entry to a given node. This method sets the nodes
parameter values to match the ones stored by the entry. It may also
add spare parameters and channels to the node and for the subnets,
it may create new child nodes.</p>
<dl class="docutils">
<dt>node</dt>
<dd>A node to which to apply the gallery entry.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hou.GalleryEntry.bestNodeType">
<code class="descname">bestNodeType</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; NodeType or None<a class="headerlink" href="#hou.GalleryEntry.bestNodeType" title="Permalink to this definition"></a></dt>
<dd><p>Return a best node type which this gallery entry is associated with
and whose nodes it can be applied to.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GalleryEntry.canApplyToNode">
<code class="descname">canApplyToNode</code><span class="sig-paren">(</span><em>self</em>, <em>node</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GalleryEntry.canApplyToNode" title="Permalink to this definition"></a></dt>
<dd><p>Return True if this gallery entry can be safely applied to the given
node. See hou.GalleryEntry.applyToNode for more info.</p>
<dl class="docutils">
<dt>node</dt>
<dd>A node to test whether the gallery entry can be applied to.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hou.GalleryEntry.canCreateChildNode">
<code class="descname">canCreateChildNode</code><span class="sig-paren">(</span><em>self</em>, <em>parent</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GalleryEntry.canCreateChildNode" title="Permalink to this definition"></a></dt>
<dd><p>Return True if hou.GalleryEntry.createChildNode can succeed.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GalleryEntry.categories">
<code class="descname">categories</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of strings<a class="headerlink" href="#hou.GalleryEntry.categories" title="Permalink to this definition"></a></dt>
<dd><p>Return the categories this gallery entry subscribes to.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GalleryEntry.createChildNode">
<code class="descname">createChildNode</code><span class="sig-paren">(</span><em>self</em>, <em>parent</em><span class="sig-paren">)</span> &#x2192; Node<a class="headerlink" href="#hou.GalleryEntry.createChildNode" title="Permalink to this definition"></a></dt>
<dd><p>Create a new node in the parent network and then apply this gallery
entry to that newly created node.</p>
<dl class="docutils">
<dt>parent</dt>
<dd>A subnetwork within which the new node should be created. If
None, an implicit natural parent is chosen using a node type
this gallery entry is associated with.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hou.GalleryEntry.description">
<code class="descname">description</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; string<a class="headerlink" href="#hou.GalleryEntry.description" title="Permalink to this definition"></a></dt>
<dd><p>Return a description of the gallery entry. A description is a short
string that states the gallery entry purpose. It is used for tool-
tip pop-ups.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GalleryEntry.helpURL">
<code class="descname">helpURL</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; string<a class="headerlink" href="#hou.GalleryEntry.helpURL" title="Permalink to this definition"></a></dt>
<dd><p>Return the URL of the help document for this gallery entry.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GalleryEntry.icon">
<code class="descname">icon</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; string<a class="headerlink" href="#hou.GalleryEntry.icon" title="Permalink to this definition"></a></dt>
<dd><p>Return the icon name or a icon file path that should be used for
this gallery entry.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GalleryEntry.keywords">
<code class="descname">keywords</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of strings<a class="headerlink" href="#hou.GalleryEntry.keywords" title="Permalink to this definition"></a></dt>
<dd><p>Return the keywords that describe this gallery entry.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GalleryEntry.label">
<code class="descname">label</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.GalleryEntry.label" title="Permalink to this definition"></a></dt>
<dd><p>Return the gallery entry label.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GalleryEntry.name">
<code class="descname">name</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; string<a class="headerlink" href="#hou.GalleryEntry.name" title="Permalink to this definition"></a></dt>
<dd><p>Return the gallery entry name.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GalleryEntry.nodeTypeCategory">
<code class="descname">nodeTypeCategory</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; NodeTypeCategory<a class="headerlink" href="#hou.GalleryEntry.nodeTypeCategory" title="Permalink to this definition"></a></dt>
<dd><p>Return the category of the node types this gallery entry is
associated with.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GalleryEntry.nodeTypeNames">
<code class="descname">nodeTypeNames</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of strings<a class="headerlink" href="#hou.GalleryEntry.nodeTypeNames" title="Permalink to this definition"></a></dt>
<dd><p>Return the names of the node type this gallery is associated with.
The gallery can be safely applied to the nodes of these types.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GalleryEntry.requiredHDAFile">
<code class="descname">requiredHDAFile</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; string<a class="headerlink" href="#hou.GalleryEntry.requiredHDAFile" title="Permalink to this definition"></a></dt>
<dd><p>Return a file path to an HDA library that should be loaded before
trying to apply this gallery entry. It is often used for gallery
entries associated with a non-native operator type.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GalleryEntry.script">
<code class="descname">script</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; string<a class="headerlink" href="#hou.GalleryEntry.script" title="Permalink to this definition"></a></dt>
<dd><p>Return a script that modifies the node parameters to match the
information stored in the gallery entry.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GalleryEntry.setAllowIconRegeneration">
<code class="descname">setAllowIconRegeneration</code><span class="sig-paren">(</span><em>self</em>, <em>allow</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GalleryEntry.setAllowIconRegeneration" title="Permalink to this definition"></a></dt>
<dd><p>Sets the allow icon regneration flag on this gallery entry.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GalleryEntry.setCategories">
<code class="descname">setCategories</code><span class="sig-paren">(</span><em>self</em>, <em>categories</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GalleryEntry.setCategories" title="Permalink to this definition"></a></dt>
<dd><p>Set the categories this gallery entry subscribes to.</p>
<dl class="docutils">
<dt>categories</dt>
<dd>A string with comma separated categories to set the gallery
entry to.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hou.GalleryEntry.setContentsFromNode">
<code class="descname">setContentsFromNode</code><span class="sig-paren">(</span><em>self</em>, <em>node</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GalleryEntry.setContentsFromNode" title="Permalink to this definition"></a></dt>
<dd><p>Save the information about the node contents (i.e., child nodes).
When applying the node entry later on, these nodes will be
reconstructed in a new parent to match the contents of the current
parent.</p>
<dl class="docutils">
<dt>node</dt>
<dd>The parent of the nodes whose data should be saved.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hou.GalleryEntry.setDescription">
<code class="descname">setDescription</code><span class="sig-paren">(</span><em>self</em>, <em>description</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GalleryEntry.setDescription" title="Permalink to this definition"></a></dt>
<dd><p>Set the description of the gallery entry.</p>
<dl class="docutils">
<dt>description</dt>
<dd>The text briefly describing the gallery entry purpose.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hou.GalleryEntry.setEqual">
<code class="descname">setEqual</code><span class="sig-paren">(</span><em>self</em>, <em>entry</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GalleryEntry.setEqual" title="Permalink to this definition"></a></dt>
<dd><p>Set this gallery entry to be exactly the same as the given entry,
except for the name, which is left unchanged.</p>
<dl class="docutils">
<dt>entry</dt>
<dd>The gallery entry to copy the information from.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hou.GalleryEntry.setHelpURL">
<code class="descname">setHelpURL</code><span class="sig-paren">(</span><em>self</em>, <em>helpurl</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GalleryEntry.setHelpURL" title="Permalink to this definition"></a></dt>
<dd><p>Set the URL of the help document for this gallery entry.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GalleryEntry.setIcon">
<code class="descname">setIcon</code><span class="sig-paren">(</span><em>self</em>, <em>icon</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GalleryEntry.setIcon" title="Permalink to this definition"></a></dt>
<dd><p>Set the icon name or an icon file path that should be used for this
gallery entry.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GalleryEntry.setKeywords">
<code class="descname">setKeywords</code><span class="sig-paren">(</span><em>self</em>, <em>keywords</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GalleryEntry.setKeywords" title="Permalink to this definition"></a></dt>
<dd><p>Set the keywords that describe this gallery entry.</p>
<dl class="docutils">
<dt>keywords</dt>
<dd>A string containing a white-space separated list of keywords.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hou.GalleryEntry.setLabel">
<code class="descname">setLabel</code><span class="sig-paren">(</span><em>self</em>, <em>label</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GalleryEntry.setLabel" title="Permalink to this definition"></a></dt>
<dd><p>Set the gallery entry label.</p>
<dl class="docutils">
<dt>label</dt>
<dd>The label string.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hou.GalleryEntry.setName">
<code class="descname">setName</code><span class="sig-paren">(</span><em>self</em>, <em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GalleryEntry.setName" title="Permalink to this definition"></a></dt>
<dd><p>Set the gallery entry name.</p>
<dl class="docutils">
<dt>name</dt>
<dd>The name string.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hou.GalleryEntry.setNodeTypeCategory">
<code class="descname">setNodeTypeCategory</code><span class="sig-paren">(</span><em>self</em>, <em>category</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GalleryEntry.setNodeTypeCategory" title="Permalink to this definition"></a></dt>
<dd><p>Set the category of the node types this gallery entry should be
associated with.</p>
<dl class="docutils">
<dt>category</dt>
<dd>A hou.NodeTypeCategory to associate this gallery entry with.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hou.GalleryEntry.setNodeTypeNames">
<code class="descname">setNodeTypeNames</code><span class="sig-paren">(</span><em>self</em>, <em>nodetypes</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GalleryEntry.setNodeTypeNames" title="Permalink to this definition"></a></dt>
<dd><p>Set the names of the node types this gallery should be associated
with.</p>
<dl class="docutils">
<dt>nodetypes</dt>
<dd>A string containing white-space separated list of node type
names.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hou.GalleryEntry.setRequiredHDAFile">
<code class="descname">setRequiredHDAFile</code><span class="sig-paren">(</span><em>self</em>, <em>hda_file</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GalleryEntry.setRequiredHDAFile" title="Permalink to this definition"></a></dt>
<dd><p>Set a file path to an HDA library on which this gallery entry
depends.</p>
<dl class="docutils">
<dt>hda_file</dt>
<dd>A path of the HDA library file (OTL).</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hou.GalleryEntry.setScript">
<code class="descname">setScript</code><span class="sig-paren">(</span><em>self</em>, <em>script</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GalleryEntry.setScript" title="Permalink to this definition"></a></dt>
<dd><p>Set a script that modifies the parameters when the gallery entry is
applied to a node.</p>
<dl class="docutils">
<dt>script</dt>
<dd>A string that contains the commands setting the nodes
parameters.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hou.GalleryEntry.setScriptFromNode">
<code class="descname">setScriptFromNode</code><span class="sig-paren">(</span><em>self</em>, <em>node</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GalleryEntry.setScriptFromNode" title="Permalink to this definition"></a></dt>
<dd><p>Set a script that modifies node parameters. Later on, when applying
this gallery entry to a node, the script will reconstruct that
nodes parameters to match exactly the parameters of a node passed
to this method.</p>
<dl class="docutils">
<dt>node</dt>
<dd>A node object from which to build the script.</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="hou.GalleryEntry.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.GalleryEntry.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.Geometry">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">Geometry</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Geometry" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A Geometry object contains the points and primitives that define a 3D
geometric shape. For example, each SOP node in Houdini generates a
single Geometry object.</p>
<p>If you ask a SOP for its geometry via hou.SopNode.geometry, youll get a
read-only reference to it. If the SOP recooks, the corresponding
Geometry object will update to the SOPs new geometry. If the SOP is
deleted, accessing the Geometry object will raise a hou.ObjectWasDeleted
exception. If you call methods that try to modify the geometry, they
will raise a hou.GeometryPermissionError exception.</p>
<p>If you do not want the geometry to update when the SOP recooks, you can
call hou.Geometry.freeze. freeze returns another Geometry object that
will not change when the SOP recooks. Accessing frozen Geometry is
slightly faster, since Houdini does not need to look up the SOP node for
each access, so you may want to use frozen geometry for speed-crucial
operations.</p>
<p>If youre writing a SOP using Python, you will have read-write access to
the geometry, and it will be frozen. To create a Python-defined SOP,
select File &gt; New Operator Type and place the Python code in the Code
tab.</p>
<p>Finally, you can allocate a new frozen geometry with read-write access
by creating an instance of hou.Geometry.</p>
<dl class="method">
<dt id="hou.Geometry.addArrayAttrib">
<code class="descname">addArrayAttrib</code><span class="sig-paren">(</span><em>self</em>, <em>type</em>, <em>name</em>, <em>data_type</em>, <em>tuple_size=1</em><span class="sig-paren">)</span> &#x2192; hou.Attrib<a class="headerlink" href="#hou.Geometry.addArrayAttrib" title="Permalink to this definition"></a></dt>
<dd><p>Create a new point, primitive, vertex, or global (a.k.a. detail)
array attribute. Returns a hou.Attrib object describing the newly
created attribute. You would typically call this method from the
code of a Python-defined SOP.</p>
<dl class="docutils">
<dt>type</dt>
<dd>A hou.attribType value to specify if the new attribute should be
a point, primitive, vertex, or global attribute.</dd>
<dt>name</dt>
<dd>The new attributes name. Each attribute in the geometry must
have a unique name.</dd>
<dt>data_type</dt>
<dd>A hou.attribData value to specify if the new attribute should be
an int, float, or string attribute.</dd>
<dt>tuple_size</dt>
<dd>The new attributes tuple size.</dd>
</dl>
<p>Raises hou.GeometryPermissionError if this geometry is not
modifiable.</p>
<p>Raises hou.OperationFailed if an attribute with this name already
exists. If you are familiar with the C++ Houdini Development Kit
(HDK), you know that Houdini can support attributes with the same
name but with different types. However, many SOPs do not let you
distinguish between attributes that have the same name, and multiple
attributes with the same name are discouraged. For this reason, you
cannot create them with this method.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.addAttrib">
<code class="descname">addAttrib</code><span class="sig-paren">(</span><em>type</em>, <em>name</em>, <em>default_value</em>, <em>transform_as_normal=False</em>, <em>create_local_variable=True</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Geometry.addAttrib" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.Geometry.attribType">
<code class="descname">attribType</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.attribType enum value<a class="headerlink" href="#hou.Geometry.attribType" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Return the enumerated value hou.attribType.Global. Points,
primitives, vertices, and geometry support the same set of methods
for querying their attributes, and this method is one of them.</p>
<p>See also:</p>
</div></blockquote>
<ul class="simple">
<li>hou.Prim.attribType</li>
<li>hou.Point.attribType</li>
<li>hou.Vertex.attribType</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.attribValue">
<code class="descname">attribValue</code><span class="sig-paren">(</span><em>self</em>, <em>name_or_attrib</em><span class="sig-paren">)</span> &#x2192; int, float, str, or tuple<a class="headerlink" href="#hou.Geometry.attribValue" title="Permalink to this definition"></a></dt>
<dd><p>Return the global (a.k.a. detail) attribute value for a particular
attribute. The attribute may be specified by name or by hou.Attrib
object.</p>
<p>Raises hou.OperationFailed if no attribute exists with this name.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.attributeCaptureObjectPaths">
<code class="descname">attributeCaptureObjectPaths</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of str<a class="headerlink" href="#hou.Geometry.attributeCaptureObjectPaths" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Returns a tuple of strings representing the capture object paths for
this geometry. The capture objects are those used to capture this
geometry and are identified from the geometrys capture attributes.
The skeleton root path is prepended to the capture object paths and
the object nodes are given by:</div></blockquote>
<p>&gt; # This code will work from inside a Python SOP, but not from the Python
&gt; # shell.
&gt; geo = hou.pwd().geometry()
&gt; nodes = [hou.node(x) for x in geo.attributeCaptureObjectPaths()]</p>
<blockquote>
<div>See also:</div></blockquote>
<ul class="simple">
<li>hou.Geometry.attributeCaptureRegions</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.attributeCaptureRegions">
<code class="descname">attributeCaptureRegions</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of str<a class="headerlink" href="#hou.Geometry.attributeCaptureRegions" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Returns a tuple of strings representing the capture region paths for
this geometry. The capture regions are identified from the
geometrys capture attributes.</p>
<p>See also:</p>
</div></blockquote>
<ul class="simple">
<li>hou.Geometry.attributeCaptureObjectPaths</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.averageEdgeLength">
<code class="descname">averageEdgeLength</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#hou.Geometry.averageEdgeLength" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Return the average edge length of the mesh.</p>
<p>Raises hou.OperationFailed if mesh does not contain any edges.</p>
</div></blockquote>
<p>&gt; # Return the average edge length.
&gt; geo.averageEdgeLength()</p>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.averageMinDistance">
<code class="descname">averageMinDistance</code><span class="sig-paren">(</span><em>self</em>, <em>local_transform</em>, <em>geometry</em>, <em>geometry_transform</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Geometry.averageMinDistance" title="Permalink to this definition"></a></dt>
<dd><p>-&gt; float</p>
<blockquote>
<div><p>Return the average over all points in &lt;geometry&gt; of the minimum
distance to the point set of &lt;self&gt;</p>
<dl class="docutils">
<dt>local_transform</dt>
<dd>A transform to be applied to all points in this geometry.</dd>
<dt>geometry</dt>
<dd>The geometry to find distances from.</dd>
<dt>geometry_transform</dt>
<dd>A transform to be applied to all points in &lt;geometry&gt;.</dd>
</dl>
<p>Raises hou.OperationFailed if &lt;geometry&gt; has no vertices.</p>
</div></blockquote>
<p>&gt; query_geometry = query_node.geometry()
&gt; queried_geometry = queried_node.geometry()
&gt; 
&gt; # Return the average over all points in &lt;queried_geometry&gt; of the minimum
&gt; # distance to the point set of &lt;query_geometry&gt;
&gt; query_geometry.averageMinDistance(
&gt;     query_node.worldTransform(),
&gt;     queried_geometry,
&gt;     queried_node.worldTransform())</p>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.boundingBox">
<code class="descname">boundingBox</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.BoundingBox<a class="headerlink" href="#hou.Geometry.boundingBox" title="Permalink to this definition"></a></dt>
<dd><p>Return an axis-aligned 3D bounding box that is sized and positioned
to be large enough to hold this geometry.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.clear">
<code class="descname">clear</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Geometry.clear" title="Permalink to this definition"></a></dt>
<dd><p>Remove everything from this geometry object. The geometry will have
no points or primitives after calling this method.</p>
<p>Raises hou.GeometryPermissionError if this geometry is not
modifiable.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.containsPrimType">
<code class="descname">containsPrimType</code><span class="sig-paren">(</span><em>self</em>, <em>type_or_name</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.Geometry.containsPrimType" title="Permalink to this definition"></a></dt>
<dd><p>Returns whether the geometry contains at least one primitive of the
specified type.</p>
<dl class="docutils">
<dt>type_or_name</dt>
<dd><p class="first">A hou.primType, or a string containing the name of a primitive
type.</p>
<p class="last">Typical examples of string values are Poly (polygon) or
PackedAgent (agent packed primitive). To see a complete list
of possible typename values, run ginfo -P on a Houdini tools
command line.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.countPrimType">
<code class="descname">countPrimType</code><span class="sig-paren">(</span><em>self</em>, <em>type_or_name</em><span class="sig-paren">)</span> &#x2192; long<a class="headerlink" href="#hou.Geometry.countPrimType" title="Permalink to this definition"></a></dt>
<dd><p>Returns the number of primitives of the specified type in the
geometry.</p>
<dl class="docutils">
<dt>type_or_name</dt>
<dd><p class="first">A hou.primType, or a string containing the name of a primitive
type.</p>
<p class="last">Typical examples of string values are Poly (polygon) or
PackedAgent (agent packed primitive). To see a complete list
of possible typename values, run ginfo -P on a Houdini tools
command line.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.createBezierCurve">
<code class="descname">createBezierCurve</code><span class="sig-paren">(</span><em>self</em>, <em>num_vertices=4</em>, <em>is_closed=False</em>, <em>order=4</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Geometry.createBezierCurve" title="Permalink to this definition"></a></dt>
<dd><p>hou.Face</p>
<p>Create a new Bezier curve with the specified number of vertices and
return it. You would typically call this method from the code of a
Python-defined SOP.</p>
<dl class="docutils">
<dt>num_vertices</dt>
<dd>The number of verticies in the curve. A new point is added to
the geometry for each vertex, and this point is located at the
origin until you change its position. You can also add more
vertices with hou.Face.addVertex.</dd>
<dt>is_closed</dt>
<dd>Controls if the curve is open or closed; see hou.Face.isClosed
for more information. If not specified, the resulting curve is
open. This behavior is different from
hou.Geometry.createPolygon, where the new polygon is closed.</dd>
<dt>order</dt>
<dd>Specifies the curves order. The default order is 4,
corresponding to a cubic Bezier curve. An order of 2, the lowest
order, will give a curve with linear segments.</dd>
</dl>
<p>An open Bezier curve must have (order - 1) * n + 1 vertices for some
integer n&gt;=1 (so valid values for order 4 curves are 4, 7, 10,
etc.). A closed Bezier curve must have (order - 1) * n vertices
(e.g. 3, 6, 9, etc. for order 4 curve). This restriction does not
apply to curves of order 2, however.</p>
<p>As a consequence, you cannot use hou.Face.setIsClosed on non-linear
Bezier curves, since the number of vertices would need to change.</p>
<p>See hou.Geometry.createNURBSCurve for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.createBezierSurface">
<code class="descname">createBezierSurface</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Geometry.createBezierSurface" title="Permalink to this definition"></a></dt>
<dd><p>createBezierSurface(self, rows, cols, is_closed_in_u=False,
is_closed_in_v=False) -&gt; hou.Surface</p>
<blockquote>
<div><blockquote>
<div><p>Create a Bezier surface in the XY plane centered at the origin with
size (1, 1) and return it. You would typically call this method from
the code of a Python-defined SOP.</p>
<dl class="docutils">
<dt>rows, cols</dt>
<dd><p class="first">Determines the size of the 2D array of vertices defining the
control points of the surface.</p>
<p class="last">Note that the number of rows corresponds to v and the number or
columns corresponds to u, which can be slightly confusing. For
example, geo.createBezierSurface(9, 7, is_closed_in_u=False,
is_closed_in_v=True) is valid, but geo.createBezierSurface(9, 7,
is_closed_in_u=True, is_closed_in_v=False) raises
hou.OperationFailed.</p>
</dd>
<dt>is_closed_in_u, is_closed_in_v</dt>
<dd>Determines if it is open or closed in each of the u and v
directions; see hou.Surface.isClosedInU for more information.</dd>
<dt>order_u, order_v</dt>
<dd>Specifies the surfaces order in of the U and V directions. The
default order for both is 4, corresponding to a cubic NURBS
surface. An order of 2, the lowest order, will give a surface
with linear segments, essentially a mesh.</dd>
</dl>
<p>As with Bezier curves, a Bezier surface has some restrictions on the
point count in each of the U and V directions. For a given
direction; if its open the number of points in the direction must
be (order - 1) * n + 1 for some integer n &gt;= 1 (e.g. 4, 7, 10, ).
If its open, the number of points must be (order - 1) * n where n
&gt;= 1 in that direction (e.g. 2, 4, 6, .. for order 3).</p>
<p>You can move or resize the surface using
hou.Geometry.transformPrims.</p>
<p>If the geometry contains primitive attributes, the new surface
receives the default values for those attributes.</p>
<p>Raises hou.GeometryPermissionError if this geometry is not
modifiable.</p>
</div></blockquote>
<p>&gt; import math
&gt; 
&gt; # This code will work from inside a Python SOP, but not from the Python
&gt; # shell.
&gt; geo = hou.pwd().geometry()
&gt; 
&gt; # Build a tube-like object about the y axis.
&gt; num_rows, num_cols = (10, 9)
&gt; surf = geo.createBezierSurface(num_rows, num_cols, is_closed_in_u=True)
&gt; for v_index in range(num_rows):
&gt;     for u_index in range(num_cols):
&gt;         angle = u_index * (2.0 * math.pi) / num_cols
&gt;         surf.vertex(u_index, v_index).point().setPosition(
&gt;             (math.cos(angle), v_index / float(num_cols-1), math.sin(angle)))</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.createEdgeGroup">
<code class="descname">createEdgeGroup</code><span class="sig-paren">(</span><em>self</em>, <em>name</em><span class="sig-paren">)</span> &#x2192; hou.EdgeGroup<a class="headerlink" href="#hou.Geometry.createEdgeGroup" title="Permalink to this definition"></a></dt>
<dd><p>Create a new edge group in this geometry.</p>
<dl class="docutils">
<dt>name</dt>
<dd>The name of the new group. Raises hou.OperationFailed if a group
with this name already exists.</dd>
</dl>
<p>Use hou.EdgeGroup.destroy to remove an edge group from the geometry.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.createMeshSurface">
<code class="descname">createMeshSurface</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Geometry.createMeshSurface" title="Permalink to this definition"></a></dt>
<dd><p>createMeshSurface(self, rows, cols, is_closed_in_u=False,
is_closed_in_v=False) -&gt; hou.Surface</p>
<blockquote>
<div><p>Create a quadrilateral mesh surface in the XY plane centered at the
origin with size (1, 1) and return it. You would typically call this
method from the code of a Python-defined SOP.</p>
<p>Note that a mesh object is not the same as a set of polygons
defining the same shape. A mesh object is a single primitive.</p>
<p>See hou.Geometry.createNURBSSurface for more information.</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.createNURBSCurve">
<code class="descname">createNURBSCurve</code><span class="sig-paren">(</span><em>self</em>, <em>num_vertices=4</em>, <em>is_closed=False</em>, <em>order=4</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Geometry.createNURBSCurve" title="Permalink to this definition"></a></dt>
<dd><p>hou.Face</p>
<blockquote>
<div><p>Create a new NURBS with the specified number of vertices and return
it. You would typically call this method from the code of a Python-
defined SOP.</p>
<dl class="docutils">
<dt>num_vertices</dt>
<dd><p class="first">The number of verticies in the curve. A new point is added to
the geometry for each vertex, and this point is located at the
origin until you change its position. You can also add more
vertices with hou.Face.addVertex.</p>
<p class="last">The minimum number of vertices for a NURBS curve is identical to
its order. So for the default order of 4, the curve must have a
minimum of 4 vertices. If you specify too few vertices, this
method raises hou.OperationFailed.</p>
</dd>
<dt>is_closed</dt>
<dd>Controls if the curve is open or closed; see hou.Face.isClosed
for more information. If not specified, the resulting curve is
open. This behavior is different from
hou.Geometry.createPolygon, where the new polygon is closed. You
can also open or close it with hou.Face.setIsClosed.</dd>
<dt>order</dt>
<dd>Specifies the curves order. The default order is 4,
corresponding to a cubic NURBS curve. An order of 2, the lowest
order, will give a curve with linear segments.</dd>
</dl>
<p>If the geometry contains primitive attributes, the new curve
receives the default values for those attributes.</p>
</div></blockquote>
<p>&gt; # This code will work from inside a Python SOP, but not from the Python
&gt; # shell.
&gt; geo = hou.pwd().geometry()
&gt; curve = geo.createNURBSCurve(10)
&gt; i = 0
&gt; for vertex in curve.vertices():
&gt;     vertex.point().setPosition((i, i % 3, 0))
&gt;     i = i + 1</p>
<blockquote>
<div><p>Raises hou.GeometryPermissionError if this geometry is not
modifiable.</p>
<p>See also:</p>
</div></blockquote>
<ul class="simple">
<li>hou.Prim.vertices</li>
<li>hou.Point.setPosition</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.createNURBSSurface">
<code class="descname">createNURBSSurface</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Geometry.createNURBSSurface" title="Permalink to this definition"></a></dt>
<dd><p>createNURBSSurface(self, rows, cols, is_closed_in_u=False,
is_closed_in_v=False) -&gt; hou.Surface</p>
<blockquote>
<div><blockquote>
<div><p>Create a NURBS surface in the XY plane centered at the origin with
size (1, 1) and return it. You would typically call this method from
the code of a Python-defined SOP.</p>
<dl class="docutils">
<dt>rows, cols</dt>
<dd>Determines the size of the 2D array of vertices defining the
control points of the surface. The number of cols and rows in
each direction, must be equal to or larger than the U and V
orders, respectively.</dd>
<dt>is_closed_in_u, is_closed_in_v</dt>
<dd>Controls if the surface is open or closed in each of the U and V
directionss; see hou.Surface.isClosedInU for more information.
If not specified, the default behavior is to build an open
surface.</dd>
<dt>order_u, order_v</dt>
<dd>Specifies the surfaces order in each of the U and V
directionss. The default order for both is 4, corresponding to a
cubic NURBS surface. An order of 2, the lowest order, will give
a surface with linear segments, essentially a mesh.</dd>
</dl>
<p>If the geometry contains primitive attributes, the new surface
receives the default values for those attributes.</p>
<p>You can move or resize the surface using
hou.Geometry.transformPrims.</p>
<p>Raises hou.GeometryPermissionError if this geometry is not
modifiable.</p>
<p>Raises hou.OperationFailed if the number of rows and/or columns is
invalid.</p>
</div></blockquote>
<p>&gt; # This code will work from inside a Python SOP, but not from the Python
&gt; # shell.
&gt; geo = hou.pwd().geometry()
&gt; 
&gt; # Create a surface with a 10x10 grid of vertices.
&gt; surf = geo.createNURBSSurface(10, 10)
&gt; 
&gt; # Initially, the center is at (0, 0, 0), size is (1, 1, 1), on the XY
&gt; # plane.  Scale to (20, 10) and rotate into the XZ plane.
&gt; geo.transformPrims((surf,),
&gt;     hou.hmath.buildScale((20, 10, 1)) *
&gt;     hou.hmath.buildRotateAboutAxis((1, 0, 0), 90))</p>
<blockquote>
<div>See also:</div></blockquote>
<ul class="simple">
<li>hou.Geometry.transformPrims</li>
<li>hou.Matrix4</li>
<li>hou.hmath</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.createPacked">
<code class="descname">createPacked</code><span class="sig-paren">(</span><em>self</em>, <em>typename</em><span class="sig-paren">)</span> &#x2192; hou.PackedPrim<a class="headerlink" href="#hou.Geometry.createPacked" title="Permalink to this definition"></a></dt>
<dd><dl class="docutils">
<dt>typename</dt>
<dd><p class="first">A string containing the name of a type of packed primitive.
Typical examples are PackedDisk (on-disk geometry file) or
AlembicRef (Alembic file).</p>
<p class="last">To see a complete list of possible typename values, run ginfo -P
on a Houdini tools command line.</p>
</dd>
</dl>
<p>See hou.PackedPrim for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.createPoint">
<code class="descname">createPoint</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Point<a class="headerlink" href="#hou.Geometry.createPoint" title="Permalink to this definition"></a></dt>
<dd><p>Create a new point located at (0, 0, 0) and return the corresponding
hou.Point object. You would typically call this method from the code
of a Python-defined SOP.</p>
<p>If the geometry contains point attributes, the new point receives
the default values for those attributes.</p>
<p>Raises hou.GeometryPermissionError if this geometry is not
modifiable.</p>
<p>See hou.Geometry.addAttrib, hou.Geometry.createPolygon, and
hou.Face.addVertex for examples.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.createPointGroup">
<code class="descname">createPointGroup</code><span class="sig-paren">(</span><em>self</em>, <em>name</em>, <em>is_ordered=False</em><span class="sig-paren">)</span> &#x2192; hou.PointGroup<a class="headerlink" href="#hou.Geometry.createPointGroup" title="Permalink to this definition"></a></dt>
<dd><p>Create a new point group in this geometry.</p>
<dl class="docutils">
<dt>name</dt>
<dd>The name of the new group. Raises hou.OperationFailed if a group
with this name already exists.</dd>
<dt>is_ordered</dt>
<dd>Whether or not the new group should be ordered. See
hou.PointGroup for more information about ordered groups.</dd>
</dl>
<p>Use hou.PointGroup.destroy to remove a point group from the
geometry.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.createPoints">
<code class="descname">createPoints</code><span class="sig-paren">(</span><em>self</em>, <em>point_positions</em><span class="sig-paren">)</span> &#x2192; tuple of hou.Point<a class="headerlink" href="#hou.Geometry.createPoints" title="Permalink to this definition"></a></dt>
<dd><p>Create a set of points located at the specified positions and return
a tuple of the new hou.Point objects. You would typically call this
method from the code of a Python-defined SOP.</p>
<p>point_positions can be either a tuple of hou.Vector3 objects or a
tuple of 3-tuple floating point numbers. For example, if
point_positions is ((0, 1, 2), (1, 2, 3)) then this method will
create 2 points with one positioned at (0, 1, 2) and the other at
(1, 2, 3).</p>
<p>If the geometry contains point attributes, the new points receive
the default values for those attributes.</p>
<p>Raises hou.GeometryPermissionError if this geometry is not
modifiable. Raises hou.InvalidSize if one of the specified point
positions does not contain 3 values (for x, y, z).</p>
<p>See hou.Geometry.addAttrib, hou.Geometry.createPolygons, and
hou.Face.addVertex for examples.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.createPolygon">
<code class="descname">createPolygon</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Polygon<a class="headerlink" href="#hou.Geometry.createPolygon" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Create a new polygon and return the corresponding hou.Polygon
object. You would typically call this method from the code of a
Python-defined SOP.</p>
<p>The newly created polygon has no vertices. Use hou.Face.addVertex to
add them. The polygon is also closed (see hou.Face.isClosed for more
information).</p>
<p>If the geometry contains primitive attributes, the new polygon
receives the default values for those attributes.</p>
<p>Raises hou.GeometryPermissionError if this geometry is not
modifiable.</p>
</div></blockquote>
<p>&gt; geo = hou.pwd().geometry()
&gt; poly = geo.createPolygon()
&gt; for position in (0,0,0), (1,0,0), (0,1,0):
&gt;     point = geo.createPoint()
&gt;     point.setPosition(position)
&gt;     poly.addVertex(point)</p>
<blockquote>
<div>See hou.Face.addVertex for a slightly more complicated example.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.createPolygons">
<code class="descname">createPolygons</code><span class="sig-paren">(</span><em>self</em>, <em>points</em><span class="sig-paren">)</span> &#x2192; tuple of hou.Polygon<a class="headerlink" href="#hou.Geometry.createPolygons" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Create a set of polygons with the specified points as vertices and
return a tuple of the new hou.Polygon objects. You would typically
call this method from the code of a Python-defined SOP.</p>
<p>points can be either a tuple of tuples of hou.Point objects or a
tuple of tuples of integers representing the point numbers. For
example, if points is ((0, 1, 2), (3, 4, 5, 6)) then this method
will create 2 polygons with one having points 0, 1 and 2 as its
vertices and the other one having points 3, 4, 5 and 6 as its
vertices.</p>
<p>The created polygons are closed (see hou.Face.isClosed for more
information).</p>
<p>If the geometry contains primitive attributes, then the new polygons
receive the default values for those attributes.</p>
<p>Raises hou.GeometryPermissionError if this geometry is not
modifiable. Raises hou.InvalidSize if one of the specified point
tuples does not contain at least 3 elements. Raises hou.InvalidInput
if one of the point numbers or hou.Point objects do not exist in the
geometry.</p>
<p>Example:</p>
</div></blockquote>
<p>&gt; # Create 6 points in the geometry.
&gt; geo = hou.pwd().geometry()
&gt; point_positions = (
&gt;     (1, 0, 0), (0, 1, 0), (0, 0, 1),
&gt;     (1, 1, 0), (1, 0, 1), (0, 1, 1),
&gt; )
&gt; points = geo.createPoints(point_positions)
&gt; 
&gt; # Create 2 polygons.
&gt; # The first polygon uses the first 3 points in the geometry as its vertices.
&gt; # The second polygon uses the last 3 points in the geometry as its vertices.
&gt; polygons = geo.createPolygons(
&gt;     ((points[0], points[1], points[2]), (points[3], points[4], points[5])))</p>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.createPrimGroup">
<code class="descname">createPrimGroup</code><span class="sig-paren">(</span><em>self</em>, <em>name</em>, <em>is_ordered=False</em><span class="sig-paren">)</span> &#x2192; Hou.PrimGroup<a class="headerlink" href="#hou.Geometry.createPrimGroup" title="Permalink to this definition"></a></dt>
<dd><p>Create a new primitive group in this geometry.</p>
<dl class="docutils">
<dt>name</dt>
<dd>The name of the new group. Raises hou.OperationFailed if a group
with this name already exists.</dd>
<dt>is_ordered</dt>
<dd>Whether or not the new group should be ordered. See
hou.PrimGroup for more information about ordered groups.</dd>
</dl>
<p>Use hou.PrimGroup.destroy to remove a primitive group from the
geometry.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.createTetrahedron">
<code class="descname">createTetrahedron</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Prim<a class="headerlink" href="#hou.Geometry.createTetrahedron" title="Permalink to this definition"></a></dt>
<dd><p>Create a new tetrahedron and return the corresponding hou.Prim
object. You would typically call this method from the code of a
Python-defined SOP.</p>
<p>The newly created tetrahedron has four vertices and new points have
been allocated for them. To build a tetrahedron out of existin
points, use</p>
<p>Raises hou.GeometryPermissionError if this geometry is not
modifiable.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.createTetrahedronInPlace">
<code class="descname">createTetrahedronInPlace</code><span class="sig-paren">(</span><em>self</em>, <em>p0</em>, <em>p1</em>, <em>p2</em>, <em>p3</em><span class="sig-paren">)</span> &#x2192; hou.Prim<a class="headerlink" href="#hou.Geometry.createTetrahedronInPlace" title="Permalink to this definition"></a></dt>
<dd><p>Create a new tetrahedron and return the corresponding hou.Prim
object. You would typically call this method from the code of a
Python-defined SOP.</p>
<p>The newly created tetrahedron has four vertices and uses the points
that have been passed into it.</p>
<p>Raises hou.GeometryPermissionError if this geometry is not
modifiable.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.createVolume">
<code class="descname">createVolume</code><span class="sig-paren">(</span><em>self</em>, <em>xres</em>, <em>yres</em>, <em>zres</em>, <em>bounding_box=None</em><span class="sig-paren">)</span> &#x2192; hou.Volume<a class="headerlink" href="#hou.Geometry.createVolume" title="Permalink to this definition"></a></dt>
<dd><p>Given the x, y, and z resolution (or size) of a voxel array, add a
new volume primitive to the geometry and return it. The values in
the new volumes voxels are all zero.</p>
<dl class="docutils">
<dt>xres, yres, zres</dt>
<dd>Integers greater than zero that specify the size of the voxel
array in one dimension. Raises hou.OperationFailed if any of
these values are not positive.</dd>
<dt>bounding_box</dt>
<dd>A hou.BoundingBox that specifies the volumes 3D size. Note that
this size is independent of the volumes voxel resolution. If
this parameter is None, Houdini uses a bounding box going from
(-1,-1,-1) to (1,1,1).</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.data">
<code class="descname">data</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.Geometry.data" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Return the geometry data in bgeo format.</p>
<p>For example:</p>
</div></blockquote>
<p>&gt; geometry = hou.node(/obj/geo1/torus1).geometry()
&gt; bgeo_data = geometry.data()
&gt; open(/tmp/torus.bgeo, wb).write(bgeo_data)</p>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.deletePoints">
<code class="descname">deletePoints</code><span class="sig-paren">(</span><em>self</em>, <em>points</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Geometry.deletePoints" title="Permalink to this definition"></a></dt>
<dd><p>Delete a sequence of points. You would typically call this method
from the code of a Python-defined SOP.</p>
<p>Note that Houdini will delete any vertices that reference the point.
For example, suppose you have a box with 6 polygons, each with 4
vertices. Also suppose that each point on the box is shared by 3
vertices on 3 separate polygons. If you delete one of those points,
Houdini will remove each of those vertices from their corresponding
polygons, leaving 3 polygons with 4 vertices and 3 polygons with 3
vertices.</p>
<p>To delete a single primitive, pass in a sequence with one point.</p>
<p>Raises hou.GeometryPermissionError if this geometry is not
modifiable.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.deletePrims">
<code class="descname">deletePrims</code><span class="sig-paren">(</span><em>self</em>, <em>prims</em>, <em>keep_points=False</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Geometry.deletePrims" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Delete a sequence of primitives. You would typically call this
method from the code of a Python-defined SOP.</p>
<dl class="docutils">
<dt>keep_points</dt>
<dd>if True, the primitive will be deleted but its points will
remain.</dd>
</dl>
<p>To delete a single primitive, pass in a sequence with one primitive.</p>
<p>Raises hou.GeometryPermissionError if this geometry is not
modifiable.</p>
</div></blockquote>
<p>&gt; # Delete every other primitive:
&gt; prims = [p for p in geo.prims() if p.number() % 2 == 0]
&gt; geo.deletePrims(prims)
&gt; 
&gt; # Delete the first primitive:
&gt; geo.deletePrims([geo.iterPrims()[0]])</p>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.edgeGroups">
<code class="descname">edgeGroups</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.EdgeGroup<a class="headerlink" href="#hou.Geometry.edgeGroups" title="Permalink to this definition"></a></dt>
<dd><p>Return a tuple of all the edge groups in the geometry.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.edgeLoop">
<code class="descname">edgeLoop</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Geometry.edgeLoop" title="Permalink to this definition"></a></dt>
<dd><p>edgeLoop(self, edges, loop_type, full_loop_per_edge, force_ring,
allow_ring) -&gt; tuple of hou.Edge</p>
<blockquote>
<div><p>Returns a tuple of hou.Edge objects that make a path connecting the
edges provided in the edges parameter. If multiple paths are being
returned, they will be separated in the single returned tuple by a
value of None. The paths are generated using the same algorithm used
when performing loop selections in the viewport.</p>
<p>edges: A list of hou.Edge objects that define the path or paths of
connected edges this function should return. Must contain at least
one or two edges depending on the loop options.</p>
<p>loop_type: Controls the type of path returned. Can be any of the
hou.componentLoopType values. If using either the
hou.componentLoopType.Extended or hou.componentLoopType.Closed loop
types, the inputs edges cannot contain any None entries. If these
conditions are not met, a hou.OperationFailed exception will be
thrown.</p>
<p>full_loop_per_edge: If set to True, with the loop_type set to
hou.componentLoopType.Extended or hou.componentLoopType.Closed loop
types, each inputs edge is used to create its own full loop or ring.
If False, the edges are taken in pairs, and so the number of edges
must be even.</p>
<p>force_ring: If set to True, this function will return edge rings
instead of edge loops.</p>
<p>allow_ring: If set to True, this function may return an edge ring if
the edges provided produce a ring more naturally than they produce a
loop (for example if two perpendicular edges are provided from the
same row on a polygonal grid). If set to False, only edge loops will
be returned.</p>
<p>Raises a hou.OperationFailed if it was unable to construct a loop
from the desired components.</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.execute">
<code class="descname">execute</code><span class="sig-paren">(</span><em>self</em>, <em>verb</em>, <em>inputs=[]</em><span class="sig-paren">)</span> &#x2192; HOM_Geometry<a class="headerlink" href="#hou.Geometry.execute" title="Permalink to this definition"></a></dt>
<dd><p>Invokes verb.execute() with myself as the first input, and returns
the resulting geometry. This allows one to chain a series of verbs
invocations: geo.execute(subdivide).execute(subdivide).</p>
<p>The optional inputs will have the geometry itself prepended.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.findEdge">
<code class="descname">findEdge</code><span class="sig-paren">(</span><em>self</em>, <em>p0</em>, <em>p1</em><span class="sig-paren">)</span> &#x2192; hou.Edge<a class="headerlink" href="#hou.Geometry.findEdge" title="Permalink to this definition"></a></dt>
<dd><dl class="docutils">
<dt>p0</dt>
<dd>The first point that makes up the edge. See hou.Point for more
information.</dd>
<dt>p1</dt>
<dd>The second point that makes up the edge. See hou.Point for more
information.</dd>
</dl>
<p>finds an edge given two points, or None if no such edge exists</p>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.findEdgeGroup">
<code class="descname">findEdgeGroup</code><span class="sig-paren">(</span><em>self</em>, <em>name</em><span class="sig-paren">)</span> &#x2192; hou.EdgeGroup or None<a class="headerlink" href="#hou.Geometry.findEdgeGroup" title="Permalink to this definition"></a></dt>
<dd><dl class="docutils">
<dt>name</dt>
<dd>The name of the edge group.</dd>
</dl>
<p>Return the edge group with the given name, or None if no such group
exists.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.findGlobalAttrib">
<code class="descname">findGlobalAttrib</code><span class="sig-paren">(</span><em>self</em>, <em>name</em><span class="sig-paren">)</span> &#x2192; hou.Attrib or None<a class="headerlink" href="#hou.Geometry.findGlobalAttrib" title="Permalink to this definition"></a></dt>
<dd><p>Look up a global (a.k.a. detail) attribute by name. Returns the
corresponding hou.Attrib object, or None if no attribute exists with
that name.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.findPointAttrib">
<code class="descname">findPointAttrib</code><span class="sig-paren">(</span><em>self</em>, <em>name</em><span class="sig-paren">)</span> &#x2192; hou.Attrib or None<a class="headerlink" href="#hou.Geometry.findPointAttrib" title="Permalink to this definition"></a></dt>
<dd><p>Look up a point attribute by name. Returns the corresponding
hou.Attrib object, or None if no attribute exists with that name.</p>
<p>Note that the point position attribute is named P and is 3 floats in
size. Also, the point weight attribute is named Pw and is 1 float in
size. These attributes always exist in HOM, even though they are not
listed by Houdinis UI.</p>
<p>See hou.Point.attribValue for an example.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.findPointGroup">
<code class="descname">findPointGroup</code><span class="sig-paren">(</span><em>self</em>, <em>name</em><span class="sig-paren">)</span> &#x2192; hou.PointGroup or None<a class="headerlink" href="#hou.Geometry.findPointGroup" title="Permalink to this definition"></a></dt>
<dd><p>Return the point group with the given name, or None if no such group
exists.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.findPrimAttrib">
<code class="descname">findPrimAttrib</code><span class="sig-paren">(</span><em>self</em>, <em>name</em><span class="sig-paren">)</span> &#x2192; hou.Attrib or None<a class="headerlink" href="#hou.Geometry.findPrimAttrib" title="Permalink to this definition"></a></dt>
<dd><p>Look up a primitive attribute by name. Returns the corresponding
hou.Attrib object, or None if no attribute exists with that name.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.findPrimGroup">
<code class="descname">findPrimGroup</code><span class="sig-paren">(</span><em>self</em>, <em>name</em><span class="sig-paren">)</span> &#x2192; hou.PrimGroup or None<a class="headerlink" href="#hou.Geometry.findPrimGroup" title="Permalink to this definition"></a></dt>
<dd><p>Return the primitive group with the given name, or None if no such
group exists.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.findVertexAttrib">
<code class="descname">findVertexAttrib</code><span class="sig-paren">(</span><em>self</em>, <em>name</em><span class="sig-paren">)</span> &#x2192; hou.Attrib or None<a class="headerlink" href="#hou.Geometry.findVertexAttrib" title="Permalink to this definition"></a></dt>
<dd><p>Look up a vertex attribute by name. Returns the corresponding
hou.Attrib object, or None if no attribute exists with that name.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.floatAttribValue">
<code class="descname">floatAttribValue</code><span class="sig-paren">(</span><em>self</em>, <em>name_or_attrib</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#hou.Geometry.floatAttribValue" title="Permalink to this definition"></a></dt>
<dd><p>Return the global (a.k.a. detail) attribute value for a particular
floating point attribute. The attribute may be specified by name or
by hou.Attrib object.</p>
<p>Raises hou.OperationFailed if no attribute exists with this name or
the attribute is not a float of size 1.</p>
<p>In most cases, youll just use hou.Geometry.attribValue to access
attribute values. Houdini uses this method internally to implement
attribValue.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.floatListAttribValue">
<code class="descname">floatListAttribValue</code><span class="sig-paren">(</span><em>self</em>, <em>name_or_attrib</em><span class="sig-paren">)</span> &#x2192; tuple of float<a class="headerlink" href="#hou.Geometry.floatListAttribValue" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Return the global (a.k.a. detail) attribute value for a particular
floating point attribute. The attribute may be specified by name or
by hou.Attrib object. The return value is a list of floats.</p>
<p>It is valid to call this method when the attributes size is 1. In
this case, a list with one element is returned.</p>
<p>See also:</p>
</div></blockquote>
<ul class="simple">
<li>hou.Geometry.attribValue</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.freeze">
<code class="descname">freeze</code><span class="sig-paren">(</span><em>self</em>, <em>read_only=False</em><span class="sig-paren">)</span> &#x2192; hou.Geometry<a class="headerlink" href="#hou.Geometry.freeze" title="Permalink to this definition"></a></dt>
<dd><p>Return another Geometry object that is not linked to a particular
SOP.</p>
<p>Normally, when you call hou.SopNode.geometry, the resultant Geometry
object retains a reference to that SOP, and is said to be unfrozen.
Each time you access points, primitives, attributes, etc. in an
unfrozen Geometry object, Houdini uses the SOPs latest cooked
geometry. So, if you change parameters or change the time for an
animated SOP, the Geometry object will update to the SOPs new
geometry.</p>
<p>Unless Python SOPs are involved, a frozen Geometry object does not
have a similar live association with a particular SOP. If you ask a
SOP for its geometry and then store a frozen copy of that geometry,
when the SOP recooks the frozen Geometry object will not update.
Instead, the frozen geometry saves its own copy of the point and
primitive data, and is unaffected by subsequent changes to the SOP.
When a frozen Geometry object is destroyed, any geometry copy it
created is also destroyed.</p>
<p>Note that accessing a Geometry objects points, primitives,
attributes, etc. may be faster when dealing with frozen objects. You
may want to work with frozen Geometry in speed-sensitive operations.</p>
<p>Calling this method on an unfrozen Geometry object returns a frozen
one. Calling it on a frozen object has no effect, and it returns a
frozen object.</p>
<p>When a Python-defined SOP cooks and runs Python code that asks for
the SOPs geometry, the returned Geometry object is writable.
Modifying this Geometry object affects the output of this SOP. For
efficiency, this geometry object is already frozen, so calling
freeze on it has no effect.</p>
<dl class="docutils">
<dt>read_only</dt>
<dd>If True, the resulting frozen geometry will be read-only. Use
read-only frozen geometry to share embedded geometry among
multiple packed primitives.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.globEdges">
<code class="descname">globEdges</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.Geometry.globEdges" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.Geometry.globPoints">
<code class="descname">globPoints</code><span class="sig-paren">(</span><em>self</em>, <em>pattern</em><span class="sig-paren">)</span> &#x2192; tuple of hou.Point<a class="headerlink" href="#hou.Geometry.globPoints" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Return a tuple of points corresponding to a pattern of point
numbers.</p>
<p>The pattern format is the same one used by the group fields on SOP
nodes that take point selections. Elements in the pattern are
separated by spaces, and elements can be point numbers, point number
ranges, or group names.</p>
<p>This method can be useful when writing a Python SOP that works on
only a selected set of points.</p>
<p>Raises hou.OperationFailed if the pattern is not valid or if it
refers to a group that does not exist. Note that an empty pattern is
considered to be invalid. Numbers that do not refer to valid points
are not errors, and simply do not match points.</p>
</div></blockquote>
<p>&gt; # Return a tuple containing points 5 and 7.
&gt; geo.globPoints(5 7)
&gt; 
&gt; # Return a tuple containing points 5 to 10.
&gt; geo.globPoints(5-10)
&gt; 
&gt; # Return a tuple containing all the points in the pointgroup called group1.
&gt; geo.globPoints(group1)
&gt; 
&gt; # Return all the points except those from 0 to 98.
&gt; geo.globPoints(!0-98)
&gt; 
&gt; # Return points 5, 10 to 20, and those in group1.
&gt; geo.globPoints(5 group1 10-20)</p>
<blockquote>
<div>The following Python SOP example is behaves similarly to the Point
sop.</div></blockquote>
<p>&gt; # This code will work from inside a Python SOP, but not from the Python
&gt; # shell.  It assumes the Python sop has the following parm tuples:
&gt; #     group: A string containing which points to affect
&gt; #     t:     A set of 3 floats that behaves like the point sops position
&gt; #            parameter.  Set these parameters to the expressions ($TX, $TY, $TZ).
&gt; geo = hou.pwd().geometry()
&gt; 
&gt; # Use the group field to determine which points to affect.  If its blank,
&gt; # operate on all points.
&gt; pattern = hou.ch(group)
&gt; if pattern == :
&gt;     points = geo.points()
&gt; else:
&gt;     points = geo.globPoints(pattern)
&gt; 
&gt; # Loop through the points, setting the SOPs current point as we go.
&gt; # Then evaluate the t parm tuple, so it can use the current point (e.g.
&gt; # with hscripts $TX or Pythons pwd().curPoint()).
&gt; for point in points:
&gt;     hou.pwd().setCurPoint(point)
&gt;     new_position = hou.pwd().evalParmTuple(t)
&gt;     point.setPosition(new_position)</p>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.globPrims">
<code class="descname">globPrims</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.Geometry.globPrims" title="Permalink to this definition"></a></dt>
<dd><p>globVertices(self, pattern) -&gt; tuple of hou.Vertex</p>
<blockquote>
<div><p>Return a tuple of vertices corresponding to a pattern of vertex
numbers.</p>
<p>The pattern format is the same one used by the group fields on SOP
nodes that take vertex selections. See hou.Geometry.globPoints for
more information.</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.globVertices">
<code class="descname">globVertices</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.Geometry.globVertices" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.Geometry.globalAttribs">
<code class="descname">globalAttribs</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.Attrib<a class="headerlink" href="#hou.Geometry.globalAttribs" title="Permalink to this definition"></a></dt>
<dd><p>Return a tuple of all the global (a.k.a. detail) attributes.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.intAttribValue">
<code class="descname">intAttribValue</code><span class="sig-paren">(</span><em>self</em>, <em>name_or_attrib</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.Geometry.intAttribValue" title="Permalink to this definition"></a></dt>
<dd><p>Return the global (a.k.a. detail) attribute value for a particular
integer attribute of size 1. The attribute may be specified by name
or by hou.Attrib object. See hou.Geometry.floatAttribValue for more
information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.intListAttribValue">
<code class="descname">intListAttribValue</code><span class="sig-paren">(</span><em>self</em>, <em>name_or_attrib</em><span class="sig-paren">)</span> &#x2192; tuple of int<a class="headerlink" href="#hou.Geometry.intListAttribValue" title="Permalink to this definition"></a></dt>
<dd><p>Return the global (a.k.a. detail) attribute value for a particular
integer attribute. The attribute may be specified by name or by
hou.Attrib object. The return value is a list of ints. See
hou.Geometry.floatListAttribValue for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.intersect">
<code class="descname">intersect</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Geometry.intersect" title="Permalink to this definition"></a></dt>
<dd><p>intersect(self, ray_origin, ray_direction, position_out, normal_out,
uvw_out, pattern=None, min_hit=0.01, max_hit=1E18) -&gt; int</p>
<blockquote>
<div><blockquote>
<div><p>Determines the intersection point of a ray with the geometry in this
object.</p>
<dl class="docutils">
<dt>NOTE</dt>
<dd>This method is unusual in that instead of returning multiple
pieces of information about the intersection, it requires that
you pass it objects which it modifies in-place with the
information.</dd>
</dl>
</div></blockquote>
<p>&gt; # Get some geometry from a SOP node
&gt; geometry = hou.node(/obj/geo1/sphere1).geometry()
&gt; # Shoot a ray from high up in the sky straight down at the origin
&gt; origin = hou.Vector3(0, 100, 0)
&gt; direction = hou.Vector3(0, -1, 0)
&gt; # Make objects for the intersect() method to modify
&gt; position = hou.Vector3()
&gt; normal = hou.Vector3()
&gt; uvw = hou.Vector3()
&gt; # Find the first intersection (if it exists)
&gt; did_intersect = geometry.intersect(origin, direction, position, normal, uvw)</p>
<blockquote>
<div><p>Returns the ID number of the hit primitive if the ray intersected
the geometry, or -1 if the ray did not hit.</p>
<dl class="docutils">
<dt>ray_origin</dt>
<dd>A hou.Vector3 object representing the starting point of the ray
in world space.</dd>
<dt>ray_direction</dt>
<dd>A hou.Vector3 object representing the direction vector of the
ray.</dd>
<dt>position_out</dt>
<dd>Pass a hou.Vector3 object to this argument. The method will
change the objects values to represent the intersection
position in world space.</dd>
<dt>normal_out</dt>
<dd>Pass a hou.Vector3 object to this argument. The method will
change the objects values to represent the normal direction
from the surface to the ray.</dd>
<dt>uvw_out</dt>
<dd>Pass a hou.Vector3 object to this argument. The method will
change the objects values to represent the UVW position within
the intersecting primitive where the ray hit.</dd>
<dt>pattern</dt>
<dd>If you pass a string containing primitive group syntax, the ray
can only intersect primitives that match the pattern.</dd>
<dt>min_hit</dt>
<dd><blockquote class="first">
<div>Ignore intersections closer than this distance. You can use the
min_hit argument to iterate through all possible hits along the
ray, by setting the min_hit a tiny bit farther than the previous
hit.</div></blockquote>
<p class="last">&gt; hit_positions = []
&gt; prev_dist = 0.01
&gt; while geometry.intersect(origin, direction, position, normal, uvw,
&gt;                          min_hit=prev_dist):
&gt;     # Make sure to store a <em>copy</em> of the position, not the object
&gt;     # that is being modified in each iteration of the loop
&gt;     hit_positions.append(hou.Vector3(position))
&gt;     prev_dist = origin.distanceTo(position) + 0.01</p>
</dd>
<dt>max_hit</dt>
<dd>Ignore intersections father than this distance.</dd>
</dl>
</div></blockquote>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.intrinsicNames">
<code class="descname">intrinsicNames</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of str<a class="headerlink" href="#hou.Geometry.intrinsicNames" title="Permalink to this definition"></a></dt>
<dd><p>Returns a tuple of strings representing the intrinsic values
available for this geometry. Different geometry types will have
different intrinsic values available. You can then get or set the
value using intrinsicValue and/or setIntrinsicValue.</p>
<p>See the intrinsicValue method for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.intrinsicReadOnly">
<code class="descname">intrinsicReadOnly</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.Geometry.intrinsicReadOnly" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.Geometry.intrinsicSize">
<code class="descname">intrinsicSize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.Geometry.intrinsicSize" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.Geometry.intrinsicValue">
<code class="descname">intrinsicValue</code><span class="sig-paren">(</span><em>self</em>, <em>intrinsic_name</em><span class="sig-paren">)</span> &#x2192; int, float, str, or tuple<a class="headerlink" href="#hou.Geometry.intrinsicValue" title="Permalink to this definition"></a></dt>
<dd><p>Gets the value of an intrinsic, often computed, value of the
geometry, such as memoryusage, pointcount, pointattributes, and so
on. Raises OperationFailed if the given intrinsic name does not
exist.</p>
<p>You can also view these values in the user interface using the
geometry spreadsheet.</p>
<p>In Houdini, some primitives have intrinsic values which cant be
accessed directly through the attribute interface. Most intrinsic
values are computed, such as measuredarea, however a few are
writeable with the setIntrinsicValue method. For example, sphere
primitives have a transform matrix as part of their definition.</p>
<p>You can get a list of the available intrinsic value names with the
intrinsicNames method. Different geometry types will have different
intrinsic values available.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.intrinsicValueDict">
<code class="descname">intrinsicValueDict</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; dict of str to value<a class="headerlink" href="#hou.Geometry.intrinsicValueDict" title="Permalink to this definition"></a></dt>
<dd><p>Returns a dictionary mapping intrinsic names to their values.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.iterPoints">
<code class="descname">iterPoints</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; generator of hou.Point<a class="headerlink" href="#hou.Geometry.iterPoints" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Return a generator that iterates through all the points in the
geometry.</p>
<p>Whereas hou.Geometry.points allocates and returns a tuple of all the
points in the geometry, this method returns a generator object that
will allocate hou.Point objects on demand. This object is very fast
at random access into the sequence.</p>
<p>If youre accessing a specific point by index and the geometry
contains many points, it is faster to use iterPoints() than
points(). If, however, you are iterating over all the points in the
geometry, it is generally faster to use points() than iterPoints().</p>
</div></blockquote>
<p>&gt; # This is preferred:
&gt; geo.iterPoints()[23]
&gt; 
&gt; # over this:
&gt; geo.points()[23]
&gt; 
&gt; # But this is preferred:
&gt; for point in geo.points():
&gt;     process point
&gt; 
&gt; # over this:
&gt; for point in geo.iterPoints():
&gt;     process point</p>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.iterPrims">
<code class="descname">iterPrims</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; generator of hou.Prim<a class="headerlink" href="#hou.Geometry.iterPrims" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Return a generator that iterates through all the primitives in the
geometry.</p>
<p>Whereas hou.Geometry.prims allocates and returns a tuple of all the
primitives in the geometry, this method returns a generator object
that will yield hou.Prim objects on demand. This object is very fast
at random access into the sequence.</p>
<p>If youre accessing a specific primitive by index and the geometry
contains many primitives, it is faster to use iterPrims() than
prims(). If, however, you are iterating over all the primitives in
the geometry, it is generally faster to use prims() than
iterPrims().</p>
</div></blockquote>
<p>&gt; # This is preferred:
&gt; geo.iterPrims()[23]
&gt; 
&gt; # over this:
&gt; geo.prims()[23]
&gt; 
&gt; # But this is preferred:
&gt; for prim in geo.prims():
&gt;     process prim
&gt; 
&gt; # over this:
&gt; for prim in geo.iterPrims():
&gt;     process prim</p>
<blockquote>
<div>See also the hou.Geometry.prims method.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.loadFromFile">
<code class="descname">loadFromFile</code><span class="sig-paren">(</span><em>self</em>, <em>file_name</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Geometry.loadFromFile" title="Permalink to this definition"></a></dt>
<dd><p>Replace the contents of this geometry object with the data stored in
a file. You would typically call this method from the code of a
Python-defined SOP.</p>
<p>You may specify any type of file supported by Houdinis File SOP.
See hou.Geometry.saveToFile for more information.</p>
<p>Raises hou.OperationFailed if the file does not exist or otherwise
cannot be loaded.</p>
<p>Raises hou.GeometryPermissionError if this geometry is not
modifiable.</p>
<p>See also hou.Geometry.merge.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.merge">
<code class="descname">merge</code><span class="sig-paren">(</span><em>self</em>, <em>geometry</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Geometry.merge" title="Permalink to this definition"></a></dt>
<dd><p>Merge the points and primitives from another hou.Geometry object
into this one. The new points and primitives are appended to this
geometrys points and primitives. You would typically call this
method from the code of a Python-defined SOP.</p>
<p>Raises hou.GeometryPermissionError if this geometry is not
modifiable.</p>
<p>See also hou.Geometry.loadFromFile.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.nearestPrim">
<code class="descname">nearestPrim</code><span class="sig-paren">(</span><em>self</em>, <em>position) -&gt; (hou.Prim or None</em>, <em>float</em>, <em>float</em>, <em>float</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Geometry.nearestPrim" title="Permalink to this definition"></a></dt>
<dd><p>Given a sequence of three floats containing a position, find the
location on the primitive closest to that position and return a
tuple containing that primitive, the u value on the primitive, the v
value on the primitive, and the distance to the primitive.</p>
<p>Note that the first value in the return tuple can be None if there
are no primitives in the geometry.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.point">
<code class="descname">point</code><span class="sig-paren">(</span><em>self</em>, <em>index</em><span class="sig-paren">)</span> &#x2192; hou.Point<a class="headerlink" href="#hou.Geometry.point" title="Permalink to this definition"></a></dt>
<dd><p>Return the point at the specified index.</p>
<p>This is a convenience method for accessing a particular point
without the overhead of obtaining all points via
hou.Geometry.points.</p>
<p>Return None if no such point at the specified index exists.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.pointAttribs">
<code class="descname">pointAttribs</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.Attrib<a class="headerlink" href="#hou.Geometry.pointAttribs" title="Permalink to this definition"></a></dt>
<dd><p>Return a tuple of all the point attributes.</p>
<p>Note that the point position attribute is named P and is 3 floats in
size. Also, the point weight attribute is named Pw and is 1 float in
size. These attributes always exist in HOM, even though they are not
listed by Houdinis UI.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.pointBoundingBox">
<code class="descname">pointBoundingBox</code><span class="sig-paren">(</span><em>self</em>, <em>pointpattern</em><span class="sig-paren">)</span> &#x2192; hou.BoundingBox<a class="headerlink" href="#hou.Geometry.pointBoundingBox" title="Permalink to this definition"></a></dt>
<dd><p>Return an axis-aligned 3D bounding box that is sized and positioned
to include the points specified by the point pattern. If the pattern
is blank, all points will be included.</p>
<p>Some primitives, such as spheres, extend beyond their points. This
extension will not be included.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.pointFloatAttribValues">
<code class="descname">pointFloatAttribValues</code><span class="sig-paren">(</span><em>self</em>, <em>name</em><span class="sig-paren">)</span> &#x2192; tuple of float<a class="headerlink" href="#hou.Geometry.pointFloatAttribValues" title="Permalink to this definition"></a></dt>
<dd><p>Return a tuple of floats containing one attributes values for all
the points.</p>
<p>This method only works on int or float attributes. If the attribute
contains more than one element, each point will correspond to
multiple values in the result. For example, if Cd is a float
attribute of size 3 and there are 3 points with values (0.1, 0.2,
0.3), (0.5, 0.5, 0.5), and (0.8, 0.7, 0.6) then the result will be
(0.1, 0.2, 0.3, 0.5, 0.5, 0.5, 0.8, 0.7, 0.6).</p>
<p>Calling this method is faster than looping over all the points and
calling hou.Point.attribValue.</p>
<p>If the attribute name is invalid or the attribute is not an int or
float (e.g. its a string attribute), this method raises
hou.OperationFailed.</p>
<p>Note that you cannot pass a hou.Attrib object to this method like
you can with many methods dealing with attributes. However, you can
use hou.Attrib.name to easily get the name from an Attrib object.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.pointFloatAttribValuesAsString">
<code class="descname">pointFloatAttribValuesAsString</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Geometry.pointFloatAttribValuesAsString" title="Permalink to this definition"></a></dt>
<dd><p>pointFloatAttribValuesAsString(self, name,
float_type=hou.numericData.Float32) -&gt; str</p>
<blockquote>
<div><blockquote>
<div><p>Return a string representation of the floats of one attributes
value for all the points. This method is faster than
hou.Geometry.pointFloatAttribValues, and you can use the array
module to convert the string into a Python sequence.</p>
<dl class="docutils">
<dt>float_type</dt>
<dd>A hou.numericData value to specify the float data type (either
Float16, Float32 or Float64).</dd>
</dl>
<p>This method provides a faster implementation of the following:</p>
</div></blockquote>
<p>&gt; import array
&gt; def pointFloatAttribValuesAsString(self, name):
&gt;     return array.array(f, self.pointFloatAttribValues(name)).tostring()</p>
<blockquote>
<div>You can convert the return value from this method to an array using
the following method:</div></blockquote>
<p>&gt; import array
&gt; def pointFloatAttribValuesAsArray(geometry, name):
&gt;     a = array.array(f)
&gt;     a.fromstring(geometry.pointFloatAttribValuesAsString(name))
&gt;     return a</p>
<blockquote>
<div>See hou.Geometry.pointFloatAttribValues for more information.</div></blockquote>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.pointGroups">
<code class="descname">pointGroups</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.PointGroup<a class="headerlink" href="#hou.Geometry.pointGroups" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Return a tuple of all the point groups in the geometry.</p>
<p>The following function returns the names of all the groups in the
geometry:</p>
</div></blockquote>
<p>&gt; def pointGroupNames(geometry):
&gt;     return [group.name() for group in geometry.pointGroups()]</p>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.pointIntAttribValues">
<code class="descname">pointIntAttribValues</code><span class="sig-paren">(</span><em>self</em>, <em>name</em><span class="sig-paren">)</span> &#x2192; tuple of int<a class="headerlink" href="#hou.Geometry.pointIntAttribValues" title="Permalink to this definition"></a></dt>
<dd><p>Return a tuple of integers containing one attributes values for all
the points.</p>
<p>This method only works on int or float attributes. If the attribute
contains more than one element, each point will correspond to
multiple values in the result. For example, if idmap is an integer
attribute of size 2 and there are 3 points with values (1, 2), (2,
3), and (3, 4) then the result will be (1, 2, 2, 3, 3, 4).</p>
<p>Calling this method is faster than looping over all the points and
calling hou.Point.attribValue.</p>
<p>If the attribute name is invalid or the attribute is not an int or
float (e.g. its a string attribute), this method raises
hou.OperationFailed.</p>
<p>Note that you cannot pass a hou.Attrib object to this method like
you can with many methods dealing with attributes. However, you can
use hou.Attrib.name to easily get the name from an Attrib object.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.pointIntAttribValuesAsString">
<code class="descname">pointIntAttribValuesAsString</code><span class="sig-paren">(</span><em>self</em>, <em>name</em>, <em>int_type=hou.numericData.Int32</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Geometry.pointIntAttribValuesAsString" title="Permalink to this definition"></a></dt>
<dd><p>-&gt; str</p>
<blockquote>
<div><p>Return a string representation of the integers of one attributes
value for all the points. This method is faster than
hou.Geometry.pointIntAttribValues, and you can use the array module
to convert the string into a Python sequence.</p>
<dl class="docutils">
<dt>int_type</dt>
<dd>A hou.numericData value to specify the integer data type (either
Int8, Int16, Int32 or Int64).</dd>
</dl>
<p>This method provides a faster implementation of the following:</p>
</div></blockquote>
<p>&gt; import array
&gt; def pointIntAttribValuesAsString(self, name):
&gt;     return array.array(i, self.pointIntAttribValues(name)).tostring()</p>
<blockquote>
<div>You can convert the return value from this method to an array using
the following method:</div></blockquote>
<p>&gt; import array
&gt; def pointIntAttribValuesAsArray(geometry, name):
&gt;     a = array.array(i)
&gt;     a.fromstring(geometry.pointIntAttribValuesAsString(name))
&gt;     return a</p>
<blockquote>
<div>See hou.Geometry.pointIntAttribValues for more information.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.pointLoop">
<code class="descname">pointLoop</code><span class="sig-paren">(</span><em>self</em>, <em>points</em>, <em>full_loop</em><span class="sig-paren">)</span> &#x2192; tuple of hou.Point<a class="headerlink" href="#hou.Geometry.pointLoop" title="Permalink to this definition"></a></dt>
<dd><p>Returns a tuple of hou.Point objects that make a path connecting the
points provided in the points parameter. If multiple paths are being
returned, they will be separated in the single returned tuple by a
value of None. The paths are generated using the same algorithm used
when performing loop selections in the viewport.</p>
<p>points: A list of hou.Point objects that define the path or paths of
connected points this function should return. Must contain at least
two points.</p>
<p>loop_type: Controls the type of path returned. Can be any of the
hou.componentLoopType values. If using either the
hou.componentLoopType.Extended or hou.componentLoopType.Closed loop
types, the inputs points cannot contain any None entries.
Furthermore, each pair of points is used to define a separate full
loop, so the number of points must be even. If these conditions are
not met, a hou.OperationFailed exception will be thrown.</p>
<p>Raises a hou.OperationFailed if it was unable to construct a loop
from the desired components.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.pointNormals">
<code class="descname">pointNormals</code><span class="sig-paren">(</span><em>self</em>, <em>points</em><span class="sig-paren">)</span> &#x2192; tuple of hou.Vector3<a class="headerlink" href="#hou.Geometry.pointNormals" title="Permalink to this definition"></a></dt>
<dd><p>Returns a tuple of hou.Vector3 objects representing the point
normals for the supplied points.</p>
<p>points: A list of hou.Point objects for which to compute point
normals.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.pointStringAttribValues">
<code class="descname">pointStringAttribValues</code><span class="sig-paren">(</span><em>self</em>, <em>name</em><span class="sig-paren">)</span> &#x2192; tuple of str<a class="headerlink" href="#hou.Geometry.pointStringAttribValues" title="Permalink to this definition"></a></dt>
<dd><p>Return a tuple of strings containing one attributes values for all
the points.</p>
<p>This method only works on string attributes. If the attribute
contains more than one element, each point will correspond to
multiple values in the result. For example, if strmap is a string
attribute of size 2 and there are 3 points with values (apple,
orange), (red, blue), and (one, two) then the result will
be (apple, orange, red, blue, one, two).</p>
<p>Calling this method is faster than looping over all the points and
calling hou.Point.attribValue.</p>
<p>If the attribute name is invalid or the attribute is not a string
attribute then this method raises hou.OperationFailed.</p>
<p>Note that you cannot pass a hou.Attrib object to this method like
you can with many methods dealing with attributes. However, you can
use hou.Attrib.name to easily get the name from an Attrib object.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.points">
<code class="descname">points</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.Point<a class="headerlink" href="#hou.Geometry.points" title="Permalink to this definition"></a></dt>
<dd><p>Return a tuple of all the points in the geometry.</p>
<p>See also the hou.Geometry.iterPoints method.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.prim">
<code class="descname">prim</code><span class="sig-paren">(</span><em>self</em>, <em>index</em><span class="sig-paren">)</span> &#x2192; hou.Prim<a class="headerlink" href="#hou.Geometry.prim" title="Permalink to this definition"></a></dt>
<dd><p>Return the primitive at the specified index.</p>
<p>This is a convenience method for accessing a particular primitive
without the overhead of obtaining all primitives via
hou.Geometry.prims.</p>
<p>Return None if no such primitive at the specified index exists.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.primAttribs">
<code class="descname">primAttribs</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.Attrib<a class="headerlink" href="#hou.Geometry.primAttribs" title="Permalink to this definition"></a></dt>
<dd><p>Return a tuple of all the primitive attributes.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.primBoundingBox">
<code class="descname">primBoundingBox</code><span class="sig-paren">(</span><em>self</em>, <em>primpattern</em><span class="sig-paren">)</span> &#x2192; hou.BoundingBox<a class="headerlink" href="#hou.Geometry.primBoundingBox" title="Permalink to this definition"></a></dt>
<dd><p>Return an axis-aligned 3D bounding box that is sized and positioned
to include the primitives specified by the primitive pattern. If the
pattern is blank, all primitives will be included.</p>
<p>Some primitives, such as spheres, extend beyond their points. This
extension will be included.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.primFloatAttribValues">
<code class="descname">primFloatAttribValues</code><span class="sig-paren">(</span><em>self</em>, <em>name</em><span class="sig-paren">)</span> &#x2192; tuple of float<a class="headerlink" href="#hou.Geometry.primFloatAttribValues" title="Permalink to this definition"></a></dt>
<dd><p>Return a tuple of floats containing one attributes values for all
the primitives.</p>
<p>This method only works on int or float attributes. If the attribute
contains more than one element, each primitive will correspond to
multiple values in the result. For example, if Cd is a float
attribute of size 3 and there are 3 primitives with values (0.1,
0.2, 0.3), (0.5, 0.5, 0.5), and (0.8, 0.7, 0.6) then the result will
be (0.1, 0.2, 0.3, 0.5, 0.5, 0.5, 0.8, 0.7, 0.6).</p>
<p>Calling this method is faster than looping over all the primitives
and calling hou.Prim.attribValue.</p>
<p>If the attribute name is invalid or the attribute is not an int or
float (e.g. its a string attribute), this method raises
hou.OperationFailed.</p>
<p>Note that you cannot pass a hou.Attrib object to this method like
you can with many methods dealing with attributes. However, you can
use hou.Attrib.name to easily get the name from an Attrib object.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.primFloatAttribValuesAsString">
<code class="descname">primFloatAttribValuesAsString</code><span class="sig-paren">(</span><em>self</em>, <em>name</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.Geometry.primFloatAttribValuesAsString" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Return a string representation of the floats of one attributes
value for all the primitives. This method is faster than
hou.Geometry.primFloatAttribValues, and you can use the array module
to convert the string into a Python sequence.</p>
<p>This method provides a faster implementation of the following:</p>
</div></blockquote>
<p>&gt; import array
&gt; def primFloatAttribValuesAsString(self, name):
&gt;     return array.array(f, self.primFloatAttribValues(name)).tostring()</p>
<blockquote>
<div>You can convert the return value from this method to an array using
the following method:</div></blockquote>
<p>&gt; import array
&gt; def primFloatAttribValuesAsArray(geometry, name):
&gt;     a = array.array(f)
&gt;     a.fromstring(geometry.primFloatAttribValuesAsString(name))
&gt;     return a</p>
<blockquote>
<div>See hou.Geometry.primFloatAttribValues for more information.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.primGroups">
<code class="descname">primGroups</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.PrimGroup<a class="headerlink" href="#hou.Geometry.primGroups" title="Permalink to this definition"></a></dt>
<dd><p>Return a tuple of all the primitive groups in the geometry.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.primIntAttribValues">
<code class="descname">primIntAttribValues</code><span class="sig-paren">(</span><em>self</em>, <em>name</em><span class="sig-paren">)</span> &#x2192; tuple of int<a class="headerlink" href="#hou.Geometry.primIntAttribValues" title="Permalink to this definition"></a></dt>
<dd><p>Return a tuple of integers containing one attributes values for all
the primitives.</p>
<p>This method only works on int or float attributes. If the attribute
contains more than one element, each primitive will correspond to
multiple values in the result. For example, if idmap is an integer
attribute of size 2 and there are 3 primitives with values (1, 2),
(2, 3), and (3,4) then the result will be (1, 2, 2, 3, 3, 4).</p>
<p>Calling this method is faster than looping over all the primitives
and calling hou.Prim.attribValue.</p>
<p>If the attribute name is invalid or the attribute is not an int or
float (e.g. its a string attribute), this method raises
hou.OperationFailed.</p>
<p>Note that you cannot pass a hou.Attrib object to this method like
you can with many methods dealing with attributes. However, you can
use hou.Attrib.name to easily get the name from an Attrib object.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.primIntAttribValuesAsString">
<code class="descname">primIntAttribValuesAsString</code><span class="sig-paren">(</span><em>self</em>, <em>name</em>, <em>int_type=hou.numericData.Int32</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Geometry.primIntAttribValuesAsString" title="Permalink to this definition"></a></dt>
<dd><p>-&gt; str</p>
<blockquote>
<div><p>Return a string representation of the integers of one attributes
value for all the primitives. This method is faster than
hou.Geometry.primFloatAttribValues, and you can use the array module
to convert the string into a Python sequence.</p>
<dl class="docutils">
<dt>int_type</dt>
<dd>A hou.numericData value to specify the integer data type (either
Int8, Int16, Int32 or Int64).</dd>
</dl>
<p>This method provides a faster implementation of the following:</p>
</div></blockquote>
<p>&gt; import array
&gt; def primIntAttribValuesAsString(self, name):
&gt;     return array.array(i, self.primIntAttribValues(name)).tostring()</p>
<blockquote>
<div>You can convert the return value from this method to an array using
the following method:</div></blockquote>
<p>&gt; import array
&gt; def primIntAttribValuesAsArray(geometry, name):
&gt;     a = array.array(i)
&gt;     a.fromstring(geometry.primIntAttribValuesAsString(name))
&gt;     return a</p>
<blockquote>
<div>See hou.Geometry.primIntAttribValues for more information.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.primLoop">
<code class="descname">primLoop</code><span class="sig-paren">(</span><em>self</em>, <em>prims</em>, <em>loop_type</em><span class="sig-paren">)</span> &#x2192; tuple of hou.Prim<a class="headerlink" href="#hou.Geometry.primLoop" title="Permalink to this definition"></a></dt>
<dd><p>Returns a tuple of hou.Prim objects that make a path connecting the
primitives provided in the prims parameter. If multiple paths are
being returned, they will be separated in the single returned tuple
by a value of None. The paths are generated using the same algorithm
used when performing loop selections in the viewport.</p>
<p>prims: A list of hou.Prim objects that define the path or paths of
connected primitives this function should return. Must contain at
least two primitives.</p>
<p>loop_type: Controls the type of path returned. Can be any of the
hou.componentLoopType values. If using either the
hou.componentLoopType.Extended or hou.componentLoopType.Closed loop
types, the inputs prims cannot contain any None entries.
Furthermore, each pair of primitives is used to define a separate
full loop, so the number of primitives must be even. If these
conditions are not met, a hou.OperationFailed exception will be
thrown.</p>
<p>Raises a hou.OperationFailed if it was unable to construct a loop
from the desired components.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.primStringAttribValues">
<code class="descname">primStringAttribValues</code><span class="sig-paren">(</span><em>self</em>, <em>name</em><span class="sig-paren">)</span> &#x2192; tuple of str<a class="headerlink" href="#hou.Geometry.primStringAttribValues" title="Permalink to this definition"></a></dt>
<dd><p>Return a tuple of strings containing one attributes values for all
the primitives.</p>
<p>This method only works on string attributes. If the attribute
contains more than one element, each primitive will correspond to
multiple values in the result. For example, if strmap is a string
attribute of size 2 and there are 3 primitives with values (apple,
orange), (red, blue), and (one, two) then the result will
be (apple, orange, red, blue, one, two).</p>
<p>Calling this method is faster than looping over all the primitives
and calling hou.Prim.attribValue.</p>
<p>If the attribute name is invalid or the attribute is not a string
attribute) then this method raises hou.OperationFailed.</p>
<p>Note that you cannot pass a hou.Attrib object to this method like
you can with many methods dealing with attributes. However, you can
use hou.Attrib.name to easily get the name from an Attrib object.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.prims">
<code class="descname">prims</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.Prim<a class="headerlink" href="#hou.Geometry.prims" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Return a tuple of all the primitives in the geometry. The primitives
returned will be subclasses of hou.Prim (e.g.polygons, volumes,
etc.).</p>
<p>See also:</p>
</div></blockquote>
<ul class="simple">
<li>hou.Geometry.iterPrims</li>
<li>hou.Face</li>
<li>hou.Polygon</li>
<li>hou.Surface</li>
<li>hou.Volume</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.renameGlobalAttrib">
<code class="descname">renameGlobalAttrib</code><span class="sig-paren">(</span><em>self</em>, <em>old_name</em>, <em>new_name</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Geometry.renameGlobalAttrib" title="Permalink to this definition"></a></dt>
<dd><p>Rename the global attribute with the specified old name to the new
name. This method is typically called from within a Python-defined
SOP when the SOPs geometry is writable.</p>
<p>Raises GeometryPermissionError if called on a read-only geometry.
Raises TypeError if old_name or new_name is None. Raises
OperationFailed if no such global attribute with the old name
exists. Raises OperationFailed if a global attribute with the new
name already exists.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.renamePointAttrib">
<code class="descname">renamePointAttrib</code><span class="sig-paren">(</span><em>self</em>, <em>old_name</em>, <em>new_name</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Geometry.renamePointAttrib" title="Permalink to this definition"></a></dt>
<dd><p>Rename the point attribute with the specified old name to the new
name. This method is typically called from within a Python-defined
SOP when the SOPs geometry is writable.</p>
<p>Raises GeometryPermissionError if called on a read-only geometry.
Raises TypeError if old_name or new_name is None. Raises
OperationFailed if no such point attribute with the old name exists.
Raises OperationFailed if a point attribute with the new name
already exists.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.renamePrimAttrib">
<code class="descname">renamePrimAttrib</code><span class="sig-paren">(</span><em>self</em>, <em>old_name</em>, <em>new_name</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Geometry.renamePrimAttrib" title="Permalink to this definition"></a></dt>
<dd><p>Rename the primitive attribute with the specified old name to the
new name. This method is typically called from within a Python-
defined SOP when the SOPs geometry is writable.</p>
<p>Raises GeometryPermissionError if called on a read-only geometry.
Raises TypeError if old_name or new_name is None. Raises
OperationFailed if no such primitive attribute with the old name
exists. Raises OperationFailed if a primitive attribute with the new
name already exists.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.renameVertexAttrib">
<code class="descname">renameVertexAttrib</code><span class="sig-paren">(</span><em>self</em>, <em>old_name</em>, <em>new_name</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Geometry.renameVertexAttrib" title="Permalink to this definition"></a></dt>
<dd><p>Rename the vertex attribute with the specified old name to the new
name. This method is typically called from within a Python-defined
SOP when the SOPs geometry is writable.</p>
<p>Raises GeometryPermissionError if called on a read-only geometry.
Raises TypeError if old_name or new_name is None. Raises
OperationFailed if no such vertex attribute with the old name
exists. Raises OperationFailed if a vertex attribute with the new
name already exists.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.saveToFile">
<code class="descname">saveToFile</code><span class="sig-paren">(</span><em>self</em>, <em>file_name</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Geometry.saveToFile" title="Permalink to this definition"></a></dt>
<dd><p>Save the contents of the geometry object to a file. The file
extension determines what file format to use.</p>
<p>All file formats supported by Houdini (e.g. geo, bgeo, obj, etc.),
including extensions listed in GEOio, are supported. If the file
extension is not recognized, the bgeo format is used.</p>
<p>Raises hou.OperationFailed if the path to the file is invalid or
there were permission or other I/O errors.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.selection">
<code class="descname">selection</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Selection<a class="headerlink" href="#hou.Geometry.selection" title="Permalink to this definition"></a></dt>
<dd><p>Returns the current cook component selection associated with this
geometry. This is the default selection set by the SOP that created
the geometry.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.setGlobalAttribValue">
<code class="descname">setGlobalAttribValue</code><span class="sig-paren">(</span><em>self</em>, <em>name_or_attrib</em>, <em>attrib_value</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Geometry.setGlobalAttribValue" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Set a global (a.k.a. detail) attribute value. The attribute may be
specified by name or by hou.Attrib object. You would typically call
this method from the code of a Python-defined SOP.</p>
<p>Raises hou.OperationFailed if no attribute exists with this name or
if the attributes data type does not match the value passed in. If
the attributes size is more than 1, the attribute value must be a
sequence of integers/floats, and the size of the sequence must match
the attributes size.</p>
<p>Raises hou.GeometryPermissionError if this geometry is not
modifiable.</p>
</div></blockquote>
<p>&gt; # This code will work from inside a Python SOP, but not from the Python
&gt; # shell.
&gt; geo = hou.pwd().geometry()
&gt; geo.addAttrib(hou.attribType.Global, author, )
&gt; geo.addAttrib(hou.attribType.Global, version, (0, 0, 0))
&gt; geo.setGlobalAttribValue(author, Joe)
&gt; geo.setGlobalAttribValue(version, (1, 0, 7))</p>
<blockquote>
<div>See also:</div></blockquote>
<ul class="simple">
<li>hou.Geometry.attribValue</li>
<li>hou.Point.setAttribValue</li>
<li>hou.Prim.setAttribValue</li>
<li>hou.Vertex.setAttribValue</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.setIntrinsicValue">
<code class="descname">setIntrinsicValue</code><span class="sig-paren">(</span><em>self</em>, <em>intrinsic_name</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Geometry.setIntrinsicValue" title="Permalink to this definition"></a></dt>
<dd><p>Some intrinsic values can be modified. For example, you change the
internal size and rotation (transform) of a sphere primitive by
passing a 16 float tuple representing the transform to
setIntrinsicValue. Raises Error if the intrinsic is not writeable or
does not accept the passed value, or if the given intrinsic name
does not exist.</p>
<dl class="docutils">
<dt>NOTE</dt>
<dd>Modifying the geometry directly will lock the geometrys parent
node.</dd>
</dl>
<p>See the intrinsicValue method for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.setPointFloatAttribValues">
<code class="descname">setPointFloatAttribValues</code><span class="sig-paren">(</span><em>self</em>, <em>name</em>, <em>values</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Geometry.setPointFloatAttribValues" title="Permalink to this definition"></a></dt>
<dd><p>For a particular attribute, set the attribute values for all points.
You would typically call this method from the code of a Python-
defined SOP.</p>
<dl class="docutils">
<dt>name</dt>
<dd>The name of the point attribute.</dd>
<dt>values</dt>
<dd>A sequence of int or float values in the same format as that
returned by hou.Geometry.pointFloatAttribValues. See that method
for more information.</dd>
</dl>
<p>Raises hou.OperationFailed if the attribute name is not valid, the
attribute is not an int or float (i.e. its a string), or the array
of values is not the correct size.</p>
<p>Raises hou.GeometryPermissionError if this geometry is not
modifiable.</p>
<p>Also see hou.Geometry.pointFloatAttribValues.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.setPointFloatAttribValuesFromString">
<code class="descname">setPointFloatAttribValuesFromString</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Geometry.setPointFloatAttribValuesFromString" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.Geometry.setPointIntAttribValues">
<code class="descname">setPointIntAttribValues</code><span class="sig-paren">(</span><em>self</em>, <em>name</em>, <em>values</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Geometry.setPointIntAttribValues" title="Permalink to this definition"></a></dt>
<dd><p>For a particular attribute, set the attribute values for all points.
You would typically call this method from the code of a Python-
defined SOP.</p>
<dl class="docutils">
<dt>name</dt>
<dd>The name of the point attribute.</dd>
<dt>values</dt>
<dd>A sequence of int or float values in the same format as that
returned by hou.Geometry.pointIntAttribValues. See that method
for more information.</dd>
</dl>
<p>Raises hou.OperationFailed if the attribute name is not valid, the
attribute is not an int or float (i.e. its a string), or the array
of values is not the correct size.</p>
<p>Raises hou.GeometryPermissionError if this geometry is not
modifiable.</p>
<p>Also see hou.Geometry.pointIntAttribValues.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.setPointIntAttribValuesFromString">
<code class="descname">setPointIntAttribValuesFromString</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Geometry.setPointIntAttribValuesFromString" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.Geometry.setPointStringAttribValues">
<code class="descname">setPointStringAttribValues</code><span class="sig-paren">(</span><em>self</em>, <em>name</em>, <em>values</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Geometry.setPointStringAttribValues" title="Permalink to this definition"></a></dt>
<dd><p>For a particular attribute, set the attribute values for all points.
You would typically call this method from the code of a Python-
defined SOP.</p>
<dl class="docutils">
<dt>name</dt>
<dd>The name of the point attribute.</dd>
<dt>values</dt>
<dd>A sequence of string values in the same format as that returned
by hou.Geometry.pointStringAttribValues. See that method for
more information.</dd>
</dl>
<p>Raises hou.OperationFailed if the attribute name is not valid, the
attribute is not a string, or the array of values is not the correct
size.</p>
<p>Raises hou.GeometryPermissionError if this geometry is not
modifiable.</p>
<p>Also see hou.Geometry.pointStringAttribValues.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.setPrimFloatAttribValues">
<code class="descname">setPrimFloatAttribValues</code><span class="sig-paren">(</span><em>self</em>, <em>name</em>, <em>values</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Geometry.setPrimFloatAttribValues" title="Permalink to this definition"></a></dt>
<dd><p>For a particular attribute, set the attribute values for all
primitives. You would typically call this method from the code of a
Python-defined SOP.</p>
<dl class="docutils">
<dt>name</dt>
<dd>The name of the primitive attribute.</dd>
<dt>values</dt>
<dd>A sequence of int or float values in the same format as that
returned by hou.Geometry.primFloatAttribValues. See that method
for more information.</dd>
</dl>
<p>Raises hou.OperationFailed if the attribute name is not valid, the
attribute is not an int or float (i.e. its a string), or the array
of values is not the correct size.</p>
<p>Raises hou.GeometryPermissionError if this geometry is not
modifiable.</p>
<p>Also see hou.Geometry.primFloatAttribValues.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.setPrimFloatAttribValuesFromString">
<code class="descname">setPrimFloatAttribValuesFromString</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Geometry.setPrimFloatAttribValuesFromString" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.Geometry.setPrimIntAttribValues">
<code class="descname">setPrimIntAttribValues</code><span class="sig-paren">(</span><em>self</em>, <em>name</em>, <em>values</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Geometry.setPrimIntAttribValues" title="Permalink to this definition"></a></dt>
<dd><p>For a particular attribute, set the attribute values for all
primitives. You would typically call this method from the code of a
Python-defined SOP.</p>
<dl class="docutils">
<dt>name</dt>
<dd>The name of the primitive attribute.</dd>
<dt>values</dt>
<dd>A sequence of int or float values in the same format as that
returned by hou.Geometry.primFloatAttribValues. See that method
for more information.</dd>
</dl>
<p>Raises hou.OperationFailed if the attribute name is not valid, the
attribute is not an int or float (i.e. its a string), or the array
of values is not the correct size.</p>
<p>Raises hou.GeometryPermissionError if this geometry is not
modifiable.</p>
<p>Also see hou.Geometry.primIntAttribValues.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.setPrimIntAttribValuesFromString">
<code class="descname">setPrimIntAttribValuesFromString</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Geometry.setPrimIntAttribValuesFromString" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.Geometry.setPrimStringAttribValues">
<code class="descname">setPrimStringAttribValues</code><span class="sig-paren">(</span><em>self</em>, <em>name</em>, <em>values</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Geometry.setPrimStringAttribValues" title="Permalink to this definition"></a></dt>
<dd><p>For a particular attribute, set the attribute values for all
primitives. You would typically call this method from the code of a
Python-defined SOP.</p>
<dl class="docutils">
<dt>name</dt>
<dd>The name of the primitive attribute.</dd>
<dt>values</dt>
<dd>A sequence of string values in the same format as that returned
by hou.Geometry.primStringAttribValues. See that method for more
information.</dd>
</dl>
<p>Raises hou.OperationFailed if the attribute name is not valid, the
attribute is not a string, or the array of values is not the correct
size.</p>
<p>Raises hou.GeometryPermissionError if this geometry is not
modifiable.</p>
<p>Also see hou.Geometry.primStringAttribValues.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.setVertexFloatAttribValues">
<code class="descname">setVertexFloatAttribValues</code><span class="sig-paren">(</span><em>self</em>, <em>name</em>, <em>values</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Geometry.setVertexFloatAttribValues" title="Permalink to this definition"></a></dt>
<dd><p>For a particular attribute, set the attribute values for all
vertices. You would typically call this method from the code of a
Python-defined SOP.</p>
<dl class="docutils">
<dt>name</dt>
<dd>The name of the vertex attribute.</dd>
<dt>values</dt>
<dd>A sequence of int or float values in the same format as that
returned by hou.Geometry.vertexFloatAttribValues. See that
method for more information.</dd>
</dl>
<p>Raises hou.OperationFailed if the attribute name is not valid, the
attribute is not an int or float (i.e. its a string), or the array
of values is not the correct size.</p>
<p>Raises hou.GeometryPermissionError if this geometry is not
modifiable.</p>
<p>Also see hou.Geometry.vertexFloatAttribValues.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.setVertexFloatAttribValuesFromString">
<code class="descname">setVertexFloatAttribValuesFromString</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Geometry.setVertexFloatAttribValuesFromString" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.Geometry.setVertexIntAttribValues">
<code class="descname">setVertexIntAttribValues</code><span class="sig-paren">(</span><em>self</em>, <em>name</em>, <em>values</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Geometry.setVertexIntAttribValues" title="Permalink to this definition"></a></dt>
<dd><p>For a particular attribute, set the attribute values for all
vertices. You would typically call this method from the code of a
Python-defined SOP.</p>
<dl class="docutils">
<dt>name</dt>
<dd>The name of the vertex attribute.</dd>
<dt>values</dt>
<dd>A sequence of int or float values in the same format as that
returned by hou.Geometry.vertexIntAttribValues. See that method
for more information.</dd>
</dl>
<p>Raises hou.OperationFailed if the attribute name is not valid, the
attribute is not an int or float (i.e. its a string), or the array
of values is not the correct size.</p>
<p>Raises hou.GeometryPermissionError if this geometry is not
modifiable.</p>
<p>Also see hou.Geometry.vertexIntAttribValues.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.setVertexIntAttribValuesFromString">
<code class="descname">setVertexIntAttribValuesFromString</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Geometry.setVertexIntAttribValuesFromString" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.Geometry.setVertexStringAttribValues">
<code class="descname">setVertexStringAttribValues</code><span class="sig-paren">(</span><em>self</em>, <em>name</em>, <em>values</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Geometry.setVertexStringAttribValues" title="Permalink to this definition"></a></dt>
<dd><p>For a particular attribute, set the attribute values for all
vertices. You would typically call this method from the code of a
Python-defined SOP.</p>
<dl class="docutils">
<dt>name</dt>
<dd>The name of the vertex attribute.</dd>
<dt>values</dt>
<dd>A sequence of string values in the same format as that returned
by hou.Geometry.vertexStringAttribValues. See that method for
more information.</dd>
</dl>
<p>Raises hou.OperationFailed if the attribute name is not valid, the
attribute is not a string, or the array of values is not the correct
size.</p>
<p>Raises hou.GeometryPermissionError if this geometry is not
modifiable.</p>
<p>Also see hou.Geometry.vertexStringAttribValues.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.sopNode">
<code class="descname">sopNode</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.SopNode<a class="headerlink" href="#hou.Geometry.sopNode" title="Permalink to this definition"></a></dt>
<dd><p>If the Geometry is not frozen, return the hou.SopNode object
corresponding to this Geometry. Otherwise, return None.</p>
<p>See hou.Geometry.freeze for more information on frozen geometry.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.sopNodeOutputIndex">
<code class="descname">sopNodeOutputIndex</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.Geometry.sopNodeOutputIndex" title="Permalink to this definition"></a></dt>
<dd><p>If the Geometry is not frozen, return the index of the SOP node
output that this geometry corresponds to. Otherwise, return -1.</p>
<p>For most cases this method will return 0 to indicate that the
geometry corresponds to the first output. This method will only
return a value other than 0 for SOP nodes that have multiple
outputs.</p>
<p>See hou.Geometry.freeze for more information on frozen geometry.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.stringAttribValue">
<code class="descname">stringAttribValue</code><span class="sig-paren">(</span><em>self</em>, <em>name_or_attrib</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.Geometry.stringAttribValue" title="Permalink to this definition"></a></dt>
<dd><p>Return the global (a.k.a. detail) attribute value for a particular
string attribute. The attribute may be specified by name or by
hou.Attrib object. See hou.Geometry.floatAttribValue for more
information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.stringListAttribValue">
<code class="descname">stringListAttribValue</code><span class="sig-paren">(</span><em>self</em>, <em>name_or_attrib</em><span class="sig-paren">)</span> &#x2192; tuple of int<a class="headerlink" href="#hou.Geometry.stringListAttribValue" title="Permalink to this definition"></a></dt>
<dd><p>Return the global (a.k.a. detail) attribute value for a particular
string attribute. The attribute may be specified by name or by
hou.Attrib object. The return value is a list of strings. See
hou.Geometry.floatListAttribValue for more information.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.Geometry.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.Geometry.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.transform">
<code class="descname">transform</code><span class="sig-paren">(</span><em>self</em>, <em>matrix</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Geometry.transform" title="Permalink to this definition"></a></dt>
<dd><p>Transforms (e.g. rotates, scales, translates, etc.) the geometry by
a transformation matrix. You would typically call this method from
the code of a Python-defined SOP.</p>
<p>See hou.hmath for functions that build transformation matrices.</p>
<p>Raises hou.GeometryPermissionError if this geometry is not
modifiable.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.transformPrims">
<code class="descname">transformPrims</code><span class="sig-paren">(</span><em>self</em>, <em>prims</em>, <em>matrix</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Geometry.transformPrims" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Transforms a set of primitives (e.g. rotates, scales, translates,
etc.) by a transformation matrix. You would typically call this
method from the code of a Python-defined SOP.</div></blockquote>
<p>&gt; import math
&gt; 
&gt; # This code will work from inside a Python SOP, but not from the Python
&gt; # shell.
&gt; 
&gt; def createCircle(geo, num_vertices=10):
&gt;     # Create a closed curve with the specified number of vertices.
&gt;     curve = geo.createNURBSCurve(num_vertices)
&gt;     curve.setIsClosed(True)
&gt; 
&gt;     # Arrange the points into a unit circle on the XZ plane,
&gt;     # centered about the origin.
&gt;     for i, vertex in enumerate(curve.vertices()):
&gt;         angle = i * (2.0 * math.pi) / num_vertices
&gt;         position = (math.cos(angle), 0, math.sin(angle))
&gt;         vertex.point().setPosition(position)
&gt;     return curve
&gt; 
&gt; # Create a bunch of circles on the XZ plane, tilt them slightly
&gt; # about X, translate them away from the origin, and rotate each
&gt; # one about the y axis by a different amount.
&gt; geo = hou.pwd().geometry()
&gt; num_copies = 20
&gt; for i in range(num_copies):
&gt;     curve = createCircle(geo)
&gt;     geo.transformPrims([curve],
&gt;         hou.hmath.buildRotateAboutAxis((1, 0, 0), 30) *
&gt;         hou.hmath.buildTranslate((2, 0, 0)) *
&gt;         hou.hmath.buildRotateAboutAxis((0, 1, 0), i * 360.0 / num_copies))</p>
<blockquote>
<div><p>See hou.hmath functions that build transformation matrices.</p>
<p>Raises hou.GeometryPermissionError if this geometry is not
modifiable.</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.vertexAttribs">
<code class="descname">vertexAttribs</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.Attrib<a class="headerlink" href="#hou.Geometry.vertexAttribs" title="Permalink to this definition"></a></dt>
<dd><p>Return a tuple of all the vertex attributes.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.vertexFloatAttribValues">
<code class="descname">vertexFloatAttribValues</code><span class="sig-paren">(</span><em>self</em>, <em>name</em><span class="sig-paren">)</span> &#x2192; tuple of float<a class="headerlink" href="#hou.Geometry.vertexFloatAttribValues" title="Permalink to this definition"></a></dt>
<dd><p>Return a tuple of floats containing one attributes values for all
the vertices.</p>
<p>This method only works on int or float attributes. If the attribute
contains more than one element, each vertex will correspond to
multiple values in the result. For example, if attrib is a float
attribute of size 3 and there are 3 vertices with values (0.1, 0.2,
0.3), (0.5, 0.5, 0.5), and (0.8, 0.7, 0.6) then the result will be
(0.1, 0.2, 0.3, 0.5, 0.5, 0.5, 0.8, 0.7, 0.6).</p>
<p>Calling this method is faster than looping over all the vertices and
calling hou.Vertex.attribValue.</p>
<p>If the attribute name is invalid or the attribute is not an int or
float (e.g. its a string attribute), this method raises
hou.OperationFailed.</p>
<p>Note that you cannot pass a hou.Attrib object to this method like
you can with many methods dealing with attributes. However, you can
use hou.Attrib.name to easily get the name from an Attrib object.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.vertexFloatAttribValuesAsString">
<code class="descname">vertexFloatAttribValuesAsString</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Geometry.vertexFloatAttribValuesAsString" title="Permalink to this definition"></a></dt>
<dd><p>vertexFloatAttribValuesAsString(self, name,
float_type=hou.numericData.Float32) -&gt; str</p>
<blockquote>
<div><blockquote>
<div><p>Return a string representation of the floats of one attributes
value for all the vertices. This method is faster than
hou.Geometry.vertexFloatAttribValues, and you can use the array
module to convert the string into a Python sequence.</p>
<dl class="docutils">
<dt>float_type</dt>
<dd>A hou.numericData value to specify the float data type (either
Float16, Float32 or Float64).</dd>
</dl>
<p>This method provides a faster implementation of the following:</p>
</div></blockquote>
<p>&gt; import array
&gt; def vertexFloatAttribValuesAsString(self, name):
&gt;     return array.array(f, self.vertexFloatAttribValues(name)).tostring()</p>
<blockquote>
<div>You can convert the return value from this method to an array using
the following method:</div></blockquote>
<p>&gt; import array
&gt; def vertexFloatAttribValuesAsArray(geometry, name):
&gt;     a = array.array(f)
&gt;     a.fromstring(geometry.vertexFloatAttribValuesAsString(name))
&gt;     return a</p>
<blockquote>
<div>See hou.Geometry.vertexFloatAttribValues for more information.</div></blockquote>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.vertexIntAttribValues">
<code class="descname">vertexIntAttribValues</code><span class="sig-paren">(</span><em>self</em>, <em>name</em><span class="sig-paren">)</span> &#x2192; tuple of int<a class="headerlink" href="#hou.Geometry.vertexIntAttribValues" title="Permalink to this definition"></a></dt>
<dd><p>Return a tuple of integers containing one attributes values for all
the vertices.</p>
<p>This method only works on int or float attributes. If the attribute
contains more than one element, each vertex will correspond to
multiple values in the result. For example, if idmap is an integer
attribute of size 2 and there are 3 vertices with values (1, 2), (2,
3), and (3, 4) then the result will be (1, 2, 2, 3, 3, 4).</p>
<p>Calling this method is faster than looping over all the vertices and
calling hou.Vertex.attribValue.</p>
<p>If the attribute name is invalid or the attribute is not an int or
float (e.g. its a string attribute), this method raises
hou.OperationFailed.</p>
<p>Note that you cannot pass a hou.Attrib object to this method like
you can with many methods dealing with attributes. However, you can
use hou.Attrib.name to easily get the name from an Attrib object.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.vertexIntAttribValuesAsString">
<code class="descname">vertexIntAttribValuesAsString</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Geometry.vertexIntAttribValuesAsString" title="Permalink to this definition"></a></dt>
<dd><p>vertexIntAttribValuesAsString(self, name,
int_type=hou.numericData.Int32) -&gt; str</p>
<blockquote>
<div><blockquote>
<div><p>Return a string representation of the integers of one attributes
value for all the vertices. This method is faster than
hou.Geometry.vertexIntAttribValues, and you can use the array module
to convert the string into a Python sequence.</p>
<dl class="docutils">
<dt>int_type</dt>
<dd>A hou.numericData value to specify the integer data type (either
Int8, Int16, Int32 or Int64).</dd>
</dl>
<p>This method provides a faster implementation of the following:</p>
</div></blockquote>
<p>&gt; import array
&gt; def vertexIntAttribValuesAsString(self, name):
&gt;     return array.array(i, self.vertexIntAttribValues(name)).tostring()</p>
<blockquote>
<div>You can convert the return value from this method to an array using
the following method:</div></blockquote>
<p>&gt; import array
&gt; def vertexIntAttribValuesAsArray(geometry, name):
&gt;     a = array.array(i)
&gt;     a.fromstring(geometry.vertexIntAttribValuesAsString(name))
&gt;     return a</p>
<blockquote>
<div>See hou.Geometry.vertexIntAttribValues for more information.</div></blockquote>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.Geometry.vertexStringAttribValues">
<code class="descname">vertexStringAttribValues</code><span class="sig-paren">(</span><em>self</em>, <em>name</em><span class="sig-paren">)</span> &#x2192; tuple of str<a class="headerlink" href="#hou.Geometry.vertexStringAttribValues" title="Permalink to this definition"></a></dt>
<dd><p>Return a tuple of strings containing one attributes values for all
the vertices.</p>
<p>This method only works on string attributes. If the attribute
contains more than one element, each vertex will correspond to
multiple values in the result. For example, if strmap is a string
attribute of size 2 and there are 3 vertices with values (apple,
orange), (red, blue), and (one, two) then the result will
be (apple, orange, red, blue, one, two).</p>
<p>Calling this method is faster than looping over all the vertices and
calling hou.Vertex.attribValue.</p>
<p>If the attribute name is invalid or the attribute is not a string
attribute then this method raises hou.OperationFailed.</p>
<p>Note that you cannot pass a hou.Attrib object to this method like
you can with many methods dealing with attributes. However, you can
use hou.Attrib.name to easily get the name from an Attrib object.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.GeometryDelta">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">GeometryDelta</code><a class="headerlink" href="#hou.GeometryDelta" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Geometry delta provides access to the geometry differences (deltas)
stored by some Geometry nodes such as the edit SOP.</p>
<p>If you ask a SOP for its geometry delta via hou.SopNode.geometryDelta,
youll get a reference to it. If the SOP recooks, the corresponding
geometry delta objects will update to the SOPs new geometry delta
object. If the SOP is deleted, accessing the geometry delta object will
raise a hou.ObjectWasDeleted exception.</p>
<dl class="method">
<dt id="hou.GeometryDelta.setPointPositionsFromString">
<code class="descname">setPointPositionsFromString</code><span class="sig-paren">(</span><em>self</em>, <em>positions</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryDelta.setPointPositionsFromString" title="Permalink to this definition"></a></dt>
<dd><p>Stores the differences between the provided positions and this SOP
nodes input geometry into this nodes geometry delta object. This
can be used, for example, to preload an edit SOPs delta so its
output geometry matches a desired shape without changing the input
geometry.</p>
<p>The positions parameter should be a binary representation of the
positions. For example, the result of calling
hou.Geometry.pointFloatAttribValuesAsString.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.GeometryDelta.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.GeometryDelta.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.GeometryPermissionError">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">GeometryPermissionError</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryPermissionError" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.Error" title="hou.Error"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.Error</span></code></a></p>
<p>Exception that is raised when you try to modify geometry from outside of
a Python SOP.</p>
<dl class="method">
<dt id="hou.GeometryPermissionError.description">
<code class="descname">description</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.GeometryPermissionError.description" title="Permalink to this definition"></a></dt>
<dd><p>Return a description of the class of exception. The description is
not related to the exception instance.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryPermissionError.exceptionTypeName">
<code class="descname">exceptionTypeName</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.GeometryPermissionError.exceptionTypeName" title="Permalink to this definition"></a></dt>
<dd><p>Return the name of the exception type. Instances of different
subclasses of hou.Error will return different names. Instances of
the base class will return Error.</p>
<p>You can also use str(e.__class__) to get the name of the subclass.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.GeometryPermissionError.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.GeometryPermissionError.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.GeometrySelection">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">GeometrySelection</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometrySelection" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Represents a component selection performed by the user in a viewport.</p>
<p>Calling hou.SceneViewer.selectGeometry waits for the user to perform a
selection in the viewport, and returns an object of this type
representing the elected components. The returned selection can be
manipulated by converting it to a specific component type, grown, or
shrunk. Then the selection can be converted to a string that can be used
in a SOP node group parameter.</p>
<p>If the selection contains components from more than one SOP, you can use
the hou.GeometrySelection.mergedNode function to create a Merge SOP
and/or Object Merge SOPs that brings all the referenced geometry into a
single node.</p>
<dl class="method">
<dt id="hou.GeometrySelection.connectivity">
<code class="descname">connectivity</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.connectivityType enum value<a class="headerlink" href="#hou.GeometrySelection.connectivity" title="Permalink to this definition"></a></dt>
<dd><p>Returns the hou.connectivityType that has been set on this geometry
selection. Unlesss you call hou.GeometrySelection.setConnectivity,
this function will return the no connectivity value.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometrySelection.geometryType">
<code class="descname">geometryType</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.geometryType enum value<a class="headerlink" href="#hou.GeometrySelection.geometryType" title="Permalink to this definition"></a></dt>
<dd><p>Returns the type of component that was selected.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometrySelection.growSelection">
<code class="descname">growSelection</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometrySelection.growSelection" title="Permalink to this definition"></a></dt>
<dd><p>Expands the selection by adding all components that are connected to
components currently in the selection.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometrySelection.mergedNode">
<code class="descname">mergedNode</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometrySelection.mergedNode" title="Permalink to this definition"></a></dt>
<dd><p>mergedNode(self, parent, creator_name,
force_keep_original_objects=False, display_original_objects=False) -&gt;
Node</p>
<blockquote>
<div>Creates a Merge SOP that combines all the SOPs referenced by the
selection. Most selections will only reference a single SOP in which
case no Merge SOP is required, and the selected SOP will be
returned.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.GeometrySelection.mergedSelectionString">
<code class="descname">mergedSelectionString</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometrySelection.mergedSelectionString" title="Permalink to this definition"></a></dt>
<dd><p>mergedSelectionString(self, empty_string_selects_all=True,
force_numeric=False) -&gt; string</p>
<blockquote>
<div>Returns a single string that can be used in group parameters of the
merged node returned by hou.GeometrySelection.mergedNode. If all
components are selected from a single node this is equivalent to the
first string in the tuple returned by
hou.GeometrySelection.selectionStrings.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.GeometrySelection.needsMergedNode">
<code class="descname">needsMergedNode</code><span class="sig-paren">(</span><em>self</em>, <em>parent</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometrySelection.needsMergedNode" title="Permalink to this definition"></a></dt>
<dd><p>Returns true if a Merge SOP needs to be created in order to access
all components in the selection.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometrySelection.nodes">
<code class="descname">nodes</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of Nodes<a class="headerlink" href="#hou.GeometrySelection.nodes" title="Permalink to this definition"></a></dt>
<dd><p>Returns a tuple of all nodes referenced by the selection.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometrySelection.ordered">
<code class="descname">ordered</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometrySelection.ordered" title="Permalink to this definition"></a></dt>
<dd><p>Returns true if this is an ordered selection. This means that the
order in which the user selected the components is preserved. To
have an ordered selection, the ordered parameter needs to have been
set to True when calling hou.SceneViewer.geometrySelection.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometrySelection.primitiveTypes">
<code class="descname">primitiveTypes</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.primitiveType enum values<a class="headerlink" href="#hou.GeometrySelection.primitiveTypes" title="Permalink to this definition"></a></dt>
<dd><p>Returns a tuple containing all primitive types that are contained in
the selection.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometrySelection.selectionStrings">
<code class="descname">selectionStrings</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometrySelection.selectionStrings" title="Permalink to this definition"></a></dt>
<dd><p>selectionStrings(self, empty_string_selects_all=True, bool
force_numeric=False) -&gt; tuple of strings</p>
<blockquote>
<div>Returns a tuple of strings that can be used to refer to the selected
components in each SOP node referenced by the selection.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.GeometrySelection.selections">
<code class="descname">selections</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of [Hom:hou.Selection]<a class="headerlink" href="#hou.GeometrySelection.selections" title="Permalink to this definition"></a></dt>
<dd><p>Returns a tuple of component selection objects. These correspond to
the nodes returned by the nodes function.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometrySelection.setConnectivity">
<code class="descname">setConnectivity</code><span class="sig-paren">(</span><em>self</em>, <em>connectivity</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometrySelection.setConnectivity" title="Permalink to this definition"></a></dt>
<dd><p>Sets the type of connectivity to enforce when modifying the
selection. The current selection is also expanded so that all
connected components (using the supplied style of connectivity)
become part of the selection.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometrySelection.setGeometryType">
<code class="descname">setGeometryType</code><span class="sig-paren">(</span><em>self</em>, <em>type</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometrySelection.setGeometryType" title="Permalink to this definition"></a></dt>
<dd><p>Changes the type of component contained in the selection, converting
the existing selection to the new component type.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometrySelection.setPrimitiveTypes">
<code class="descname">setPrimitiveTypes</code><span class="sig-paren">(</span><em>self</em>, <em>primitive_types</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometrySelection.setPrimitiveTypes" title="Permalink to this definition"></a></dt>
<dd><p>Sets the tuple of primitive types allowed in the selection. Any
primtives that are not of an allowed type are removed from the
selection. Only has an effect if this is a primitive selection.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometrySelection.shrinkSelection">
<code class="descname">shrinkSelection</code><span class="sig-paren">(</span><em>checkuv = true</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometrySelection.shrinkSelection" title="Permalink to this definition"></a></dt>
<dd><p>Removes components that are on the boundary of the selection.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.GeometrySelection.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.GeometrySelection.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.GeometryViewport">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">GeometryViewport</code><a class="headerlink" href="#hou.GeometryViewport" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>REPLACES</p>
<blockquote>
<div><ul class="simple">
<li>viewcamera</li>
<li>viewhome</li>
<li>viewwrite</li>
</ul>
</div></blockquote>
<dl class="method">
<dt id="hou.GeometryViewport.addEventCallback">
<code class="descname">addEventCallback</code><span class="sig-paren">(</span><em>self</em>, <em>callback</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewport.addEventCallback" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><blockquote>
<div><p>Register a Python callback to be called whenever a viewport event
occurs. The event types are defined in hou.geometryViewportEvent.</p>
<p>callback:</p>
<p>Any callable Python object that expects keyworded arguments specific
to an event type. This callback can be used for any geometry
viewport event type.</p>
<p>Arguments for hou.geometryViewportEvent.CameraSwitched:</p>
</div></blockquote>
<ul class="simple">
<li>event_type: This viewport event.</li>
<li>desktop: The desktop object holding the scene viewer.</li>
<li>viewer: The scene viewer object holding the viewport.</li>
<li>viewport: The viewport object that triggered the event.</li>
</ul>
<p>&gt; import hou
&gt; 
&gt; def myViewportCB(<a href="#id11"><span class="problematic" id="id12">**</span></a>kwargs):
&gt;         event_type=kwargs[event_type]
&gt;         desktop=kwargs[desktop]
&gt;         viewer=kwargs[viewer]
&gt;         viewport=kwargs[viewport]
&gt; 
&gt;         print </p>
</div></blockquote>
<dl class="docutils">
<dt>myViewportCB=,myViewportCB</dt>
<dd>&gt;         print event type=,event_type
&gt;         print desktop=,desktop
&gt;         print viewer=,viewer
&gt;         print viewport=,viewport
&gt; 
&gt;         cam = viewport.camera()
&gt;         print camera=%s</dd>
<dt>%(cam.name())</dt>
<dd>&gt; 
&gt; curSceneViewer = [item for item in hou.ui.curDesktop().currentPaneTabs() if item.type() == hou.paneTabType.SceneViewer][0]
&gt; curSceneViewer.curViewport().addEventCallback(myViewportCB)</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewport.camera">
<code class="descname">camera</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewport.camera" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.GeometryViewport.changeName">
<code class="descname">changeName</code><span class="sig-paren">(</span><em>self</em>, <em>str</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewport.changeName" title="Permalink to this definition"></a></dt>
<dd><p>Set the name of the viewport.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewport.changeType">
<code class="descname">changeType</code><span class="sig-paren">(</span><em>self</em><span class="optional">[</span>, <em>Hom:hou.geometryViewportType</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewport.changeType" title="Permalink to this definition"></a></dt>
<dd><p>Set the viewport type (hou.geometryViewportType). This method first
attempts to restore a stashed view for the new viewport type, but
failing that, will home the viewport.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewport.clearEventCallbacks">
<code class="descname">clearEventCallbacks</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewport.clearEventCallbacks" title="Permalink to this definition"></a></dt>
<dd><p>Remove all Python callbacks that have been registered with
hou.GeometryViewport.addEventCallback.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewport.defaultCamera">
<code class="descname">defaultCamera</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.GeometryViewportCamera<a class="headerlink" href="#hou.GeometryViewport.defaultCamera" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Returns an object representing the viewports viewpoint. The
returned object is live in that changing its settings will
immediately change the view</p>
<p>If a camera/ight is locked to the view, changing the settings of the
GeometryViewportCamera will change the camera/light nodes
parameters as well.</p>
<p>Instead of a live object, you can get a disconnected version of
the viewpoint using hou.GeometryViewportCamera.stash. This is a
useful way to remember a certain viewpoint in code for later. You
can restore a stashed camera using setDefaultCamera().</p>
</div></blockquote>
<p>&gt; # Remember the current view
&gt; cam = viewport.defaultCamera()
&gt; saved = cam.stash()
&gt; 
&gt; # Change the view somehow
&gt; 
&gt; # Restore the original view
&gt; viewport.setDefaultCamera(saved)</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewport.draw">
<code class="descname">draw</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewport.draw" title="Permalink to this definition"></a></dt>
<dd><p>Request that the viewport redraw. Multiple draw() calls within the
same script will be merged into a single call.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewport.eventCallbacks">
<code class="descname">eventCallbacks</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of callbacks<a class="headerlink" href="#hou.GeometryViewport.eventCallbacks" title="Permalink to this definition"></a></dt>
<dd><p>Return a tuple of all the Python callbacks that have been registered
with hou.GeometryViewport.addEventCallback.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewport.frameAll">
<code class="descname">frameAll</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewport.frameAll" title="Permalink to this definition"></a></dt>
<dd><p>Moves the view to show all geometry/objects. See also
frameNonTemplates().</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewport.frameBoundingBox">
<code class="descname">frameBoundingBox</code><span class="sig-paren">(</span><em>self</em>, <em>bbox</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewport.frameBoundingBox" title="Permalink to this definition"></a></dt>
<dd><p>Moves the view to show an arbitrary area in the scene.</p>
<dl class="docutils">
<dt>bbox</dt>
<dd>A hou.BoundingBox representing the volume of space to focus on.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewport.frameGrid">
<code class="descname">frameGrid</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewport.frameGrid" title="Permalink to this definition"></a></dt>
<dd><p>Frames the view on the grid.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewport.frameNonTemplated">
<code class="descname">frameNonTemplated</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewport.frameNonTemplated" title="Permalink to this definition"></a></dt>
<dd><p>Moves the view to show all _non-<a href="#id55"><span class="problematic" id="id56">templated_</span></a> geometry.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewport.frameSelected">
<code class="descname">frameSelected</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewport.frameSelected" title="Permalink to this definition"></a></dt>
<dd><p>Moves the view to show the selected geometry/objects.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewport.home">
<code class="descname">home</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewport.home" title="Permalink to this definition"></a></dt>
<dd><p>Moves/tumbles the viewport to the default view.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewport.homeAll">
<code class="descname">homeAll</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewport.homeAll" title="Permalink to this definition"></a></dt>
<dd><p>Moves/tumbles the view to show all geometry/objects (including
templated geometry). See also homeNonTemplated().</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewport.homeGrid">
<code class="descname">homeGrid</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewport.homeGrid" title="Permalink to this definition"></a></dt>
<dd><p>Homes the viewport on the grid.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewport.homeNonTemplated">
<code class="descname">homeNonTemplated</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewport.homeNonTemplated" title="Permalink to this definition"></a></dt>
<dd><p>Moves/tumbles the view to show all _non-<a href="#id57"><span class="problematic" id="id58">templated_</span></a> geometry.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewport.homeSelected">
<code class="descname">homeSelected</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewport.homeSelected" title="Permalink to this definition"></a></dt>
<dd><p>Moves/tumbles the view to show the selected geometry/objects.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewport.isCameraLockedToView">
<code class="descname">isCameraLockedToView</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewport.isCameraLockedToView" title="Permalink to this definition"></a></dt>
<dd><p>Query to see if the camera is locked to the view. This returns the
state of the camera lock only; this can be enabled without viewing
through a camera.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewport.lockCameraToView">
<code class="descname">lockCameraToView</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewport.lockCameraToView" title="Permalink to this definition"></a></dt>
<dd><p>Set the viewport camera lock. When True, any changes to the view
will affect the camera object being viewed though. When False, the
camera will become disconnected from the viewport and revert to the
default viewport camera when the user tumbles the view. It is
possible to enable this without the viewport looking through a
camera, though view changes will not affect any objects until the
user sets the viewport to look through a camera or light.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewport.mapFromMouseChop">
<code class="descname">mapFromMouseChop</code><span class="sig-paren">(</span><em>self</em>, <em>x</em>, <em>y) -&gt; tuple of (int</em>, <em>int</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewport.mapFromMouseChop" title="Permalink to this definition"></a></dt>
<dd><p>Convert from the Mouse CHOPs X and Y screen values (which range
from -1 to 1) to viewport coordinates, where (0,0) is the bottom
left corner of the viewport.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewport.mapToScreen">
<code class="descname">mapToScreen</code><span class="sig-paren">(</span><em>self</em>, <em>position</em><span class="sig-paren">)</span> &#x2192; hou.Vector2<a class="headerlink" href="#hou.GeometryViewport.mapToScreen" title="Permalink to this definition"></a></dt>
<dd><p>Convert world coordinates to viewport coordinates.</p>
<dl class="docutils">
<dt>position</dt>
<dd>A hou.Vector3 containing a world space position.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewport.mapToWorld">
<code class="descname">mapToWorld</code><span class="sig-paren">(</span><em>self</em>, <em>x</em>, <em>y) -&gt; tuple of (hou.Vector3</em>, <em>hou.Vector3</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewport.mapToWorld" title="Permalink to this definition"></a></dt>
<dd><p>Convert viewport coordinates to world coordinates. Returns a ray
(direction vector and an origin point).</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewport.name">
<code class="descname">name</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.GeometryViewport.name" title="Permalink to this definition"></a></dt>
<dd><p>Query of the name of the viewport (persp1, top1, etc).</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewport.queryInspectedGeometry">
<code class="descname">queryInspectedGeometry</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Geometry or None<a class="headerlink" href="#hou.GeometryViewport.queryInspectedGeometry" title="Permalink to this definition"></a></dt>
<dd><p>Return the geometry currently being inspected in the viewport, or
None when nothing is being inspected or when called outside of an
inspect script.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewport.queryInspectedPrim">
<code class="descname">queryInspectedPrim</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Prim or None<a class="headerlink" href="#hou.GeometryViewport.queryInspectedPrim" title="Permalink to this definition"></a></dt>
<dd><p>Return the primitive currently being inspected in the viewport, or
None when nothing is being inspected or when called outside of an
inspect script. The primitive returned will be a subclass of
hou.Prim.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewport.queryNodeAtPixel">
<code class="descname">queryNodeAtPixel</code><span class="sig-paren">(</span><em>self</em>, <em>x</em>, <em>y</em><span class="sig-paren">)</span> &#x2192; hou.ObjNode, hou.SopNode, or None<a class="headerlink" href="#hou.GeometryViewport.queryNodeAtPixel" title="Permalink to this definition"></a></dt>
<dd><p>Return the node draw at the specified pixel in the viewport, or None
if there is nothing there. The type of node returned depends on the
level of the viewer.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewport.queryPrimAtPixel">
<code class="descname">queryPrimAtPixel</code><span class="sig-paren">(</span><em>self</em>, <em>node</em>, <em>x</em>, <em>y</em><span class="sig-paren">)</span> &#x2192; hou.Prim or None<a class="headerlink" href="#hou.GeometryViewport.queryPrimAtPixel" title="Permalink to this definition"></a></dt>
<dd><p>Return the primitive drawn at the specified pixel in the viewport,
or None if there is nothing there. The primitive returned will be a
subclass of hou.Prim.</p>
<p>The parameter node is used to restrict the query to geometry within
a particular node. If node is None, then the query is unrestricted.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewport.removeEventCallback">
<code class="descname">removeEventCallback</code><span class="sig-paren">(</span><em>self</em>, <em>callback</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewport.removeEventCallback" title="Permalink to this definition"></a></dt>
<dd><p>Remove a specific Python callback that have been registered with
hou.GeometryViewport.addEventCallback.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewport.resolutionInPixels">
<code class="descname">resolutionInPixels</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; 2-tuple of int<a class="headerlink" href="#hou.GeometryViewport.resolutionInPixels" title="Permalink to this definition"></a></dt>
<dd><p>Returns the resolution of the viewport in pixels, as (width,
height).</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewport.saveViewToCamera">
<code class="descname">saveViewToCamera</code><span class="sig-paren">(</span><em>self</em>, <em>camera_node</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewport.saveViewToCamera" title="Permalink to this definition"></a></dt>
<dd><p>Copies the viewpoint transform of the current view onto the
transformation parameters of a camera or light node.</p>
<dl class="docutils">
<dt>camera_node</dt>
<dd>A hou.ObjNode object representing the node to save the view to.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewport.setCamera">
<code class="descname">setCamera</code><span class="sig-paren">(</span><em>self</em>, <em>camera_node</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewport.setCamera" title="Permalink to this definition"></a></dt>
<dd><p>Copies the viewport transfrom from the transformation parameters of
a camera or light onto the current view. This is the same as
choosing a camera/light from the Look throuogh submenu in the
viewports Camera menu.</p>
<dl class="docutils">
<dt>camera_node</dt>
<dd>A hou.ObjNode object representing the node to save the view
from.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewport.setDefaultCamera">
<code class="descname">setDefaultCamera</code><span class="sig-paren">(</span><em>self</em>, <em>stashed_cam</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewport.setDefaultCamera" title="Permalink to this definition"></a></dt>
<dd><p>Takes a hou.GeometryViewportCamera and copies its values into this
viewport.</p>
<p>Set the current camera settings of the viewport to the settings
stored in cam_setting. If the viewport is looking through a camera
and the view is not locked to the camera, it will be switched to No
camera. If the view is locked to the camera, the camera object will
be updated instead.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewport.settings">
<code class="descname">settings</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.GeometryViewportSettings<a class="headerlink" href="#hou.GeometryViewport.settings" title="Permalink to this definition"></a></dt>
<dd><p>Set the name of the viewport. Setting the name does not affect its
type, so naming a perspective view front will be confusing. This is
best used in conjunction with changeType().</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.GeometryViewport.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.GeometryViewport.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewport.type">
<code class="descname">type</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.geometryViewportType enum value<a class="headerlink" href="#hou.GeometryViewport.type" title="Permalink to this definition"></a></dt>
<dd><p>Query the viewport type (UV, 3D, top, left, etc).</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewport.useDefaultCamera">
<code class="descname">useDefaultCamera</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewport.useDefaultCamera" title="Permalink to this definition"></a></dt>
<dd><p>Set the viewport camera to No camera and stop looking through a
camera object (or light).</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewport.viewPivot">
<code class="descname">viewPivot</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Vector3<a class="headerlink" href="#hou.GeometryViewport.viewPivot" title="Permalink to this definition"></a></dt>
<dd><p>Returns a hou.Vector3 representing the view pivot as a point in
world space.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewport.viewTransform">
<code class="descname">viewTransform</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Matrix4<a class="headerlink" href="#hou.GeometryViewport.viewTransform" title="Permalink to this definition"></a></dt>
<dd><p>Returns the transform matrix of the view. To set the viewpoint
programmatically, use defaultCamera() to get a hou.ViewportCamera
object and manipulate that.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.GeometryViewportBackground">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">GeometryViewportBackground</code><a class="headerlink" href="#hou.GeometryViewportBackground" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="method">
<dt id="hou.GeometryViewportBackground.autoPlace">
<code class="descname">autoPlace</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportBackground.autoPlace" title="Permalink to this definition"></a></dt>
<dd><p>Query if the background image is automatically fit to the viewport.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportBackground.brightness">
<code class="descname">brightness</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#hou.GeometryViewportBackground.brightness" title="Permalink to this definition"></a></dt>
<dd><p>Query the intensity multiplier of the background iamge.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportBackground.imageCOP">
<code class="descname">imageCOP</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.GeometryViewportBackground.imageCOP" title="Permalink to this definition"></a></dt>
<dd><p>Query the operation path of the background image.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportBackground.imageFile">
<code class="descname">imageFile</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.GeometryViewportBackground.imageFile" title="Permalink to this definition"></a></dt>
<dd><p>Query the filename of the background image.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportBackground.imageOffset">
<code class="descname">imageOffset</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of float<a class="headerlink" href="#hou.GeometryViewportBackground.imageOffset" title="Permalink to this definition"></a></dt>
<dd><p>Query the background image offset.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportBackground.imageScale">
<code class="descname">imageScale</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of float<a class="headerlink" href="#hou.GeometryViewportBackground.imageScale" title="Permalink to this definition"></a></dt>
<dd><p>Query the background image scale.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportBackground.imageSource">
<code class="descname">imageSource</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.GeometryViewportBackground.imageSource" title="Permalink to this definition"></a></dt>
<dd><p>Query the file or cop path, depending on the current background
image source.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportBackground.isCOPSource">
<code class="descname">isCOPSource</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportBackground.isCOPSource" title="Permalink to this definition"></a></dt>
<dd><p>Query if the background image is sourced from a composite operator.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportBackground.isFileSource">
<code class="descname">isFileSource</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportBackground.isFileSource" title="Permalink to this definition"></a></dt>
<dd><p>Query if the background image is sourced from a disk file.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportBackground.setAutoPlace">
<code class="descname">setAutoPlace</code><span class="sig-paren">(</span><em>self</em>, <em>enable</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportBackground.setAutoPlace" title="Permalink to this definition"></a></dt>
<dd><p>Automatically fit the background image to the viewport. If False,
use the manual offset and scale to position the image.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportBackground.setBrightness">
<code class="descname">setBrightness</code><span class="sig-paren">(</span><em>self</em>, <em>intensity</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportBackground.setBrightness" title="Permalink to this definition"></a></dt>
<dd><p>Set the intensity multiplier of the background image. A value of 1
keeps it at its original intensity, and values less than that dim
it.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportBackground.setImageCOP">
<code class="descname">setImageCOP</code><span class="sig-paren">(</span><em>self</em>, <em>op_path</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportBackground.setImageCOP" title="Permalink to this definition"></a></dt>
<dd><p>Set the path to the Composite operator defining the background image
and set the background source to COP.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportBackground.setImageFile">
<code class="descname">setImageFile</code><span class="sig-paren">(</span><em>self</em>, <em>file_path</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportBackground.setImageFile" title="Permalink to this definition"></a></dt>
<dd><p>Set the filename of the background image and set the background
source to File.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportBackground.setImageOffset">
<code class="descname">setImageOffset</code><span class="sig-paren">(</span><em>self</em>, <em>offset</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportBackground.setImageOffset" title="Permalink to this definition"></a></dt>
<dd><p>Set the background image offset, which is a 2-tuple of float. The
values should be in the 0-1 range, representing fractions of the
viewport width and height.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportBackground.setImageScale">
<code class="descname">setImageScale</code><span class="sig-paren">(</span><em>self</em>, <em>scale</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportBackground.setImageScale" title="Permalink to this definition"></a></dt>
<dd><p>Set the background image scale, which is a 2-tuple of float. The
values should be in the 0-1 range, representing fractions of the
viewport width and height.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportBackground.setImageSource">
<code class="descname">setImageSource</code><span class="sig-paren">(</span><em>self</em>, <em>file_or_op_path</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportBackground.setImageSource" title="Permalink to this definition"></a></dt>
<dd><p>Set the file or cop path, depending on the current background image
source.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportBackground.sourceFromCOP">
<code class="descname">sourceFromCOP</code><span class="sig-paren">(</span><em>self</em>, <em>use_cop</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportBackground.sourceFromCOP" title="Permalink to this definition"></a></dt>
<dd><p>Fetch the background image from a composite operator instead of a
disk file. If False, a disk file is used.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.GeometryViewportBackground.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.GeometryViewportBackground.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.GeometryViewportCamera">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">GeometryViewportCamera</code><a class="headerlink" href="#hou.GeometryViewportCamera" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="method">
<dt id="hou.GeometryViewportCamera.aperture">
<code class="descname">aperture</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#hou.GeometryViewportCamera.aperture" title="Permalink to this definition"></a></dt>
<dd><p>Query the aperture of the viewport camera (or current camera).</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportCamera.aspectRatio">
<code class="descname">aspectRatio</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#hou.GeometryViewportCamera.aspectRatio" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportCamera.clipPlanes">
<code class="descname">clipPlanes</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; 2-tuple of float<a class="headerlink" href="#hou.GeometryViewportCamera.clipPlanes" title="Permalink to this definition"></a></dt>
<dd><p>Query the clip planes of the viewport camera as (near,far).</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportCamera.focalLength">
<code class="descname">focalLength</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#hou.GeometryViewportCamera.focalLength" title="Permalink to this definition"></a></dt>
<dd><p>Query the focal length of the viewport camera (or current camera).</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportCamera.isOrthographic">
<code class="descname">isOrthographic</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportCamera.isOrthographic" title="Permalink to this definition"></a></dt>
<dd><p>Query if the camara view uses an orthographic projection.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportCamera.isPerspective">
<code class="descname">isPerspective</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportCamera.isPerspective" title="Permalink to this definition"></a></dt>
<dd><p>Query if the camara view uses a perspective projection.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportCamera.orthoWidth">
<code class="descname">orthoWidth</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#hou.GeometryViewportCamera.orthoWidth" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportCamera.pivot">
<code class="descname">pivot</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; 3-tuple of float<a class="headerlink" href="#hou.GeometryViewportCamera.pivot" title="Permalink to this definition"></a></dt>
<dd><p>Query the pivot of the viewport camera.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportCamera.rotation">
<code class="descname">rotation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportCamera.rotation" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportCamera.setAperture">
<code class="descname">setAperture</code><span class="sig-paren">(</span><em>self</em>, <em>ap</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportCamera.setAperture" title="Permalink to this definition"></a></dt>
<dd><p>Set the aperture of the viewport camera. Throws an error if the
viewport is looking though camera object and the view is not locked
to that camera.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportCamera.setAspectRatio">
<code class="descname">setAspectRatio</code><span class="sig-paren">(</span><em>self</em>, <em>ar</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportCamera.setAspectRatio" title="Permalink to this definition"></a></dt>
<dd><p>Set the view aspect ratio of the viewport camera (16:9 would be
1.777). Throws an error if the viewport is looking though camera
object and the view is not locked to that camera.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportCamera.setClipPlanes">
<code class="descname">setClipPlanes</code><span class="sig-paren">(</span><em>self</em>, <em>near_far</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportCamera.setClipPlanes" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportCamera.setFocalLength">
<code class="descname">setFocalLength</code><span class="sig-paren">(</span><em>self</em>, <em>fl</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportCamera.setFocalLength" title="Permalink to this definition"></a></dt>
<dd><p>Set the focal length of the viewport camera. Throws an error if the
viewport is looking though camera object and the view is not locked
to that camera.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportCamera.setOrthoWidth">
<code class="descname">setOrthoWidth</code><span class="sig-paren">(</span><em>self</em>, <em>ow</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportCamera.setOrthoWidth" title="Permalink to this definition"></a></dt>
<dd><p>Set the orthographic width of the viewport camera. Throws an error
if the viewport is looking though camera object and the view is not
locked to that camera. This has no effect on perspective cameras.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportCamera.setPerspective">
<code class="descname">setPerspective</code><span class="sig-paren">(</span><em>self</em>, <em>perspective</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportCamera.setPerspective" title="Permalink to this definition"></a></dt>
<dd><p>Set the camera view to perspective (True) or orthographic (False).
Fixed orthographics views cannot be changed to perspective (Top,
Bottom, Left, Right, Front, and Back).</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportCamera.setPivot">
<code class="descname">setPivot</code><span class="sig-paren">(</span><em>self</em>, <em>xyz</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportCamera.setPivot" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportCamera.setRotation">
<code class="descname">setRotation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportCamera.setRotation" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportCamera.setTranslation">
<code class="descname">setTranslation</code><span class="sig-paren">(</span><em>self</em>, <em>xyz</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportCamera.setTranslation" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportCamera.setWindowOffset">
<code class="descname">setWindowOffset</code><span class="sig-paren">(</span><em>self</em>, <em>xy</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportCamera.setWindowOffset" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportCamera.setWindowSize">
<code class="descname">setWindowSize</code><span class="sig-paren">(</span><em>self</em>, <em>size</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportCamera.setWindowSize" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportCamera.stash">
<code class="descname">stash</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.GeometryViewportCamera<a class="headerlink" href="#hou.GeometryViewportCamera.stash" title="Permalink to this definition"></a></dt>
<dd><p>Create a copy of the camera settings which can be used to store the
view, usually so it can be restored later. Stashed camera settings
are not connected to a viewport, so modifying them will have no
effect on the viewport until it is passed to the viewport via
hou.GeometryViewport.setDefaultCamera().</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.GeometryViewportCamera.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.GeometryViewportCamera.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportCamera.translation">
<code class="descname">translation</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; 3-tuple of float<a class="headerlink" href="#hou.GeometryViewportCamera.translation" title="Permalink to this definition"></a></dt>
<dd><p>Query the translation (position) of the viewport camera.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportCamera.windowOffset">
<code class="descname">windowOffset</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; 2-tuple of float<a class="headerlink" href="#hou.GeometryViewportCamera.windowOffset" title="Permalink to this definition"></a></dt>
<dd><p>Query the window offset of the viewport, in (0,1) space.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportCamera.windowSize">
<code class="descname">windowSize</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; 2-tuple of float<a class="headerlink" href="#hou.GeometryViewportCamera.windowSize" title="Permalink to this definition"></a></dt>
<dd><p>Query the window size of the viewport, in (0,1) space.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.GeometryViewportDisplaySet">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">GeometryViewportDisplaySet</code><a class="headerlink" href="#hou.GeometryViewportDisplaySet" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A Display Set represents a group of 3D viewport display options that
apply to a particular context of geometry.</p>
<p>OVERVIEW</p>
<blockquote>
<div><blockquote>
<div>In Houdinis 3D viewer display options window, you can apply
different display options to certain subsets of objects/geometry,
for example selected objects, or the displayed SOP. This object
represents a set of options that apply to one of these subsets. For
example, you can set templated SOPs to display as wireframe:</div></blockquote>
<p>&gt; # Get a reference to the geometry viewer
&gt; pane = hou.ui.curDesktop().paneTabOfType(hou.paneTabType.SceneViewer)
&gt; 
&gt; # Get the display settings
&gt; settings = pane.curViewport().settings()
&gt; 
&gt; # Get the GeometryViewportDisplaySet for objects
&gt; tmplset = settings.displaySet(hou.displaySetType.TemplateModel)
&gt; 
&gt; # Tell Houdini to show set the shading mode for this subset to wireframe
&gt; tmplset.setShadedMode(hou.glShadingType.Wire)</p>
<blockquote>
<div><p>There are several subsets available:</p>
<p>Objects</p>
<dl class="docutils">
<dt>hou.displaySetType.SceneObject</dt>
<dd>Object nodes which are not selected or ghosted.</dd>
<dt>hou.displaySetType.SelectedObject</dt>
<dd>Object nodes which are selected.</dd>
<dt>hou.displaySetType.GhostObject</dt>
<dd>Object nodes which ghosted, which occurs when they are visible
when at the SOP level and Ghost Other Objects is the current
object mode, but are not the current object.</dd>
</dl>
<p>Geometry</p>
<dl class="docutils">
<dt>hou.displaySetType.DisplayModel</dt>
<dd>SOP with the display flag. This takes precendence over
TemplateModel and CurrentModel, if the SOP has either the
template flag set or is selected.</dd>
<dt>hou.displaySetType.CurrentModel</dt>
<dd>SOP that is currently selected. This takes precendence over
TemplateModel, if that SOP also has the template flag set.</dd>
<dt>hou.displaySetType.TemplateModel</dt>
<dd>SOP that has a template flag set.</dd>
</dl>
<p>You can set the options in each display set independently of the
other sets. You can also link a subset to another, so this subset
uses the linked sets options.</p>
</div></blockquote>
</div></blockquote>
<dl class="method">
<dt id="hou.GeometryViewportDisplaySet.boundaryMode">
<code class="descname">boundaryMode</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.boundaryDisplay<a class="headerlink" href="#hou.GeometryViewportDisplaySet.boundaryMode" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Query which viewport types display 3D boundaries
(hou.boundaryDisplay).</div></blockquote>
<ul>
<li><p class="first">hou.boundaryDisplay.Off:</p>
<blockquote>
<div><p>No 3D boundaries are displayed.</p>
</div></blockquote>
</li>
<li><p class="first">hou.boundaryDisplay.On:</p>
<blockquote>
<div><p>3D boundaries are shown in all viewports.</p>
</div></blockquote>
</li>
<li><p class="first">hou.boundaryDisplay.View3D:</p>
<blockquote>
<div><p>3D boundaries are shown in 3D viewports only.</p>
</div></blockquote>
</li>
<li><p class="first">hou.boundaryDisplay.ViewUV: .</p>
<blockquote>
<div><p>3D boundaries are shown in UV viewports only.</p>
</div></blockquote>
</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportDisplaySet.displaySetType">
<code class="descname">displaySetType</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; hou.displaySetType<a class="headerlink" href="#hou.GeometryViewportDisplaySet.displaySetType" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Returns the geometry context this display set represents:</div></blockquote>
<ul class="simple">
<li>hou.displaySetType.SceneObject - object nodes which are not selected
or ghosted.</li>
<li>hou.displaySetType.SelectedObject - object nodes which are selected.</li>
<li>hou.displaySetType.GhostObject - object nodes which ghosted, which
occurs when they are visible when at the SOP level and Ghost Other
Objects is the current object mode, but are not the current object.</li>
<li>hou.displaySetType.DisplayModel - SOP with the display flag. This
takes precendence over TemplateModel and CurrentModel, if the SOP
has either the template flag set or is selected.</li>
<li>hou.displaySetType.CurrentModel - SOP that is currently selected.
This takes precendence over TemplateModel, if that SOP also has the
template flag set.</li>
<li>hou.displaySetType.TemplateModel - SOP that has a template flag set.</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportDisplaySet.isShadingModeLocked">
<code class="descname">isShadingModeLocked</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportDisplaySet.isShadingModeLocked" title="Permalink to this definition"></a></dt>
<dd><p>Query if the shading mode is locked. When locked, changing the
shading mode in the viewport will not affect the look of geometry in
this display set.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportDisplaySet.isShowingCoincidentPoints">
<code class="descname">isShowingCoincidentPoints</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportDisplaySet.isShowingCoincidentPoints" title="Permalink to this definition"></a></dt>
<dd><p>Query if coincident point detection is enabled (yellow points and a
duplicate count where coincident points are detected).</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportDisplaySet.isShowingPointMarkers">
<code class="descname">isShowingPointMarkers</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportDisplaySet.isShowingPointMarkers" title="Permalink to this definition"></a></dt>
<dd><p>Query if point markers are shown (blue dots at points).</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportDisplaySet.isShowingPointNormals">
<code class="descname">isShowingPointNormals</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportDisplaySet.isShowingPointNormals" title="Permalink to this definition"></a></dt>
<dd><p>Query if point normals are shown.</p>
<p>If the point normals are blue, the geometry has point normals. If
they are dimmed, the model does not have normals and the normals
shown have been automatically generated for display. If no normals
are shown, the geometry has vertex normals. This query does not
check for those conditions, but just the current setting of the
display option.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportDisplaySet.isShowingPointNumbers">
<code class="descname">isShowingPointNumbers</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportDisplaySet.isShowingPointNumbers" title="Permalink to this definition"></a></dt>
<dd><p>Query if point numbers are shown as text (blue point numbers, one
per point).</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportDisplaySet.isShowingPointPositions">
<code class="descname">isShowingPointPositions</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportDisplaySet.isShowingPointPositions" title="Permalink to this definition"></a></dt>
<dd><p>Query if 3D point positions are being shown, as text: (x,y,z).</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportDisplaySet.isShowingPointTrails">
<code class="descname">isShowingPointTrails</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportDisplaySet.isShowingPointTrails" title="Permalink to this definition"></a></dt>
<dd><p>Query if point trails are shown (based on the velocity v attribute).</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportDisplaySet.isShowingPointUVs">
<code class="descname">isShowingPointUVs</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportDisplaySet.isShowingPointUVs" title="Permalink to this definition"></a></dt>
<dd><p>Query if point texture coordinates are being shown, as text:
(u,v).</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportDisplaySet.isShowingPrimBackfaces">
<code class="descname">isShowingPrimBackfaces</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportDisplaySet.isShowingPrimBackfaces" title="Permalink to this definition"></a></dt>
<dd><p>Query if backfacing polygons are tinted to distinguish them from
front facing polygons.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportDisplaySet.isShowingPrimBreakpoints">
<code class="descname">isShowingPrimBreakpoints</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportDisplaySet.isShowingPrimBreakpoints" title="Permalink to this definition"></a></dt>
<dd><p>Query if breakpoints are displayed. Breakpoints are only available
on NURBS and bezier surfaces and curves.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportDisplaySet.isShowingPrimHulls">
<code class="descname">isShowingPrimHulls</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportDisplaySet.isShowingPrimHulls" title="Permalink to this definition"></a></dt>
<dd><p>Query if primitive hulls are shown. Only some primitives have hulls,
such as volumes, NURBS, crowd agents, and bezier curves.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportDisplaySet.isShowingPrimNormals">
<code class="descname">isShowingPrimNormals</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportDisplaySet.isShowingPrimNormals" title="Permalink to this definition"></a></dt>
<dd><p>Query if the primitive face normals are shown. Only polygon-based
primitives have face normals.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportDisplaySet.isShowingPrimNumbers">
<code class="descname">isShowingPrimNumbers</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportDisplaySet.isShowingPrimNumbers" title="Permalink to this definition"></a></dt>
<dd><p>Query if primitive numbers are shown. The primitive numbers can be
used to specify primitives in primitive groups. The number is shown
at the center of the primitive.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportDisplaySet.isShowingPrimProfileNumbers">
<code class="descname">isShowingPrimProfileNumbers</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportDisplaySet.isShowingPrimProfileNumbers" title="Permalink to this definition"></a></dt>
<dd><p>Query if profile curve numbers are shown, on NURBS surfaces only.
Each profile curve has an index from 0 to #profiles-1.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportDisplaySet.isShowingPrimProfiles">
<code class="descname">isShowingPrimProfiles</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportDisplaySet.isShowingPrimProfiles" title="Permalink to this definition"></a></dt>
<dd><p>Query if profile curves are shown, on NURBS surfaces only.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportDisplaySet.isShowingUVBackfaces">
<code class="descname">isShowingUVBackfaces</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportDisplaySet.isShowingUVBackfaces" title="Permalink to this definition"></a></dt>
<dd><p>Query if UV Backface highlighting is enabled in the UV view.
Highlight polygons that are facing away, as the texture will appear
backwards on these polygons.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportDisplaySet.isShowingUVOverlap">
<code class="descname">isShowingUVOverlap</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportDisplaySet.isShowingUVOverlap" title="Permalink to this definition"></a></dt>
<dd><p>Query if the UV overlap is shown in the UV texture viewport. UV
areas that reuse the same UV coordinates will be highlighted.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportDisplaySet.isShowingVertexMarkers">
<code class="descname">isShowingVertexMarkers</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportDisplaySet.isShowingVertexMarkers" title="Permalink to this definition"></a></dt>
<dd><p>Query if vertex markers are shown. Vertex markers are inset into
their polygon slightly, for ease of selection and selection display.
The markers are small hollow squares. Not all primitive types have
vertex markers.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportDisplaySet.isShowingVertexNormals">
<code class="descname">isShowingVertexNormals</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportDisplaySet.isShowingVertexNormals" title="Permalink to this definition"></a></dt>
<dd><p>Query if vertex normals are shown. If the geometry does not have
vertex normals, they will not be shown. The base of the vertex
normal is inset slightly into its polygon to make it easier to see
which polygon the normal is influencing.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportDisplaySet.isShowingVertexNumbers">
<code class="descname">isShowingVertexNumbers</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportDisplaySet.isShowingVertexNumbers" title="Permalink to this definition"></a></dt>
<dd><p>Query if vertex numbers are shown. Each vertex on a polygon or mesh
is numbered 0 to #edges-1.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportDisplaySet.isShowingVertexUVs">
<code class="descname">isShowingVertexUVs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportDisplaySet.isShowingVertexUVs" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportDisplaySet.isToolbarLinked">
<code class="descname">isToolbarLinked</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportDisplaySet.isToolbarLinked" title="Permalink to this definition"></a></dt>
<dd><p>Query if the display set is linked to the right viewport toolbar.
When linked, clicking a display option button on this toolbar will
affect the corresponding option in this display set.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportDisplaySet.isUniqueDisplaySet">
<code class="descname">isUniqueDisplaySet</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportDisplaySet.isUniqueDisplaySet" title="Permalink to this definition"></a></dt>
<dd><p>A display set can be linked to another display set, so that all of
its options are taken from that linked set rather than its own. This
method returns True if the display set is unique, in that it is not
linked to another display set, and False if the set refers to
another display set.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportDisplaySet.isUsingFadedLook">
<code class="descname">isUsingFadedLook</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportDisplaySet.isUsingFadedLook" title="Permalink to this definition"></a></dt>
<dd><p>Query if the display set is faded. Faded geometry suppresses the
display of geometry color.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportDisplaySet.isUsingGhostedLook">
<code class="descname">isUsingGhostedLook</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportDisplaySet.isUsingGhostedLook" title="Permalink to this definition"></a></dt>
<dd><p>Query if the display set is ghosted. Ghosted geometry appears
transluscent so that geometry behind it can be easily seen.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportDisplaySet.isUsingLighting">
<code class="descname">isUsingLighting</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportDisplaySet.isUsingLighting" title="Permalink to this definition"></a></dt>
<dd><p>Query if lighting is used for this display set. When off, the
geometry is displayed without any lighting (often much brighter).</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportDisplaySet.isUsingXRay">
<code class="descname">isUsingXRay</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportDisplaySet.isUsingXRay" title="Permalink to this definition"></a></dt>
<dd><p>Query if the display set is drawn with XRay. XRay geometry will
appear as a faded wireframe behind other geometry that occludes it.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportDisplaySet.linkedToDisplaySet">
<code class="descname">linkedToDisplaySet</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.displaySetType<a class="headerlink" href="#hou.GeometryViewportDisplaySet.linkedToDisplaySet" title="Permalink to this definition"></a></dt>
<dd><p>A display set can be linked to another display set, so that all of
its options are taken from that linked set rather than its own. This
method returns the display set this set is linked to. If it is not
linked to another set, it will return the its own set.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportDisplaySet.pointMarkerVisibility">
<code class="descname">pointMarkerVisibility</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.markerVisibility<a class="headerlink" href="#hou.GeometryViewportDisplaySet.pointMarkerVisibility" title="Permalink to this definition"></a></dt>
<dd><p>Query the visibility setting of point markers.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportDisplaySet.pointNormalVisibility">
<code class="descname">pointNormalVisibility</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.markerVisibility<a class="headerlink" href="#hou.GeometryViewportDisplaySet.pointNormalVisibility" title="Permalink to this definition"></a></dt>
<dd><p>Query the visibility setting of point normals.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportDisplaySet.pointNumberVisibility">
<code class="descname">pointNumberVisibility</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.markerVisibility<a class="headerlink" href="#hou.GeometryViewportDisplaySet.pointNumberVisibility" title="Permalink to this definition"></a></dt>
<dd><p>Query the visibility setting of point numbers.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportDisplaySet.pointPositionVisibility">
<code class="descname">pointPositionVisibility</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.markerVisibility<a class="headerlink" href="#hou.GeometryViewportDisplaySet.pointPositionVisibility" title="Permalink to this definition"></a></dt>
<dd><p>Query the visibility setting of point UVs.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportDisplaySet.pointTrailVisibility">
<code class="descname">pointTrailVisibility</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.markerVisibility<a class="headerlink" href="#hou.GeometryViewportDisplaySet.pointTrailVisibility" title="Permalink to this definition"></a></dt>
<dd><p>Query the visibility setting of point trails.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportDisplaySet.pointUVVisibility">
<code class="descname">pointUVVisibility</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.markerVisibility<a class="headerlink" href="#hou.GeometryViewportDisplaySet.pointUVVisibility" title="Permalink to this definition"></a></dt>
<dd><p>Query the visibility setting of point UVs.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportDisplaySet.primBreakpointVisibility">
<code class="descname">primBreakpointVisibility</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.markerVisibility<a class="headerlink" href="#hou.GeometryViewportDisplaySet.primBreakpointVisibility" title="Permalink to this definition"></a></dt>
<dd><p>Query the visibility setting of primitive breakpoints.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportDisplaySet.primNormalVisibility">
<code class="descname">primNormalVisibility</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.markerVisibility<a class="headerlink" href="#hou.GeometryViewportDisplaySet.primNormalVisibility" title="Permalink to this definition"></a></dt>
<dd><p>Query the visibility setting of primitive normals.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportDisplaySet.primNumberVisibility">
<code class="descname">primNumberVisibility</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.markerVisibility<a class="headerlink" href="#hou.GeometryViewportDisplaySet.primNumberVisibility" title="Permalink to this definition"></a></dt>
<dd><p>Query the visibility setting of primitive numbers.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportDisplaySet.setBoundaryMode">
<code class="descname">setBoundaryMode</code><span class="sig-paren">(</span><em>self</em>, <em>hou.boundaryDisplay</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportDisplaySet.setBoundaryMode" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Set the viewport types that highlight 3D boundaries for the geometry
in the display set.</div></blockquote>
<ul>
<li><p class="first">hou.boundaryDisplay.Off:</p>
<blockquote>
<div><p>No 3D boundaries are displayed.</p>
</div></blockquote>
</li>
<li><p class="first">hou.boundaryDisplay.On:</p>
<blockquote>
<div><p>3D boundaries are shown in all viewports.</p>
</div></blockquote>
</li>
<li><p class="first">hou.boundaryDisplay.View3D:</p>
<blockquote>
<div><p>3D boundaries are shown in 3D viewports only.</p>
</div></blockquote>
</li>
<li><p class="first">hou.boundaryDisplay.ViewUV: .</p>
<blockquote>
<div><p>3D boundaries are shown in UV viewports only.</p>
</div></blockquote>
</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportDisplaySet.setLinkToDisplaySet">
<code class="descname">setLinkToDisplaySet</code><span class="sig-paren">(</span><em>self</em>, <em>view_display_set</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportDisplaySet.setLinkToDisplaySet" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Link this display set to the settings of another display set. This
display sets option settings are then ignored, and the other sets
are used in their place. Linking a set to itself restores its own
settings.</div></blockquote>
<ul class="simple">
<li>hou.displaySetType.SceneObject</li>
<li>hou.displaySetType.SelectedObject</li>
<li>hou.displaySetType.GhostObject</li>
<li>hou.displaySetType.DisplayModel</li>
<li>hou.displaySetType.CurrentModel</li>
<li>hou.displaySetType.TemplateModel</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportDisplaySet.setPointMarkerVisibility">
<code class="descname">setPointMarkerVisibility</code><span class="sig-paren">(</span><em>self</em>, <em>visibility</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportDisplaySet.setPointMarkerVisibility" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Controls how point markers are shown when displayed.</div></blockquote>
<ul class="simple">
<li>hou.markerVisibility.Always: All are shown.</li>
<li>hou.markerVisibility.Selected: Only markers for selected points are
shown.</li>
<li>hou.markerVisibility.AroundPointer: Markers close to the 3D point
the mouse cursor is currently over are shown.</li>
<li>hou.markerVisibility.UnderPointer: Markers under the mouse cursor
are shown.</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportDisplaySet.setPointNormalVisibility">
<code class="descname">setPointNormalVisibility</code><span class="sig-paren">(</span><em>self</em>, <em>visibility</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportDisplaySet.setPointNormalVisibility" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Controls how point normals are shown when displayed.</div></blockquote>
<ul class="simple">
<li>hou.markerVisibility.Always: All are shown.</li>
<li>hou.markerVisibility.Selected: Only normals for selected points are
shown.</li>
<li>hou.markerVisibility.AroundPointer: Normals close to the 3D point
the mouse cursor is currently over are shown.</li>
<li>hou.markerVisibility.UnderPointer: Normals under the mouse cursor
are shown.</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportDisplaySet.setPointNumberVisibility">
<code class="descname">setPointNumberVisibility</code><span class="sig-paren">(</span><em>self</em>, <em>visibility</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportDisplaySet.setPointNumberVisibility" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Controls how point numbers are shown when displayed.</div></blockquote>
<ul class="simple">
<li>hou.markerVisibility.Always: All are shown.</li>
<li>hou.markerVisibility.Selected: Only numbers for selected points are
shown.</li>
<li>hou.markerVisibility.AroundPointer: Numbers close to the 3D point
the mouse cursor is currently over are shown.</li>
<li>hou.markerVisibility.UnderPointer: Numbers under the mouse cursor
are shown.</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportDisplaySet.setPointPositionVisibility">
<code class="descname">setPointPositionVisibility</code><span class="sig-paren">(</span><em>self</em>, <em>visibility</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportDisplaySet.setPointPositionVisibility" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Controls how point positions are shown when displayed.</div></blockquote>
<ul class="simple">
<li>hou.markerVisibility.Always: All are shown.</li>
<li>hou.markerVisibility.Selected: Only positions for selected points
are shown.</li>
<li>hou.markerVisibility.AroundPointer: Positions close to the 3D point
the mouse cursor is currently over are shown.</li>
<li>hou.markerVisibility.UnderPointer: Positions under the mouse cursor
are shown.</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportDisplaySet.setPointTrailVisibility">
<code class="descname">setPointTrailVisibility</code><span class="sig-paren">(</span><em>self</em>, <em>visibility</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportDisplaySet.setPointTrailVisibility" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Controls how point trails are shown when displayed.</div></blockquote>
<ul class="simple">
<li>hou.markerVisibility.Always: All are shown.</li>
<li>hou.markerVisibility.Selected: Only trails for selected points are
shown.</li>
<li>hou.markerVisibility.AroundPointer: Trails close to the 3D point the
mouse cursor is currently over are shown.</li>
<li>hou.markerVisibility.UnderPointer: Trails under the mouse cursor are
shown.</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportDisplaySet.setPointUVVisibility">
<code class="descname">setPointUVVisibility</code><span class="sig-paren">(</span><em>self</em>, <em>visibility</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportDisplaySet.setPointUVVisibility" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Controls how point UVs are shown when displayed.</div></blockquote>
<ul class="simple">
<li>hou.markerVisibility.Always: All are shown.</li>
<li>hou.markerVisibility.Selected: Only UVs for selected points are
shown.</li>
<li>hou.markerVisibility.AroundPointer: UVs close to the 3D point the
mouse cursor is currently over are shown.</li>
<li>hou.markerVisibility.UnderPointer: UVs under the mouse cursor are
shown.</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportDisplaySet.setPrimBreakpointVisibility">
<code class="descname">setPrimBreakpointVisibility</code><span class="sig-paren">(</span><em>self</em>, <em>visibility</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportDisplaySet.setPrimBreakpointVisibility" title="Permalink to this definition"></a></dt>
<dd><p>Controls how primitive breakpoints are shown when displayed.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportDisplaySet.setPrimNormalVisibility">
<code class="descname">setPrimNormalVisibility</code><span class="sig-paren">(</span><em>self</em>, <em>visibility</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportDisplaySet.setPrimNormalVisibility" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Controls how primitive face normals are shown when displayed.</div></blockquote>
<ul class="simple">
<li>hou.markerVisibility.Always: All are shown.</li>
<li>hou.markerVisibility.Selected: Only normals for selected primitives
are shown.</li>
<li>hou.markerVisibility.AroundPointer: Normals close to the 3D point
the mouse cursor is currently over are shown.</li>
<li>hou.markerVisibility.UnderPointer: Normals under the mouse cursor
are shown.</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportDisplaySet.setPrimNumberVisibility">
<code class="descname">setPrimNumberVisibility</code><span class="sig-paren">(</span><em>self</em>, <em>visibility</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportDisplaySet.setPrimNumberVisibility" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Controls how primitive numbers are shown when displayed.</div></blockquote>
<ul class="simple">
<li>hou.markerVisibility.Always: All are shown.</li>
<li>hou.markerVisibility.Selected: Only numbers for selected primitives
are shown.</li>
<li>hou.markerVisibility.AroundPointer: Numbers close to the 3D point
the mouse cursor is currently over are shown.</li>
<li>hou.markerVisibility.UnderPointer: Numbers under the mouse cursor
are shown.</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportDisplaySet.setShadedMode">
<code class="descname">setShadedMode</code><span class="sig-paren">(</span><em>self</em>, <em>shaded_mode</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportDisplaySet.setShadedMode" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Sets the shading mode for this display set:</div></blockquote>
<ul class="simple">
<li>hou.glShadingType.WireBoundingBox: no geometry, only bounding box
outline</li>
<li>hou.glShadingType.ShadedBoundingBox: no geometry, solid bounding box</li>
<li>hou.glShadingType.Wire: wireframe</li>
<li>hou.glShadingType.WireGhost: wireframe with muted hidden lines</li>
<li>hou.glShadingType.HiddenLineInvisible: wireframe with hidden lines</li>
<li>hou.glShadingType.HiddenLineGhost: wireframe with solid constant
faces</li>
<li>hou.glShadingType.Flat: shaded with primitive face normals</li>
<li>hou.glShadingType.FlatWire: shaded with primitive face normals,
outlined polygons</li>
<li>hou.glShadingType.Smooth: shaded with point or vertex normals</li>
<li>hou.glShadingType.SmoothWire: shaded with point or vertex normals,
outlined polygons</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportDisplaySet.setShadingModeLocked">
<code class="descname">setShadingModeLocked</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportDisplaySet.setShadingModeLocked" title="Permalink to this definition"></a></dt>
<dd><p>Locks the shading mode so that it cannot be changed by the user
using the Shading Mode menu in the viewport or the wireframe toggle
hotkey. Passing False unlocks the display set so that it follows the
viewports shading mode.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportDisplaySet.setToolbarLinked">
<code class="descname">setToolbarLinked</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportDisplaySet.setToolbarLinked" title="Permalink to this definition"></a></dt>
<dd><p>Link the display sets options to the option toggles in the right
viewport toolbar. When linked, clicking a display option button on
this toolbar will affect the corresponding option in this display
set.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportDisplaySet.setUVBoundaryMode">
<code class="descname">setUVBoundaryMode</code><span class="sig-paren">(</span><em>self</em>, <em>hou.boundaryDisplay</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportDisplaySet.setUVBoundaryMode" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Set viewport types that highlight UV boundaries for the geometry in
the display set.</div></blockquote>
<ul>
<li><p class="first">hou.boundaryDisplay.Off:</p>
<blockquote>
<div><p>No UV boundaries are displayed.</p>
</div></blockquote>
</li>
<li><p class="first">hou.boundaryDisplay.On:</p>
<blockquote>
<div><p>UV boundaries are shown in all viewports.</p>
</div></blockquote>
</li>
<li><p class="first">hou.boundaryDisplay.View3D:</p>
<blockquote>
<div><p>UV boundaries are shown in 3D viewports only.</p>
</div></blockquote>
</li>
<li><p class="first">hou.boundaryDisplay.ViewUV: .</p>
<blockquote>
<div><p>UV boundaries are shown in UV viewports only.</p>
</div></blockquote>
</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportDisplaySet.setUniqueDisplaySet">
<code class="descname">setUniqueDisplaySet</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportDisplaySet.setUniqueDisplaySet" title="Permalink to this definition"></a></dt>
<dd><p>When True, remove any link from this display set to another display
set. Its own settings will be used. Passing False has no effect; use
setLinkToDisplaySet to link this set to another display set.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportDisplaySet.setVertexMarkerVisibility">
<code class="descname">setVertexMarkerVisibility</code><span class="sig-paren">(</span><em>self</em>, <em>visibility</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportDisplaySet.setVertexMarkerVisibility" title="Permalink to this definition"></a></dt>
<dd><p>Controls how vertex markers are shown when displayed.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportDisplaySet.setVertexNormalVisibility">
<code class="descname">setVertexNormalVisibility</code><span class="sig-paren">(</span><em>self</em>, <em>visibility</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportDisplaySet.setVertexNormalVisibility" title="Permalink to this definition"></a></dt>
<dd><p>Controls how vertex normals are shown when displayed.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportDisplaySet.setVertexNumberVisibility">
<code class="descname">setVertexNumberVisibility</code><span class="sig-paren">(</span><em>self</em>, <em>visibility</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportDisplaySet.setVertexNumberVisibility" title="Permalink to this definition"></a></dt>
<dd><p>Controls how vertex numbers are shown when displayed.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportDisplaySet.setVertexUVVisibility">
<code class="descname">setVertexUVVisibility</code><span class="sig-paren">(</span><em>self</em>, <em>visibility</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportDisplaySet.setVertexUVVisibility" title="Permalink to this definition"></a></dt>
<dd><p>Controls how vertex normals are shown when displayed.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportDisplaySet.shadedMode">
<code class="descname">shadedMode</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.glShadingType<a class="headerlink" href="#hou.GeometryViewportDisplaySet.shadedMode" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Query the shading mode of the display set (hou.glShadingType):</div></blockquote>
<ul class="simple">
<li>hou.glShadingType.WireBoundingBox: no geometry, only bounding box
outline</li>
<li>hou.glShadingType.ShadedBoundingBox: no geometry, solid bounding box</li>
<li>hou.glShadingType.Wire: wireframe</li>
<li>hou.glShadingType.WireGhost: wireframe with muted hidden lines</li>
<li>hou.glShadingType.HiddenLineInvisible: wireframe with hidden lines</li>
<li>hou.glShadingType.HiddenLineGhost: wireframe with solid constant
faces</li>
<li>hou.glShadingType.Flat: shaded with primitive face normals</li>
<li>hou.glShadingType.FlatWire: shaded with primitive face normals,
outlined polygons</li>
<li>hou.glShadingType.Smooth: shaded with point or vertex normals</li>
<li>hou.glShadingType.SmoothWire: shaded with point or vertex normals,
outlined polygons</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportDisplaySet.showCoincidentPoints">
<code class="descname">showCoincidentPoints</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportDisplaySet.showCoincidentPoints" title="Permalink to this definition"></a></dt>
<dd><p>Enable or disable coincident point detection. Orange points markers
and a duplicate count are placed where coincident points are
detected.</p>
<p>Coindicent point detection has affects viewport performance more
significantly than other markers. It is best used when zoomed in on
an area of the geometry for dense meshes, to avoid false positives.</p>
<dl class="docutils">
<dt>NOTE</dt>
<dd>Coindicent point detection has affects viewport performance more
significantly than other markers. It is best used when zoomed in
on an area of the geometry for dense meshes, to avoid false
positives.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportDisplaySet.showPointMarkers">
<code class="descname">showPointMarkers</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportDisplaySet.showPointMarkers" title="Permalink to this definition"></a></dt>
<dd><p>Show or hide point markers.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportDisplaySet.showPointNormals">
<code class="descname">showPointNormals</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportDisplaySet.showPointNormals" title="Permalink to this definition"></a></dt>
<dd><p>Show or hide point normals.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportDisplaySet.showPointNumbers">
<code class="descname">showPointNumbers</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportDisplaySet.showPointNumbers" title="Permalink to this definition"></a></dt>
<dd><p>Show or hide point numbers.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportDisplaySet.showPointPositions">
<code class="descname">showPointPositions</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportDisplaySet.showPointPositions" title="Permalink to this definition"></a></dt>
<dd><p>Show or hide point position text display, drawn by each point.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportDisplaySet.showPointTrails">
<code class="descname">showPointTrails</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportDisplaySet.showPointTrails" title="Permalink to this definition"></a></dt>
<dd><p>Show or hide point trails on all points. Geometry must have a
velocity attribute v.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportDisplaySet.showPointUVs">
<code class="descname">showPointUVs</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportDisplaySet.showPointUVs" title="Permalink to this definition"></a></dt>
<dd><p>Show or hide point UVs. If the geometry does not have point UVs,
nothing will be displayed (ie. no UVs or vertex UVs).</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportDisplaySet.showPrimBackfaces">
<code class="descname">showPrimBackfaces</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportDisplaySet.showPrimBackfaces" title="Permalink to this definition"></a></dt>
<dd><p>Enable to tint backfacing polygons to distinguish them from front
facing polygons.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportDisplaySet.showPrimBreakpoints">
<code class="descname">showPrimBreakpoints</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportDisplaySet.showPrimBreakpoints" title="Permalink to this definition"></a></dt>
<dd><p>Enable or disable breakpoints display. Breakpoints are only
available on NURBS and bezier surfaces and curves, and appear as
hollow circles along the isoparms.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportDisplaySet.showPrimHulls">
<code class="descname">showPrimHulls</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportDisplaySet.showPrimHulls" title="Permalink to this definition"></a></dt>
<dd><p>Enable or disable primitive hulls. Only certain primitive types have
hulls, such as NURBS, volumes, agents, and bezier curves.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportDisplaySet.showPrimNormals">
<code class="descname">showPrimNormals</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportDisplaySet.showPrimNormals" title="Permalink to this definition"></a></dt>
<dd><p>Enable or disable primitive face normals. This shows the face
normals of polygons, not the value of a primitive N attribute.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportDisplaySet.showPrimNumbers">
<code class="descname">showPrimNumbers</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportDisplaySet.showPrimNumbers" title="Permalink to this definition"></a></dt>
<dd><p>Enable or disable the display of primitive numbers, which are shown
in the middle of the primitive.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportDisplaySet.showPrimProfileNumbers">
<code class="descname">showPrimProfileNumbers</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportDisplaySet.showPrimProfileNumbers" title="Permalink to this definition"></a></dt>
<dd><p>Enable or disable profile curve number display on NURBS surfaces.
Each profile on a NURBS surface has an index from 0 to #profiles-1.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportDisplaySet.showPrimProfiles">
<code class="descname">showPrimProfiles</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportDisplaySet.showPrimProfiles" title="Permalink to this definition"></a></dt>
<dd><p>Enable or disable profile curve display on NURBS surfaces.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportDisplaySet.showUVBackfaces">
<code class="descname">showUVBackfaces</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportDisplaySet.showUVBackfaces" title="Permalink to this definition"></a></dt>
<dd><p>Enable or disable UV backface highlighting in the UV viewport.
Backfacing polygons would have the texture displayed on them
backwards, from the point of view of the background image in the UV
viewport.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportDisplaySet.showUVOverlap">
<code class="descname">showUVOverlap</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportDisplaySet.showUVOverlap" title="Permalink to this definition"></a></dt>
<dd><p>Enable or disable highlighting of UV overlap. Areas of the texture
that would be share the same UVs are highlighted.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportDisplaySet.showVertexMarkers">
<code class="descname">showVertexMarkers</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportDisplaySet.showVertexMarkers" title="Permalink to this definition"></a></dt>
<dd><p>Enable or disable vertex markers. Vertex markers are drawn as small
squares inset into its parent polygon slightly.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportDisplaySet.showVertexNormals">
<code class="descname">showVertexNormals</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportDisplaySet.showVertexNormals" title="Permalink to this definition"></a></dt>
<dd><p>Enable or disable vertex normal display. Vertex normals are drawn
inset into its parent polygon slightly. The geometry must have
vertex normals to be shown (vertex N).</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportDisplaySet.showVertexNumbers">
<code class="descname">showVertexNumbers</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportDisplaySet.showVertexNumbers" title="Permalink to this definition"></a></dt>
<dd><p>Enable or disable vertex numbers. Vertex numbers are drawn as
numbers inset into its parent polygon slightly, ranging 0 to
#edges-1.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportDisplaySet.showVertexUVs">
<code class="descname">showVertexUVs</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportDisplaySet.showVertexUVs" title="Permalink to this definition"></a></dt>
<dd><p>Enable or disable vertex UV texture display. Vertex UVs are drawn
inset into its parent polygon. The geometry must have vertex texture
coordinates to be shown (vertex uv).</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.GeometryViewportDisplaySet.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.GeometryViewportDisplaySet.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportDisplaySet.useFadedLook">
<code class="descname">useFadedLook</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportDisplaySet.useFadedLook" title="Permalink to this definition"></a></dt>
<dd><p>Suppress geometry color (Cd attribute, point, primitive, or vertex)
on the geometry in the display set.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportDisplaySet.useGhostedLook">
<code class="descname">useGhostedLook</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportDisplaySet.useGhostedLook" title="Permalink to this definition"></a></dt>
<dd><p>Make all geometry in the display set appear ghosted - slightly
translucent. This allows geometry behind the ghosted to seen and de-
emphasizes the ghosted geometry in the viewport. This is normal used
to direct focus to other geometry (displayed SOP within an object,
for example).</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportDisplaySet.useLighting">
<code class="descname">useLighting</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportDisplaySet.useLighting" title="Permalink to this definition"></a></dt>
<dd><p>Enable lighting for the geometry in the display set. This works in
conjunction with the global lighting mode in the viewport. Both this
option and the global lighting mode must be set to a lighting mode
in order to see lighting (ie, enabling Lighting on this display set
will not cause it to be lit if the global viewport mode is No
Lighting).</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportDisplaySet.useXRay">
<code class="descname">useXRay</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportDisplaySet.useXRay" title="Permalink to this definition"></a></dt>
<dd><p>Draw the geometry in the display set as XRay, which draws the
geometry normally if not occluded, and as a dimmed wireframe where
occluded by other geometry.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportDisplaySet.uvBoundaryMode">
<code class="descname">uvBoundaryMode</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.boundaryDisplay<a class="headerlink" href="#hou.GeometryViewportDisplaySet.uvBoundaryMode" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Query which viewport types display UV boundaries
(hou.boundaryDisplay).</div></blockquote>
<ul>
<li><p class="first">hou.boundaryDisplay.Off:</p>
<blockquote>
<div><p>No UV boundaries are displayed.</p>
</div></blockquote>
</li>
<li><p class="first">hou.boundaryDisplay.On:</p>
<blockquote>
<div><p>UV boundaries are shown in all viewports.</p>
</div></blockquote>
</li>
<li><p class="first">hou.boundaryDisplay.View3D:</p>
<blockquote>
<div><p>UV boundaries are shown in 3D viewports only.</p>
</div></blockquote>
</li>
<li><p class="first">hou.boundaryDisplay.ViewUV: .</p>
<blockquote>
<div><p>UV boundaries are shown in UV viewports only.</p>
</div></blockquote>
</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportDisplaySet.vertexMarkerVisibility">
<code class="descname">vertexMarkerVisibility</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.markerVisibility<a class="headerlink" href="#hou.GeometryViewportDisplaySet.vertexMarkerVisibility" title="Permalink to this definition"></a></dt>
<dd><p>Query the visibility setting of vertex markers.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportDisplaySet.vertexNormalVisibility">
<code class="descname">vertexNormalVisibility</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.markerVisibility<a class="headerlink" href="#hou.GeometryViewportDisplaySet.vertexNormalVisibility" title="Permalink to this definition"></a></dt>
<dd><p>Query the visibility setting of vertex normals.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportDisplaySet.vertexNumberVisibility">
<code class="descname">vertexNumberVisibility</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.markerVisibility<a class="headerlink" href="#hou.GeometryViewportDisplaySet.vertexNumberVisibility" title="Permalink to this definition"></a></dt>
<dd><p>Query the visibility setting of vertex numbers.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportDisplaySet.vertexUVVisibility">
<code class="descname">vertexUVVisibility</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.markerVisibility<a class="headerlink" href="#hou.GeometryViewportDisplaySet.vertexUVVisibility" title="Permalink to this definition"></a></dt>
<dd><p>Query the visibility setting of vertex UVs.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.GeometryViewportSettings">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">GeometryViewportSettings</code><a class="headerlink" href="#hou.GeometryViewportSettings" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>REPLACES</p>
<blockquote>
<div><ul class="simple">
<li>cplane</li>
<li>viewbackground</li>
<li>viewcamera</li>
<li>viewcopy</li>
<li>viewdisplay</li>
<li>viewls</li>
<li>viewname</li>
<li>vieworthogrid</li>
<li>viewprojection</li>
<li>viewsnapshot</li>
<li>viewtransform</li>
<li>viewtype</li>
<li>viewuvgrid</li>
</ul>
</div></blockquote>
<dl class="method">
<dt id="hou.GeometryViewportSettings.agentLODReduction">
<code class="descname">agentLODReduction</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportSettings.agentLODReduction" title="Permalink to this definition"></a></dt>
<dd><p>Query if mutliple levels of detail (LOD) are generated for crowd
agents.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.agentLODReductionBias">
<code class="descname">agentLODReductionBias</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.GeometryViewportSettings.agentLODReductionBias" title="Permalink to this definition"></a></dt>
<dd><p>Query the LOD bias for agents.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.agentShapePointCutoff">
<code class="descname">agentShapePointCutoff</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.GeometryViewportSettings.agentShapePointCutoff" title="Permalink to this definition"></a></dt>
<dd><p>Query the minimum number of points in an agent LOD level.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.agentWireframe">
<code class="descname">agentWireframe</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.viewportAgentWireframe<a class="headerlink" href="#hou.GeometryViewportSettings.agentWireframe" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Query the appearance of agents in wireframe mode.</div></blockquote>
<ul>
<li><p class="first">hou.viewportAgentWireframe.Bone:</p>
<blockquote>
<div><p>Agents are rendered as bone-based skeletons.</p>
</div></blockquote>
</li>
<li><p class="first">hou.viewportAgentWireframe.Line:</p>
<blockquote>
<div><p>Agents are rendered as line-based skeletons.</p>
</div></blockquote>
</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.allowParticleSprites">
<code class="descname">allowParticleSprites</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportSettings.allowParticleSprites" title="Permalink to this definition"></a></dt>
<dd><p>Query if particles are drawn as sprites when sprite attributes are
detected on the particle (sprite* or shop_materialpath).</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.ambientOcclusion">
<code class="descname">ambientOcclusion</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportSettings.ambientOcclusion" title="Permalink to this definition"></a></dt>
<dd><p>Query if ambient occlusion is enabled. This can return true even if
not in a high quality mode as this queries the raw display option
value, not a reflection of whether the pass is active. If querying
it the pass is active, the lighting mode should also be checked.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.ambientOcclusionLevel">
<code class="descname">ambientOcclusionLevel</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.GeometryViewportSettings.ambientOcclusionLevel" title="Permalink to this definition"></a></dt>
<dd><p>Return the current occlusion level for ambient occlusion.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.applyZoomToBackgroundImage">
<code class="descname">applyZoomToBackgroundImage</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportSettings.applyZoomToBackgroundImage" title="Permalink to this definition"></a></dt>
<dd><p>Query if the camera zoom is affecting the background image.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.aspectRatio">
<code class="descname">aspectRatio</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#hou.GeometryViewportSettings.aspectRatio" title="Permalink to this definition"></a></dt>
<dd><p>Query the viewport aspect ratio display option. Use
viewAspectRatio() to query the current viewport aspect ratio.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.autoGenerateVertexNormals">
<code class="descname">autoGenerateVertexNormals</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportSettings.autoGenerateVertexNormals" title="Permalink to this definition"></a></dt>
<dd><p>Query if vertex normals are produced when geometry is missing
normals. If false, point numbers are produced.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.backgroundImage">
<code class="descname">backgroundImage</code><span class="sig-paren">(</span><em>self</em>, <em>viewportBGImageView</em>, <em>layer</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.backgroundImage" title="Permalink to this definition"></a></dt>
<dd><p>hou.GeometryViewportBGImage</p>
<blockquote>
<div>Access the background image parameters for the target view type.
layer is currently not used but reserved for future use.</div></blockquote>
<ul>
<li><p class="first">hou.viewportBGImageView.Perspective:</p>
<blockquote>
<div><p>The 3D view not attached to a camera (No cam).</p>
</div></blockquote>
</li>
<li><p class="first">hou.viewportBGImageView.Camera:</p>
<blockquote>
<div><p>The 3D view looking through a camera.</p>
</div></blockquote>
</li>
<li><p class="first">hou.viewportBGImageView.Top:</p>
<blockquote>
<div><p>The orthographic top view.</p>
</div></blockquote>
</li>
<li><p class="first">hou.viewportBGImageView.Front:</p>
<blockquote>
<div><p>The orthographic front view.</p>
</div></blockquote>
</li>
<li><p class="first">hou.viewportBGImageView.Right:</p>
<blockquote>
<div><p>The orthographic right view.</p>
</div></blockquote>
</li>
<li><p class="first">hou.viewportBGImageView.Bottom:</p>
<blockquote>
<div><p>The orthographic bottom view.</p>
</div></blockquote>
</li>
<li><p class="first">hou.viewportBGImageView.Back:</p>
<blockquote>
<div><p>The orthographic back view.</p>
</div></blockquote>
</li>
<li><p class="first">hou.viewportBGImageView.Left:</p>
<blockquote>
<div><p>The orthographic left view.</p>
</div></blockquote>
</li>
<li><p class="first">hou.viewportBGImageView.UV:</p>
<blockquote>
<div><p>The UV texture viewport.</p>
</div></blockquote>
</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.backgroundImageGammaLUT">
<code class="descname">backgroundImageGammaLUT</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportSettings.backgroundImageGammaLUT" title="Permalink to this definition"></a></dt>
<dd><p>Query if color correction is applied to the background image.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.backgroundImageQuality">
<code class="descname">backgroundImageQuality</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.GeometryViewportSettings.backgroundImageQuality" title="Permalink to this definition"></a></dt>
<dd><p>Query the quality of background image display, from 0-100.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.baseLODLevel">
<code class="descname">baseLODLevel</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.GeometryViewportSettings.baseLODLevel" title="Permalink to this definition"></a></dt>
<dd><p>Query the base level of detail.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.camera">
<code class="descname">camera</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; ObjNode or None<a class="headerlink" href="#hou.GeometryViewportSettings.camera" title="Permalink to this definition"></a></dt>
<dd><p>Return the camera or light node that the viewport is looking
through. Return None if the viewport is not looking through a camera
or light node.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.clampUVGridToBackground">
<code class="descname">clampUVGridToBackground</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportSettings.clampUVGridToBackground" title="Permalink to this definition"></a></dt>
<dd><p>Query if the grid is restricted to the background images area.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.clipPlanes">
<code class="descname">clipPlanes</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of float<a class="headerlink" href="#hou.GeometryViewportSettings.clipPlanes" title="Permalink to this definition"></a></dt>
<dd><p>Query the near and far camera clip planes, returning them in a
2-tuple.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.closureSelection">
<code class="descname">closureSelection</code><span class="sig-paren">(</span><em>self</em>, <em>hou.viewportClosureSelection</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.closureSelection" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Change the closure selection display setting. A Closure selection is
shown on a primitive when any part of that primitive is selected.</div></blockquote>
<ul class="simple">
<li>hou.viewportClosureSelection.Hide: Do not show closure selections.</li>
<li>hou.viewportClosureSelection.HullPrimitives: Only show closure
selections on primitives that have hulls which are disconnected from
the tessellated surface or curve (such as a NURBS surface).</li>
<li>hou.viewportClosureSelection.Show: Show closure selections on all
primitive types.</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.colorScheme">
<code class="descname">colorScheme</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.viewportColorScheme<a class="headerlink" href="#hou.GeometryViewportSettings.colorScheme" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Query the current viewport color scheme.</div></blockquote>
<ul>
<li><p class="first">hou.viewportColorScheme.Dark:</p>
<blockquote>
<div><p>Black background.</p>
</div></blockquote>
</li>
<li><p class="first">hou.viewportColorScheme.Grey:</p>
<blockquote>
<div><p>Light grey background.</p>
</div></blockquote>
</li>
<li><p class="first">hou.viewportColorScheme.Light:</p>
<blockquote>
<div><p>Light blue gradient background.</p>
</div></blockquote>
</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.defaultMaterialAmbient">
<code class="descname">defaultMaterialAmbient</code><span class="sig-paren">(</span><em>self</em>, <em>tint</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.defaultMaterialAmbient" title="Permalink to this definition"></a></dt>
<dd><p>Set the ambient color of the default material (used when no material
assignment is present or Show Materials is disabled).</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.defaultMaterialDiffuse">
<code class="descname">defaultMaterialDiffuse</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Color<a class="headerlink" href="#hou.GeometryViewportSettings.defaultMaterialDiffuse" title="Permalink to this definition"></a></dt>
<dd><p>Query the default materials diffuse color.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.defaultMaterialEmission">
<code class="descname">defaultMaterialEmission</code><span class="sig-paren">(</span><em>self</em>, <em>tint</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.defaultMaterialEmission" title="Permalink to this definition"></a></dt>
<dd><p>Set the emission color of the default material (used when no
material assignment is present or Show Materials is disabled).</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.defaultMaterialSpecular">
<code class="descname">defaultMaterialSpecular</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Color<a class="headerlink" href="#hou.GeometryViewportSettings.defaultMaterialSpecular" title="Permalink to this definition"></a></dt>
<dd><p>Query the default materials specular color.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.displacementLevel">
<code class="descname">displacementLevel</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; double<a class="headerlink" href="#hou.GeometryViewportSettings.displacementLevel" title="Permalink to this definition"></a></dt>
<dd><p>Query the level of detail used for displacement mapping.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.displayBackgroundImage">
<code class="descname">displayBackgroundImage</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportSettings.displayBackgroundImage" title="Permalink to this definition"></a></dt>
<dd><p>Query if background image display is globally enabled.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.displayEnvironmentBackgroundImage">
<code class="descname">displayEnvironmentBackgroundImage</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportSettings.displayEnvironmentBackgroundImage" title="Permalink to this definition"></a></dt>
<dd><p>Query if environmenty lights envirnoment maps are shown as 360
degree background images.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.displayOrthoGrid">
<code class="descname">displayOrthoGrid</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportSettings.displayOrthoGrid" title="Permalink to this definition"></a></dt>
<dd><p>Query if the grid is displayed in fixed orthographic views.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.displayProjectedTextures">
<code class="descname">displayProjectedTextures</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportSettings.displayProjectedTextures" title="Permalink to this definition"></a></dt>
<dd><p>Query if projected textures from spotlights are rendered.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.displaySet">
<code class="descname">displaySet</code><span class="sig-paren">(</span><em>self</em>, <em>display_set</em><span class="sig-paren">)</span> &#x2192; GeometryViewportDisplaySet<a class="headerlink" href="#hou.GeometryViewportSettings.displaySet" title="Permalink to this definition"></a></dt>
<dd><p>Returns the display set associated with the context display_set,
which contains context-sensitive display options such as Draw Mode
and Point Numbers.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.displayTextureLayers">
<code class="descname">displayTextureLayers</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportSettings.displayTextureLayers" title="Permalink to this definition"></a></dt>
<dd><p>Query if multiple texture layers are rendered.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.displayTextures">
<code class="descname">displayTextures</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportSettings.displayTextures" title="Permalink to this definition"></a></dt>
<dd><p>Query if material texturing is enabled.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.displayUVTileBoundaries">
<code class="descname">displayUVTileBoundaries</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportSettings.displayUVTileBoundaries" title="Permalink to this definition"></a></dt>
<dd><p>Query if the boundaries of UV tiles are displayed.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.distanceBasedPackedCulling">
<code class="descname">distanceBasedPackedCulling</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportSettings.distanceBasedPackedCulling" title="Permalink to this definition"></a></dt>
<dd><p>Query if packed primitive culling is enabled.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.enableGuide">
<code class="descname">enableGuide</code><span class="sig-paren">(</span><em>self</em>, <em>hou.viewportGuide</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.enableGuide" title="Permalink to this definition"></a></dt>
<dd><p>Show or hide the guide specified by hou.viewportGuide.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.filterBackgroundImage">
<code class="descname">filterBackgroundImage</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportSettings.filterBackgroundImage" title="Permalink to this definition"></a></dt>
<dd><p>Query if texture filtering of background images is enabled.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.geometryInfo">
<code class="descname">geometryInfo</code><span class="sig-paren">(</span><em>self</em>, <em>hou.viewportGeometryInfo</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.geometryInfo" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Queries the current geometry information display setting:</div></blockquote>
<ul class="simple">
<li>hou.viewportGeometryInfo.Off: No information displayed.</li>
<li>hou.viewportGeometryInfo.SelectedOnly: only display information if
something is selected.</li>
<li>hou.viewportGeometryInfo.Always: Always display information.</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.guideEnabled">
<code class="descname">guideEnabled</code><span class="sig-paren">(</span><em>self</em>, <em>hou.viewportGuide</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportSettings.guideEnabled" title="Permalink to this definition"></a></dt>
<dd><p>Query if the guide specified by hou.viewportGuide is shown (True) or
hidden (False).</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.guideFontSize">
<code class="descname">guideFontSize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.guideFontSize" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.handleHighlight">
<code class="descname">handleHighlight</code><span class="sig-paren">(</span><em>self</em>, <em>hou.viewportHandleHighlight</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.handleHighlight" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Sets the size of the handle highlight when the mouse is over a
handle part:</div></blockquote>
<ul class="simple">
<li>hou.viewportHandleHighlight.Off: Handles do not show highlights.</li>
<li>hou.viewportHandleHighlight.Small: Handles have a subtle highlight.</li>
<li>hou.viewportHandleHighlight.Normal: Handles use their default
highlight, which is twice the width of the small highlight.</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.hdrReflections">
<code class="descname">hdrReflections</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportSettings.hdrReflections" title="Permalink to this definition"></a></dt>
<dd><p>Query if High Dynamic Range (HDR) color buffers are use for the
scene cubemap.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.hdrRendering">
<code class="descname">hdrRendering</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.hdrRendering" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.headlightDirection">
<code class="descname">headlightDirection</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of double<a class="headerlink" href="#hou.GeometryViewportSettings.headlightDirection" title="Permalink to this definition"></a></dt>
<dd><p>Query the vector direction of the headlight.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.headlightIntensity">
<code class="descname">headlightIntensity</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; double<a class="headerlink" href="#hou.GeometryViewportSettings.headlightIntensity" title="Permalink to this definition"></a></dt>
<dd><p>Query the intensity of the headlight.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.headlightSpecular">
<code class="descname">headlightSpecular</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportSettings.headlightSpecular" title="Permalink to this definition"></a></dt>
<dd><p>Query if specular reflections are generated by the headlight.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.homeAutoAdjustClip">
<code class="descname">homeAutoAdjustClip</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.viewportHomeClipMode<a class="headerlink" href="#hou.GeometryViewportSettings.homeAutoAdjustClip" title="Permalink to this definition"></a></dt>
<dd><p>Queries which camara clip planes are adjusted when performing a
homing operation.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.hullsOnly">
<code class="descname">hullsOnly</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportSettings.hullsOnly" title="Permalink to this definition"></a></dt>
<dd><p>Query if only hulls are drawn for complex curves and surfaces.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.instanceStandInGeometry">
<code class="descname">instanceStandInGeometry</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.viewportStandInGeometry<a class="headerlink" href="#hou.GeometryViewportSettings.instanceStandInGeometry" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Query the current stand-in geometry for culled instances.</div></blockquote>
<ul class="simple">
<li>hou.viewportStandInGeometry.DisplayOff: Show nothing for culled
instances.</li>
<li>hou.viewportStandInGeometry.LocationMarker: Show a location marker
at the local space origin of each instanced.</li>
<li>hou.viewportStandInGeometry.BoundingBox: Show the culled instances
bounding boxes.</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.interactiveMaterialUpdate">
<code class="descname">interactiveMaterialUpdate</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportSettings.interactiveMaterialUpdate" title="Permalink to this definition"></a></dt>
<dd><p>Query if materials are updated when they change.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.interiorWireAlpha">
<code class="descname">interiorWireAlpha</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; double<a class="headerlink" href="#hou.GeometryViewportSettings.interiorWireAlpha" title="Permalink to this definition"></a></dt>
<dd><p>Query the dimness of the interior wires in a tet mesh. Outer wires
are drawn normally, inner wires are dimmed. This only affects tet
meshes in wireframe mode.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.levelOfDetail">
<code class="descname">levelOfDetail</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; double<a class="headerlink" href="#hou.GeometryViewportSettings.levelOfDetail" title="Permalink to this definition"></a></dt>
<dd><p>Query the current level of detail used for tessellating geometry.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.lightSampling">
<code class="descname">lightSampling</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.GeometryViewportSettings.lightSampling" title="Permalink to this definition"></a></dt>
<dd><p>Query the number of lighting samples.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.lighting">
<code class="descname">lighting</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.viewportLighting<a class="headerlink" href="#hou.GeometryViewportSettings.lighting" title="Permalink to this definition"></a></dt>
<dd><p>Query the current global lighting mode.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.materialUpdate">
<code class="descname">materialUpdate</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.viewportMaterialUpdate<a class="headerlink" href="#hou.GeometryViewportSettings.materialUpdate" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Query the material assignment update frequency.</div></blockquote>
<ul>
<li><p class="first">hou.viewportMaterialUpdate.Always:</p>
<blockquote>
<div><p>Update assignments whenever needeed.</p>
</div></blockquote>
</li>
<li><p class="first">hou.viewportMaterialUpdate.OffForPlayback:</p>
<blockquote>
<div><p>Update assignments whenever needed, but not during playback.</p>
</div></blockquote>
</li>
<li><p class="first">hou.viewportMaterialUpdate.Manual:</p>
<blockquote>
<div><p>Only update assignments when Update Materials is pressed.</p>
</div></blockquote>
</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.maxLODLevels">
<code class="descname">maxLODLevels</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.GeometryViewportSettings.maxLODLevels" title="Permalink to this definition"></a></dt>
<dd><p>Query the maximum number of levels generated for an agent.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.minHomeSize">
<code class="descname">minHomeSize</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#hou.GeometryViewportSettings.minHomeSize" title="Permalink to this definition"></a></dt>
<dd><p>Query the smallest area that viewport can home to, in world units.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.minReflectAmount">
<code class="descname">minReflectAmount</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; double<a class="headerlink" href="#hou.GeometryViewportSettings.minReflectAmount" title="Permalink to this definition"></a></dt>
<dd><p>Query the minimum reflection level required for a cubemap to be
generated for an object.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.normalScale">
<code class="descname">normalScale</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.normalScale" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.objectOrigins">
<code class="descname">objectOrigins</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportSettings.objectOrigins" title="Permalink to this definition"></a></dt>
<dd><p>Query if object origin display is globally enabled.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.offsetVertexMarkers">
<code class="descname">offsetVertexMarkers</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportSettings.offsetVertexMarkers" title="Permalink to this definition"></a></dt>
<dd><p>When enabled, vertex markers and normals are inset into the polygon
so they can be selected independently when part of a seemless mesh.
When disabled, the markers and normals are placed at the actual
vertex, potentially overlapping.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.onionSkinFrameIncrement">
<code class="descname">onionSkinFrameIncrement</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.GeometryViewportSettings.onionSkinFrameIncrement" title="Permalink to this definition"></a></dt>
<dd><p>Query the frame increment between onion skins.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.onionSkinFramesAfterCount">
<code class="descname">onionSkinFramesAfterCount</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.GeometryViewportSettings.onionSkinFramesAfterCount" title="Permalink to this definition"></a></dt>
<dd><p>Queries the number of onion skins after the current frame.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.onionSkinFramesAfterTint">
<code class="descname">onionSkinFramesAfterTint</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of double<a class="headerlink" href="#hou.GeometryViewportSettings.onionSkinFramesAfterTint" title="Permalink to this definition"></a></dt>
<dd><p>Query the tint color of skins that appear after the current frame.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.onionSkinFramesBeforeCount">
<code class="descname">onionSkinFramesBeforeCount</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.GeometryViewportSettings.onionSkinFramesBeforeCount" title="Permalink to this definition"></a></dt>
<dd><p>Queries the number of onion skins before the current frame.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.onionSkinFramesBeforeTint">
<code class="descname">onionSkinFramesBeforeTint</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of double<a class="headerlink" href="#hou.GeometryViewportSettings.onionSkinFramesBeforeTint" title="Permalink to this definition"></a></dt>
<dd><p>Query the tint color of skins that appear before the current frame.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.onionSkinOpacity">
<code class="descname">onionSkinOpacity</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; double<a class="headerlink" href="#hou.GeometryViewportSettings.onionSkinOpacity" title="Permalink to this definition"></a></dt>
<dd><p>Query the current onion skin opacity.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.onionSkinning">
<code class="descname">onionSkinning</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportSettings.onionSkinning" title="Permalink to this definition"></a></dt>
<dd><p>Query if onion skinning is globally enabled.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.optimizeGeometry">
<code class="descname">optimizeGeometry</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportSettings.optimizeGeometry" title="Permalink to this definition"></a></dt>
<dd><p>Query if packed geometry is optimized.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.orientDiscToNormal">
<code class="descname">orientDiscToNormal</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportSettings.orientDiscToNormal" title="Permalink to this definition"></a></dt>
<dd><p>Queries if discs and sprites are oriented to the normal (true) or
not. The normal will be orthoganal to the disc (they will face in
that direction).</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.originGnomonSize">
<code class="descname">originGnomonSize</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#hou.GeometryViewportSettings.originGnomonSize" title="Permalink to this definition"></a></dt>
<dd><p>Queries the world size of the gnomon axes that appear at the world
origin.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.orthoRuler">
<code class="descname">orthoRuler</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.viewportGridRuler<a class="headerlink" href="#hou.GeometryViewportSettings.orthoRuler" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Query where the grid numbers are displayed on the fixed orthographic
view grid.</div></blockquote>
<ul>
<li><p class="first">hou.viewportGridRuler.Hide:</p>
<blockquote>
<div><p>Not displayed.</p>
</div></blockquote>
</li>
<li><p class="first">hou.viewportGridRuler.MainAxis:</p>
<blockquote>
<div><p>Displayed along the main axes at grid line intersections.</p>
</div></blockquote>
</li>
<li><p class="first">hou.viewportGridRuler.GridPoints:</p>
<blockquote>
<div><p>Displayed on grid line intersections.</p>
</div></blockquote>
</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.othroGridOffset">
<code class="descname">othroGridOffset</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of float<a class="headerlink" href="#hou.GeometryViewportSettings.othroGridOffset" title="Permalink to this definition"></a></dt>
<dd><p>Query the offset of the grid in fixed orthographics views.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.othroGridRuler">
<code class="descname">othroGridRuler</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of int<a class="headerlink" href="#hou.GeometryViewportSettings.othroGridRuler" title="Permalink to this definition"></a></dt>
<dd><p>Query the spacing of the grid numbers in fixed orthographics views
as a 2-tuple.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.othroGridSpacing">
<code class="descname">othroGridSpacing</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of float<a class="headerlink" href="#hou.GeometryViewportSettings.othroGridSpacing" title="Permalink to this definition"></a></dt>
<dd><p>Query the spacing of the grid lines in fixed orthographics views as
a 2-tuple.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.packedBoundingBoxMode">
<code class="descname">packedBoundingBoxMode</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.viewportPackedBoxMode<a class="headerlink" href="#hou.GeometryViewportSettings.packedBoundingBoxMode" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Query how culled packed primitives are displayed.</div></blockquote>
<ul>
<li><p class="first">hou.viewportPackedBoxMode.NoDisplay:</p>
<blockquote>
<div><p>Culled packed primitives are not displayed at all.</p>
</div></blockquote>
</li>
<li><p class="first">hou.viewportPackedBoxMode.Wireframe:</p>
<blockquote>
<div><p>A wireframe bounding box replaces the packed primitive.</p>
</div></blockquote>
</li>
<li><p class="first">hou.viewportPackedBoxMode.Shaded:</p>
<blockquote>
<div><p>A shaded bounding box replaces the packed primitive.</p>
</div></blockquote>
</li>
<li><p class="first">hou.viewportPackedBoxMode.CurrentShadingMode:</p>
<blockquote>
<div><p>A bounding box replaces the packed primitive, drawn wireframe in
wireframe shading modes and shaded otherwise.</p>
</div></blockquote>
</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.particleDiscSize">
<code class="descname">particleDiscSize</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; double<a class="headerlink" href="#hou.GeometryViewportSettings.particleDiscSize" title="Permalink to this definition"></a></dt>
<dd><p>Query the disc diameter for particles drawn as Discs or Sprites if
the pscale attribute does not exist. This is specified in world-
space units.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.particleDisplayType">
<code class="descname">particleDisplayType</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.viewportParticleDisplay<a class="headerlink" href="#hou.GeometryViewportSettings.particleDisplayType" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Query the default particle display.</div></blockquote>
<ul class="simple">
<li>hou.viewportParticleDisplay.Points: Constant sized point marker,
with the diameter specified by particlePointSize. This marker is
unaffected by pscale.</li>
<li>hou.viewportParticleDisplay.Pixels: Single pixel drawn for a
particle.</li>
<li>hou.viewportParticleDisplay.Lines: Streak trail plus marker.</li>
<li>hou.viewportParticleDisplay.Discs: World-space circle, affected by
pscale or discSize.</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.particlePointSize">
<code class="descname">particlePointSize</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; double<a class="headerlink" href="#hou.GeometryViewportSettings.particlePointSize" title="Permalink to this definition"></a></dt>
<dd><p>Query the point diameter for particles drawn as Points or Lines.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.pointInstancing">
<code class="descname">pointInstancing</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportSettings.pointInstancing" title="Permalink to this definition"></a></dt>
<dd><p>Query if point instancing is globally enabled.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.pointInstancingLimit">
<code class="descname">pointInstancingLimit</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.GeometryViewportSettings.pointInstancingLimit" title="Permalink to this definition"></a></dt>
<dd><p>Query the current polygon limit for instancing.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.pointInstancingPercent">
<code class="descname">pointInstancingPercent</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; double<a class="headerlink" href="#hou.GeometryViewportSettings.pointInstancingPercent" title="Permalink to this definition"></a></dt>
<dd><p>Query the percentage of instances shown in the viewport for point
instancing.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.pointMarkerSize">
<code class="descname">pointMarkerSize</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#hou.GeometryViewportSettings.pointMarkerSize" title="Permalink to this definition"></a></dt>
<dd><p>Queries the size of point marker decorations, in pixels.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.polygonConvexQuality">
<code class="descname">polygonConvexQuality</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportSettings.polygonConvexQuality" title="Permalink to this definition"></a></dt>
<dd><p>Query the polygon convexing quality, true for high quality and false
for fast convexing.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.reflectMapSize">
<code class="descname">reflectMapSize</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.GeometryViewportSettings.reflectMapSize" title="Permalink to this definition"></a></dt>
<dd><p>Query the size of reflection cubemaps.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.removeBackfaces">
<code class="descname">removeBackfaces</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportSettings.removeBackfaces" title="Permalink to this definition"></a></dt>
<dd><p>Query if backwards facing polygons are culled.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.saveViewToCamera">
<code class="descname">saveViewToCamera</code><span class="sig-paren">(</span><em>self</em>, <em>camera_node</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.saveViewToCamera" title="Permalink to this definition"></a></dt>
<dd><p>Saves the viewports current view into the given camera node. It
does this by setting the cameras transform parameters to match the
viewports view transform matrix.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.sceneAntialias">
<code class="descname">sceneAntialias</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.sceneAntialias" title="Permalink to this definition"></a></dt>
<dd><p>Returns the number of samples used to antialias the viewport.
Possible values are 1 (no antialiasing), 2, 4 (default for most
hardware), 8, 16, 32, 64, or 128.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.sceneGamma">
<code class="descname">sceneGamma</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; double<a class="headerlink" href="#hou.GeometryViewportSettings.sceneGamma" title="Permalink to this definition"></a></dt>
<dd><p>Query the scene gamma correction.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.sceneLUT">
<code class="descname">sceneLUT</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.GeometryViewportSettings.sceneLUT" title="Permalink to this definition"></a></dt>
<dd><p>Query the current Lookup Table (LUT) file.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.scenePolygonLimit">
<code class="descname">scenePolygonLimit</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.GeometryViewportSettings.scenePolygonLimit" title="Permalink to this definition"></a></dt>
<dd><p>Query the maximum allowed number of polygons in the view frustum, in
millions of polygons.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.selectWireframeAsSolid">
<code class="descname">selectWireframeAsSolid</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportSettings.selectWireframeAsSolid" title="Permalink to this definition"></a></dt>
<dd><p>Query if selection of wireframe polygons is done by face (true) or
edge (false).</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setAgentLODReduction">
<code class="descname">setAgentLODReduction</code><span class="sig-paren">(</span><em>self</em>, <em>enable</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setAgentLODReduction" title="Permalink to this definition"></a></dt>
<dd><p>Enable the use of multiple levels of detail for crowd agents, each
LOD level being half the polygon count of the previous level.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setAgentLODReductionBias">
<code class="descname">setAgentLODReductionBias</code><span class="sig-paren">(</span><em>self</em>, <em>reduce_bias</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setAgentLODReductionBias" title="Permalink to this definition"></a></dt>
<dd><p>Set the LOD balance from Performance (0) to Quality (10), which
biases which LOD levels are chosen.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setAgentShapePointCutoff">
<code class="descname">setAgentShapePointCutoff</code><span class="sig-paren">(</span><em>self</em>, <em>num_points</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setAgentShapePointCutoff" title="Permalink to this definition"></a></dt>
<dd><p>Set the minimum number of points in an agent LOD level. If an LOD
level would go below this number, it is not generated.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setAgentWireframe">
<code class="descname">setAgentWireframe</code><span class="sig-paren">(</span><em>self</em>, <em>viewportAgentWireframe</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setAgentWireframe" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Set the appearance of agents in wireframe mode.</div></blockquote>
<ul>
<li><p class="first">hou.viewportAgentWireframe.Bone:</p>
<blockquote>
<div><p>Agents are rendered as bone-based skeletons.</p>
</div></blockquote>
</li>
<li><p class="first">hou.viewportAgentWireframe.Line:</p>
<blockquote>
<div><p>Agents are rendered as line-based skeletons.</p>
</div></blockquote>
</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setAmbientOcclusion">
<code class="descname">setAmbientOcclusion</code><span class="sig-paren">(</span><em>self</em>, <em>enable</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setAmbientOcclusion" title="Permalink to this definition"></a></dt>
<dd><p>Enable an ambient occlusion pass in high quality lighting modes.
This generates local occlusion shadows.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setAmbientOcclusionLevel">
<code class="descname">setAmbientOcclusionLevel</code><span class="sig-paren">(</span><em>self</em>, <em>level</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setAmbientOcclusionLevel" title="Permalink to this definition"></a></dt>
<dd><p>Set the level of occlusion to generate, from 1-4. Higher levels
produce a larger area of effect, while lower values produce fine
detail.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setApplyZoomToBackgroundImage">
<code class="descname">setApplyZoomToBackgroundImage</code><span class="sig-paren">(</span><em>self</em>, <em>enable</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setApplyZoomToBackgroundImage" title="Permalink to this definition"></a></dt>
<dd><p>Allow the camera zoom to affect the background image.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setAspectRatio">
<code class="descname">setAspectRatio</code><span class="sig-paren">(</span><em>self</em>, <em>aspect</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setAspectRatio" title="Permalink to this definition"></a></dt>
<dd><p>Set the viewport aspect ratio (width/height).</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setBackgroundImageGammaLUT">
<code class="descname">setBackgroundImageGammaLUT</code><span class="sig-paren">(</span><em>self</em>, <em>apply_to_bg</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setBackgroundImageGammaLUT" title="Permalink to this definition"></a></dt>
<dd><p>Apply gamma and Lookup Table (LUT) color correction to the
background image.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setBackgroundImageQuality">
<code class="descname">setBackgroundImageQuality</code><span class="sig-paren">(</span><em>self</em>, <em>quality</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setBackgroundImageQuality" title="Permalink to this definition"></a></dt>
<dd><p>Set the quality of the background image, from 0-100. Values less
than 100 will scale down the resolution of the background image.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setBaseLODLevel">
<code class="descname">setBaseLODLevel</code><span class="sig-paren">(</span><em>self</em>, <em>base_level</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setBaseLODLevel" title="Permalink to this definition"></a></dt>
<dd><p>Set the level to use as the full level of detail model, generally 0
(the original agent model). For very heavy poly count agents, this
can be set to higher values to reduce the polygon count of the
highest level of detail model.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setCamera">
<code class="descname">setCamera</code><span class="sig-paren">(</span><em>self</em>, <em>camera_node</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setCamera" title="Permalink to this definition"></a></dt>
<dd><p>Makes the viewport look through the given camera node.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setClampUVGridToBackground">
<code class="descname">setClampUVGridToBackground</code><span class="sig-paren">(</span><em>self</em>, <em>enable</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setClampUVGridToBackground" title="Permalink to this definition"></a></dt>
<dd><p>Restrict the grid to the background images area.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setClipPlanes">
<code class="descname">setClipPlanes</code><span class="sig-paren">(</span><em>self</em>, <em>clip</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setClipPlanes" title="Permalink to this definition"></a></dt>
<dd><p>Set the near and far camera clip planes from a 2-tuple.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setColorScheme">
<code class="descname">setColorScheme</code><span class="sig-paren">(</span><em>self</em>, <em>viewportColorScheme</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setColorScheme" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Set the color scheme for the viewport.</div></blockquote>
<ul>
<li><p class="first">hou.viewportColorScheme.Dark:</p>
<blockquote>
<div><p>Black background.</p>
</div></blockquote>
</li>
<li><p class="first">hou.viewportColorScheme.Grey:</p>
<blockquote>
<div><p>Light grey background.</p>
</div></blockquote>
</li>
<li><p class="first">hou.viewportColorScheme.Light:</p>
<blockquote>
<div><p>Light blue gradient background.</p>
</div></blockquote>
</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setDefaultMaterialAmbient">
<code class="descname">setDefaultMaterialAmbient</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Color<a class="headerlink" href="#hou.GeometryViewportSettings.setDefaultMaterialAmbient" title="Permalink to this definition"></a></dt>
<dd><p>Query the default materials ambient color.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setDefaultMaterialDiffuse">
<code class="descname">setDefaultMaterialDiffuse</code><span class="sig-paren">(</span><em>self</em>, <em>tint</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setDefaultMaterialDiffuse" title="Permalink to this definition"></a></dt>
<dd><p>Set the diffuse color of the default material (used when no material
assignment is present or Show Materials is disabled).</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setDefaultMaterialEmission">
<code class="descname">setDefaultMaterialEmission</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Color<a class="headerlink" href="#hou.GeometryViewportSettings.setDefaultMaterialEmission" title="Permalink to this definition"></a></dt>
<dd><p>Query the default materials emission color.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setDefaultMaterialSpecular">
<code class="descname">setDefaultMaterialSpecular</code><span class="sig-paren">(</span><em>self</em>, <em>tint</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setDefaultMaterialSpecular" title="Permalink to this definition"></a></dt>
<dd><p>Set the specular color of the default material (used when no
material assignment is present or Show Materials is disabled).</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setDisplacementLevel">
<code class="descname">setDisplacementLevel</code><span class="sig-paren">(</span><em>self</em>, <em>level</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setDisplacementLevel" title="Permalink to this definition"></a></dt>
<dd><p>Set the level of detail for displacement mapping. Displacement
mapping adaptively subdivides the geometry to provide finer detail.
Higher values result in denser subdivision, while lower values
prodce lighter meshes. The default is 1.0.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setDisplayBackgroundImage">
<code class="descname">setDisplayBackgroundImage</code><span class="sig-paren">(</span><em>self</em>, <em>enable</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setDisplayBackgroundImage" title="Permalink to this definition"></a></dt>
<dd><p>Globally enable background image display.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setDisplayEnvironmentBackgroundImage">
<code class="descname">setDisplayEnvironmentBackgroundImage</code><span class="sig-paren">(</span><em>self</em>, <em>enable</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setDisplayEnvironmentBackgroundImage" title="Permalink to this definition"></a></dt>
<dd><p>Allow environment lights to show their environment maps as 360
degree background images.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setDisplayOrthoGrid">
<code class="descname">setDisplayOrthoGrid</code><span class="sig-paren">(</span><em>self</em>, <em>enable</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setDisplayOrthoGrid" title="Permalink to this definition"></a></dt>
<dd><p>Display the grid in fixed orthographic views (Top, Left, Front,
Bottom, Right, Back).</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setDisplayProjectedTextures">
<code class="descname">setDisplayProjectedTextures</code><span class="sig-paren">(</span><em>self</em>, <em>enable</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setDisplayProjectedTextures" title="Permalink to this definition"></a></dt>
<dd><p>Enable projected textures from spotlights with a valid texture.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setDisplayTextureLayers">
<code class="descname">setDisplayTextureLayers</code><span class="sig-paren">(</span><em>self</em>, <em>enable</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setDisplayTextureLayers" title="Permalink to this definition"></a></dt>
<dd><p>Enable multiple texture layers when texturing. This causes an extra
render of the geometry per texture layer.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setDisplayTextures">
<code class="descname">setDisplayTextures</code><span class="sig-paren">(</span><em>self</em>, <em>enable</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setDisplayTextures" title="Permalink to this definition"></a></dt>
<dd><p>Enable material texturing.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setDisplayUVTileBoundaries">
<code class="descname">setDisplayUVTileBoundaries</code><span class="sig-paren">(</span><em>self</em>, <em>enable</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setDisplayUVTileBoundaries" title="Permalink to this definition"></a></dt>
<dd><p>Display the boundaries of UV tiles at integral U and V numbers.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setDistanceBasedPackedCulling">
<code class="descname">setDistanceBasedPackedCulling</code><span class="sig-paren">(</span><em>self</em>, <em>enable</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setDistanceBasedPackedCulling" title="Permalink to this definition"></a></dt>
<dd><p>Enable culling of packed primitives when the polygon count of the
visible objects in the frustum exceeds a certain amount, starting
with the most distant.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setFilterBackgroundImage">
<code class="descname">setFilterBackgroundImage</code><span class="sig-paren">(</span><em>self</em>, <em>enable</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setFilterBackgroundImage" title="Permalink to this definition"></a></dt>
<dd><p>Enable texture filtering of background images. When off, individual
pixels are shown as blocks at high zoome levels rather than blended.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setHdrReflections">
<code class="descname">setHdrReflections</code><span class="sig-paren">(</span><em>self</em>, <em>hdr_reflect</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setHdrReflections" title="Permalink to this definition"></a></dt>
<dd><p>Enable High Dynamic Range (HDR) color buffers for the generated
scene cubemap, which allows for higher contrast and bright spots in
reflections.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setHdrRendering">
<code class="descname">setHdrRendering</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setHdrRendering" title="Permalink to this definition"></a></dt>
<dd><p>hdrRendering(self) -&gt; bool</p>
<blockquote>
<div>Queries if High Dynamic Range (HDR) rendering is enabled.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setHeadlightDirection">
<code class="descname">setHeadlightDirection</code><span class="sig-paren">(</span><em>self</em>, <em>dir</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setHeadlightDirection" title="Permalink to this definition"></a></dt>
<dd><p>Set the direction of the headlight used in Headlight lighting mode.
This is expressed as a direction vector in camera space (the camera
looks down -Z).</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setHeadlightIntensity">
<code class="descname">setHeadlightIntensity</code><span class="sig-paren">(</span><em>self</em>, <em>intensity</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setHeadlightIntensity" title="Permalink to this definition"></a></dt>
<dd><p>Set the intensity of the headlight used in Headlight lighting mode.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setHeadlightSpecular">
<code class="descname">setHeadlightSpecular</code><span class="sig-paren">(</span><em>self</em>, <em>enable</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setHeadlightSpecular" title="Permalink to this definition"></a></dt>
<dd><p>Enable specular reflections when in Headlight lighting mode. Turning
this off results in purely diffuse lighting.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setHomeAutoAdjustsClip">
<code class="descname">setHomeAutoAdjustsClip</code><span class="sig-paren">(</span><em>self</em>, <em>viewportHomeClipMode</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setHomeAutoAdjustsClip" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Set which camera clip planes are adjusted when performing a homing
operation.</div></blockquote>
<ul>
<li><p class="first">hou.viewportHomeClipMode.Neither:</p>
<blockquote>
<div><p>Neither clip plane is adjusted.</p>
</div></blockquote>
</li>
<li><p class="first">hou.viewportHomeClipMode.FarOnly:</p>
<blockquote>
<div><p>Only the far clip plane is adjusted.</p>
</div></blockquote>
</li>
<li><p class="first">hou.viewportHomeClipMode.NearOnly:</p>
<blockquote>
<div><p>Only the near clip plane is adjusted.</p>
</div></blockquote>
</li>
<li><p class="first">hou.viewportHomeClipMode.NearAndFar:</p>
<blockquote>
<div><p>Both clip planes are adjusted.</p>
</div></blockquote>
</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setHullsOnly">
<code class="descname">setHullsOnly</code><span class="sig-paren">(</span><em>self</em>, <em>enable</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setHullsOnly" title="Permalink to this definition"></a></dt>
<dd><p>Draw only hulls for complex curves and surfaces like NURBS and
Beziers.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setInteractiveMaterialUpdate">
<code class="descname">setInteractiveMaterialUpdate</code><span class="sig-paren">(</span><em>self</em>, <em>enable</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setInteractiveMaterialUpdate" title="Permalink to this definition"></a></dt>
<dd><p>Update materials when they are changed to reflect their new state.
When disabled, Update Materials must be pressed manually for changes
to be reflected in the viewport.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setLightSampling">
<code class="descname">setLightSampling</code><span class="sig-paren">(</span><em>self</em>, <em>num_samples</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setLightSampling" title="Permalink to this definition"></a></dt>
<dd><p>Set the number of lighting samples to perform when doing high
quality lighting for area and environment lights.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setLighting">
<code class="descname">setLighting</code><span class="sig-paren">(</span><em>self</em>, <em>viewportLighting</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setLighting" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Set the global lighting mode for all viewports.</div></blockquote>
<ul>
<li><p class="first">hou.viewportLighting.Off:</p>
<blockquote>
<div><p>No lighting, constant shaded.</p>
</div></blockquote>
</li>
<li><p class="first">hou.viewportLighting.Headlight:</p>
<blockquote>
<div><p>Basic lighting from a single directional light defined in the
display options.</p>
</div></blockquote>
</li>
<li><p class="first">hou.viewportLighting.Normal:</p>
<blockquote>
<div><p>Good quality lighting from up to 10 basic lights (area lights
modeled as point lights, limited environment lights).</p>
</div></blockquote>
</li>
<li><p class="first">hou.viewportLighting.HighQuality:</p>
<blockquote>
<div><p>High quality lighting from an unlimited number of lights
including area, geometry, environment and ambient occlusion.</p>
</div></blockquote>
</li>
<li><p class="first">hou.viewportLighting.HighQualityWithShadows:</p>
<blockquote>
<div><p>High quality lighting with shadows.</p>
</div></blockquote>
</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setMaterialUpdate">
<code class="descname">setMaterialUpdate</code><span class="sig-paren">(</span><em>self</em>, <em>viewportMaterialUpdate</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setMaterialUpdate" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Set the material assignment update frequeuncy.</div></blockquote>
<ul>
<li><p class="first">hou.viewportMaterialUpdate.Always:</p>
<blockquote>
<div><p>Update assignments whenever needeed.</p>
</div></blockquote>
</li>
<li><p class="first">hou.viewportMaterialUpdate.OffForPlayback:</p>
<blockquote>
<div><p>Update assignments whenever needed, but not during playback.</p>
</div></blockquote>
</li>
<li><p class="first">hou.viewportMaterialUpdate.Manual:</p>
<blockquote>
<div><p>Only update assignments when Update Materials is pressed.</p>
</div></blockquote>
</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setMaxLODLevels">
<code class="descname">setMaxLODLevels</code><span class="sig-paren">(</span><em>self</em>, <em>num_levels</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setMaxLODLevels" title="Permalink to this definition"></a></dt>
<dd><p>Set the maximum number of levels to generate for an agent. This will
be the original model plus this number.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setMinHomeSize">
<code class="descname">setMinHomeSize</code><span class="sig-paren">(</span><em>self</em>, <em>min_size</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setMinHomeSize" title="Permalink to this definition"></a></dt>
<dd><p>Set the smallest area that viewport can home to, in world units.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setMinReflectAmount">
<code class="descname">setMinReflectAmount</code><span class="sig-paren">(</span><em>self</em>, <em>min_reflect</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setMinReflectAmount" title="Permalink to this definition"></a></dt>
<dd><p>Set the minimum level of reflection required for a reflection
cubemap to be generated for an object. This is based on the largest
reflective value from all the materials assigned to the object. The
larger this value, the more reflective an object must be to generate
a reflection maps. A value of zero is not recommended, as all
objects will generate a reflection map.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setNormalScale">
<code class="descname">setNormalScale</code><span class="sig-paren">(</span><em>self</em>, <em>normal_scale</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setNormalScale" title="Permalink to this definition"></a></dt>
<dd><p>Set a scale factor for the display of normals to increase or
decrease their length.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setObjectOrigins">
<code class="descname">setObjectOrigins</code><span class="sig-paren">(</span><em>self</em>, <em>globel_enable</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setObjectOrigins" title="Permalink to this definition"></a></dt>
<dd><p>Globally allow object origins to be displayed. Object origins are
enabled by setting the Origin flag on objects.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setOffsetVertexMarkers">
<code class="descname">setOffsetVertexMarkers</code><span class="sig-paren">(</span><em>self</em>, <em>enable</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setOffsetVertexMarkers" title="Permalink to this definition"></a></dt>
<dd><p>When enabled, vertex markers and normals are inset into the polygon
so they can be selected independently when part of a seemless mesh.
When disabled, the markers and normals are placed at the actual
vertex, potentially overlapping.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setOnionSkinFrameIncrement">
<code class="descname">setOnionSkinFrameIncrement</code><span class="sig-paren">(</span><em>self</em>, <em>frame_increment</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setOnionSkinFrameIncrement" title="Permalink to this definition"></a></dt>
<dd><p>Set the frame increment between onion skins. Using 1 will draw every
frame around the current frame ($F-2 $F-1 $F $F+1 $F+2, while 5
would step by 5 ($F-10 $F-5 $F $F+5 $F+10).</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setOnionSkinFramesAfterCount">
<code class="descname">setOnionSkinFramesAfterCount</code><span class="sig-paren">(</span><em>self</em>, <em>num_frames</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setOnionSkinFramesAfterCount" title="Permalink to this definition"></a></dt>
<dd><p>Set the number of onion skins after the current frame. Their spacing
depends on the onion skin frame increment.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setOnionSkinFramesAfterTint">
<code class="descname">setOnionSkinFramesAfterTint</code><span class="sig-paren">(</span><em>self</em>, <em>tint</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setOnionSkinFramesAfterTint" title="Permalink to this definition"></a></dt>
<dd><p>Tint all onion skins that appear after the current frame with this
color.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setOnionSkinFramesBeforeCount">
<code class="descname">setOnionSkinFramesBeforeCount</code><span class="sig-paren">(</span><em>self</em>, <em>num_frames</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setOnionSkinFramesBeforeCount" title="Permalink to this definition"></a></dt>
<dd><p>Set the number of onion skins before the current frame. Their
spacing depends on the onion skin frame increment.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setOnionSkinFramesBeforeTint">
<code class="descname">setOnionSkinFramesBeforeTint</code><span class="sig-paren">(</span><em>self</em>, <em>tint</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setOnionSkinFramesBeforeTint" title="Permalink to this definition"></a></dt>
<dd><p>Tint all onion skins that appear before the current frame with this
color.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setOnionSkinOpacity">
<code class="descname">setOnionSkinOpacity</code><span class="sig-paren">(</span><em>self</em>, <em>opacity</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setOnionSkinOpacity" title="Permalink to this definition"></a></dt>
<dd><p>Set the opacity of the onion skins to make them more or less
prominent.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setOnionSkinning">
<code class="descname">setOnionSkinning</code><span class="sig-paren">(</span><em>self</em>, <em>global_enable</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setOnionSkinning" title="Permalink to this definition"></a></dt>
<dd><p>Globally allow onion skinning to be displayed. Onion skinning is
enabled on a per-object basis in the Misc tab of objects. This shows
animation as a series of ghosted poses at other frames around the
current frame.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setOptimizeGeometry">
<code class="descname">setOptimizeGeometry</code><span class="sig-paren">(</span><em>self</em>, <em>enable</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setOptimizeGeometry" title="Permalink to this definition"></a></dt>
<dd><p>Optimize packed geometry when loaded to make it faster for display
(triangulating and splitting meshes).</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setOriginGnomonSize">
<code class="descname">setOriginGnomonSize</code><span class="sig-paren">(</span><em>self</em>, <em>size</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setOriginGnomonSize" title="Permalink to this definition"></a></dt>
<dd><p>Sets the world size of the gnomon axes that appear at the world
origin.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setOrthoRuler">
<code class="descname">setOrthoRuler</code><span class="sig-paren">(</span><em>self</em>, <em>viewportGridRuler</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setOrthoRuler" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Where to display the grid numbers on the fixed orthographic view
grid.</div></blockquote>
<ul>
<li><p class="first">hou.viewportGridRuler.Hide:</p>
<blockquote>
<div><p>Do not display.</p>
</div></blockquote>
</li>
<li><p class="first">hou.viewportGridRuler.MainAxis:</p>
<blockquote>
<div><p>Display along the main axes at grid line intersections.</p>
</div></blockquote>
</li>
<li><p class="first">hou.viewportGridRuler.GridPoints:</p>
<blockquote>
<div><p>Display on grid line intersections.</p>
</div></blockquote>
</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setOthroGridOffset">
<code class="descname">setOthroGridOffset</code><span class="sig-paren">(</span><em>self</em>, <em>offset</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setOthroGridOffset" title="Permalink to this definition"></a></dt>
<dd><p>Set the offset of the grid in fixed orthographics views, as a
3-tuple in world space.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setOthroGridRuler">
<code class="descname">setOthroGridRuler</code><span class="sig-paren">(</span><em>self</em>, <em>offset</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setOthroGridRuler" title="Permalink to this definition"></a></dt>
<dd><p>Set the spacing of the grid numbers in fixed orthographics views as
a 2-tuple.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setOthroGridSpacing">
<code class="descname">setOthroGridSpacing</code><span class="sig-paren">(</span><em>self</em>, <em>offset</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setOthroGridSpacing" title="Permalink to this definition"></a></dt>
<dd><p>Set the spacing of the grid lines in fixed orthographics views as a
2-tuple.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setPackedBoundingBoxMode">
<code class="descname">setPackedBoundingBoxMode</code><span class="sig-paren">(</span><em>self</em>, <em>viewportPackedBoxMode</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setPackedBoundingBoxMode" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Define how culled packed primitives are displayed.</div></blockquote>
<ul>
<li><p class="first">hou.viewportPackedBoxMode.NoDisplay:</p>
<blockquote>
<div><p>Culled packed primitives are not displayed at all.</p>
</div></blockquote>
</li>
<li><p class="first">hou.viewportPackedBoxMode.Wireframe:</p>
<blockquote>
<div><p>A wireframe bounding box replaces the packed primitive.</p>
</div></blockquote>
</li>
<li><p class="first">hou.viewportPackedBoxMode.Shaded:</p>
<blockquote>
<div><p>A shaded bounding box replaces the packed primitive.</p>
</div></blockquote>
</li>
<li><p class="first">hou.viewportPackedBoxMode.CurrentShadingMode:</p>
<blockquote>
<div><p>A bounding box replaces the packed primitive, drawn wireframe in
wireframe shading modes and shaded otherwise.</p>
</div></blockquote>
</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setPointMarkerSize">
<code class="descname">setPointMarkerSize</code><span class="sig-paren">(</span><em>self</em>, <em>point_size</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setPointMarkerSize" title="Permalink to this definition"></a></dt>
<dd><p>Set the size of point marker decorations, in pixels.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setReflectMapSize">
<code class="descname">setReflectMapSize</code><span class="sig-paren">(</span><em>self</em>, <em>size</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setReflectMapSize" title="Permalink to this definition"></a></dt>
<dd><p>Set the size of the cubemap used to store the surrounding scene as
an environment map. Larger cubemaps produce sharper reflections but
increase memory use.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setRemoveBackfaces">
<code class="descname">setRemoveBackfaces</code><span class="sig-paren">(</span><em>self</em>, <em>enable</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setRemoveBackfaces" title="Permalink to this definition"></a></dt>
<dd><p>Cull polygons facing backwards instead of rasterizing them.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setSceneAntialias">
<code class="descname">setSceneAntialias</code><span class="sig-paren">(</span><em>self</em>, <em>aalevel</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setSceneAntialias" title="Permalink to this definition"></a></dt>
<dd><p>Sets the viewports full-scene antialiasing level to one of 1, 2, 4,
8, 16, 32, 64, or 128. This represents the number of samples
rendered to produce a higher quality image. Higher numbers produce
better antialiasing, but this can affect the viewports rendering
performance. Some graphics hardware only support a subset of these
modes (eg. up to 8 or 32).</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setSceneGamma">
<code class="descname">setSceneGamma</code><span class="sig-paren">(</span><em>self</em>, <em>gamma</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setSceneGamma" title="Permalink to this definition"></a></dt>
<dd><p>Set the gamma correction for the scene. This value should match the
calibrated gamma of the display device.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setSceneLUT">
<code class="descname">setSceneLUT</code><span class="sig-paren">(</span><em>self</em>, <em>lut_file</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setSceneLUT" title="Permalink to this definition"></a></dt>
<dd><p>Specify a Lookup Table (LUT) file to use for color correction.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setScenePolygonLimit">
<code class="descname">setScenePolygonLimit</code><span class="sig-paren">(</span><em>self</em>, <em>millions_of_polygons</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setScenePolygonLimit" title="Permalink to this definition"></a></dt>
<dd><p>Set the maximum number of polygons in the view frustum, in millions,
before the viewport begins culling packed primitives.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setShadowMapSize">
<code class="descname">setShadowMapSize</code><span class="sig-paren">(</span><em>self</em>, <em>size</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setShadowMapSize" title="Permalink to this definition"></a></dt>
<dd><p>Set the maximum shadow map size, in pixels. Larger maps will produce
sharper shadows but increase memory usage. Shadow maps are always
square.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setShadowMapSizeFromLight">
<code class="descname">setShadowMapSizeFromLight</code><span class="sig-paren">(</span><em>self</em>, <em>enable</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setShadowMapSizeFromLight" title="Permalink to this definition"></a></dt>
<dd><p>Set whether to use the shadow map size specified by the Shadow Map
size parameter in the light object (clamped to the maximum size
specified in the display options) or always use the maximum size.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setShadowQuality">
<code class="descname">setShadowQuality</code><span class="sig-paren">(</span><em>self</em>, <em>viewportShadowQuality</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setShadowQuality" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Set the quality of shadow sampling in High Quality Lighting with
Shadows lighting mode.</div></blockquote>
<ul>
<li><p class="first">hou.viewportShadowQuality.Point:</p>
<blockquote>
<div><p>Area lights are treated as point lights when generating and
sampling shadow maps. This is the fastest option.</p>
</div></blockquote>
</li>
<li><p class="first">hou.viewportShadowQuality.PointAA:</p>
<blockquote>
<div><p>Do some antialiasing of shadow edges. Treat area lights as point
lights when generating and sampling shadow maps.</p>
</div></blockquote>
</li>
<li><p class="first">hou.viewportShadowQuality.Area:</p>
<blockquote>
<div><p>Area lights generate multiple shadow maps which are sampled to
generate an approximation of a blurred shadow from an area
source.</p>
</div></blockquote>
</li>
<li><p class="first">hou.viewportShadowQuality.AreaAA:</p>
<blockquote>
<div><p>Area lights generate multiple maps and antialias the shadow
lookups.</p>
</div></blockquote>
</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setShadowSensitivity">
<code class="descname">setShadowSensitivity</code><span class="sig-paren">(</span><em>self</em>, <em>offset</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setShadowSensitivity" title="Permalink to this definition"></a></dt>
<dd><p>Set the shadow bias to avoid self-shadowing. A 2-tuple is expected,
with the first value setting the variable offset (depending on how
parallel the surface is to the view direction) and the second a
constant offset. Generally these dont need to be changed from their
default, but larger values reduce self shadowing but increase the
risk of missing shadows for very close geometry.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setSingleBoneDeform">
<code class="descname">setSingleBoneDeform</code><span class="sig-paren">(</span><em>self</em>, <em>viewportAgentBoneDeform</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setSingleBoneDeform" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Set the complexity of bone-based deformation on agents.</div></blockquote>
<ul>
<li><p class="first">hou.viewportAgentBoneDeform.Always:</p>
<blockquote>
<div><p>Only use 1 bone to deform on all agent instances (the one with
the most influence).</p>
</div></blockquote>
</li>
<li><p class="first">hou.viewportAgentBoneDeform.ReducedLOD:</p>
<blockquote>
<div><p>Use up to 4 bones to deform the highest LOD agent instances, and
1 bone on all the reduced LOD instances.</p>
</div></blockquote>
</li>
<li><p class="first">hou.viewportAgentBoneDeform.Disabled:</p>
<blockquote>
<div><p>Use up to 4 bones to deform on all agent instances.</p>
</div></blockquote>
</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setSingleObjectMaterialLimit">
<code class="descname">setSingleObjectMaterialLimit</code><span class="sig-paren">(</span><em>self</em>, <em>num_materials</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setSingleObjectMaterialLimit" title="Permalink to this definition"></a></dt>
<dd><p>Set the maximum number of material variations for a single object.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setStereoMode">
<code class="descname">setStereoMode</code><span class="sig-paren">(</span><em>self</em>, <em>viewportStereoMode</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setStereoMode" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Set the stereo display mode when viewing through a stereo camera.</div></blockquote>
<ul>
<li><p class="first">hou.viewportStereoMode.Anaglyph:</p>
<blockquote>
<div><p>Anaglyph display of left/right as red/cyan.</p>
</div></blockquote>
</li>
<li><p class="first">hou.viewportStereoMode.HorizontalInterlace:</p>
<blockquote>
<div><p>Interlace left and right on alternating scanlines. Only useful
for 3D monitors which support this.</p>
</div></blockquote>
</li>
<li><p class="first">hou.viewportStereoMode.HorizontalInterlaceReverse:</p>
<blockquote>
<div><p>Interlace left and right on alternating scanlines, swapping
which scanlines are used for left and right.</p>
</div></blockquote>
</li>
<li><p class="first">hou.viewportStereoMode.QuadBufferGL:</p>
<blockquote>
<div><p>Use OpenGL quad buffer stereo, generally only available on
professional cards.</p>
</div></blockquote>
</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setTexture2DSettingsFor3D">
<code class="descname">setTexture2DSettingsFor3D</code><span class="sig-paren">(</span><em>self</em>, <em>enable</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setTexture2DSettingsFor3D" title="Permalink to this definition"></a></dt>
<dd><p>When enabled, use all the 2D texture settings for 3D textures.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setTextureAnisotropicFilter">
<code class="descname">setTextureAnisotropicFilter</code><span class="sig-paren">(</span><em>self</em>, <em>num_samples</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setTextureAnisotropicFilter" title="Permalink to this definition"></a></dt>
<dd><p>Set the number of samples for anisotropic texture filtering. More
samples produces better results for textures on polygons on an angle
to the view direction.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setTextureAutoReduce">
<code class="descname">setTextureAutoReduce</code><span class="sig-paren">(</span><em>self</em>, <em>enable</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setTextureAutoReduce" title="Permalink to this definition"></a></dt>
<dd><p>Enable auto-reduction of viewport textures. This attempts to scale
down textures to fit within the texture cache.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setTextureAutoReduce2D">
<code class="descname">setTextureAutoReduce2D</code><span class="sig-paren">(</span><em>self</em>, <em>enable</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setTextureAutoReduce2D" title="Permalink to this definition"></a></dt>
<dd><p>Allow auto-reduction of regular 2D textures.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setTextureAutoReduce3D">
<code class="descname">setTextureAutoReduce3D</code><span class="sig-paren">(</span><em>self</em>, <em>enable</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setTextureAutoReduce3D" title="Permalink to this definition"></a></dt>
<dd><p>Allow auto-reduction of 3D textures (volumes).</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setTextureBitDepthLimit2D">
<code class="descname">setTextureBitDepthLimit2D</code><span class="sig-paren">(</span><em>self</em>, <em>viewportTextureDepth</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setTextureBitDepthLimit2D" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Set the maximum bit depth for a 2D texture. Textures with a bit
depth higher than this will be downconverted to this bit depth.
Textures with an equal or lower bit depth will not be converted.</div></blockquote>
<ul>
<li><p class="first">hou.viewportTextureDepth.Compressed8:</p>
<blockquote>
<div><p>Compressed, 8b SDR texture format. Smallest memory use.</p>
</div></blockquote>
</li>
<li><p class="first">hou.viewportTextureDepth.Fixed8:</p>
<blockquote>
<div><p>8b SDR texture format. Good balance between memory and quality.</p>
</div></blockquote>
</li>
<li><p class="first">hou.viewportTextureDepth.HDR16:</p>
<blockquote>
<div><p>16b HDR texture format. Excellent dynamic range, but more memory
use and slower texturing performance.</p>
</div></blockquote>
</li>
<li><p class="first">hou.viewportTextureDepth.FullHDR:</p>
<blockquote>
<div><p>32b HDR texture format. Extreme dynamic range, but very high
memory use and slow texturing performance. Use with care.</p>
</div></blockquote>
</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setTextureBitDepthLimit3D">
<code class="descname">setTextureBitDepthLimit3D</code><span class="sig-paren">(</span><em>self</em>, <em>viewportTextureDepth</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setTextureBitDepthLimit3D" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Set the maximum bit depth for a 3D texture (volume). Textures with a
bit depth higher than this will be downconverted to this bit depth.
Textures with an equal or lower bit depth will not be converted. 3D
textures do not support compressed formats.</div></blockquote>
<ul>
<li><p class="first">hou.viewportTextureDepth.Fixed8:</p>
<blockquote>
<div><p>8b SDR texture format. Good balance between memory and quality.</p>
</div></blockquote>
</li>
<li><p class="first">hou.viewportTextureDepth.HDR16:</p>
<blockquote>
<div><p>16b HDR texture format. Excellent dynamic range, but more memory
use and slower texturing performance.</p>
</div></blockquote>
</li>
<li><p class="first">hou.viewportTextureDepth.FullHDR:</p>
<blockquote>
<div><p>32b HDR texture format. Extreme dynamic range, but very high
memory use and slow texturing performance. Use with care.</p>
</div></blockquote>
</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setTextureCacheSize">
<code class="descname">setTextureCacheSize</code><span class="sig-paren">(</span><em>self</em>, <em>size_in_mb</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setTextureCacheSize" title="Permalink to this definition"></a></dt>
<dd><p>Set the size of the texture cache, in megabytes. The viewport will
use as much texture memory as it needs, even if it exceeds this
level, but textures will be culled once they are no longer used to
remain within this limit.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setTextureMaxMemory">
<code class="descname">setTextureMaxMemory</code><span class="sig-paren">(</span><em>self</em>, <em>size_in_mb</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setTextureMaxMemory" title="Permalink to this definition"></a></dt>
<dd><p>Set the maximum size of a single texture, in megabytes. This
prevents extremely large textures from starving the graphics
hardwares bandwidth (mostly by 3D textures).</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setTextureMaxRes2D">
<code class="descname">setTextureMaxRes2D</code><span class="sig-paren">(</span><em>self</em>, <em>res</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setTextureMaxRes2D" title="Permalink to this definition"></a></dt>
<dd><p>Set the maximum resolution of a 2D texture. res is an integer
2-tuple of (width, height). OpenGL has its own limit, and setting
this limit higher than that will have no effect. The image will be
scaled to fit the limit if it exceeds it.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setTextureMaxRes3D">
<code class="descname">setTextureMaxRes3D</code><span class="sig-paren">(</span><em>self</em>, <em>res</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setTextureMaxRes3D" title="Permalink to this definition"></a></dt>
<dd><p>Set the maximum resolution of a 3D texture (volume). res is an
integer 3-tuple of (width, height, depth). OpenGL has its own limit,
and setting this limit higher than that will have no effect. The
image will be scaled to fit the limit if it exceeds it.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setTextureMipmapping">
<code class="descname">setTextureMipmapping</code><span class="sig-paren">(</span><em>self</em>, <em>enable</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setTextureMipmapping" title="Permalink to this definition"></a></dt>
<dd><p>Enable mipmapping for textures, improving display quality but
increasing texture memory use by 50%.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setTextureResLimit2D">
<code class="descname">setTextureResLimit2D</code><span class="sig-paren">(</span><em>self</em>, <em>enable</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setTextureResLimit2D" title="Permalink to this definition"></a></dt>
<dd><p>Limit the resolution of all 2D textures, so that the width and
height cannot exceed the limit. Even if disabled, OpenGL has its own
texture limits which will be applied (usually 8k or 16k).</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setTextureResLimit3D">
<code class="descname">setTextureResLimit3D</code><span class="sig-paren">(</span><em>self</em>, <em>enable</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setTextureResLimit3D" title="Permalink to this definition"></a></dt>
<dd><p>Limit the resolution of all 3D textures (volumes), so that the
width, height, and depth cannot exceed the limit. Even if disabled,
OpenGL has its own texture limits which will be applied (usually 2k
or 8k).</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setTextureScale2D">
<code class="descname">setTextureScale2D</code><span class="sig-paren">(</span><em>self</em>, <em>scale</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setTextureScale2D" title="Permalink to this definition"></a></dt>
<dd><p>Uniformly downscale all 2D textures by this fraction (default 1.0,
no scale).</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setTextureScale3D">
<code class="descname">setTextureScale3D</code><span class="sig-paren">(</span><em>self</em>, <em>scale</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setTextureScale3D" title="Permalink to this definition"></a></dt>
<dd><p>Uniformly downscale all 3D textures (volumes) by this fraction
(default 1.0, no scale).</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setTransparencyQuality">
<code class="descname">setTransparencyQuality</code><span class="sig-paren">(</span><em>self</em>, <em>viewportTransparency</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setTransparencyQuality" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Set the quality of the transparency pass performed by the viewport.</div></blockquote>
<ul>
<li><p class="first">hou.viewportTransparency.Cutout:</p>
<blockquote>
<div><p>Fast test to render the transparent pixel as opaque (&gt;0) or to
discard it (0). This can be used for texture cards such as
leaves. This doesnt require an additional pass for
transparency.</p>
</div></blockquote>
</li>
<li><p class="first">hou.viewportTransparency.Low:</p>
<blockquote>
<div><p>Render transparent pixels in a separate pass. Only the front-
most transparent pixel is rendered.</p>
</div></blockquote>
</li>
<li><p class="first">hou.viewportTransparency.Medium:</p>
<blockquote>
<div><p>Render transparent pixels in an Order-Independent buffer of 8
samples, which is then sorted and composited together to do
multi-layer transparency for up to 8 layers of overlapping
transparency.</p>
</div></blockquote>
</li>
<li><p class="first">hou.viewportTransparency.High:</p>
<blockquote>
<div><p>Render transparent pixels in an Order-Independent buffer of 16
samples, which is then sorted and composited together to do
multi-layer transparency for up to 16 layers of overlapping
transparency.</p>
</div></blockquote>
</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setUVAutoAttribute">
<code class="descname">setUVAutoAttribute</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setUVAutoAttribute" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setUVDisplayAttribute">
<code class="descname">setUVDisplayAttribute</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setUVDisplayAttribute" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setUVDisplayGridOverImage">
<code class="descname">setUVDisplayGridOverImage</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setUVDisplayGridOverImage" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setUVGridPixelOffset">
<code class="descname">setUVGridPixelOffset</code><span class="sig-paren">(</span><em>self</em>, <em>offset</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setUVGridPixelOffset" title="Permalink to this definition"></a></dt>
<dd><p>Set the spacing, in pixels, of the dot grid.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setUVGridPixelSpacing">
<code class="descname">setUVGridPixelSpacing</code><span class="sig-paren">(</span><em>self</em>, <em>offset</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setUVGridPixelSpacing" title="Permalink to this definition"></a></dt>
<dd><p>Set the spacing of the UV dot grid displayed over the background
image.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setUVReferenceGrid">
<code class="descname">setUVReferenceGrid</code><span class="sig-paren">(</span><em>self</em>, <em>enable</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setUVReferenceGrid" title="Permalink to this definition"></a></dt>
<dd><p>Display the grid in UV viewports.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setUVVertexType">
<code class="descname">setUVVertexType</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setUVVertexType" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setUseSceneLUT">
<code class="descname">setUseSceneLUT</code><span class="sig-paren">(</span><em>self</em>, <em>enable</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setUseSceneLUT" title="Permalink to this definition"></a></dt>
<dd><p>Enable Lookup Table (LUT) color correction. A valid LUT file must
also be present.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setVectorScale">
<code class="descname">setVectorScale</code><span class="sig-paren">(</span><em>self</em>, <em>scale</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setVectorScale" title="Permalink to this definition"></a></dt>
<dd><p>Set the scale applied to vector decorations, to make them longer or
shorter.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setViewMaskOpacity">
<code class="descname">setViewMaskOpacity</code><span class="sig-paren">(</span><em>self</em>, <em>opacity</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setViewMaskOpacity" title="Permalink to this definition"></a></dt>
<dd><p>Set the opacity of the bars used to mask areas out the viewport
outside the aspect ratio.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setVisibleObjects">
<code class="descname">setVisibleObjects</code><span class="sig-paren">(</span><em>self</em>, <em>uv</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setVisibleObjects" title="Permalink to this definition"></a></dt>
<dd><p>Set the mask for all visible objects in the viewport. Wilcards can
be used.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setWireOverPackedGeo">
<code class="descname">setWireOverPackedGeo</code><span class="sig-paren">(</span><em>self</em>, <em>wire_over_packed</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setWireOverPackedGeo" title="Permalink to this definition"></a></dt>
<dd><p>Show polygon outlines on meshes in packed geometry when drawing a
wire-over-shaded mode. Disabling this hides the outlines on packed
geometry, making meshes appear as a single shape, which packed
geometry technically is.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setXrayDrawing">
<code class="descname">setXrayDrawing</code><span class="sig-paren">(</span><em>self</em>, <em>global_enable</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setXrayDrawing" title="Permalink to this definition"></a></dt>
<dd><p>Globally enable or disable X-ray drawing. Object must have their
X-ray flag set in order to render as X-ray. X-ray causes the object
to be visible when occluded.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setXrayQuality">
<code class="descname">setXrayQuality</code><span class="sig-paren">(</span><em>self</em>, <em>quality</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setXrayQuality" title="Permalink to this definition"></a></dt>
<dd><p>Enable high-quality X-ray rendering, which draws X-rayed objects as
dimmed shaded surfaces when occluded, with up to 8 levels of overlap
between X-rayed objects. This looks better but takes longer to
render. Regular X-ray rendering displays X-ray objects as wireframe
when occluded.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.setXrayStrength">
<code class="descname">setXrayStrength</code><span class="sig-paren">(</span><em>self</em>, <em>strength</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.setXrayStrength" title="Permalink to this definition"></a></dt>
<dd><p>Sets the strength of the occluded x-ray objects. Lower values make
occluded X-ray objects dimmer.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.shadeOpenCurves">
<code class="descname">shadeOpenCurves</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportSettings.shadeOpenCurves" title="Permalink to this definition"></a></dt>
<dd><p>Query if shaded open curves are enabled or not.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.shadowMapSize">
<code class="descname">shadowMapSize</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.GeometryViewportSettings.shadowMapSize" title="Permalink to this definition"></a></dt>
<dd><p>Query the maximum size of the shadow maps used by High Quality
Lighting with Shadows lighting mode.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.shadowMapSizeFromLight">
<code class="descname">shadowMapSizeFromLight</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportSettings.shadowMapSizeFromLight" title="Permalink to this definition"></a></dt>
<dd><p>Query if the shadow map size is defined by the light object.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.shadowQuality">
<code class="descname">shadowQuality</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.viewportShadowQuality<a class="headerlink" href="#hou.GeometryViewportSettings.shadowQuality" title="Permalink to this definition"></a></dt>
<dd><p>Query the current shadow quality.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.shadowSensitivity">
<code class="descname">shadowSensitivity</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of int<a class="headerlink" href="#hou.GeometryViewportSettings.shadowSensitivity" title="Permalink to this definition"></a></dt>
<dd><p>Query the variable and constant shadow offsets, returned in a
2-tuple.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.showAmbient">
<code class="descname">showAmbient</code><span class="sig-paren">(</span><em>self</em>, <em>enable</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.showAmbient" title="Permalink to this definition"></a></dt>
<dd><p>Enable ambient lighting. When disabled, all ambient lights will not
contribute to the final lit color. This can be used to debug
lighting.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.showBadges">
<code class="descname">showBadges</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportSettings.showBadges" title="Permalink to this definition"></a></dt>
<dd><p>Query if viewport status badges are displayed. Badges are icons
which present additional state information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.showCameraName">
<code class="descname">showCameraName</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportSettings.showCameraName" title="Permalink to this definition"></a></dt>
<dd><p>Query if the camera name menu is displayed.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.showDiffuse">
<code class="descname">showDiffuse</code><span class="sig-paren">(</span><em>self</em>, <em>enable</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.showDiffuse" title="Permalink to this definition"></a></dt>
<dd><p>Enable diffuse contribution of lighting. When disabled, diffuse will
not contribute to the final lit color. This can be used to debug
lighting.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.showEmission">
<code class="descname">showEmission</code><span class="sig-paren">(</span><em>self</em>, <em>enable</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.showEmission" title="Permalink to this definition"></a></dt>
<dd><p>Enable emissive lighting. Emission lighting comes from materials on
geometry, not lights, so modifying the lights in the scene has no
effect on it. This can be used to debug lighting.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.showGeometryColor">
<code class="descname">showGeometryColor</code><span class="sig-paren">(</span><em>self</em>, <em>enable</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.showGeometryColor" title="Permalink to this definition"></a></dt>
<dd><p>Enable contribution of the geometry Cd attribute to the material.
When disabled, this is ignored. Cd multiplies both the the material
diffuse and ambient colors.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.showMaterials">
<code class="descname">showMaterials</code><span class="sig-paren">(</span><em>self</em>, <em>enable</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.showMaterials" title="Permalink to this definition"></a></dt>
<dd><p>Enable materials on geometry from SHOPs or VOPs. When disabled,
these material assignments are ignored and only the attributes on
the geometry will affect shading.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.showName">
<code class="descname">showName</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportSettings.showName" title="Permalink to this definition"></a></dt>
<dd><p>Query if the viewport name menu is displayed.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.showSpecular">
<code class="descname">showSpecular</code><span class="sig-paren">(</span><em>self</em>, <em>enable</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.showSpecular" title="Permalink to this definition"></a></dt>
<dd><p>Enable specular highlights. When disabled, specular will not
contribute to the final lit color. This will also disable most
reflections. This can be used to debug lighting.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.showStateStatus">
<code class="descname">showStateStatus</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportSettings.showStateStatus" title="Permalink to this definition"></a></dt>
<dd><p>Query if the tool status messages are displayed.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.showingAmbient">
<code class="descname">showingAmbient</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportSettings.showingAmbient" title="Permalink to this definition"></a></dt>
<dd><p>Query if ambient lighting is enabled.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.showingDiffuse">
<code class="descname">showingDiffuse</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportSettings.showingDiffuse" title="Permalink to this definition"></a></dt>
<dd><p>Query if diffuse lighting is enabled.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.showingEmission">
<code class="descname">showingEmission</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportSettings.showingEmission" title="Permalink to this definition"></a></dt>
<dd><p>Query if emission lighting is enabled.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.showingGeometryColor">
<code class="descname">showingGeometryColor</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportSettings.showingGeometryColor" title="Permalink to this definition"></a></dt>
<dd><p>Query if geometry Cd contributes to the material.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.showingMaterials">
<code class="descname">showingMaterials</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportSettings.showingMaterials" title="Permalink to this definition"></a></dt>
<dd><p>Query if materials are shown.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.showingSpecular">
<code class="descname">showingSpecular</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportSettings.showingSpecular" title="Permalink to this definition"></a></dt>
<dd><p>Query if specular lighting is enabled.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.showsBadges">
<code class="descname">showsBadges</code><span class="sig-paren">(</span><em>self</em>, <em>show</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.showsBadges" title="Permalink to this definition"></a></dt>
<dd><p>Display viewport status badges as icons beside the camera menu,
which presents additional state information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.showsCameraName">
<code class="descname">showsCameraName</code><span class="sig-paren">(</span><em>self</em>, <em>show</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.showsCameraName" title="Permalink to this definition"></a></dt>
<dd><p>Display the camera name and menu in the upper right corner.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.showsName">
<code class="descname">showsName</code><span class="sig-paren">(</span><em>self</em>, <em>show</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.showsName" title="Permalink to this definition"></a></dt>
<dd><p>Display the viewport name and menu in the upper right corner.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.showsStateStatus">
<code class="descname">showsStateStatus</code><span class="sig-paren">(</span><em>self</em>, <em>show</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.showsStateStatus" title="Permalink to this definition"></a></dt>
<dd><p>Display any status messages of the current tool.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.singleBoneDeform">
<code class="descname">singleBoneDeform</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.viewportAgentBoneDeform<a class="headerlink" href="#hou.GeometryViewportSettings.singleBoneDeform" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Query the complexity of bone-based deformation on agents.</div></blockquote>
<ul>
<li><p class="first">hou.viewportAgentBoneDeform.Always:</p>
<blockquote>
<div><p>Only use 1 bone to deform on all agent instances (the one with
the most influence).</p>
</div></blockquote>
</li>
<li><p class="first">hou.viewportAgentBoneDeform.ReducedLOD:</p>
<blockquote>
<div><p>Use up to 4 bones to deform the highest LOD agent instances, and
1 bone on all the reduced LOD instances.</p>
</div></blockquote>
</li>
<li><p class="first">hou.viewportAgentBoneDeform.Disabled:</p>
<blockquote>
<div><p>Use up to 4 bones to deform on all agent instances.</p>
</div></blockquote>
</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.singleObjectMaterialLimit">
<code class="descname">singleObjectMaterialLimit</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.GeometryViewportSettings.singleObjectMaterialLimit" title="Permalink to this definition"></a></dt>
<dd><p>Query the maximum number of material variations for a single object.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.spriteTextureLimit">
<code class="descname">spriteTextureLimit</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of int<a class="headerlink" href="#hou.GeometryViewportSettings.spriteTextureLimit" title="Permalink to this definition"></a></dt>
<dd><p>Query the maximum texture resolution for sprites. This is primarly a
performance vs. quality tradeoff option. Larger sprites look better
but may cause slowdowns for large particle systems.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.stereoMode">
<code class="descname">stereoMode</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.viewportStereoMode<a class="headerlink" href="#hou.GeometryViewportSettings.stereoMode" title="Permalink to this definition"></a></dt>
<dd><p>Query the current stereo display mode.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.subdivsionLimit">
<code class="descname">subdivsionLimit</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.GeometryViewportSettings.subdivsionLimit" title="Permalink to this definition"></a></dt>
<dd><p>Returns the current subdivision polygon limit, in millions of
polygons.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.texture2DSettingsFor3D">
<code class="descname">texture2DSettingsFor3D</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportSettings.texture2DSettingsFor3D" title="Permalink to this definition"></a></dt>
<dd><p>Query if the 2D settings are used for 3D textures.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.textureAnisotropicFilter">
<code class="descname">textureAnisotropicFilter</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.GeometryViewportSettings.textureAnisotropicFilter" title="Permalink to this definition"></a></dt>
<dd><p>Query the number of samples used for anisotropic texture filtering.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.textureAutoReduce">
<code class="descname">textureAutoReduce</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportSettings.textureAutoReduce" title="Permalink to this definition"></a></dt>
<dd><p>Query if auto-reduction of viewport textures is enabled.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.textureAutoReduce2D">
<code class="descname">textureAutoReduce2D</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportSettings.textureAutoReduce2D" title="Permalink to this definition"></a></dt>
<dd><p>Query if auto-reduction of regular 2D textures is allowed.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.textureAutoReduce3D">
<code class="descname">textureAutoReduce3D</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportSettings.textureAutoReduce3D" title="Permalink to this definition"></a></dt>
<dd><p>Query if auto-reduction of 3D textures is allowed.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.textureBitDepthLimit2D">
<code class="descname">textureBitDepthLimit2D</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.viewportTextureDepth<a class="headerlink" href="#hou.GeometryViewportSettings.textureBitDepthLimit2D" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Query the maximum bit depth for a 2D texture.</div></blockquote>
<ul>
<li><p class="first">hou.viewportTextureDepth.Compressed8:</p>
<blockquote>
<div><p>Compressed, 8b SDR texture format. Smallest memory use.</p>
</div></blockquote>
</li>
<li><p class="first">hou.viewportTextureDepth.Fixed8:</p>
<blockquote>
<div><p>8b SDR texture format. Good balance between memory and quality.</p>
</div></blockquote>
</li>
<li><p class="first">hou.viewportTextureDepth.HDR16:</p>
<blockquote>
<div><p>16b HDR texture format. Excellent dynamic range, but more memory
use and slower texturing performance.</p>
</div></blockquote>
</li>
<li><p class="first">hou.viewportTextureDepth.FullHDR:</p>
<blockquote>
<div><p>32b HDR texture format. Extreme dynamic range, but very high
memory use and slow texturing performance. Use with care.</p>
</div></blockquote>
</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.textureBitDepthLimit3D">
<code class="descname">textureBitDepthLimit3D</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.viewportTextureDepth<a class="headerlink" href="#hou.GeometryViewportSettings.textureBitDepthLimit3D" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Query the maximum bit depth of a 3D texture (volume).</div></blockquote>
<ul>
<li><p class="first">hou.viewportTextureDepth.Fixed8:</p>
<blockquote>
<div><p>8b SDR texture format. Good balance between memory and quality.</p>
</div></blockquote>
</li>
<li><p class="first">hou.viewportTextureDepth.HDR16:</p>
<blockquote>
<div><p>16b HDR texture format. Excellent dynamic range, but more memory
use and slower texturing performance.</p>
</div></blockquote>
</li>
<li><p class="first">hou.viewportTextureDepth.FullHDR:</p>
<blockquote>
<div><p>32b HDR texture format. Extreme dynamic range, but very high
memory use and slow texturing performance. Use with extreme
care.</p>
</div></blockquote>
</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.textureCacheSize">
<code class="descname">textureCacheSize</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.GeometryViewportSettings.textureCacheSize" title="Permalink to this definition"></a></dt>
<dd><p>Query the texture cache size, in megabytes.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.textureMaxMemory">
<code class="descname">textureMaxMemory</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.GeometryViewportSettings.textureMaxMemory" title="Permalink to this definition"></a></dt>
<dd><p>Return the maximum size of a single texture, in megabytes.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.textureMaxRes2D">
<code class="descname">textureMaxRes2D</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; 2-tuple of int<a class="headerlink" href="#hou.GeometryViewportSettings.textureMaxRes2D" title="Permalink to this definition"></a></dt>
<dd><p>Return the maximum resolution for a 2D texture.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.textureMaxRes3D">
<code class="descname">textureMaxRes3D</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; 3-tuple of int<a class="headerlink" href="#hou.GeometryViewportSettings.textureMaxRes3D" title="Permalink to this definition"></a></dt>
<dd><p>Query the maximum resolution of a 3D texture (volume).</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.textureMipmapping">
<code class="descname">textureMipmapping</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportSettings.textureMipmapping" title="Permalink to this definition"></a></dt>
<dd><p>Query if texture mipmapping is enabled.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.textureResLimit2D">
<code class="descname">textureResLimit2D</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportSettings.textureResLimit2D" title="Permalink to this definition"></a></dt>
<dd><p>Query if 2D textures have their resolutions limited.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.textureResLimit3D">
<code class="descname">textureResLimit3D</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportSettings.textureResLimit3D" title="Permalink to this definition"></a></dt>
<dd><p>Query if 3D textures have their resolutions limited.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.textureScale2D">
<code class="descname">textureScale2D</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#hou.GeometryViewportSettings.textureScale2D" title="Permalink to this definition"></a></dt>
<dd><p>Query the uniform scale applied to 2D textures.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.textureScale3D">
<code class="descname">textureScale3D</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#hou.GeometryViewportSettings.textureScale3D" title="Permalink to this definition"></a></dt>
<dd><p>Query the uniform scale applied to 3D textures (volumes).</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.GeometryViewportSettings.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.GeometryViewportSettings.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.transparencyQuality">
<code class="descname">transparencyQuality</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.viewportTransparency<a class="headerlink" href="#hou.GeometryViewportSettings.transparencyQuality" title="Permalink to this definition"></a></dt>
<dd><p>Query the transparency quality.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.updateMaterials">
<code class="descname">updateMaterials</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.updateMaterials" title="Permalink to this definition"></a></dt>
<dd><p>Manually update all materials and material assignments.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.useAspectRatio">
<code class="descname">useAspectRatio</code><span class="sig-paren">(</span><em>self</em>, <em>enable</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.useAspectRatio" title="Permalink to this definition"></a></dt>
<dd><p>Enforce a specific aspect ratio for the viewport, which will add
bars if the viewport aspect ratio does not match.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.useDisplacement">
<code class="descname">useDisplacement</code><span class="sig-paren">(</span><em>self</em>, <em>enable</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.useDisplacement" title="Permalink to this definition"></a></dt>
<dd><p>Enable displacement mapping for materials that have a displacement
map. When disabled, the displacement map is ignored. This can have a
significant hit for lower-end GPUs.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.useMaterialOverrides">
<code class="descname">useMaterialOverrides</code><span class="sig-paren">(</span><em>self</em>, <em>enable</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.useMaterialOverrides" title="Permalink to this definition"></a></dt>
<dd><p>Allow material overrides from material stylesheets and the
material_override attribute.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.useMaterialStylesheets">
<code class="descname">useMaterialStylesheets</code><span class="sig-paren">(</span><em>self</em>, <em>enable</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.useMaterialStylesheets" title="Permalink to this definition"></a></dt>
<dd><p>Enable evaluation of material stylesheets for viewport material
assignment.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.usePackedStylesheets">
<code class="descname">usePackedStylesheets</code><span class="sig-paren">(</span><em>self</em>, <em>enable</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.usePackedStylesheets" title="Permalink to this definition"></a></dt>
<dd><p>Enable assignment of material stylesheets to geometry within packed
primitives.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.usePerPrimStylesheets">
<code class="descname">usePerPrimStylesheets</code><span class="sig-paren">(</span><em>self</em>, <em>enable</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.usePerPrimStylesheets" title="Permalink to this definition"></a></dt>
<dd><p>Enable evaluation of per-primitive stylesheets.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.useReflections">
<code class="descname">useReflections</code><span class="sig-paren">(</span><em>self</em>, <em>enable</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.useReflections" title="Permalink to this definition"></a></dt>
<dd><p>Enable reflection mapping. Objects with reflective materials
generate reflection maps of the scene around them, which can be
quite expensive.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.useSceneLUT">
<code class="descname">useSceneLUT</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportSettings.useSceneLUT" title="Permalink to this definition"></a></dt>
<dd><p>Query if Lookup Table color correction is enabled. This will return
True even no LUT file exists.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.useTransparency">
<code class="descname">useTransparency</code><span class="sig-paren">(</span><em>self</em>, <em>enable</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.useTransparency" title="Permalink to this definition"></a></dt>
<dd><p>Enable transparency rendering. When transparency is enabled, another
pass handles areas of the geometry that have Alpha less than one
(either due to an Alpha attribute or material opacity). When
disabled, alpha is ignored and rendered as opaque.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.usingAspectRatio">
<code class="descname">usingAspectRatio</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportSettings.usingAspectRatio" title="Permalink to this definition"></a></dt>
<dd><p>Query if a specific aspect ratio is being enforced.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.usingDisplacement">
<code class="descname">usingDisplacement</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportSettings.usingDisplacement" title="Permalink to this definition"></a></dt>
<dd><p>Query if displacement mapping is allowed.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.usingMaterialOverrides">
<code class="descname">usingMaterialOverrides</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportSettings.usingMaterialOverrides" title="Permalink to this definition"></a></dt>
<dd><p>Query if material overrides are being applied to material
assignments.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.usingMaterialStylesheets">
<code class="descname">usingMaterialStylesheets</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportSettings.usingMaterialStylesheets" title="Permalink to this definition"></a></dt>
<dd><p>Query if material stylesheet assignment is active.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.usingPackedStylesheets">
<code class="descname">usingPackedStylesheets</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportSettings.usingPackedStylesheets" title="Permalink to this definition"></a></dt>
<dd><p>Query if material stylesheet assignments are applied to geometry
within packed primitives.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.usingPerPrimStylesheets">
<code class="descname">usingPerPrimStylesheets</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportSettings.usingPerPrimStylesheets" title="Permalink to this definition"></a></dt>
<dd><p>Query if per-primitive stylesheets are evaluated.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.usingReflections">
<code class="descname">usingReflections</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportSettings.usingReflections" title="Permalink to this definition"></a></dt>
<dd><p>Query if reflection mapping is enabled.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.usingTransparency">
<code class="descname">usingTransparency</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportSettings.usingTransparency" title="Permalink to this definition"></a></dt>
<dd><p>Query if transparency rendering is enabled.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.uvAutoAttribute">
<code class="descname">uvAutoAttribute</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportSettings.uvAutoAttribute" title="Permalink to this definition"></a></dt>
<dd><p>Return True if the UV viewport is auto-detecting the class of the
displayed UV attribute.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.uvDisplayAttribute">
<code class="descname">uvDisplayAttribute</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.GeometryViewportSettings.uvDisplayAttribute" title="Permalink to this definition"></a></dt>
<dd><p>Return the attribute currently displayed in the UV viewport.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.uvGridPixelOffset">
<code class="descname">uvGridPixelOffset</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of float<a class="headerlink" href="#hou.GeometryViewportSettings.uvGridPixelOffset" title="Permalink to this definition"></a></dt>
<dd><p>Query the spacing of the dot grid in pixels.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.uvGridPixelSpacing">
<code class="descname">uvGridPixelSpacing</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of float<a class="headerlink" href="#hou.GeometryViewportSettings.uvGridPixelSpacing" title="Permalink to this definition"></a></dt>
<dd><p>Query the spacing of the UV dot grid displayed over background
images.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.uvReferenceGrid">
<code class="descname">uvReferenceGrid</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.uvReferenceGrid" title="Permalink to this definition"></a></dt>
<dd><p>uvReferenceGridOverImage(self) -&gt; bool</p>
<blockquote>
<div>Query if the dot grid is displayed.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.uvReferenceGridOverImage">
<code class="descname">uvReferenceGridOverImage</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.GeometryViewportSettings.uvReferenceGridOverImage" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.uvVertexType">
<code class="descname">uvVertexType</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportSettings.uvVertexType" title="Permalink to this definition"></a></dt>
<dd><p>Return the class of the UV attribute, Point or Vertex. This returns
the viewport setting, and not the detected class of the current UV
attribute. If uvAutoAttribute is enabled, the class will be the same
as the currently displayed attribute, but if it is disabled it may
be different.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.vectorScale">
<code class="descname">vectorScale</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#hou.GeometryViewportSettings.vectorScale" title="Permalink to this definition"></a></dt>
<dd><p>Query the scale applied to the length of vector decorations.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.vertexNormalCuspAngle">
<code class="descname">vertexNormalCuspAngle</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; double<a class="headerlink" href="#hou.GeometryViewportSettings.vertexNormalCuspAngle" title="Permalink to this definition"></a></dt>
<dd><p>Query the cusp angle for vertex normal generation. Any shared edge
between polygons will be considered a hard edge if the polygon faces
differ by more than this angle, otherwise the normals will be smooth
over the edge.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.vertexNormalLimit">
<code class="descname">vertexNormalLimit</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.GeometryViewportSettings.vertexNormalLimit" title="Permalink to this definition"></a></dt>
<dd><p>Query the polygon limit for generating vertex normals, in millions
of polygons.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.viewAspectRatio">
<code class="descname">viewAspectRatio</code><span class="sig-paren">(</span><em>self</em>, <em>masked</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#hou.GeometryViewportSettings.viewAspectRatio" title="Permalink to this definition"></a></dt>
<dd><p>Query the actual viewport aspect ratio. If masked is True, return
the aspect ratio of the area inside the camera mask, otherwise
return the full viewport aspect ratio.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.viewMaskOpacity">
<code class="descname">viewMaskOpacity</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#hou.GeometryViewportSettings.viewMaskOpacity" title="Permalink to this definition"></a></dt>
<dd><p>Query the opacity of the bars used to mask areas out the viewport
outside the aspect ratio.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.viewportType">
<code class="descname">viewportType</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.geometryViewportType enum value<a class="headerlink" href="#hou.GeometryViewportSettings.viewportType" title="Permalink to this definition"></a></dt>
<dd><p>Query the viewport type (UV, 3D, top, left, etc).</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.visibleObjects">
<code class="descname">visibleObjects</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.GeometryViewportSettings.visibleObjects" title="Permalink to this definition"></a></dt>
<dd><p>Query the current visible object mask.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.volumeQuality">
<code class="descname">volumeQuality</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.viewportVolumeQuality<a class="headerlink" href="#hou.GeometryViewportSettings.volumeQuality" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Query the volume display quality.</div></blockquote>
<ul class="simple">
<li>hou.viewportVolumeQuality.VeryLow: Very fast, low quality preview</li>
<li>hou.viewportVolumeQuality.Low: Fewer slices than Normal for speed</li>
<li>hou.viewportVolumeQuality.Normal: Good quality vs. speed setting.</li>
<li>hou.viewportVolumeQuality.High: Large number of slices with
jittering</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.volumeWireAsPoints">
<code class="descname">volumeWireAsPoints</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportSettings.volumeWireAsPoints" title="Permalink to this definition"></a></dt>
<dd><p>Query if volumes are currently drawn as a point field in wireframe.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.wireBlend">
<code class="descname">wireBlend</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; double<a class="headerlink" href="#hou.GeometryViewportSettings.wireBlend" title="Permalink to this definition"></a></dt>
<dd><p>Query the blend factor between wires and the surface in wire-over-
shaded modes. Values close to 0 produce very faint lines, values
closer to 1 produce solid lines.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.wireOverPackedGeo">
<code class="descname">wireOverPackedGeo</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportSettings.wireOverPackedGeo" title="Permalink to this definition"></a></dt>
<dd><p>Query if polygon outlines are visible on packed geometry when a
wire-over-shaded mode is active.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.wireWidth">
<code class="descname">wireWidth</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; double<a class="headerlink" href="#hou.GeometryViewportSettings.wireWidth" title="Permalink to this definition"></a></dt>
<dd><p>Query the width of lines drawn for wireframe and wire-over-shaded
modes.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.xrayDrawing">
<code class="descname">xrayDrawing</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportSettings.xrayDrawing" title="Permalink to this definition"></a></dt>
<dd><p>Query if X-ray drawing is enabled globally.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.xrayQuality">
<code class="descname">xrayQuality</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.GeometryViewportSettings.xrayQuality" title="Permalink to this definition"></a></dt>
<dd><p>Queries if high quality X-ray rendering is active.</p>
</dd></dl>

<dl class="method">
<dt id="hou.GeometryViewportSettings.xrayStrength">
<code class="descname">xrayStrength</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; double<a class="headerlink" href="#hou.GeometryViewportSettings.xrayStrength" title="Permalink to this definition"></a></dt>
<dd><p>Query the strength of occluded x-ray objects.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.HDADefinition">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">HDADefinition</code><a class="headerlink" href="#hou.HDADefinition" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Represents the definition of a houdini digital asset (HDA).</p>
<p>A digital asset definition defines a node type and exists inside an hda
file. The node type is implemented in terms of other nodes wired
together inside a subnet. These nodes inside the subnet are called the
definitions contents.</p>
<p>An hda file contains one or more digital asset definitions, and
installing an hda file installs all the definitions in the file. When a
digital asset definition is installed, the node type it defines is added
to Houdini. Note that you can access an HDADefinition without installing
it.</p>
<p>A digital assets algorithm is determined by the nodes inside it. To
edit those nodes you create an instance of the digital asset, unlock it,
modify the contents, and save the definition. New digital asset
instances are normally locked, meaning that they are read-only, and they
automatically update when the assets definition changes. An unlocked
instance is editable, does not update when the definition changes, and
you can save its contents to change the definition.</p>
<p>To unlock a node, select Allow Editing of Contents or call
hou.Node.allowEditingOfContents. To save the contents of an unlocked
node to the definition, select Save Operator Type or call
hou.HDADefinition.updateFromNode. To revert an unlocked instance back to
the last saved definition and change it back into a locked instance,
select Match Current Definition or call hou.Node.matchCurrentDefinition.</p>
<p>See also hou.hda and hou.HDAOptions.</p>
<dl class="method">
<dt id="hou.HDADefinition.addParmFolder">
<code class="descname">addParmFolder</code><span class="sig-paren">(</span><em>folder_name</em>, <em>in_folder=()</em>, <em>parm_name=None</em>, <em>create_missing_folders=False</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.HDADefinition.addParmFolder" title="Permalink to this definition"></a></dt>
<dd><p>addParmFolder(self, folder_name, in_folder=(), parm_name=None,
create_missing_folders=False)</p>
<blockquote>
<div><p>Adds a folder to this node types parameters.</p>
<dl class="docutils">
<dt>folder_name</dt>
<dd>The name of the folder that is displayed in the parameter
dialog.</dd>
<dt>in_folder</dt>
<dd>A sequence of folder name strings to indicate where the folder
should go. If this sequence is empty, the folder will go in top
level set of folders. It it is, for example, (Transform,), the
folder is added inside the Transform folder. If it is
(Transform, Options), it will go inside the Options folder
inside the Transform folder.</dd>
<dt>parm_name</dt>
<dd><p class="first">The name of the underlying parameter tuple corresponding to the
set of folders. For example, the folders in a set might be named
Transform, Subnet, and Controls, and these correspond to one
parameter tuple named, say, stdswitcher0. The value of the
parameter in this tuple is the index of the folder that is open.</p>
<p>If this is the first folder to go in the set, parm_name is used
as the parameter name. Otherwise, it is ignored and Houdini uses
the parameter name of the first folder in the set.</p>
<p class="last">If this is the first folder in the set and parm_name is None, it
will default to folder0. If parm_name is already in use,
Houdini automatically generates a unique name.</p>
</dd>
<dt>create_missing_folders</dt>
<dd>Whether Houdini should create folders specified in in_folder
that do not already exist. If this parameter is True, you can
use this method to add nested folders in one call.</dd>
</dl>
<p>Note that you can add folders by passing a hou.FolderParmTemplate to
the addSpareParmTuple method, so this method is deprecated. Note
also that addSpareParmTuple is deprecated in favor of
setParmTemplateGroup.</p>
<p>See also the removeParmFolder and addParmTuple methods.</p>
<p>This method is deprecated in favor of setParmTemplateGroup.</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.HDADefinition.addParmTuple">
<code class="descname">addParmTuple</code><span class="sig-paren">(</span><em>parm_template</em>, <em>in_folder=()</em>, <em>create_missing_folders=False</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.HDADefinition.addParmTuple" title="Permalink to this definition"></a></dt>
<dd><p>addParmTuple(self, parm_template, in_folder=(),
create_missing_folders=False)</p>
<blockquote>
<div><p>Add a parameter tuple to this node types parameters. Houdini places
the new parameter at the bottom of the parameters in a particular
folder.</p>
<dl class="docutils">
<dt>parm_template</dt>
<dd>An instance of a hou.ParmTemplate subclass that describes the
parameter.</dd>
<dt>in_folder</dt>
<dd>A sequence of folder name strings to tell Houdini which folder
to put the parameter in. If this sequence is empty, the
parameter will go in top level set of folders. It it is, for
example, (Transform,), the parameter is added inside the
Transform folder. If it is (Transform, Options), it will go
inside the Options folder inside the Transform folder.</dd>
<dt>create_missing_folders</dt>
<dd>Whether Houdini should create folders specified in in_folder
that do not already exist. If this parameter is True, you can
create folders without having to call
hou.HDADefinition.addParmFolder.</dd>
</dl>
<p>Note that this method can add a single folder by passing a
hou.FolderParmTemplate for parm_template.</p>
<p>See also hou.HDADefinition.replaceParmTuple.</p>
<p>This method is deprecated in favor of
hou.HDADefinition.setParmTemplateGroup.</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.HDADefinition.addSection">
<code class="descname">addSection</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.HDADefinition.addSection" title="Permalink to this definition"></a></dt>
<dd><p>addSection(self, name, contents=,
compression_type=hou.compressionType.NoCompression) -&gt; hou.HDASection</p>
<blockquote>
<div><blockquote>
<div><p>Create a new section with the specified contents. If a section
already exists with this name, changes the existing contents to the
new contents. Note that the contents may contain binary data. Also
note that section names may contain /.</p>
<p>You can optionally specify a compression type, hou.compressionType,
to compress the contents. Note that you must specify the same
compression type when reading the contents back to decompress them.</p>
<p>See hou.HDASection for more information on sections. To remove a
section, use hou.HDASection.destroy.</p>
<p>Sections can have associated properties stored in the
hou.HDADefinition.extraFileOptions.</p>
</div></blockquote>
<p>&gt; def addSectionFromFile(hda_definition, section_name, file_name):
&gt;     Add a section whose contents come from a file.  If the section
&gt;        already exists, replace its contents.
&gt;     section_file = open(file_name, r)
&gt;     hda_definition.addSection(section_name, section_file.read())
&gt;     section_file.close()</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.HDADefinition.comment">
<code class="descname">comment</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.HDADefinition.comment" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.HDADefinition.compileCodeSection">
<code class="descname">compileCodeSection</code><span class="sig-paren">(</span><em>self</em>, <em>source_section</em>, <em>destination_section</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.HDADefinition.compileCodeSection" title="Permalink to this definition"></a></dt>
<dd><p>This function is deprecated. Compiled VEX code should no longer be
stored inside of an HDA.</p>
</dd></dl>

<dl class="method">
<dt id="hou.HDADefinition.copyToHDAFile">
<code class="descname">copyToHDAFile</code><span class="sig-paren">(</span><em>self</em>, <em>file_name</em>, <em>new_name=None</em>, <em>new_menu_name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.HDADefinition.copyToHDAFile" title="Permalink to this definition"></a></dt>
<dd><p>Copy this definition into an hda file.</p>
<dl class="docutils">
<dt>file_name</dt>
<dd>The hda file where the definition will be saved. If the file
does not already exist, it will be created. If it already
contains a definition for this node type, it will be
overwritten.</dd>
<dt>new_name</dt>
<dd>The new name of the node type. If None, the definition will be
saved as the existing node type name. See also
hou.NodeType.name.</dd>
<dt>new_menu_name</dt>
<dd>The new description of the node type that appears in the tab
menu. If None, Houdini will use the existing description. Note
that the node type name must be unique within the hda file, so
saving the definition with a new description to an hda file
containing a definition with the old node name will still
overwrite the existing definition. See also
hou.NodeType.description.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hou.HDADefinition.current">
<code class="descname">current</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.HDADefinition.current" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.HDADefinition.description">
<code class="descname">description</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.HDADefinition.description" title="Permalink to this definition"></a></dt>
<dd><p>Return the description for this definitions node type. Houdini uses
this description for user interface elements such as the TAB menu.
This description is also called the operator label in Houdini.</p>
<p>See also hou.NodeType.description.</p>
</dd></dl>

<dl class="method">
<dt id="hou.HDADefinition.destroy">
<code class="descname">destroy</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.HDADefinition.destroy" title="Permalink to this definition"></a></dt>
<dd><p>Uninstall this definition and _delete it from the hda <a href="#id59"><span class="problematic" id="id60">file_</span></a>. Any
node instances of this asset will warn that they are using an
incomplete asset definition.</p>
<p>See also hou.hda.uninstallFile.</p>
</dd></dl>

<dl class="method">
<dt id="hou.HDADefinition.embeddedHelp">
<code class="descname">embeddedHelp</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.HDADefinition.embeddedHelp" title="Permalink to this definition"></a></dt>
<dd><p>Return the help text embedded in the digital asset. Return an empty
string if no embedded help exists.</p>
<p>Embedded help typically comes from the Help tab of the operator type
properties window, but it may also come from a dialog script.</p>
</dd></dl>

<dl class="method">
<dt id="hou.HDADefinition.extraFileOptions">
<code class="descname">extraFileOptions</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; dict of str to bool, int, float, str<a class="headerlink" href="#hou.HDADefinition.extraFileOptions" title="Permalink to this definition"></a></dt>
<dd><p>Return a dictionary containing the extra options attached to
sections in the assets definition. For example, event handler
scripts such as OnCreated are stored as sections inside the asset,
and extra metadata in this dictionary determines whether Houdini
runs these scripts as Python as as Hscript.</p>
<p>These is one dictionary for the entire asset, and keys in this
dictionary are usually of the form section_name/option_name. For
example, if the OnCreated section is marked as containing Python
code, this dictionary will contain OnCreated/IsPython set to True.</p>
<p>Note that the contents of this dictionary are saved in the
ExtraFileOptions section and are encoded in a binary format.</p>
<p>See also hou.HDADefinition.setExtraFileOption and
hou.HDADefinition.removeExtraFileOption.</p>
</dd></dl>

<dl class="method">
<dt id="hou.HDADefinition.extraInfo">
<code class="descname">extraInfo</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.HDADefinition.extraInfo" title="Permalink to this definition"></a></dt>
<dd><p>Return a string storing extra information about the asset definition
that isnt stored elsewhere, like the representative node, guide
geometry, whether default parameters are hidden, etc.</p>
<p>See also hou.HDADefinition.representativeNodePath and
hou.HDADefinition.hideDefaultParameters to more easily retrieve some
portions of the extra info.</p>
</dd></dl>

<dl class="method">
<dt id="hou.HDADefinition.hasSection">
<code class="descname">hasSection</code><span class="sig-paren">(</span><em>self</em>, <em>name</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.HDADefinition.hasSection" title="Permalink to this definition"></a></dt>
<dd><p>Return True if the HDA definition contains a section with the
specified name and False otherwise.</p>
<p>See hou.HDASection for more information on sections.</p>
</dd></dl>

<dl class="method">
<dt id="hou.HDADefinition.hideDefaultParameters">
<code class="descname">hideDefaultParameters</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.HDADefinition.hideDefaultParameters" title="Permalink to this definition"></a></dt>
<dd><p>Return whether the parameters that are common to nodes types in this
node type category are hidden or not. For example, nearly all
objects have common translation, rotation, scale, etc. parameters,
and object level digital assets have these parameters by default. If
hidden, though, these parameters are still there but are not
displayed to the user.</p>
<p>Note that this value is also stored in the string returned by
hou.HDADefinition.extraInfo.</p>
</dd></dl>

<dl class="method">
<dt id="hou.HDADefinition.icon">
<code class="descname">icon</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.HDADefinition.icon" title="Permalink to this definition"></a></dt>
<dd><p>Return the name or path of the icon for this definitions node type.
Note that Houdini uses its search path to locate icons, so you do
not need to pass in a full path.</p>
<p>See also hou.NodeType.icon.</p>
</dd></dl>

<dl class="method">
<dt id="hou.HDADefinition.installed">
<code class="descname">installed</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.HDADefinition.installed" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.HDADefinition.isCurrent">
<code class="descname">isCurrent</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.HDADefinition.isCurrent" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Return whether this definition is the one currently in use by
Houdini.</p>
<p>This example shows how you can access other definitions for the same
node type:</p>
</div></blockquote>
<p>&gt; def otherDefinitions(definition):
&gt;     Given an HDADefinition object, return the other loaded definitions
&gt;        for the same node type.
&gt;     # Look through all the loaded hda files for definitions providing
&gt;     # the same node type.
&gt;     result = []
&gt;     for hda_file in hou.hda.loadedFiles():
&gt;         # Skip the hda file containing the definition that was passed in.
&gt;         if hda_file == definition.libraryFilePath():
&gt;             continue
&gt; 
&gt;         for other_definition in hou.hda.definitionsInFile(hda_file):
&gt;             if other_definition.nodeType() == definition.nodeType():
&gt;                 result.append(other_definition)
&gt;     return result
&gt; # Print the paths to hda files providing other definitions for a digital asset instance.
&gt; &gt;&gt;&gt; for other_definition in otherDefinitions(hou.node(/obj/my_hda1).type().definition()):
&gt;      print other_definition.libraryFilePath()
&gt; /path/to/file1.hda
&gt; /path/to/file2.hda</p>
</dd></dl>

<dl class="method">
<dt id="hou.HDADefinition.isInstalled">
<code class="descname">isInstalled</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.HDADefinition.isInstalled" title="Permalink to this definition"></a></dt>
<dd><p>Return whether this definition is installed in Houdini.</p>
<p>It is possible to access HDADefinition objects in hda files that are
not installed with hou.hda.definitionsInFile.</p>
<p>See also hou.hda.installFile.</p>
</dd></dl>

<dl class="method">
<dt id="hou.HDADefinition.isPreferred">
<code class="descname">isPreferred</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.HDADefinition.isPreferred" title="Permalink to this definition"></a></dt>
<dd><p>Return whether this definition is preferred.</p>
<p>After loading hda files, Houdini uses a set of rules to resolve
conflicts when it encounters multiple definitions for the same node
type (e.g. preferring the most recent hda file, preferring
definitions embedded in the hip file, etc.). When these rules do not
use the definition you want, you can override them by explicitly
marking a definition as preferred. Houdini saves this list of
preferred definitions with the hip file. Marking a definition as not
preferred will remove it from this list, and the normal rules will
apply again.</p>
</dd></dl>

<dl class="method">
<dt id="hou.HDADefinition.libraryFilePath">
<code class="descname">libraryFilePath</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.HDADefinition.libraryFilePath" title="Permalink to this definition"></a></dt>
<dd><p>Return the path to the hda file containing the digital assets
definition.</p>
<p>Note that it is possible to save an asset with a hip file, without
storing it in an hda file. In this case, this method returns
Embedded.</p>
</dd></dl>

<dl class="method">
<dt id="hou.HDADefinition.maxNumInputs">
<code class="descname">maxNumInputs</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.HDADefinition.maxNumInputs" title="Permalink to this definition"></a></dt>
<dd><p>Return the maximum number of inputs that node instances of this
digital asset can have. Return a number greater than 4 if this node
type can accept an unlimited number of inputs.</p>
<p>See also hou.NodeType.maxNumInputs.</p>
</dd></dl>

<dl class="method">
<dt id="hou.HDADefinition.minNumInputs">
<code class="descname">minNumInputs</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.HDADefinition.minNumInputs" title="Permalink to this definition"></a></dt>
<dd><p>Return the minimum number of connected inputs that node instances of
this digital asset can have. If these inputs are not connected, the
node will generate an error.</p>
<p>See also hou.NodeType.minNumInputs.</p>
</dd></dl>

<dl class="method">
<dt id="hou.HDADefinition.modificationTime">
<code class="descname">modificationTime</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.HDADefinition.modificationTime" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Return the time when the definition was last modified. This time is
returned as a POSIX timestamp, such as is returned by time.time().</div></blockquote>
<p>&gt; &gt;&gt;&gt; import time
&gt; &gt;&gt;&gt; time.ctime(hou.nodeType(hou.objNodeTypeCategory(), toon_character).
&gt;      definition().modificationTime())
&gt; Thu Nov  6 18:22:38 2008</p>
</dd></dl>

<dl class="method">
<dt id="hou.HDADefinition.nodeType">
<code class="descname">nodeType</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.NodeType<a class="headerlink" href="#hou.HDADefinition.nodeType" title="Permalink to this definition"></a></dt>
<dd><p>Return the node type defined by this digital asset. Raises
hou.OperationFailed if the digital asset is not installed.</p>
</dd></dl>

<dl class="method">
<dt id="hou.HDADefinition.nodeTypeCategory">
<code class="descname">nodeTypeCategory</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.NodeTypeCategory<a class="headerlink" href="#hou.HDADefinition.nodeTypeCategory" title="Permalink to this definition"></a></dt>
<dd><p>Return the node type category (e.g. Objects, SOPs, DOPs, etc.) for
the node type defined by this digital asset. See
hou.NodeTypeCategory for more information.</p>
<p>It is safe to call this method if the digital asset is not
installed. If the digital asset is installed, this method is
equivalent to self.nodeType().category().</p>
</dd></dl>

<dl class="method">
<dt id="hou.HDADefinition.nodeTypeName">
<code class="descname">nodeTypeName</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.HDADefinition.nodeTypeName" title="Permalink to this definition"></a></dt>
<dd><p>Return the name of the node type defined by this digital asset.
Raises hou.OperationFailed if the digital asset is not installed.</p>
<p>If the digital asset is installed, this method is a shortcut for
self.nodeType().name().</p>
</dd></dl>

<dl class="method">
<dt id="hou.HDADefinition.options">
<code class="descname">options</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.HDAOptions<a class="headerlink" href="#hou.HDADefinition.options" title="Permalink to this definition"></a></dt>
<dd><p>Return a hou.HDAOptions object for the options stored in this
digital asset. See hou.HDAOptions for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.HDADefinition.parmTemplateGroup">
<code class="descname">parmTemplateGroup</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.ParmTemplateGroup<a class="headerlink" href="#hou.HDADefinition.parmTemplateGroup" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Return the group of parm templates corresponding to the current
parameter layout for this node.</p>
<p>You can edit the parameter layout for this node (add or remove spare
parameters, reorder or hide built-in parameters, etc.) by getting
the current parameter group, modifying it, and calling
hou.Node.setParmTemplateGroup with it.</p>
<p>The following example creates a geometry object, adds a My Parms
folder to it, and adds a My Parm float parameter to it in that
folder. The parameters are added only to the geometry object
created; other geometry objects are unaffected.</p>
</div></blockquote>
<p>&gt; &gt;&gt;&gt; node = hou.node(/obj).createNode(geo)
&gt; &gt;&gt;&gt; group = node.parmTemplateGroup()
&gt; &gt;&gt;&gt; folder = hou.FolderParmTemplate(folder, My Parms)
&gt; &gt;&gt;&gt; folder.addParmTemplate(hou.FloatParmTemplate(myparm, My Parm, 1))
&gt; &gt;&gt;&gt; group.append(folder)
&gt; &gt;&gt;&gt; node.setParmTemplateGroup(group)</p>
<blockquote>
<div>See hou.ParmTemplateGroup and the setParmTemplateGroup method for
more information and examples.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.HDADefinition.parsedContents">
<code class="descname">parsedContents</code><span class="sig-paren">(</span><em>self) -&gt; tuple of (str</em>, <em>str</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.HDADefinition.parsedContents" title="Permalink to this definition"></a></dt>
<dd><p>Return a list of (name, value) pairs of the parsed from the Contents
section.</p>
<p>The Contents section consists of the child nodes used to create a
node instance of the HDA.</p>
<p>See also hou.HDADefinition.uncompressedContents.</p>
</dd></dl>

<dl class="method">
<dt id="hou.HDADefinition.preferred">
<code class="descname">preferred</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.HDADefinition.preferred" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.HDADefinition.removeExtraFileOption">
<code class="descname">removeExtraFileOption</code><span class="sig-paren">(</span><em>self</em>, <em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.HDADefinition.removeExtraFileOption" title="Permalink to this definition"></a></dt>
<dd><p>Remove an entry in the dictionary of extra file options. See
hou.HDADefinition.extraFileOptions for more information.</p>
<p>Raises hou.OperationFailed if there is no entry in the dictionary
with this name.</p>
</dd></dl>

<dl class="method">
<dt id="hou.HDADefinition.removeParmFolder">
<code class="descname">removeParmFolder</code><span class="sig-paren">(</span><em>self</em>, <em>folder</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.HDADefinition.removeParmFolder" title="Permalink to this definition"></a></dt>
<dd><p>Remove an empty folder from this node types parameters.</p>
<dl class="docutils">
<dt>folder</dt>
<dd>A _sequence of folder <a href="#id61"><span class="problematic" id="id62">names_</span></a>. For example, to remove the Output
folder, pass in (Output,) and not Output.</dd>
</dl>
<p>Raises hou.OperationFailed if the folder does not exist or it is not
empty. Use hou.HDADefinition.removeParmTuple to remove all the
parameters inside the folder before calling this method.</p>
<p>See also addParmFolder, hou.ParmTemplateGroup.remove, and
hou.ParmTemplateGroup.findFolder.</p>
<p>This method is deprecated in favor of
hou.HDADefinition.setParmTemplateGroup.</p>
</dd></dl>

<dl class="method">
<dt id="hou.HDADefinition.removeParmTuple">
<code class="descname">removeParmTuple</code><span class="sig-paren">(</span><em>self</em>, <em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.HDADefinition.removeParmTuple" title="Permalink to this definition"></a></dt>
<dd><p>Remove a parameter tuple from this node types parameters.</p>
<p>See also hou.HDADefinition.addParmTuple and
hou.HDADefinition.removeParmFolder.</p>
<p>This method is deprecated in favor of
hou.HDADefinition.setParmTemplateGroup.</p>
</dd></dl>

<dl class="method">
<dt id="hou.HDADefinition.removeSection">
<code class="descname">removeSection</code><span class="sig-paren">(</span><em>self</em>, <em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.HDADefinition.removeSection" title="Permalink to this definition"></a></dt>
<dd><p>Remove an existing section. Only remove sections that you explicitly
added. Do not remove the special sections that Houdini uses to store
the contents of the digital asset definition, or Houdini will
generate errors or strange side effects.</p>
<p>See hou.HDASection for more information on sections. Note that
hou.HDASection.destroy will also remove a section.</p>
<p>Raises hou.OperationFailed if no such section exists in the
definition.</p>
</dd></dl>

<dl class="method">
<dt id="hou.HDADefinition.replaceParmTuple">
<code class="descname">replaceParmTuple</code><span class="sig-paren">(</span><em>self</em>, <em>parm_tuple_name</em>, <em>parm_template</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.HDADefinition.replaceParmTuple" title="Permalink to this definition"></a></dt>
<dd><p>Replace an existing parameter tuple with a new one. The old
parameter tuple is removed and the new one is added in its place.</p>
<dl class="docutils">
<dt>parm_tuple_name</dt>
<dd>The name of the parameter tuple to replace. Raises
hou.OperationFailed if no parameter tuple exists with this name.</dd>
<dt>parm_template</dt>
<dd>A hou.ParmTemplate describing the new parameter tuple.</dd>
</dl>
<p>The new parameter tuple may or may not have the same name as the old
one. By providing a parameter tuple with the same name, you can
modify an existing parameter tuple. The following example function
changes the definition of the asset to make a parameter tuple
visible or invisible in all nodes of that type.</p>
<p>To show or hide a parameter in just one instance of a node, use
hou.ParmTuple.hide.</p>
<p>To change a spare parameter on a node, use
hou.Node.replaceSpareParmTuple or hou.Node.setParmTemplateGroup.</p>
<p>This method is deprecated in favor of
hou.HDADefinition.setParmTemplateGroup.</p>
</dd></dl>

<dl class="method">
<dt id="hou.HDADefinition.representativeNodePath">
<code class="descname">representativeNodePath</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.HDADefinition.representativeNodePath" title="Permalink to this definition"></a></dt>
<dd><p>Return the contents of the Representative Node field on the Basic
tab of the Type Properties dialog.</p>
<p>For object-level digital assets that contain other object nodes, it
is possible to make Houdini treat your digital asset like a camera
or light by choosing a node inside the asset to represent it. For
example, if you choose a camera inside the asset as the
representative node, instances of the digital asset will appear in
the viewports list of camera objects.</p>
<p>Note that this value is also stored in the string returned by
hou.HDADefinition.extraInfo.</p>
</dd></dl>

<dl class="method">
<dt id="hou.HDADefinition.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.HDADefinition.save" title="Permalink to this definition"></a></dt>
<dd><p>save(self, file_name, template_node=None, options=None,
create_backup=True)</p>
<blockquote>
<div><p>Save the definition into an hda file.</p>
<dl class="docutils">
<dt>file_name</dt>
<dd>Where to save the definition. To save to the current hda file,
use the return value from hou.HDADefinition.libraryFilePath.</dd>
<dt>template_node</dt>
<dd>Either None or a hou.Node object containing an unlocked instance
of the digital asset that defines the definitions new contents.
If None, this method does not update the definitions contents.</dd>
<dt>options</dt>
<dd>Either None or a hou.HDAOptions object that specifies extra
behaviors of the definition. If template_node is not None, the
compressContents, lockContents, saveSpareParms, and
makeInitialParmsDefaults values of the hou.HDAOptions object are
used. Otherwise, only the compressContents value is used.</dd>
<dt>create_backup</dt>
<dd>Create a backup before modifying existing hda files.</dd>
</dl>
<p>See also hou.HDADefinition.updateFromNode for a way to save an
unlocked nodes definition to the current hda file. See also
hou.HDADefinition.copyToHDAFile.</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.HDADefinition.sections">
<code class="descname">sections</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; dict of str to hou.HDASection<a class="headerlink" href="#hou.HDADefinition.sections" title="Permalink to this definition"></a></dt>
<dd><p>Return a dictionary mapping section names to hou.HDASection objects.
See hou.HDASection for more information on sections.</p>
</dd></dl>

<dl class="method">
<dt id="hou.HDADefinition.setComment">
<code class="descname">setComment</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.HDADefinition.setComment" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.HDADefinition.setDescription">
<code class="descname">setDescription</code><span class="sig-paren">(</span><em>self</em>, <em>description</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.HDADefinition.setDescription" title="Permalink to this definition"></a></dt>
<dd><p>Set the description for this definitions node type. Houdini uses
this description for user interface elements such as the TAB menu.
This description is also called the operator label in Houdini.</p>
<p>See also hou.HDADefinition.description and hou.NodeType.description.</p>
</dd></dl>

<dl class="method">
<dt id="hou.HDADefinition.setExtraFileOption">
<code class="descname">setExtraFileOption</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.HDADefinition.setExtraFileOption" title="Permalink to this definition"></a></dt>
<dd><p>setExtraFileOption(self, name, value, type_hint =
hou.fieldType::NoSuchField)</p>
<blockquote>
<div><blockquote>
<div><p>Set an entry in the dictionary of extra file options. See
hou.HDADefinition.extraFileOptions for more information.</p>
<dl class="docutils">
<dt>name</dt>
<dd>The name of the option to set.</dd>
<dt>value</dt>
<dd>An integer, float, string, hou.Vector2, hou.Vector3,
hou.Vector4, hou.Quaternion, hou.Matrix3, hou.matrix4, or
sequence of numbers.</dd>
<dt>type_hint</dt>
<dd>Used to determine the exact hou.fieldType desired when the
specified value type is not enough to unambiguously determine
it.</dd>
</dl>
<p>The following example function marks an section, such as OnCreated,
as containing Python code:</p>
</div></blockquote>
<p>&gt; def markSectionAsPython(definition, section_name):
&gt;     definition.setExtraFileOption(section_name + /IsPython, True)</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.HDADefinition.setExtraInfo">
<code class="descname">setExtraInfo</code><span class="sig-paren">(</span><em>self</em>, <em>extra_info</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.HDADefinition.setExtraInfo" title="Permalink to this definition"></a></dt>
<dd><p>Set extra information about the asset definition that isnt stored
elsewhere, like the representative node, guide geometry, etc. This
string is encoded in a specific format, so it is recommended that
you only call this method with values returned from
hou.HDADefinition.extraInfo.</p>
</dd></dl>

<dl class="method">
<dt id="hou.HDADefinition.setIcon">
<code class="descname">setIcon</code><span class="sig-paren">(</span><em>self</em>, <em>icon</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.HDADefinition.setIcon" title="Permalink to this definition"></a></dt>
<dd><p>Set the icon for this definitions node type. See
hou.HDADefinition.icon for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.HDADefinition.setIsPreferred">
<code class="descname">setIsPreferred</code><span class="sig-paren">(</span><em>self</em>, <em>preferred</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.HDADefinition.setIsPreferred" title="Permalink to this definition"></a></dt>
<dd><p>Set whether this definition is preferred. See
hou.HDADefinition.isPreferred for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.HDADefinition.setMaxNumInputs">
<code class="descname">setMaxNumInputs</code><span class="sig-paren">(</span><em>self</em>, <em>max_num_inputs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.HDADefinition.setMaxNumInputs" title="Permalink to this definition"></a></dt>
<dd><p>Set the maximum number of inputs that node instances of this digital
asset may have. This number must be greater than or equal to the
minimum number of inputs. If it is 5 or greater, Houdini will use a
merge SOP-style input connector that allows an unlimited number of
inputs. Otherwise, the node will have between 0 and 4 input
connectors, each of which may or may not be connected, that
correspond to the subnet indirect inputs inside the digital asset.</p>
<p>See hou.Node.inputConnectors and hou.SubnetIndirectInput for more
information on input connectors and subnet indirect inputs.</p>
</dd></dl>

<dl class="method">
<dt id="hou.HDADefinition.setMinNumInputs">
<code class="descname">setMinNumInputs</code><span class="sig-paren">(</span><em>self</em>, <em>min_num_inputs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.HDADefinition.setMinNumInputs" title="Permalink to this definition"></a></dt>
<dd><p>Set the minimum number of connected inputs that node instances of
this digital asset must have. min_num_inputs must be between 0 and
4, inclusive. If a node does not have the minimum number of inputs,
it will generate an error.</p>
</dd></dl>

<dl class="method">
<dt id="hou.HDADefinition.setModificationTime">
<code class="descname">setModificationTime</code><span class="sig-paren">(</span><em>self</em>, <em>time=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.HDADefinition.setModificationTime" title="Permalink to this definition"></a></dt>
<dd><p>Set the modification time for the definition to the given POSIX
timestamp. If the time parameter is negative, uses the current time.</p>
<p>See also hou.HDADefinition.modificationTime.</p>
</dd></dl>

<dl class="method">
<dt id="hou.HDADefinition.setOptions">
<code class="descname">setOptions</code><span class="sig-paren">(</span><em>self</em>, <em>options</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.HDADefinition.setOptions" title="Permalink to this definition"></a></dt>
<dd><p>Set this digital asset definitions options to the data in a
hou.HDAOptions object. See hou.HDAOptions for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.HDADefinition.setParmTemplateGroup">
<code class="descname">setParmTemplateGroup</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.HDADefinition.setParmTemplateGroup" title="Permalink to this definition"></a></dt>
<dd><p>setParmTemplateGroup(self, parm_template_group,
rename_conflicting_parms=False)</p>
<blockquote>
<div><p>Change the spare parameters for this node.</p>
<dl class="docutils">
<dt>parm_template_group</dt>
<dd>A hou.ParmTemplateGroup object containing the new parameter
layout.</dd>
<dt>rename_conflicting_parms</dt>
<dd>If True, parameters in the group with the same parm tuple names
will be automatically renamed. If False and there are parms with
the same name, this method raises hou.OperationFailed.</dd>
</dl>
<p>Note that each node type has a set of parameters which must exist
and must be of certain types. If your parm template group does not
contain the required parameters for the node type the will be added
at the bottom and will be made invisible. Similarly, if your parm
template group attempts to modify the type, range, label, or other
property of a required parameter, all changes to that parameter
other than visibility settings will be ignored.</p>
<p>This method is preferred over the other parameter-related methods in
this class (addSpareParmTuple, removeSpareParmTuple,
replaceSpareParmTuple, addSpareParmFolder, removeSpareParmFolder)
because it lets you more easily make manipulate parameters.</p>
<p>See hou.HDADefinition.setParmTemplateGroup to change the parameter
interface of a digital asset.</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.HDADefinition.setPreferred">
<code class="descname">setPreferred</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.HDADefinition.setPreferred" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.HDADefinition.setUserInfo">
<code class="descname">setUserInfo</code><span class="sig-paren">(</span><em>self</em>, <em>extra_info</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.HDADefinition.setUserInfo" title="Permalink to this definition"></a></dt>
<dd><p>Set user information about the asset definition. This info isnt
used by Houdini so it can contain any text.</p>
</dd></dl>

<dl class="method">
<dt id="hou.HDADefinition.setVersion">
<code class="descname">setVersion</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.HDADefinition.setVersion" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.HDADefinition.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.HDADefinition.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

<dl class="method">
<dt id="hou.HDADefinition.uncompressedContents">
<code class="descname">uncompressedContents</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.HDADefinition.uncompressedContents" title="Permalink to this definition"></a></dt>
<dd><p>Return a string containing the data of the uncompressed Contents
section.</p>
<p>The Contents section consists of data in the CPIO format
representing the child nodes used to create a node instance of the
HDA.</p>
<p>See also hou.HDADefinition.parsedContents.</p>
</dd></dl>

<dl class="method">
<dt id="hou.HDADefinition.updateFromNode">
<code class="descname">updateFromNode</code><span class="sig-paren">(</span><em>self</em>, <em>node</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.HDADefinition.updateFromNode" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Update and save the definition to match the contents of a given
unlocked instance of the asset. Calling this method is the same as
selecting Save Operator Type on the nodes menu.</div></blockquote>
<p>&gt; def saveUnlockedNodes():
&gt;     Look through all the nodes in the file for unlocked digital asset
&gt;        instances and save and lock them.
&gt;     for node in hou.node(/).allSubChildren():
&gt;         if node.type().definition() is None or node.matchesCurrentDefinition():
&gt;             continue
&gt; 
&gt;         node.type().definition().updateFromNode(node)
&gt;         node.matchCurrentDefinition()</p>
</dd></dl>

<dl class="method">
<dt id="hou.HDADefinition.userInfo">
<code class="descname">userInfo</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.HDADefinition.userInfo" title="Permalink to this definition"></a></dt>
<dd><p>Return a string containing user specified information about the
asset definition.</p>
</dd></dl>

<dl class="method">
<dt id="hou.HDADefinition.version">
<code class="descname">version</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.HDADefinition.version" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.HDAModule">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">HDAModule</code><a class="headerlink" href="#hou.HDAModule" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>User-defined Python module containing functions, classes, and constants
that are stored with and accessed from a digital asset.</p>
<p>In Python, a module lets you organize functions, classes, and constants
into a common namespace. For example, os is a module and os.getcwd is a
function inside that module, and you access the contents of a module by
looking up Python attributes on it.</p>
<p>An HDAModule is a Python module that is associated with a particular
digital asset type. It lets you store a library of Python code in one
location in your asset, and you can invoke that code from parameters,
event handlers, and callbacks inside that asset.</p>
<p>The modules source code is stored in the Python Module section of the
Scripts tab in the Type Properties dialog. For example, suppose the
digit asset is an object named gear and the Python Module section
contains the following:</p>
<p>&gt; def position():
&gt;     return (hou.frame() * 1.2, 0.0, 3.2)
&gt; 
&gt; def onButtonPress():
&gt;     print you pressed the button
&gt; 
&gt; def onLoaded():
&gt;     print onLoaded section running</p>
<p>Unlike regular Python modules, which you access by name, you access a
digital assets Python module by calling hou.NodeType.hdaModule on its
node type. For example, suppose you created an object-level digital
asset named gear and put the above code in its Python Module section.
You could then access the contents of the Python module as follows:</p>
<p>&gt; &gt;&gt;&gt; node_type = hou.nodeType(hou.objNodeTypeCategory(), gear)
&gt; &gt;&gt;&gt; node_type.hdaModule().position()
&gt; (1.2, 0.0, 3.2)
&gt; &gt;&gt;&gt; node_type.hdaModule().onButtonPress()
&gt; you pressed the button</p>
<p>One use for the Python module is drive parameter expressions on nodes
inside the digital asset. For example, suppose /obj/gear1 is an instance
of the digital asset and /obj/gear1/geo1 is a node inside the asset. You
could put the following inside geo1s tx parameter expression:</p>
<p>&gt; hou.node(..).type().hdaModule().position()[0]</p>
<p>For convenience, you can also access the module from a node instance of
the digital asset using hou.Node.hdaModule. So, you could simplify the
above expression to:</p>
<p>&gt; hou.node(..).hdaModule().position()[0]</p>
<p>And since you dont need to use the hou. prefix inside expressions, you
could further simplify it to:</p>
<p>&gt; node(..).hdaModule().position()[0]</p>
<p>The following example shows how you might run code in the module from
the Callback Script field of a button parameter:</p>
<p>&gt; hou.pwd().hdaModule().onButtonPress()</p>
<p>In an event handler script, such as On Loaded, you can use the kwargs
dict to access the node type:</p>
<p>&gt; kwargs[type].hdaModule().onLoaded()</p>
<p>Note that Houdini creates a local kwargs dict thats accessible from the
Python Module, too. It contains one entry with the key type, to give
you access to the hou.NodeType defined by the digital asset.</p>
<p>If you find that a digital asset has too much Python code to store in
one module, its possible to create submodules. For example, if you want
to create a submodule named bar, put its source code in a new digital
asset section (say, bar_PythonModule). Then, from the Python Module
section, you can write the following:</p>
<p>&gt; import toolutils
&gt; bar = toolutils.createModuleFromSection(bar, kwargs[type], bar_PythonModule)</p>
<p>bar now appears as a submodule of the main module. If, for example, the
bar_PythonModule section contains:</p>
<p>&gt; def foo():
&gt;     return 3.2</p>
<p>then you could write the following from a parameter on the digital asset
node:</p>
<p>&gt; pwd().hdaModule().bar.foo()</p>
<p>Note that the Python Module code is stored in a section of the digital
asset named PythonModule. For example, you can get a string containing
that source code using
node_type.definition().sections()[PythonModule].contents().</p>
<dl class="attribute">
<dt id="hou.HDAModule.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.HDAModule.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.HDAOptions">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">HDAOptions</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.HDAOptions" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Stores miscellaneous options about a houdini digital asset (HDA).</p>
<p>The contents of this object correspond to some of the checkboxes on the
Basic tab of the Type Properties dialog. These values are stored in the
TypePropertiesOptions section of a digital asset definition.</p>
<p>Call hou.HDADefinition.options to get an HDAOptions instance. Note that
an instance of this class is simply a data structure, and is not
associated with an particular digital asset instance. In other words,
changing the values inside this object will not change the digital
asset. To save these values to the digital asset definition, call
hou.HDADefinition.setOptions.</p>
<p>&gt; &gt;&gt;&gt; node = hou.node(/obj/my_digital_asset1)
&gt; &gt;&gt;&gt; definition = node.type().definition()
&gt; &gt;&gt;&gt; print definition.sections()[TypePropertiesOptions].contents()
&gt; ParmsFromVfl := 0;
&gt; PrefixDroppedParmName := 1;
&gt; UseDSParms := 1;
&gt; ForbidOutsideParms := 1;
&gt; LockContents := 1;
&gt; SaveSpareParms := 0; # &lt; Currently 0
&gt; CheckExternal := 1;
&gt; GzipContents := 1;
&gt; MakeDefault := 1;
&gt; PrefixDroppedParmLabel := 1;
&gt; UnlockOnCreate := 0;
&gt; 
&gt; &gt;&gt;&gt; options = definition.options()
&gt; &gt;&gt;&gt; options.saveSpareParms()
&gt; False
&gt; &gt;&gt;&gt; options.setSaveSpareParms(True)
&gt; &gt;&gt;&gt; definition.setOptions(options)
&gt; &gt;&gt;&gt; print definition.sections()[TypePropertiesOptions].contents()
&gt; ParmsFromVfl := 0;
&gt; PrefixDroppedParmName := 1;
&gt; UseDSParms := 1;
&gt; ForbidOutsideParms := 1;
&gt; LockContents := 1;
&gt; SaveSpareParms := 1; # &lt; Now 1
&gt; CheckExternal := 1;
&gt; GzipContents := 1;
&gt; MakeDefault := 1;
&gt; PrefixDroppedParmLabel := 1;
&gt; UnlockOnCreate := 0;</p>
<dl class="method">
<dt id="hou.HDAOptions.checkForExternalLinks">
<code class="descname">checkForExternalLinks</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.HDAOptions.checkForExternalLinks" title="Permalink to this definition"></a></dt>
<dd><p>Return whether the Check for External Node References option is set.</p>
<p>If set, this option changes all absolute node references inside the
digital asset into relative references.</p>
</dd></dl>

<dl class="method">
<dt id="hou.HDAOptions.compressContents">
<code class="descname">compressContents</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.HDAOptions.compressContents" title="Permalink to this definition"></a></dt>
<dd><p>Return whether the Compress Contents option is on.</p>
<p>When this option is set, Houdini compresses the contents of the
asset definition to reduce the size of the .hda file. Note that this
option only as effect when the result of hou.HDAOptions.lockContents
is True.</p>
</dd></dl>

<dl class="method">
<dt id="hou.HDAOptions.compressionType">
<code class="descname">compressionType</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.HDAOptions.compressionType" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.HDAOptions.forbidOutsideParms">
<code class="descname">forbidOutsideParms</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.HDAOptions.forbidOutsideParms" title="Permalink to this definition"></a></dt>
<dd><p>Return whether the Forbid Linking Parameters from Outside this
Subnet option is set.</p>
<p>When set, this option does not allow you to drag parameters from
nodes outside the contents of the digital asset.</p>
</dd></dl>

<dl class="method">
<dt id="hou.HDAOptions.lockContents">
<code class="descname">lockContents</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.HDAOptions.lockContents" title="Permalink to this definition"></a></dt>
<dd><p>Return whether the Save Contents as Locked option is on.</p>
<p>When this option is not set, Houdini will use a creation script to
store the contents of the digital asset instead of storing the node
data. A creation script cannot store extra data like locked SOPs,
edit SOP information, paint SOP information, etc.</p>
<p>If this option is not set, new instances of the digital asset will
be locked, so the user can edit the contents. However, you probably
do not ever want to turn this option off. Instead, if you want to
lock new instances of the digital asset, see
hou.HDAOptions.unlockNewInstances.</p>
</dd></dl>

<dl class="method">
<dt id="hou.HDAOptions.makeInitialParmsDefaults">
<code class="descname">makeInitialParmsDefaults</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.HDAOptions.makeInitialParmsDefaults" title="Permalink to this definition"></a></dt>
<dd><p>Return whether the Save Defaults as Initial Parameters option is on.</p>
<p>When set, this option uses the default values of the original
parameters as the initial values for new nodes, instead of their
current values.</p>
</dd></dl>

<dl class="method">
<dt id="hou.HDAOptions.parametersFromVexCode">
<code class="descname">parametersFromVexCode</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.HDAOptions.parametersFromVexCode" title="Permalink to this definition"></a></dt>
<dd><p>Return whether the Get Properties from VEX Code option is on.</p>
<p>When this option is set, most properties and parameters of the
operator come from pragma statements in the VEX source code.</p>
</dd></dl>

<dl class="method">
<dt id="hou.HDAOptions.prefixDroppedParmLabels">
<code class="descname">prefixDroppedParmLabels</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.HDAOptions.prefixDroppedParmLabels" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.HDAOptions.prefixDroppedParmNames">
<code class="descname">prefixDroppedParmNames</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.HDAOptions.prefixDroppedParmNames" title="Permalink to this definition"></a></dt>
<dd><p>Return whether the Prefix Dropped Parameter Names option is on.</p>
<p>When this option is set, Houdini will not include a prefix on
parameter names when you drag and drop parameters into the Existing
Parameters areas of the Parameters tab of the Type Properties
dialog.</p>
<p>See also hou.HDAOptions.prefixDroppedParmLabels.</p>
</dd></dl>

<dl class="method">
<dt id="hou.HDAOptions.saveCachedCode">
<code class="descname">saveCachedCode</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.HDAOptions.saveCachedCode" title="Permalink to this definition"></a></dt>
<dd><p>Return the Save Cached Code option.</p>
<p>When set, this option will save cached code for applicable
definitions, such as digital assets defined by VOP networks that
generate VEX code. With this option on, the compiled code will be
saved to the HDA section(s) and will be used for shaders, etc,
without the need to recompile the network. This can save significant
amounts of time for complex shaders.</p>
</dd></dl>

<dl class="method">
<dt id="hou.HDAOptions.saveInitialParmsAndContents">
<code class="descname">saveInitialParmsAndContents</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.HDAOptions.saveInitialParmsAndContents" title="Permalink to this definition"></a></dt>
<dd><p>Return whether the Save Initial Contents and Parameters option is
on.</p>
<p>When this option is set, Houdini saves any parameter values and node
contents referenced by the digital asset to be saved as part of the
assets definition.</p>
</dd></dl>

<dl class="method">
<dt id="hou.HDAOptions.saveSpareParms">
<code class="descname">saveSpareParms</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.HDAOptions.saveSpareParms" title="Permalink to this definition"></a></dt>
<dd><p>Return the Save Spare Parameters option.</p>
<p>When set, this option will add code into the asset creation script
to recreate the nodes current spare parameters. New node instances
of the digital asset will contain the same spare parameters as those
on the representative node.</p>
</dd></dl>

<dl class="method">
<dt id="hou.HDAOptions.setCheckForExternalLinks">
<code class="descname">setCheckForExternalLinks</code><span class="sig-paren">(</span><em>self</em>, <em>check_for_external_links</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.HDAOptions.setCheckForExternalLinks" title="Permalink to this definition"></a></dt>
<dd><p>Sets the Check for External Node References option. See
hou.HDAOptions.checkForExternalLinks for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.HDAOptions.setCompressContents">
<code class="descname">setCompressContents</code><span class="sig-paren">(</span><em>self</em>, <em>compress_contents</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.HDAOptions.setCompressContents" title="Permalink to this definition"></a></dt>
<dd><p>Sets the Compress Contents option. See
hou.HDAOptions.compressContents for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.HDAOptions.setCompressionType">
<code class="descname">setCompressionType</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.HDAOptions.setCompressionType" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.HDAOptions.setForbidOutsideParms">
<code class="descname">setForbidOutsideParms</code><span class="sig-paren">(</span><em>self</em>, <em>forbid_outside_parms</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.HDAOptions.setForbidOutsideParms" title="Permalink to this definition"></a></dt>
<dd><p>Sets the Forbid Linking Parameters from Outside this Subnet option.
See hou.HDAOptions.forbidOutsideParms for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.HDAOptions.setLockContents">
<code class="descname">setLockContents</code><span class="sig-paren">(</span><em>self</em>, <em>lock_contents</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.HDAOptions.setLockContents" title="Permalink to this definition"></a></dt>
<dd><p>Sets the Save Contents as Locked option. See
hou.HDAOptions.lockContents for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.HDAOptions.setMakeInitialParmsDefaults">
<code class="descname">setMakeInitialParmsDefaults</code><span class="sig-paren">(</span><em>self</em>, <em>make_initial_parms_defaults</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.HDAOptions.setMakeInitialParmsDefaults" title="Permalink to this definition"></a></dt>
<dd><p>Sets the Save Defaults as Initial Parameters option. See
hou.HDAOptions.makeInitialParmsDefaults for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.HDAOptions.setParametersFromVexCode">
<code class="descname">setParametersFromVexCode</code><span class="sig-paren">(</span><em>self</em>, <em>parameters_from_vex_code</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.HDAOptions.setParametersFromVexCode" title="Permalink to this definition"></a></dt>
<dd><p>Sets the Get Properties from VEX Code option. See
hou.HDAOptions.parametersFromVexCode for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.HDAOptions.setPrefixDroppedParmLabels">
<code class="descname">setPrefixDroppedParmLabels</code><span class="sig-paren">(</span><em>self</em>, <em>prefix_dropped_parm_labels</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.HDAOptions.setPrefixDroppedParmLabels" title="Permalink to this definition"></a></dt>
<dd><p>Sets the Prefix Dropped Parameter Labels option. See
hou.HDAOptions.prefixDroppedParmLabels for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.HDAOptions.setPrefixDroppedParmNames">
<code class="descname">setPrefixDroppedParmNames</code><span class="sig-paren">(</span><em>self</em>, <em>prefix_dropped_parm_names</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.HDAOptions.setPrefixDroppedParmNames" title="Permalink to this definition"></a></dt>
<dd><p>Sets the Prefix Dropped Parameter Names option. See
hou.HDAOptions.prefixDroppedParmNames for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.HDAOptions.setSaveCachedCode">
<code class="descname">setSaveCachedCode</code><span class="sig-paren">(</span><em>self</em>, <em>save_cached_code</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.HDAOptions.setSaveCachedCode" title="Permalink to this definition"></a></dt>
<dd><p>Set the Save Cached Code option. See hou.HDAOptions.saveCachedCode
for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.HDAOptions.setSaveInitialParmsAndContents">
<code class="descname">setSaveInitialParmsAndContents</code><span class="sig-paren">(</span><em>self</em>, <em>save_initial_parms_and_contents</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.HDAOptions.setSaveInitialParmsAndContents" title="Permalink to this definition"></a></dt>
<dd><p>Set the Save Initial Contents and Parameters option. See
hou.HDAOptions.saveInitialParmsAndContents for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.HDAOptions.setSaveSpareParms">
<code class="descname">setSaveSpareParms</code><span class="sig-paren">(</span><em>self</em>, <em>save_spare_parms</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.HDAOptions.setSaveSpareParms" title="Permalink to this definition"></a></dt>
<dd><p>Set the Save Spare Parameters option. See
hou.HDAOptions.saveSpareParms for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.HDAOptions.setUnlockNewInstances">
<code class="descname">setUnlockNewInstances</code><span class="sig-paren">(</span><em>self</em>, <em>unlock_new_instances</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.HDAOptions.setUnlockNewInstances" title="Permalink to this definition"></a></dt>
<dd><p>Sets the Unlock New Nodes on Creation option. See
hou.HDAOptions.unlockNewInstances for more information.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.HDAOptions.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.HDAOptions.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

<dl class="method">
<dt id="hou.HDAOptions.unlockNewInstances">
<code class="descname">unlockNewInstances</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.HDAOptions.unlockNewInstances" title="Permalink to this definition"></a></dt>
<dd><p>Return whether the Unlock New Nodes on Creation option is set.</p>
<p>When this option is set, Houdini will unlock new instances of the
digital asset when they are created. Note that this option only has
effect when the result of hou.HDAOptions.lockContents is True.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.HDASection">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">HDASection</code><a class="headerlink" href="#hou.HDASection" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Represents a section of data stored along with a digital asset.</p>
<p>A digital asset stores its contents in a number of different pieces of
data called sections. Each section is named and contains an arbitrarily
sized piece of data, often textual. Each section is like a file embedded
inside the definition, and Houdini uses specially named sections to
store the node contents, list of parameters, etc. You can embed your own
data into a digital asset by putting it inside a section.</p>
<p>Any parameter in Houdini that references a file can also reference a
section inside a digital asset. For example, if car is an object-level
digital asset and the section is named texture.jpg, you can reference
that texture with opdef:/Object/car?texture.jpg. Note that hou.readFile
also supports this opdef: syntax.</p>
<p>By moving files into digital asset sections, you can build self-
contained digital assets that can be distributed via a single hda file.</p>
<p>Note that section names may contain /.</p>
<dl class="method">
<dt id="hou.HDASection.contents">
<code class="descname">contents</code><span class="sig-paren">(</span><em>self</em>, <em>compressionType=hou.compressionType.NoCompression</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.HDASection.contents" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Return a string containing the contents of this section.</p>
<p>You can optionally specify a compression type, hou.compressionType,
to decompress the contents.</p>
<p>Raises hou.OperationFailed if a compression type is specified and
the contents are not compressed by that type.</p>
</div></blockquote>
<p>&gt; def saveSectionToFile(section, file_name):
&gt;     Given a section, save it to a file.
&gt;     section_file = file(file_name, w)
&gt;     section_file.write(section.contents())
&gt;     section_file.close()</p>
</dd></dl>

<dl class="method">
<dt id="hou.HDASection.definition">
<code class="descname">definition</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.HDADefinition<a class="headerlink" href="#hou.HDASection.definition" title="Permalink to this definition"></a></dt>
<dd><p>Return the digital asset definition containing this section.</p>
</dd></dl>

<dl class="method">
<dt id="hou.HDASection.destroy">
<code class="descname">destroy</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.HDASection.destroy" title="Permalink to this definition"></a></dt>
<dd><p>Remove this section from the HDA definition. You can also remove a
section with hou.HDADefinition.removeSection, and this method is
equivalent to self.definition().removeSection(self.name()).</p>
<p>Only remove sections that you explicitly added. Do not remove the
special sections that Houdini uses to store the contents of the
digital asset definition, or Houdini will generate errors or strange
side effects.</p>
<p>To add a section, use hou.HDADefinition.addSection.</p>
</dd></dl>

<dl class="method">
<dt id="hou.HDASection.modificationTime">
<code class="descname">modificationTime</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.HDASection.modificationTime" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Return the time when the section was last modified. This time is
returned as a POSIX timestamp, such as is returned by time.time().</div></blockquote>
<p>&gt; &gt;&gt;&gt; hou.nodeType(hou.cop2NodeTypeCategory(), colorwheel).definition()
&gt; &lt;hou.HDADefinition of Cop2 colorwheel in /opt/hfs9.5/houdini/hda/OPlibCop2.hda&gt;
&gt; &gt;&gt;&gt; definition = hou.nodeType(hou.cop2NodeTypeCategory(), colorwheel).definition()
&gt; &gt;&gt;&gt; definition.sections().keys()
&gt; [VflCode, DialogScript, VexCode]
&gt; &gt;&gt;&gt; section = definition.sections()[VflCode]
&gt; &gt;&gt;&gt; section.modificationTime()
&gt; 1177535169
&gt; &gt;&gt;&gt; import datetime, time
&gt; &gt;&gt;&gt; datetime.datetime.fromtimestamp(section.modificationTime())
&gt; datetime.datetime(2007, 4, 25, 17, 6, 9)
&gt; &gt;&gt;&gt; time.ctime(section.modificationTime())
&gt; Wed Apr 25 17:06:09 2007</p>
</dd></dl>

<dl class="method">
<dt id="hou.HDASection.name">
<code class="descname">name</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.HDASection.name" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Return the name of this section.</p>
<p>Note that is is not possible to rename a section, but the following
function will emulate renaming:</p>
</div></blockquote>
<p>&gt; def renameSection(section):
&gt;     Rename a section by removing it and creating a new one.  Return the new section.
&gt;     new_section = section.definition().addSection(new_name, section.contents())
&gt;     section.destroy()
&gt;     return new_section</p>
</dd></dl>

<dl class="method">
<dt id="hou.HDASection.setContents">
<code class="descname">setContents</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.HDASection.setContents" title="Permalink to this definition"></a></dt>
<dd><p>setContents(self, contents,
compressionType=hou.compressionType.NoCompression)</p>
<blockquote>
<div><p>Set the contents of this section to the given string. A section may
contain binary information, like bgeo files, images, etc.</p>
<p>You can optionally specify a compression type, hou.compressionType,
to compress the contents. Note that you must specify the same
compression type when reading the contents back to decompress them.</p>
<p>See hou.HDADefinition.addSection for an example of how to create a
section from a file on disk.</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.HDASection.size">
<code class="descname">size</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.HDASection.size" title="Permalink to this definition"></a></dt>
<dd><p>Return the number of bytes in the contents. This method is a
shortcut for len(self.contents()).</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.HDASection.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.HDASection.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.HelpBrowser">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">HelpBrowser</code><a class="headerlink" href="#hou.HelpBrowser" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.PaneTab" title="hou.PaneTab"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.PaneTab</span></code></a></p>
<p>Class representing a help browser pane tab. Provides methods for
controlling the help browser.</p>
<p>REPLACES</p>
<blockquote>
<div><ul class="simple">
<li>helpbrowser</li>
</ul>
</div></blockquote>
<dl class="method">
<dt id="hou.HelpBrowser.displayHelp">
<code class="descname">displayHelp</code><span class="sig-paren">(</span><em>self</em>, <em>node_type</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.HelpBrowser.displayHelp" title="Permalink to this definition"></a></dt>
<dd><p>Loads the help for the specified node type.</p>
<p>Raises HOM_ObjectWasDeleted if the help browser pane tab was
deleted.</p>
</dd></dl>

<dl class="method">
<dt id="hou.HelpBrowser.displayHelpPath">
<code class="descname">displayHelpPath</code><span class="sig-paren">(</span><em>self</em>, <em>help_path</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.HelpBrowser.displayHelpPath" title="Permalink to this definition"></a></dt>
<dd><p>Loads the help for the specified help path. The path can either be a
Houdini help URL (i.e. op:Sop/copy, tool:curve) or a raw help path
(i.e. /nodes/sop/copy, shelf/curve).</p>
</dd></dl>

<dl class="method">
<dt id="hou.HelpBrowser.displayHelpPyPanel">
<code class="descname">displayHelpPyPanel</code><span class="sig-paren">(</span><em>self</em>, <em>interface_name</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.HelpBrowser.displayHelpPyPanel" title="Permalink to this definition"></a></dt>
<dd><p>Loads the help for the python panel with the specified name.</p>
<p>Raises HOM_Error if the interface name is invalid.</p>
</dd></dl>

<dl class="method">
<dt id="hou.HelpBrowser.homePage">
<code class="descname">homePage</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.HelpBrowser.homePage" title="Permalink to this definition"></a></dt>
<dd><p>Returns the home page URL of this help browser.</p>
<p>Raises HOM_ObjectWasDeleted if the help browser pane tab was
deleted.</p>
</dd></dl>

<dl class="method">
<dt id="hou.HelpBrowser.setHomePage">
<code class="descname">setHomePage</code><span class="sig-paren">(</span><em>self</em>, <em>home_page</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.HelpBrowser.setHomePage" title="Permalink to this definition"></a></dt>
<dd><p>Sets the home page for this help browser to the specified URL.</p>
<p>Raises HOM_ObjectWasDeleted if the help browser pane tab was
deleted, and raises HOM_Error if home_page is not given.</p>
</dd></dl>

<dl class="method">
<dt id="hou.HelpBrowser.setUrl">
<code class="descname">setUrl</code><span class="sig-paren">(</span><em>self</em>, <em>url</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.HelpBrowser.setUrl" title="Permalink to this definition"></a></dt>
<dd><p>Loads the specified URL.</p>
<p>Raises HOM_ObjectWasDeleted if the help browser pane tab was
deleted, and raises HOM_Error if url is not given.</p>
</dd></dl>

<dl class="method">
<dt id="hou.HelpBrowser.showUI">
<code class="descname">showUI</code><span class="sig-paren">(</span><em>self</em>, <em>show</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.HelpBrowser.showUI" title="Permalink to this definition"></a></dt>
<dd><p>Shows or hides the help browsers navigation controls.</p>
<p>Raises HOM_ObjectWasDeleted if the help browser pane tab was
deleted.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.HelpBrowser.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.HelpBrowser.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

<dl class="method">
<dt id="hou.HelpBrowser.url">
<code class="descname">url</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.HelpBrowser.url" title="Permalink to this definition"></a></dt>
<dd><p>Return the current URL of this help browser.</p>
<p>Raises HOM_ObjectWasDeleted if the help browser pane tab was
deleted.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.IPRViewer">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">IPRViewer</code><a class="headerlink" href="#hou.IPRViewer" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.PaneTab" title="hou.PaneTab"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.PaneTab</span></code></a></p>
<p>An interactive preview render (IPR) window.</p>
<p>The IPR viewer progressively refines a render, first providing a rough
view of the rendered image and eventually providing the fully rendered
image. When you change a shader value, move an object, etc., the viewer
will re-render the image.</p>
<p>When you Ctrl+click on a pixel in the rendered image, Houdini searches
$HOUDINI_PATH for scripts/ipr/pickpixel.py and runs it. The version of
this file that ships with Houdini pops up the shader contributing the
pixel, or an information window if there is is no shader. If Houdini
cannot find that Python file it then looks for the Hscript file
scripts/ipr/pickpixel.cmd.</p>
<p>When you drag a SHOP node onto the rendered image, Houdini searches for
and runs scripts/ipr/dragdrop.py. By default, this script assigns the
SHOP to the object contributing the pixel. If it cannot find a Python
version, Houdini then looks for scripts/ipr/dragdrop.cmd.</p>
<p>Note that shelf scripts can access the last location the user clicked on
with hou.IPRViewer.lastClickLocation.</p>
<dl class="method">
<dt id="hou.IPRViewer.autoSavePath">
<code class="descname">autoSavePath</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.IPRViewer.autoSavePath" title="Permalink to this definition"></a></dt>
<dd><p>Returns the render save path. This is the path that is used when the
IPR viewer is set to automatically save render progress to disk.</p>
<p>See also hou.IPRViewer.setSavePath.</p>
</dd></dl>

<dl class="method">
<dt id="hou.IPRViewer.autoSaveTime">
<code class="descname">autoSaveTime</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#hou.IPRViewer.autoSaveTime" title="Permalink to this definition"></a></dt>
<dd><p>Returns the time between IPR auto saves in seconds. When auto saving
is on, a render progress image is written out at this rate.</p>
<p>See also hou.IPRViewer.setAutoSaveTime.</p>
</dd></dl>

<dl class="method">
<dt id="hou.IPRViewer.cropRegion">
<code class="descname">cropRegion</code><span class="sig-paren">(</span><em>self) -&gt; (float</em>, <em>float</em>, <em>float</em>, <em>float</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.IPRViewer.cropRegion" title="Permalink to this definition"></a></dt>
<dd><p>Return the x0, x1, y0, and y1 normalized coordinates of the
subregion that is selected, where (x0, y0) is the bottom-left corner
and (x1, y1) is the top-right corner of the subregion.</p>
<p>You can optionally tell the IPR viewer to only re-render only a
portion of the image. To select a subportion of the image, hold down
shift and select the box.</p>
<p>Note that the bottom-left corner is (0.0, 0.0) and the top-right
corner is (1.0, 1.0). For example, if the entire image is being
rendered, this method returns (0.0, 1.0, 0.0, 1.0).</p>
</dd></dl>

<dl class="method">
<dt id="hou.IPRViewer.delay">
<code class="descname">delay</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#hou.IPRViewer.delay" title="Permalink to this definition"></a></dt>
<dd><p>Return the contents of the viewers Delay field. This value
determines how long Houdini waits between when you change a
parameter value and when it starts re-rendering.</p>
<p>See also hou.IPRViewer.setDelay and hou.IPRViewer.updateTime.</p>
</dd></dl>

<dl class="method">
<dt id="hou.IPRViewer.displayedPlane">
<code class="descname">displayedPlane</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.IPRViewer.displayedPlane" title="Permalink to this definition"></a></dt>
<dd><p>Return the name of the currently-displayed image plane in the
rendered output.</p>
<p>Note that the special Op_Id image plane contains the
hou.Node.sessionId ids of the object nodes in the image. -1
indicates that there is no object node associated with the pixel.
Use hou.IPRViewer.objectNode to access the object corresponding to
that id.</p>
<p>Similarly, the Prim_Id plane contains the hou.Prim.number ids of the
primitives in the image. Use hou.IPRViewer.prim to access the
primitive corresponding to that id.</p>
<p>Raises hou.OperationFailed if the viewer does not contain an image.</p>
</dd></dl>

<dl class="method">
<dt id="hou.IPRViewer.evaluatedStyleSheetJSON">
<code class="descname">evaluatedStyleSheetJSON</code><span class="sig-paren">(</span><em>self</em>, <em>x</em>, <em>y</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.IPRViewer.evaluatedStyleSheetJSON" title="Permalink to this definition"></a></dt>
<dd><p>Returns a JSON string describing the material style sheet at a given
pixel. If no style sheet is active, an empty string is returned.</p>
</dd></dl>

<dl class="method">
<dt id="hou.IPRViewer.evaluatedStyleSheetPaths">
<code class="descname">evaluatedStyleSheetPaths</code><span class="sig-paren">(</span><em>self</em>, <em>x</em>, <em>y</em><span class="sig-paren">)</span> &#x2192; tuple of str<a class="headerlink" href="#hou.IPRViewer.evaluatedStyleSheetPaths" title="Permalink to this definition"></a></dt>
<dd><p>Returns a list of paths to the styles that contribute to the style
sheet at the current pixel.</p>
</dd></dl>

<dl class="method">
<dt id="hou.IPRViewer.imageResolution">
<code class="descname">imageResolution</code><span class="sig-paren">(</span><em>self) -&gt; (int</em>, <em>int</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.IPRViewer.imageResolution" title="Permalink to this definition"></a></dt>
<dd><p>Return the resolution of the image.</p>
<p>Raises hou.OperationFailed if the viewer does not contain an image.</p>
</dd></dl>

<dl class="method">
<dt id="hou.IPRViewer.isActive">
<code class="descname">isActive</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.IPRViewer.isActive" title="Permalink to this definition"></a></dt>
<dd><p>Indicates whether an active IPR sessions exists.</p>
</dd></dl>

<dl class="method">
<dt id="hou.IPRViewer.isAutoSaveOn">
<code class="descname">isAutoSaveOn</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.IPRViewer.isAutoSaveOn" title="Permalink to this definition"></a></dt>
<dd><p>Returns whether or not the Auto Save toggle is selected. When turned
on, IPR will periodically save the render progress to the auto save
file path. The time between saves can be configured by setting the
auto save time.</p>
<p>See also hou.IPRViewer.setAutoSave.</p>
</dd></dl>

<dl class="method">
<dt id="hou.IPRViewer.isAutoUpdateOn">
<code class="descname">isAutoUpdateOn</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.IPRViewer.isAutoUpdateOn" title="Permalink to this definition"></a></dt>
<dd><p>Return whether or not the Auto-Update checkbox is checked. When it
is unchecked, the viewer will not refresh when objects, shaders,
lights, etc. change. In this case, you can force a re-render by
clicking on the Render button.</p>
<p>See also hou.IPRViewer.setAutoUpdate.</p>
</dd></dl>

<dl class="method">
<dt id="hou.IPRViewer.isPaused">
<code class="descname">isPaused</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.IPRViewer.isPaused" title="Permalink to this definition"></a></dt>
<dd><p>Indicates whether the IPR session is paused. If there is no active
session, this returns false.</p>
</dd></dl>

<dl class="method">
<dt id="hou.IPRViewer.isPreviewOn">
<code class="descname">isPreviewOn</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.IPRViewer.isPreviewOn" title="Permalink to this definition"></a></dt>
<dd><p>Return whether or not the Preview checkbox is checked. When it is
unchecked, the viewer will not progressively refine the image using
IPR, and will instead use the rendering engine from the ROP node to
render it.</p>
<p>See also hou.IPRViewer.setPreview.</p>
</dd></dl>

<dl class="method">
<dt id="hou.IPRViewer.isRendering">
<code class="descname">isRendering</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.IPRViewer.isRendering" title="Permalink to this definition"></a></dt>
<dd><p>Indicates whether the IPR session has an render in progress. Returns
True even if the render is paused.</p>
</dd></dl>

<dl class="method">
<dt id="hou.IPRViewer.killRender">
<code class="descname">killRender</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.IPRViewer.killRender" title="Permalink to this definition"></a></dt>
<dd><p>Kills the active IPR session (if there is one).</p>
</dd></dl>

<dl class="method">
<dt id="hou.IPRViewer.lastClickLocation">
<code class="descname">lastClickLocation</code><span class="sig-paren">(</span><em>self) -&gt; (int</em>, <em>int</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.IPRViewer.lastClickLocation" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Return the x and y coordinates for the pixel location where the user
last clicked in the IPR viewer. Note that this location might be
outside the image: the x and y coordinates can be negative and can
be greater than or equal to the image resolution. Note that if the
user never clicked in the viewer, the x and y coordinates will be
negative.</p>
<p>You would typically call this method from a shelf script. For
example, a user can click on a pixel in the IPR viewer and then
click on the shelf to perform an action on that pixel (e.g. display
the shader parameters, assign a shader, etc.).</p>
<p>Use hou.IPRViewer.imageResolution to get the valid range for pixel
coordinates.</p>
<p>Note that when you Ctrl-click on a pixel, Houdini searches
$HOUDINI_PATH for scripts/ipr/pickpixel.py and runs it. This script
can access the viewer with kwargs[viewer] and the location where
the user clicked with kwargs[position].</p>
<p>The following script opens a floating parameter window for the
shader corresponding to the pixel the user last clicked on.</p>
</div></blockquote>
<p>&gt; viewer = hou.ui.paneTabOfType(hou.paneTabType.IPRViewer)
&gt; px, py = viewer.lastClickLocation()
&gt; 
&gt; if (px &lt; 0 or px &gt; viewer.imageResolution()[0] or
&gt;         py &lt; 0 or py &gt;= viewer.imageResolution()[1]):
&gt;     hou.ui.displayMessage(Click on the image and then run this script again)
&gt; else:
&gt;     material = viewer.materialNode(px, py)
&gt; 
&gt;     if material is not None:
&gt;         parm_window = hou.ui.curDesktop().createFloatingPaneTab(
&gt;             hou.paneTabType.Parm)
&gt;         parm_window.setCurrentNode(material)
&gt;         parm_window.setPin(True)
&gt;     else:
&gt;         hou.ui.displayMessage(Click on an object to bring up the shader.)</p>
</dd></dl>

<dl class="method">
<dt id="hou.IPRViewer.materialNode">
<code class="descname">materialNode</code><span class="sig-paren">(</span><em>self</em>, <em>x</em>, <em>y</em><span class="sig-paren">)</span> &#x2192; hou.ShopNode or None<a class="headerlink" href="#hou.IPRViewer.materialNode" title="Permalink to this definition"></a></dt>
<dd><p>Return the SHOP node contributing the pixel at the specified
location, or None if there is nothing at the pixel, the pixel
location is outside the image bounds, or there is no shader on the
geometry.</p>
<p>This method first checks the primitive corresponding to the pixel
and returns the SHOP corresponding to its shop_materialpath
attribute. If the primitive does not have this attribute then it
returns the SHOP assigned to the object. If no SHOP is assigned to
the object, it returns None.</p>
<p>Raises hou.OperationFailed if the viewer does not contain an image.</p>
</dd></dl>

<dl class="method">
<dt id="hou.IPRViewer.objectNode">
<code class="descname">objectNode</code><span class="sig-paren">(</span><em>self</em>, <em>x</em>, <em>y</em><span class="sig-paren">)</span> &#x2192; hou.ObjNode or None<a class="headerlink" href="#hou.IPRViewer.objectNode" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Return the object node contributing the pixel at the specified
location, or None if there is no object at the pixel or if the pixel
location is outside the image bounds</p>
<p>The following function returns the SOP node containing the geometry
that contributes the pixel to the final image:</p>
</div></blockquote>
<p>&gt; def sopNode(viewer, x, y):
&gt;     obj_node = viewer.objectNode(x, y)
&gt;     return (obj_node.renderNode() if obj_node is not None else None)</p>
<blockquote>
<div>Raises hou.OperationFailed if the viewer does not contain an image.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.IPRViewer.pauseRender">
<code class="descname">pauseRender</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.IPRViewer.pauseRender" title="Permalink to this definition"></a></dt>
<dd><p>Pauses the active IPR session (if there is one).</p>
</dd></dl>

<dl class="method">
<dt id="hou.IPRViewer.pixel">
<code class="descname">pixel</code><span class="sig-paren">(</span><em>self</em>, <em>plane_name</em>, <em>x</em>, <em>y</em><span class="sig-paren">)</span> &#x2192; tuple of float<a class="headerlink" href="#hou.IPRViewer.pixel" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Return the value of a pixel in one plane of the image. This method
returns a tuple of 1 to 4 floats, depending on the type of image
plane.</p>
<p>Note that the color plane is named C.</p>
<p>Raises hou.OperationFailed if the plane name is invalid, the pixel
location is outside the image, or the viewer does not contain an
image.</p>
<p>You can determine the number of components in the image plane using
the following: len(viewer.pixel(plane_name, 0, 0)).</p>
</div></blockquote>
<p>&gt; &gt;&gt;&gt; viewer.pixel(C, 300, 200)
&gt; (0.69970703125, 0.46728515625, 0.289794921875, 1.0)</p>
</dd></dl>

<dl class="method">
<dt id="hou.IPRViewer.pixels">
<code class="descname">pixels</code><span class="sig-paren">(</span><em>self</em>, <em>plane_name</em><span class="sig-paren">)</span> &#x2192; tuple of tuple of float<a class="headerlink" href="#hou.IPRViewer.pixels" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Returns the value of all pixels in one plane of the image. This
method returns a tuple of tuples of 1 to 4 floats, depending on the
type of image plane. The results are in row-major order, starting at
the bottom left corner of the IPR image.</p>
<p>Note that the color plane is named C.</p>
<p>Raises hou.OperationFailed if the plane name is invalid or the
viewer does not contain an image.</p>
</div></blockquote>
<p>&gt; &gt;&gt;&gt; all_pixels = viewer.pixels(C)
&gt; &gt;&gt;&gt; width = viewer.imageResolution()[0]
&gt; &gt;&gt;&gt; all_pixels[width*200 + 300]
&gt; (0.69970703125, 0.46728515625, 0.289794921875, 1.0)</p>
</dd></dl>

<dl class="method">
<dt id="hou.IPRViewer.planes">
<code class="descname">planes</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of str<a class="headerlink" href="#hou.IPRViewer.planes" title="Permalink to this definition"></a></dt>
<dd><p>Return the names of the image planes in the rendered output.</p>
<p>Note that the special Op_Id image plane contains the
hou.Node.sessionId ids of the object nodes in the image. -1
indicates that there is no object node associated with the pixel.
Use hou.IPRViewer.objectNode to access the object corresponding to
that id.</p>
<p>Similarly, the Prim_Id plane contains the hou.Prim.number ids of the
primitives in the image. Use hou.IPRViewer.prim to access the
primitive corresponding to that id.</p>
<p>Raises hou.OperationFailed if the viewer does not contain an image.</p>
</dd></dl>

<dl class="method">
<dt id="hou.IPRViewer.prim">
<code class="descname">prim</code><span class="sig-paren">(</span><em>self</em>, <em>x</em>, <em>y</em><span class="sig-paren">)</span> &#x2192; hou.Prim or None<a class="headerlink" href="#hou.IPRViewer.prim" title="Permalink to this definition"></a></dt>
<dd><p>Return the geometry primitive contributing the pixel at the
specified location, or None if there is nothing at the pixel or if
the pixel location is outside the image bounds</p>
<p>Raises hou.OperationFailed if the viewer does not contain an image.</p>
</dd></dl>

<dl class="method">
<dt id="hou.IPRViewer.resumeRender">
<code class="descname">resumeRender</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.IPRViewer.resumeRender" title="Permalink to this definition"></a></dt>
<dd><p>Resumes the active IPR session (if there is one).</p>
</dd></dl>

<dl class="method">
<dt id="hou.IPRViewer.ropNode">
<code class="descname">ropNode</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.RopNode or None<a class="headerlink" href="#hou.IPRViewer.ropNode" title="Permalink to this definition"></a></dt>
<dd><p>Return the ROP node that is selected in the viewer, or None if
nothing is selected.</p>
</dd></dl>

<dl class="method">
<dt id="hou.IPRViewer.saveFrame">
<code class="descname">saveFrame</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.IPRViewer.saveFrame" title="Permalink to this definition"></a></dt>
<dd><p>saveFrame(self, file_path, snapshot=0, xres=-1, yres=-1, color=C,
alpha=C, scope=*, lut=, gamma=1.0, convert=True) -&gt; bool</p>
<blockquote>
<div><p>Saves the current IPR render to the specified file path. It is
possible to save an in progress/incomplete render.</p>
<p>The output image type is inferred from the file extension on the
provided file path. The snapshot parameter controls which IPR
snapshot to save. A value of 0 indicates the active render.</p>
<p>The native IPR resolution is used by default, however a custom
resolution can be specified with the xres and yres parameters. The
color and alpha parameters control which render planes are used when
writing RGBA images like .jpg or .png. If a deep image format such
as .pic or .exr is used, the scope parameter can be used to specify
which image planes to include in the output.</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.IPRViewer.setAutoSave">
<code class="descname">setAutoSave</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.IPRViewer.setAutoSave" title="Permalink to this definition"></a></dt>
<dd><p>Set or unset the Auto Save toggle.</p>
<p>See hou.IPRViewer.isAutoSaveOn for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.IPRViewer.setAutoSavePath">
<code class="descname">setAutoSavePath</code><span class="sig-paren">(</span><em>self</em>, <em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.IPRViewer.setAutoSavePath" title="Permalink to this definition"></a></dt>
<dd><p>Sets the render progress save path.</p>
<p>See also hou.IPRViewer.autoSavePath for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.IPRViewer.setAutoSaveTime">
<code class="descname">setAutoSaveTime</code><span class="sig-paren">(</span><em>self</em>, <em>float</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.IPRViewer.setAutoSaveTime" title="Permalink to this definition"></a></dt>
<dd><p>Sets the auto save time in seconds.</p>
<p>See also hou.IPRViewer.autoSaveTime for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.IPRViewer.setAutoUpdate">
<code class="descname">setAutoUpdate</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.IPRViewer.setAutoUpdate" title="Permalink to this definition"></a></dt>
<dd><p>Check or uncheck the Auto-Update checkbox.</p>
<p>See hou.IPRViewer.isAutoUpdateOn for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.IPRViewer.setDelay">
<code class="descname">setDelay</code><span class="sig-paren">(</span><em>self</em>, <em>time</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.IPRViewer.setDelay" title="Permalink to this definition"></a></dt>
<dd><p>Set the contents of the viewers Delay field.</p>
<p>See hou.IPRViewer.delay for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.IPRViewer.setPreview">
<code class="descname">setPreview</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.IPRViewer.setPreview" title="Permalink to this definition"></a></dt>
<dd><p>Check or uncheck the Preview checkbox.</p>
<p>See hou.IPRViewer.isPreviewOn for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.IPRViewer.setRopNode">
<code class="descname">setRopNode</code><span class="sig-paren">(</span><em>self</em>, <em>rop_node</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.IPRViewer.setRopNode" title="Permalink to this definition"></a></dt>
<dd><p>Set the ROP node to use for rendering.</p>
</dd></dl>

<dl class="method">
<dt id="hou.IPRViewer.setUpdateTime">
<code class="descname">setUpdateTime</code><span class="sig-paren">(</span><em>self</em>, <em>time</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.IPRViewer.setUpdateTime" title="Permalink to this definition"></a></dt>
<dd><p>Set the contents of the viewers Update Time field.</p>
<p>See hou.IPRViewer.updateTime for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.IPRViewer.startRender">
<code class="descname">startRender</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.IPRViewer.startRender" title="Permalink to this definition"></a></dt>
<dd><p>Start a new render if there is no active IPR session or issue a re-
render if there is one.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.IPRViewer.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.IPRViewer.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

<dl class="method">
<dt id="hou.IPRViewer.updateTime">
<code class="descname">updateTime</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#hou.IPRViewer.updateTime" title="Permalink to this definition"></a></dt>
<dd><p>Return the contents of the viewers Update Time field. This value
determines approximately how long each progressive refinement should
take. Smaller values will produce more progressive renders where
detail is added more gradually.</p>
<p>See also hou.IPRViewer.setUpdateTime and hou.IPRViewer.delay.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.IndexPairPropertyTable">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">IndexPairPropertyTable</code><a class="headerlink" href="#hou.IndexPairPropertyTable" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Describes properties of an index pair attribute.</p>
<dl class="method">
<dt id="hou.IndexPairPropertyTable.attrib">
<code class="descname">attrib</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Attrib<a class="headerlink" href="#hou.IndexPairPropertyTable.attrib" title="Permalink to this definition"></a></dt>
<dd><p>Return the parent index pair attribute.</p>
</dd></dl>

<dl class="method">
<dt id="hou.IndexPairPropertyTable.floatListPropertyValueAtIndex">
<code class="descname">floatListPropertyValueAtIndex</code><span class="sig-paren">(</span><em>self</em>, <em>property_name</em>, <em>row</em><span class="sig-paren">)</span> &#x2192; tuple of<a class="headerlink" href="#hou.IndexPairPropertyTable.floatListPropertyValueAtIndex" title="Permalink to this definition"></a></dt>
<dd><p>float</p>
<p>Return a list of property values for a particular floating point
property.</p>
<p>Raises hou.OperationFailed if no property exists with this name.</p>
</dd></dl>

<dl class="method">
<dt id="hou.IndexPairPropertyTable.floatPropertyValueAtIndex">
<code class="descname">floatPropertyValueAtIndex</code><span class="sig-paren">(</span><em>self</em>, <em>property_name</em>, <em>row</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#hou.IndexPairPropertyTable.floatPropertyValueAtIndex" title="Permalink to this definition"></a></dt>
<dd><p>Return the property value for a particular floating point property.</p>
<p>Raises hou.OperationFailed if no property exists with this name or
the property is not float of size 1.</p>
</dd></dl>

<dl class="method">
<dt id="hou.IndexPairPropertyTable.intListPropertyValueAtIndex">
<code class="descname">intListPropertyValueAtIndex</code><span class="sig-paren">(</span><em>self</em>, <em>property_name</em>, <em>row</em><span class="sig-paren">)</span> &#x2192; tuple of int<a class="headerlink" href="#hou.IndexPairPropertyTable.intListPropertyValueAtIndex" title="Permalink to this definition"></a></dt>
<dd><p>Return a list of property values for a particular integer property.</p>
<p>Raises hou.OperationFailed if no property exists with this name.</p>
</dd></dl>

<dl class="method">
<dt id="hou.IndexPairPropertyTable.intPropertyValueAtIndex">
<code class="descname">intPropertyValueAtIndex</code><span class="sig-paren">(</span><em>self</em>, <em>property_name</em>, <em>row</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.IndexPairPropertyTable.intPropertyValueAtIndex" title="Permalink to this definition"></a></dt>
<dd><p>Return the property value for a particular integer property.</p>
<p>Raises hou.OperationFailed if no property exists with this name or
the property is not integer of size 1.</p>
</dd></dl>

<dl class="method">
<dt id="hou.IndexPairPropertyTable.numIndices">
<code class="descname">numIndices</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.IndexPairPropertyTable.numIndices" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.IndexPairPropertyTable.propertyDataType">
<code class="descname">propertyDataType</code><span class="sig-paren">(</span><em>self</em>, <em>property_name</em><span class="sig-paren">)</span> &#x2192; hou.attribData enum value<a class="headerlink" href="#hou.IndexPairPropertyTable.propertyDataType" title="Permalink to this definition"></a></dt>
<dd><p>Return the propertys data type (int, float or string).</p>
</dd></dl>

<dl class="method">
<dt id="hou.IndexPairPropertyTable.propertyNames">
<code class="descname">propertyNames</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of string<a class="headerlink" href="#hou.IndexPairPropertyTable.propertyNames" title="Permalink to this definition"></a></dt>
<dd><p>Return a list of all property names.</p>
</dd></dl>

<dl class="method">
<dt id="hou.IndexPairPropertyTable.propertySize">
<code class="descname">propertySize</code><span class="sig-paren">(</span><em>self</em>, <em>property_name</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.IndexPairPropertyTable.propertySize" title="Permalink to this definition"></a></dt>
<dd><p>Return the number of data components in the property value.</p>
</dd></dl>

<dl class="method">
<dt id="hou.IndexPairPropertyTable.stringListPropertyValueAtIndex">
<code class="descname">stringListPropertyValueAtIndex</code><span class="sig-paren">(</span><em>self</em>, <em>property_name</em>, <em>row</em><span class="sig-paren">)</span> &#x2192; tuple of<a class="headerlink" href="#hou.IndexPairPropertyTable.stringListPropertyValueAtIndex" title="Permalink to this definition"></a></dt>
<dd><p>string</p>
<p>Return a list of property values for a particular string property.</p>
<p>Raises hou.OperationFailed if no property exists with this name.</p>
</dd></dl>

<dl class="method">
<dt id="hou.IndexPairPropertyTable.stringPropertyValueAtIndex">
<code class="descname">stringPropertyValueAtIndex</code><span class="sig-paren">(</span><em>self</em>, <em>property_name</em>, <em>row</em><span class="sig-paren">)</span> &#x2192; string<a class="headerlink" href="#hou.IndexPairPropertyTable.stringPropertyValueAtIndex" title="Permalink to this definition"></a></dt>
<dd><p>Return the property value for a particular string property.</p>
<p>Raises hou.OperationFailed if no property exists with this name or
the property is not string of size 1.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.IndexPairPropertyTable.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.IndexPairPropertyTable.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.IndirectInput">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">IndirectInput</code><a class="headerlink" href="#hou.IndirectInput" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.NetworkMovableItem" title="hou.NetworkMovableItem"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.NetworkMovableItem</span></code></a></p>
<p>An abstract base class for a network item that can be used as an input
to nodes in the same network, but which is not a node itself.</p>
<p>There are two specific forms of an indirect input. The
hou.SubnetIndirectInput provides a way to connect nodes outside a sub-
network to nodes inside the sub-network. The hou.NetworkDot allows
connections to be routed through a network along any path.</p>
<dl class="method">
<dt id="hou.IndirectInput.input">
<code class="descname">input</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.IndirectInput.input" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.IndirectInput.inputItem">
<code class="descname">inputItem</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.NetworkMovableItem<a class="headerlink" href="#hou.IndirectInput.inputItem" title="Permalink to this definition"></a></dt>
<dd><p>Returns the item connected directly to the input side of this
indirect input. This may be a node, indirect input, or None if
nothing is connected. Note that the returned item may not be inside
the same parent network as this object if it is a
hou.SubnetIndirectInput.</p>
</dd></dl>

<dl class="method">
<dt id="hou.IndirectInput.inputItemOutputIndex">
<code class="descname">inputItemOutputIndex</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.IndirectInput.inputItemOutputIndex" title="Permalink to this definition"></a></dt>
<dd><p>Returns the index of the output connection on the network item
connected directly to the input side of this object. Returns 0 if
nothing is connected. This value will only be non-zero if a hou.Node
is connected to this object since all other network items only has a
single output connector.</p>
</dd></dl>

<dl class="method">
<dt id="hou.IndirectInput.inputOutputIndex">
<code class="descname">inputOutputIndex</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.IndirectInput.inputOutputIndex" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.IndirectInput.outputConnections">
<code class="descname">outputConnections</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.IndirectInput.outputConnections" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.IndirectInput.outputs">
<code class="descname">outputs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.IndirectInput.outputs" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.IndirectInput.setColorDefault">
<code class="descname">setColorDefault</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.IndirectInput.setColorDefault" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.IndirectInput.setSymbolicColorName">
<code class="descname">setSymbolicColorName</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.IndirectInput.setSymbolicColorName" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.IndirectInput.setUseColorFromOutput">
<code class="descname">setUseColorFromOutput</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.IndirectInput.setUseColorFromOutput" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.IndirectInput.symbolicColorName">
<code class="descname">symbolicColorName</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.IndirectInput.symbolicColorName" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.IndirectInput.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.IndirectInput.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

<dl class="method">
<dt id="hou.IndirectInput.useColorFromOutput">
<code class="descname">useColorFromOutput</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.IndirectInput.useColorFromOutput" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.InitScriptFailed">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">InitScriptFailed</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.InitScriptFailed" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.Error" title="hou.Error"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.Error</span></code></a></p>
<dl class="method">
<dt id="hou.InitScriptFailed.description">
<code class="descname">description</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.InitScriptFailed.description" title="Permalink to this definition"></a></dt>
<dd><p>Return a description of the class of exception. The description is
not related to the exception instance.</p>
</dd></dl>

<dl class="method">
<dt id="hou.InitScriptFailed.exceptionTypeName">
<code class="descname">exceptionTypeName</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.InitScriptFailed.exceptionTypeName" title="Permalink to this definition"></a></dt>
<dd><p>Return the name of the exception type. Instances of different
subclasses of hou.Error will return different names. Instances of
the base class will return Error.</p>
<p>You can also use str(e.__class__) to get the name of the subclass.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.InitScriptFailed.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.InitScriptFailed.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.IntParmTemplate">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">IntParmTemplate</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.IntParmTemplate" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.ParmTemplate" title="hou.ParmTemplate"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.ParmTemplate</span></code></a></p>
<p>Describes a parameter tuple containing integer values.</p>
<p>Note that integer parameters may also be menu parameters. Integer
parameters with menus are conceptually the same as parameters derived
from hou.MenuParmTemplate.</p>
<dl class="method">
<dt id="hou.IntParmTemplate.defaultExpression">
<code class="descname">defaultExpression</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of strings<a class="headerlink" href="#hou.IntParmTemplate.defaultExpression" title="Permalink to this definition"></a></dt>
<dd><p>Return the default expression for new parameter instances.</p>
<p>The default expression takes precendence over the default value. If
a component has no default expression (i.e. an empty string), then
the default value is used for new parameter instances.</p>
<p>Note that the default expression language is needed to interpret the
meaning of the default expression.</p>
<p>For example, suppose this parm template is named divisions, the
naming scheme is XYZW, it has 3 components, the default value is
(10, 20, 30), the default expression is ($F, hou.frame(), )
and the default expression language is (hou.scriptLanguage.Hscript,
hou.scriptLanguage.Python, hou.scriptLanguage.Hscript). Then the
corresponding parm tuple instance on a node would be named
divisions and would contain parameters divisionsx, divisionsy,
divisionsz. When the node is created, divisionsx would have a
default Hscript expression of $F, divisionsy would have a
default Python expression of hou.frame(), and divisionsz would
have a default value of 30.</p>
</dd></dl>

<dl class="method">
<dt id="hou.IntParmTemplate.defaultExpressionLanguage">
<code class="descname">defaultExpressionLanguage</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.scriptLanguage<a class="headerlink" href="#hou.IntParmTemplate.defaultExpressionLanguage" title="Permalink to this definition"></a></dt>
<dd><p>Return the default expression language for new parameter instances.</p>
<p>The default expression language only applies if the default
expression is set. If the default expression of a component is not
set, then the expression language is set to
hou.scriptLanguage.Hscript.</p>
</dd></dl>

<dl class="method">
<dt id="hou.IntParmTemplate.defaultValue">
<code class="descname">defaultValue</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of int<a class="headerlink" href="#hou.IntParmTemplate.defaultValue" title="Permalink to this definition"></a></dt>
<dd><p>Return the default value for new parameter instances.</p>
<p>For example, suppose this parm template is named divisions, the
naming scheme is XYZW, it has 3 components, and the default value is
(10, 20, 30). The corresponding parm tuple instance on a node would
be named divisions and would contain parameters divisionsx,
divisionsy, and divisionsz. When the node is created,
divisionsx would be 10, divisionsy would be 20, and divisionsz
would be 30.</p>
</dd></dl>

<dl class="method">
<dt id="hou.IntParmTemplate.iconNames">
<code class="descname">iconNames</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of str<a class="headerlink" href="#hou.IntParmTemplate.iconNames" title="Permalink to this definition"></a></dt>
<dd><p>Return the tuple of icons corresponding to the menu items. If there
are no icons, returns a tuple of empty strings.</p>
<p>These icons are used when this parm template uses a menu.</p>
</dd></dl>

<dl class="method">
<dt id="hou.IntParmTemplate.itemGeneratorScript">
<code class="descname">itemGeneratorScript</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.IntParmTemplate.itemGeneratorScript" title="Permalink to this definition"></a></dt>
<dd><p>itemGeneratorScriptLanguage(self) -&gt; hou.scriptLanguage enum value</p>
<blockquote>
<div>Return the script used to generate menu items, or an empty string if
there is no such script.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.IntParmTemplate.itemGeneratorScriptLanguage">
<code class="descname">itemGeneratorScriptLanguage</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.IntParmTemplate.itemGeneratorScriptLanguage" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.IntParmTemplate.maxIsStrict">
<code class="descname">maxIsStrict</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.IntParmTemplate.maxIsStrict" title="Permalink to this definition"></a></dt>
<dd><p>Return whether the maximum value is strictly enforced.</p>
<p>See the minIsStrict method for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.IntParmTemplate.maxValue">
<code class="descname">maxValue</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.IntParmTemplate.maxValue" title="Permalink to this definition"></a></dt>
<dd><p>Return the minimum value of the parameter.</p>
<p>See also the minIsStrict method.</p>
</dd></dl>

<dl class="method">
<dt id="hou.IntParmTemplate.menuItems">
<code class="descname">menuItems</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of str<a class="headerlink" href="#hou.IntParmTemplate.menuItems" title="Permalink to this definition"></a></dt>
<dd><p>Return the tuple of internal menu names. If this integer does not
use a menu, returns an empty tuple.</p>
<p>These internal menu names are not displayed in the UI, but they can
be passed to hou.Parm.set.</p>
</dd></dl>

<dl class="method">
<dt id="hou.IntParmTemplate.menuLabels">
<code class="descname">menuLabels</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of str<a class="headerlink" href="#hou.IntParmTemplate.menuLabels" title="Permalink to this definition"></a></dt>
<dd><p>Return the tuple of menu labels displayed in the UI.</p>
</dd></dl>

<dl class="method">
<dt id="hou.IntParmTemplate.menuType">
<code class="descname">menuType</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.menuType enum value<a class="headerlink" href="#hou.IntParmTemplate.menuType" title="Permalink to this definition"></a></dt>
<dd><p>Return the type of menu. See hou.menuType for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.IntParmTemplate.menuUseToken">
<code class="descname">menuUseToken</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.IntParmTemplate.menuUseToken" title="Permalink to this definition"></a></dt>
<dd><p>Return whether the parameter is set to the token value instead of
the index.</p>
<p>See also the setMenuUseToken method.</p>
</dd></dl>

<dl class="method">
<dt id="hou.IntParmTemplate.minIsStrict">
<code class="descname">minIsStrict</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.IntParmTemplate.minIsStrict" title="Permalink to this definition"></a></dt>
<dd><p>Returns whether the minimum value is strictly enforced.</p>
<p>If a minimum value is not strictly enforced, the slider will not let
you change the value below the minimum, but you can set the value to
be lower than the minimum by typing it in, changing it via
hou.Parm.setValue, or using the ladder handle.</p>
<p>If it is strictly enforced and you try to change it below the
minimum value using any mechanism, Houdini will set it to the
minimum value.</p>
<p>See also the minValue method.</p>
</dd></dl>

<dl class="method">
<dt id="hou.IntParmTemplate.minValue">
<code class="descname">minValue</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.IntParmTemplate.minValue" title="Permalink to this definition"></a></dt>
<dd><p>Return the minimum value of the parameter.</p>
<p>See also the minIsStrict method.</p>
</dd></dl>

<dl class="method">
<dt id="hou.IntParmTemplate.setDefaultExpression">
<code class="descname">setDefaultExpression</code><span class="sig-paren">(</span><em>self</em>, <em>default_expression</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.IntParmTemplate.setDefaultExpression" title="Permalink to this definition"></a></dt>
<dd><p>Set the default expression for new parameter instances to a sequence
of strings.</p>
<p>See the hou.IntParmTemplate.defaultExpression method for more
information. Note that if the number of strings in the sequence is
different from the number of components in the parm template, any
extra values will be discarded and any missing expressions will
become the empty string.</p>
</dd></dl>

<dl class="method">
<dt id="hou.IntParmTemplate.setDefaultExpressionLanguage">
<code class="descname">setDefaultExpressionLanguage</code><span class="sig-paren">(</span><em>self</em>, <em>default_expression_language</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.IntParmTemplate.setDefaultExpressionLanguage" title="Permalink to this definition"></a></dt>
<dd><p>Set the default expression language for new parameter instances to a
sequence of hou.scriptLanguage values.</p>
<p>See the defaultExpressionLanguage method for more information. Note
that if the number of hou.scriptLanguage values in the sequence is
different from the number of components in the parm template, any
extra values will be discarded and any missing expression languages
will become hou.scriptLanguage.Hscript.</p>
</dd></dl>

<dl class="method">
<dt id="hou.IntParmTemplate.setDefaultValue">
<code class="descname">setDefaultValue</code><span class="sig-paren">(</span><em>self</em>, <em>default_value</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.IntParmTemplate.setDefaultValue" title="Permalink to this definition"></a></dt>
<dd><p>Set the default value for new parameter instances to a sequence of
ints.</p>
<p>See the defaultValue method for more information. Note that if the
number of ints in the sequence is different from the number of
components in the parm template, any extra values will be discarded
and any missing values will become zeros.</p>
</dd></dl>

<dl class="method">
<dt id="hou.IntParmTemplate.setIconNames">
<code class="descname">setIconNames</code><span class="sig-paren">(</span><em>self</em>, <em>icon_names</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.IntParmTemplate.setIconNames" title="Permalink to this definition"></a></dt>
<dd><p>Set the icon names to the given sequence of strings.</p>
</dd></dl>

<dl class="method">
<dt id="hou.IntParmTemplate.setItemGeneratorScript">
<code class="descname">setItemGeneratorScript</code><span class="sig-paren">(</span><em>self</em>, <em>item_generator_script</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.IntParmTemplate.setItemGeneratorScript" title="Permalink to this definition"></a></dt>
<dd><p>Set the script used to generate menu items.</p>
<p>See the itemGeneratorScript method for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.IntParmTemplate.setItemGeneratorScriptLanguage">
<code class="descname">setItemGeneratorScriptLanguage</code><span class="sig-paren">(</span><em>self</em>, <em>language</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.IntParmTemplate.setItemGeneratorScriptLanguage" title="Permalink to this definition"></a></dt>
<dd><p>Set the script language used to generate menu items to a
hou.scriptLanguage enum value.</p>
<p>See the itemGeneratorScriptLanguage method for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.IntParmTemplate.setMaxIsStrict">
<code class="descname">setMaxIsStrict</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.IntParmTemplate.setMaxIsStrict" title="Permalink to this definition"></a></dt>
<dd><p>Set whether the maximum value is strictly enforced.</p>
<p>See the maxIsStrict method for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.IntParmTemplate.setMaxValue">
<code class="descname">setMaxValue</code><span class="sig-paren">(</span><em>self</em>, <em>max_value</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.IntParmTemplate.setMaxValue" title="Permalink to this definition"></a></dt>
<dd><p>Set the maximum value of the parameter.</p>
<p>See the maxValue method for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.IntParmTemplate.setMenuItems">
<code class="descname">setMenuItems</code><span class="sig-paren">(</span><em>self</em>, <em>menu_items</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.IntParmTemplate.setMenuItems" title="Permalink to this definition"></a></dt>
<dd><p>Set the internal menu names to the given sequence of strings.</p>
<p>See the menuItems method for more information.</p>
<p>If the new number of menu items is less than the old number, the
menu labels will be shortened and the default value will be modified
if it is out of range.</p>
</dd></dl>

<dl class="method">
<dt id="hou.IntParmTemplate.setMenuLabels">
<code class="descname">setMenuLabels</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.IntParmTemplate.setMenuLabels" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.IntParmTemplate.setMenuType">
<code class="descname">setMenuType</code><span class="sig-paren">(</span><em>self</em>, <em>menu_type</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.IntParmTemplate.setMenuType" title="Permalink to this definition"></a></dt>
<dd><p>Set the type of menu to a hou.menuType enum value.</p>
<p>See the menuType method for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.IntParmTemplate.setMenuUseToken">
<code class="descname">setMenuUseToken</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.IntParmTemplate.setMenuUseToken" title="Permalink to this definition"></a></dt>
<dd><p>Set whether the parameter is set to the token value instead of the
index.</p>
<p>See also the menuUseToken method.</p>
</dd></dl>

<dl class="method">
<dt id="hou.IntParmTemplate.setMinIsStrict">
<code class="descname">setMinIsStrict</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.IntParmTemplate.setMinIsStrict" title="Permalink to this definition"></a></dt>
<dd><p>Set whether the minimum value is strictly enforced.</p>
<p>See the minIsStrict method for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.IntParmTemplate.setMinValue">
<code class="descname">setMinValue</code><span class="sig-paren">(</span><em>self</em>, <em>min_value</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.IntParmTemplate.setMinValue" title="Permalink to this definition"></a></dt>
<dd><p>Set the minimum value of the parameter.</p>
<p>See the minValue method for more information.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.IntParmTemplate.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.IntParmTemplate.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.InterruptableOperation">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">InterruptableOperation</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.InterruptableOperation" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Use this class to turn any Python code block into an interruptable
operation.</p>
<dl class="attribute">
<dt id="hou.InterruptableOperation.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.InterruptableOperation.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

<dl class="method">
<dt id="hou.InterruptableOperation.updateLongProgress">
<code class="descname">updateLongProgress</code><span class="sig-paren">(</span><em>self</em>, <em>percentage=-1.0</em>, <em>long_op_status=None</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.InterruptableOperation.updateLongProgress" title="Permalink to this definition"></a></dt>
<dd><p>Update the progress percentage and status of the long, or high-
level, operation. At the same time, check if the operation was
interrupted by the user.</p>
<dl class="docutils">
<dt>percentage</dt>
<dd>A fractional number between 0.0 and 1.0. A value of 0.0 means
that no progress has been made while 1.0 means that the
operation is complete. A negative percentage indicates that the
progress percentage is not available.</dd>
<dt>long_op_status</dt>
<dd>Text describing the current status of the long operation. The
status will overwrite the text in the 2nd progress bar of the
interrupt dialog. To keep the previous text in the progress bar,
set this parameter to None.</dd>
</dl>
<p>Raises hou.OperationInterrupted if the user has chosen to interrupt
the operation.</p>
<p>Raises hou.OperationFailed if the interruptable operation object was
constructed outside of a with statement.</p>
</dd></dl>

<dl class="method">
<dt id="hou.InterruptableOperation.updateProgress">
<code class="descname">updateProgress</code><span class="sig-paren">(</span><em>self</em>, <em>percentage=-1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.InterruptableOperation.updateProgress" title="Permalink to this definition"></a></dt>
<dd><p>Update the progress percentage of the operation. At the same time,
check if the operation was interrupted by the user.</p>
<dl class="docutils">
<dt>percentage</dt>
<dd>A fractional number between 0.0 and 1.0. A value of 0.0 means
that no progress has been made while 1.0 means that the
operation is complete. A negative percentage indicates that the
progress percentage is not available.</dd>
</dl>
<p>Raises hou.OperationInterrupted if the user has chosen to interrupt
the operation.</p>
<p>Raises hou.OperationFailed if the interruptable operation object was
constructed outside of a with statement.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.InvalidInput">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">InvalidInput</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.InvalidInput" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.Error" title="hou.Error"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.Error</span></code></a></p>
<p>Exception that is raised when you try to set a nodes input to something
invalid.</p>
<dl class="method">
<dt id="hou.InvalidInput.description">
<code class="descname">description</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.InvalidInput.description" title="Permalink to this definition"></a></dt>
<dd><p>Return a description of the class of exception. The description is
not related to the exception instance.</p>
</dd></dl>

<dl class="method">
<dt id="hou.InvalidInput.exceptionTypeName">
<code class="descname">exceptionTypeName</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.InvalidInput.exceptionTypeName" title="Permalink to this definition"></a></dt>
<dd><p>Return the name of the exception type. Instances of different
subclasses of hou.Error will return different names. Instances of
the base class will return Error.</p>
<p>You can also use str(e.__class__) to get the name of the subclass.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.InvalidInput.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.InvalidInput.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="hou.InvalidNodeName">
<code class="descclassname">hou.</code><code class="descname">InvalidNodeName</code><a class="headerlink" href="#hou.InvalidNodeName" title="Permalink to this definition"></a></dt>
<dd><p>alias of <a class="reference internal" href="#hou.OperationFailed" title="hou.OperationFailed"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.OperationFailed</span></code></a></p>
</dd></dl>

<dl class="class">
<dt id="hou.InvalidNodeType">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">InvalidNodeType</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.InvalidNodeType" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.Error" title="hou.Error"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.Error</span></code></a></p>
<p>Exception that is raised when you try to call a method on a Node that
isnt supported by that type of node.</p>
<p>For example, if you ask a non-subnet node for its indirect inputs,
hou.Node.indirectInputs raises an instance of this exception.</p>
<dl class="method">
<dt id="hou.InvalidNodeType.description">
<code class="descname">description</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.InvalidNodeType.description" title="Permalink to this definition"></a></dt>
<dd><p>Return a description of the class of exception. The description is
not related to the exception instance.</p>
</dd></dl>

<dl class="method">
<dt id="hou.InvalidNodeType.exceptionTypeName">
<code class="descname">exceptionTypeName</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.InvalidNodeType.exceptionTypeName" title="Permalink to this definition"></a></dt>
<dd><p>Return the name of the exception type. Instances of different
subclasses of hou.Error will return different names. Instances of
the base class will return Error.</p>
<p>You can also use str(e.__class__) to get the name of the subclass.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.InvalidNodeType.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.InvalidNodeType.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.InvalidSize">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">InvalidSize</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.InvalidSize" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.Error" title="hou.Error"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.Error</span></code></a></p>
<p>Exception that is raised when you pass a sequence of the wrong length to
a function.</p>
<dl class="method">
<dt id="hou.InvalidSize.description">
<code class="descname">description</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.InvalidSize.description" title="Permalink to this definition"></a></dt>
<dd><p>Return a description of the class of exception. The description is
not related to the exception instance.</p>
</dd></dl>

<dl class="method">
<dt id="hou.InvalidSize.exceptionTypeName">
<code class="descname">exceptionTypeName</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.InvalidSize.exceptionTypeName" title="Permalink to this definition"></a></dt>
<dd><p>Return the name of the exception type. Instances of different
subclasses of hou.Error will return different names. Instances of
the base class will return Error.</p>
<p>You can also use str(e.__class__) to get the name of the subclass.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.InvalidSize.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.InvalidSize.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.Keyframe">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">Keyframe</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Keyframe" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.BaseKeyframe" title="hou.BaseKeyframe"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.BaseKeyframe</span></code></a></p>
<p>Class representing the default keyframe type, a numerical keyframe.</p>
<p>REPLACES</p>
<blockquote>
<div><ul class="simple">
<li>chkey</li>
<li>chkeyls</li>
</ul>
</div></blockquote>
<dl class="method">
<dt id="hou.Keyframe.accel">
<code class="descname">accel</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; double<a class="headerlink" href="#hou.Keyframe.accel" title="Permalink to this definition"></a></dt>
<dd><p>Returns the acceleration leaving the keyframe.</p>
<p>This function raises hou.KeyframeValueNotSet if the acceleration has
not been set.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Keyframe.asJSON">
<code class="descname">asJSON</code><span class="sig-paren">(</span><em>self</em>, <em>brief=False</em>, <em>save_keys_in_frames=False</em><span class="sig-paren">)</span> &#x2192; dict<a class="headerlink" href="#hou.Keyframe.asJSON" title="Permalink to this definition"></a></dt>
<dd><p>Returns a JSON dictionary that represents the keyframe. The
dictionary includes the frame time, value/expression, and the slope
and acceleration parameters. If the brief parameter is set to True a
smaller set of key/value pairs are included in the dictionary to
reduce space usage. If the save_keys_in_frames parameter is True the
dictionary uses a frame number instead of a time value.</p>
<p>See also the fromJSON method.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Keyframe.evaluatedType">
<code class="descname">evaluatedType</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.parmData enum value<a class="headerlink" href="#hou.Keyframe.evaluatedType" title="Permalink to this definition"></a></dt>
<dd><p>Return the data type of the keyframes evaluated value. For
keyframes storing numerical values this method returns
hou.parmData.Float.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Keyframe.fromJSON">
<code class="descname">fromJSON</code><span class="sig-paren">(</span><em>self</em>, <em>keyframe_dict</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Keyframe.fromJSON" title="Permalink to this definition"></a></dt>
<dd><p>Sets the keyframe time, value and parameters using the key/value
pairs from a JSON dictionary.</p>
<p>See also the asJSON method.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Keyframe.inAccel">
<code class="descname">inAccel</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; double<a class="headerlink" href="#hou.Keyframe.inAccel" title="Permalink to this definition"></a></dt>
<dd><p>Returns the acceleration entering the keyframe.</p>
<p>This method raises hou.KeyframeValueNotSet if the acceleration has
not been set or it is tied.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Keyframe.inSlope">
<code class="descname">inSlope</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; double<a class="headerlink" href="#hou.Keyframe.inSlope" title="Permalink to this definition"></a></dt>
<dd><p>Returns the slope entering the keyframe.</p>
<p>This method raises hou.KeyframeValueNotSet if the slope has not been
set or the slope is tied.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Keyframe.inValue">
<code class="descname">inValue</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; double<a class="headerlink" href="#hou.Keyframe.inValue" title="Permalink to this definition"></a></dt>
<dd><p>Returns the value entering the keyframe.</p>
<p>This method raises hou.KeyframeValueNotSet if the value has not been
set or the value is tied.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Keyframe.interpretAccelAsRatio">
<code class="descname">interpretAccelAsRatio</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Keyframe.interpretAccelAsRatio" title="Permalink to this definition"></a></dt>
<dd><p>Sets whether Houdini should interpret the acceleration values
entering and leaving the keyframe as a single ratio. When set to
True, the ratio of the in-acceleration to out-acceleration is always
maintained. If, for example, the in-acceleration is made to be twice
as large using the Animation Editor, then the out-acceleration will
automatically be adjusted to be twice as large as well. This is the
default behavior for Houdini keyframes.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Keyframe.isAccelInterpretedAsRatio">
<code class="descname">isAccelInterpretedAsRatio</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.Keyframe.isAccelInterpretedAsRatio" title="Permalink to this definition"></a></dt>
<dd><p>Returns True if the acceleration values entering and leaving the
keyframe are interpreted as a ratio by Houdini.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Keyframe.isAccelSet">
<code class="descname">isAccelSet</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.Keyframe.isAccelSet" title="Permalink to this definition"></a></dt>
<dd><p>Returns True if the acceleration entering or leaving the keyframe
has been set.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Keyframe.isAccelTied">
<code class="descname">isAccelTied</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.Keyframe.isAccelTied" title="Permalink to this definition"></a></dt>
<dd><p>Returns True if the acceleration entering the keyframe has not been
set.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Keyframe.isAccelUsed">
<code class="descname">isAccelUsed</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.Keyframe.isAccelUsed" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.Keyframe.isInSlopeAuto">
<code class="descname">isInSlopeAuto</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.Keyframe.isInSlopeAuto" title="Permalink to this definition"></a></dt>
<dd><p>Returns True if the slope entering the keyframe is set to automatic.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Keyframe.isSlopeAuto">
<code class="descname">isSlopeAuto</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.Keyframe.isSlopeAuto" title="Permalink to this definition"></a></dt>
<dd><p>Returns True if the slope leaving the keyframe is set to automatic.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Keyframe.isSlopeSet">
<code class="descname">isSlopeSet</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.Keyframe.isSlopeSet" title="Permalink to this definition"></a></dt>
<dd><p>Returns True if the slope entering or leaving the keyframe has been
set.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Keyframe.isSlopeTied">
<code class="descname">isSlopeTied</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.Keyframe.isSlopeTied" title="Permalink to this definition"></a></dt>
<dd><p>Returns True if the slope entering the keyframe has not been set.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Keyframe.isSlopeUsed">
<code class="descname">isSlopeUsed</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.Keyframe.isSlopeUsed" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.Keyframe.isValueSet">
<code class="descname">isValueSet</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.Keyframe.isValueSet" title="Permalink to this definition"></a></dt>
<dd><p>Returns True if the value entering or leaving the keyframe has been
set.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Keyframe.isValueTied">
<code class="descname">isValueTied</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.Keyframe.isValueTied" title="Permalink to this definition"></a></dt>
<dd><p>Returns True if the value entering the keyframe has not been set.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Keyframe.isValueUsed">
<code class="descname">isValueUsed</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.Keyframe.isValueUsed" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.Keyframe.setAccel">
<code class="descname">setAccel</code><span class="sig-paren">(</span><em>self</em>, <em>accel</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Keyframe.setAccel" title="Permalink to this definition"></a></dt>
<dd><p>Sets the acceleration leaving the keyframe.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Keyframe.setInAccel">
<code class="descname">setInAccel</code><span class="sig-paren">(</span><em>self</em>, <em>in_accel</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Keyframe.setInAccel" title="Permalink to this definition"></a></dt>
<dd><p>Sets the acceleration entering the keyframe. Sets the acceleration
leaving the keyframe, if not already set. Unties the acceleration.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Keyframe.setInSlope">
<code class="descname">setInSlope</code><span class="sig-paren">(</span><em>self</em>, <em>in_slope</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Keyframe.setInSlope" title="Permalink to this definition"></a></dt>
<dd><p>Sets the slope entering the keyframe. Sets the slope leaving the
keyframe, if not already set. Unties the slope.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Keyframe.setInSlopeAuto">
<code class="descname">setInSlopeAuto</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Keyframe.setInSlopeAuto" title="Permalink to this definition"></a></dt>
<dd><p>Sets the slope entering the keyframe to automatic.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Keyframe.setInValue">
<code class="descname">setInValue</code><span class="sig-paren">(</span><em>self</em>, <em>in_value</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Keyframe.setInValue" title="Permalink to this definition"></a></dt>
<dd><p>Sets the value entering the keyframe. Sets the value leaving the
keyframe, if not already set. Unties the value.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Keyframe.setSlope">
<code class="descname">setSlope</code><span class="sig-paren">(</span><em>self</em>, <em>slope</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Keyframe.setSlope" title="Permalink to this definition"></a></dt>
<dd><p>Sets the slope leaving the keyframe.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Keyframe.setSlopeAuto">
<code class="descname">setSlopeAuto</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Keyframe.setSlopeAuto" title="Permalink to this definition"></a></dt>
<dd><p>Sets the slope leaving the keyframe to automatic.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Keyframe.setValue">
<code class="descname">setValue</code><span class="sig-paren">(</span><em>self</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Keyframe.setValue" title="Permalink to this definition"></a></dt>
<dd><p>Sets the value leaving the keyframe.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Keyframe.slope">
<code class="descname">slope</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; double<a class="headerlink" href="#hou.Keyframe.slope" title="Permalink to this definition"></a></dt>
<dd><p>Returns the slope leaving the keyframe.</p>
<p>This method raises hou.KeyframeValueNotSet if the slope has not been
set.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.Keyframe.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.Keyframe.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

<dl class="method">
<dt id="hou.Keyframe.unsetInAccel">
<code class="descname">unsetInAccel</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Keyframe.unsetInAccel" title="Permalink to this definition"></a></dt>
<dd><p>Unsets the acceleration entering the keyframe and untie the
acceleration.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Keyframe.unsetInSlope">
<code class="descname">unsetInSlope</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Keyframe.unsetInSlope" title="Permalink to this definition"></a></dt>
<dd><p>Unsets the slope entering the keyframe and untie the slope.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Keyframe.unsetInValue">
<code class="descname">unsetInValue</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Keyframe.unsetInValue" title="Permalink to this definition"></a></dt>
<dd><p>Unsets the value entering the keyframe and untie the values.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Keyframe.useAccel">
<code class="descname">useAccel</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.Keyframe.useAccel" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.Keyframe.useSlope">
<code class="descname">useSlope</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.Keyframe.useSlope" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.Keyframe.useValue">
<code class="descname">useValue</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.Keyframe.useValue" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.Keyframe.value">
<code class="descname">value</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; double<a class="headerlink" href="#hou.Keyframe.value" title="Permalink to this definition"></a></dt>
<dd><p>Returns the value leaving the keyframe.</p>
<p>This method raises hou.KeyframeValueNotSet if the value has not been
set.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.KeyframeValueNotSet">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">KeyframeValueNotSet</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.KeyframeValueNotSet" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.Error" title="hou.Error"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.Error</span></code></a></p>
<dl class="method">
<dt id="hou.KeyframeValueNotSet.description">
<code class="descname">description</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.KeyframeValueNotSet.description" title="Permalink to this definition"></a></dt>
<dd><p>Return a description of the class of exception. The description is
not related to the exception instance.</p>
</dd></dl>

<dl class="method">
<dt id="hou.KeyframeValueNotSet.exceptionTypeName">
<code class="descname">exceptionTypeName</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.KeyframeValueNotSet.exceptionTypeName" title="Permalink to this definition"></a></dt>
<dd><p>Return the name of the exception type. Instances of different
subclasses of hou.Error will return different names. Instances of
the base class will return Error.</p>
<p>You can also use str(e.__class__) to get the name of the subclass.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.KeyframeValueNotSet.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.KeyframeValueNotSet.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.LabelParmTemplate">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">LabelParmTemplate</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.LabelParmTemplate" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.ParmTemplate" title="hou.ParmTemplate"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.ParmTemplate</span></code></a></p>
<p>Describes a label parameter. Unlike most other parameters, labels do not
store parameter values.</p>
<dl class="method">
<dt id="hou.LabelParmTemplate.columnLabels">
<code class="descname">columnLabels</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; tuple of str<a class="headerlink" href="#hou.LabelParmTemplate.columnLabels" title="Permalink to this definition"></a></dt>
<dd><p>Return the tuple of strings of column labels. Normally, label parm
templates do not have any column labels. However, they may have
these extra labels that are displayed in addition to the main label.</p>
<p>Note that the number of components in a label parm template
corresponds to the number of column labels.</p>
</dd></dl>

<dl class="method">
<dt id="hou.LabelParmTemplate.setColumnLabels">
<code class="descname">setColumnLabels</code><span class="sig-paren">(</span><em>column_labels</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.LabelParmTemplate.setColumnLabels" title="Permalink to this definition"></a></dt>
<dd><p>Set the column labels to a sequence of strings.</p>
<p>The parameter editor in the &lt;Type Properties Dialog&gt; always has at
least one column label, so if you supply an empty sequence there
will be one column label that is an empty string.</p>
<p>See the columnLabels method for more information.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.LabelParmTemplate.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.LabelParmTemplate.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.LoadWarning">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">LoadWarning</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.LoadWarning" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.Error" title="hou.Error"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.Error</span></code></a></p>
<p>Exception class for when loading a hip file in Houdini generates
warnings.</p>
<dl class="method">
<dt id="hou.LoadWarning.description">
<code class="descname">description</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.LoadWarning.description" title="Permalink to this definition"></a></dt>
<dd><p>Return a description of the class of exception. The description is
not related to the exception instance.</p>
</dd></dl>

<dl class="method">
<dt id="hou.LoadWarning.exceptionTypeName">
<code class="descname">exceptionTypeName</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.LoadWarning.exceptionTypeName" title="Permalink to this definition"></a></dt>
<dd><p>Return the name of the exception type. Instances of different
subclasses of hou.Error will return different names. Instances of
the base class will return Error.</p>
<p>You can also use str(e.__class__) to get the name of the subclass.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.LoadWarning.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.LoadWarning.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.LopNode">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">LopNode</code><a class="headerlink" href="#hou.LopNode" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.Node" title="hou.Node"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.Node</span></code></a></p>
<p>Represents a lighting node.</p>
<dl class="method">
<dt id="hou.LopNode.activeLayer">
<code class="descname">activeLayer</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; pxr.Sdf.Layer<a class="headerlink" href="#hou.LopNode.activeLayer" title="Permalink to this definition"></a></dt>
<dd><p>Returns a pxr.Sdf.Layer object representing the USD layer that has
been modified by this node.</p>
</dd></dl>

<dl class="method">
<dt id="hou.LopNode.bypass">
<code class="descname">bypass</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.LopNode.bypass" title="Permalink to this definition"></a></dt>
<dd><p>Turns this nodes bypass flag on or off, making this node have no
effect.</p>
</dd></dl>

<dl class="method">
<dt id="hou.LopNode.displayNode">
<code class="descname">displayNode</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; Node<a class="headerlink" href="#hou.LopNode.displayNode" title="Permalink to this definition"></a></dt>
<dd><p>If this is a subnet TOP, return the TOP node inside the subnet with
its display flag on. Otherwise, return None.</p>
</dd></dl>

<dl class="method">
<dt id="hou.LopNode.editableLayer">
<code class="descname">editableLayer</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; pxr.Sdf.Layer<a class="headerlink" href="#hou.LopNode.editableLayer" title="Permalink to this definition"></a></dt>
<dd><p>Returns a pxr.Sdf.Layer object with permission to edit that
represents the active layer in a Python LOP.</p>
</dd></dl>

<dl class="method">
<dt id="hou.LopNode.editableStage">
<code class="descname">editableStage</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; pxr.Usd.Stage<a class="headerlink" href="#hou.LopNode.editableStage" title="Permalink to this definition"></a></dt>
<dd><p>Returns a pxr.Usd.Stage object with permission to edit that
represents the USD stage input to a Python LOP.</p>
</dd></dl>

<dl class="method">
<dt id="hou.LopNode.inputPrims">
<code class="descname">inputPrims</code><span class="sig-paren">(</span><em>self</em>, <em>inputidx</em><span class="sig-paren">)</span> &#x2192; tuple of str<a class="headerlink" href="#hou.LopNode.inputPrims" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Returns the paths of the USD primitives modified by the specified
input of this node. This method is roughly equivalent to:</div></blockquote>
<p>&gt; lopnode.inputs()[inputidx].lastModifiedPrims()</p>
</dd></dl>

<dl class="method">
<dt id="hou.LopNode.isBypassed">
<code class="descname">isBypassed</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.LopNode.isBypassed" title="Permalink to this definition"></a></dt>
<dd><p>Returns whether this nodes bypass flag is on.</p>
</dd></dl>

<dl class="method">
<dt id="hou.LopNode.isDebugFlagSet">
<code class="descname">isDebugFlagSet</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.LopNode.isDebugFlagSet" title="Permalink to this definition"></a></dt>
<dd><p>Returns True if the nodes debug flag is turned on. Returns False
otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="hou.LopNode.isDisplayFlagSet">
<code class="descname">isDisplayFlagSet</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.LopNode.isDisplayFlagSet" title="Permalink to this definition"></a></dt>
<dd><p>Returns whether this nodes display flag is on.</p>
</dd></dl>

<dl class="method">
<dt id="hou.LopNode.lastModifiedPrims">
<code class="descname">lastModifiedPrims</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of str<a class="headerlink" href="#hou.LopNode.lastModifiedPrims" title="Permalink to this definition"></a></dt>
<dd><p>Returns the paths of the USD primitives modified by this node.</p>
</dd></dl>

<dl class="method">
<dt id="hou.LopNode.network">
<code class="descname">network</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.LopNode<a class="headerlink" href="#hou.LopNode.network" title="Permalink to this definition"></a></dt>
<dd><p>Return the LOP Network that contains this LOP Node. If this node is
a LOP Network itself, this node will be returned. The LOP Network
returned by this method is the one that is accessed using any of the
methods that start with network or setNetwork.</p>
</dd></dl>

<dl class="method">
<dt id="hou.LopNode.networkClearSelectionRules">
<code class="descname">networkClearSelectionRules</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.LopNode.networkClearSelectionRules" title="Permalink to this definition"></a></dt>
<dd><p>Deletes all selection rules stored on the LOP Network that owns this
LOP node.</p>
</dd></dl>

<dl class="method">
<dt id="hou.LopNode.networkSelection">
<code class="descname">networkSelection</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of str<a class="headerlink" href="#hou.LopNode.networkSelection" title="Permalink to this definition"></a></dt>
<dd><p>Return a tuple of strings representing all the scene graph locations
currently selected in the LOP Network parent of this LOP node. This
is the same selection that will be showing in the Scene Graph Tree
pane and the LOP viewport.</p>
</dd></dl>

<dl class="method">
<dt id="hou.LopNode.networkSelectionCurrentPrim">
<code class="descname">networkSelectionCurrentPrim</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.LopNode.networkSelectionCurrentPrim" title="Permalink to this definition"></a></dt>
<dd><p>Return a string with the path to the scene graph primitive that
should be displayed in the Scene Graph Details pane. Set this value
with the hou.LopNode.setNetworkSelection method.</p>
</dd></dl>

<dl class="method">
<dt id="hou.LopNode.networkSelectionLayerId">
<code class="descname">networkSelectionLayerId</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.LopNode.networkSelectionLayerId" title="Permalink to this definition"></a></dt>
<dd><p>Return a string with the layer identifier of the specific USD layer
that should be displayed in the Scene Graph Details pane. Set this
value with the hou.LopNode.setNetworkSelection method.</p>
</dd></dl>

<dl class="method">
<dt id="hou.LopNode.networkSelectionRules">
<code class="descname">networkSelectionRules</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; dict of str to hou.LopSelectionRule<a class="headerlink" href="#hou.LopNode.networkSelectionRules" title="Permalink to this definition"></a></dt>
<dd><p>Return a dictionary mapping string names to hou.LopSelectionRule
objects that match the selection rules stored on the LOP Network
that owns this LOP node.</p>
</dd></dl>

<dl class="method">
<dt id="hou.LopNode.networkSessionEditor">
<code class="descname">networkSessionEditor</code><span class="sig-paren">(</span><em>self</em>, <em>output_index = 0</em>, <em>layer_index = 0</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.LopNode.networkSessionEditor" title="Permalink to this definition"></a></dt>
<dd><p>hou.LopSessionEditor</p>
<p>Return a hou.LopSessionEditor object that allows editing of the
current session-only modifications which should be applied to any
scene being viewed in a Scene Graph Tree pane or a Scene Viewer
pane.</p>
<p>The output_index controls which output of this LOP node will be used
to author the stage presented through the hou.LopSessionEditor.stage
method. The layer_index parameter controls which specific session
sublayer is to be modified.</p>
</dd></dl>

<dl class="method">
<dt id="hou.LopNode.networkSetSelectionRule">
<code class="descname">networkSetSelectionRule</code><span class="sig-paren">(</span><em>self</em>, <em>name</em>, <em>rule</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.LopNode.networkSetSelectionRule" title="Permalink to this definition"></a></dt>
<dd><p>Stores a named selection rule on the LOP Network that owns this LOP
node. The rule parameter must be a hou.LopSelectionRule or None. Use
None to remove a single named rule from the LOP Network.</p>
<p>The selection rule name can be a slash-separated path, in which case
the selection rule will appear in the Scene Graph Tree pane as part
of a nested hierarchy. This in no way affects the operation of the
rule, serving only as a way of organizing sets of rules.</p>
</dd></dl>

<dl class="method">
<dt id="hou.LopNode.setDebugFlag">
<code class="descname">setDebugFlag</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.LopNode.setDebugFlag" title="Permalink to this definition"></a></dt>
<dd><p>Turns the nodes debug flag on or off. The debug flag on a LOP node
is used to force the node to create its own USD Layer and apply its
edits in that new layer. This makes it easier to track which scene
graph modifications were made by which LOP node. Setting this flag
will also affect the performance of the LOP Network since
composition of the USD stage takes longer if there are more layers.</p>
<p>Raises hou.PermissionError if the node is unwritable.</p>
</dd></dl>

<dl class="method">
<dt id="hou.LopNode.setDisplayFlag">
<code class="descname">setDisplayFlag</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.LopNode.setDisplayFlag" title="Permalink to this definition"></a></dt>
<dd><p>Turn this nodes display flag on or off.</p>
</dd></dl>

<dl class="method">
<dt id="hou.LopNode.setLastModifiedPrims">
<code class="descname">setLastModifiedPrims</code><span class="sig-paren">(</span><em>self</em>, <em>primpaths</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.LopNode.setLastModifiedPrims" title="Permalink to this definition"></a></dt>
<dd><p>When used in a Python based LOP node, this method sets the value
that will be returned by subsequent calls to lastModifiedPrims. The
primpaths parameter must be a tuple or list of strings.</p>
</dd></dl>

<dl class="method">
<dt id="hou.LopNode.setNetworkSelection">
<code class="descname">setNetworkSelection</code><span class="sig-paren">(</span><em>self</em>, <em>selection</em>, <em>layerid = None</em>, <em>currentprim = None</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.LopNode.setNetworkSelection" title="Permalink to this definition"></a></dt>
<dd><p>Accepts a tuple of strings holding the scene graph locations which
should become the selection in the LOP Network parent of this LOP
node. This selection will be reflected in the Scene Graph Tree pane
and the LOP viewport.</p>
<p>The optional layerid parameter can be a string which is the layer
identifier of a specific layer that should be displayed in the Scene
Graph Details pane. Similarly the currentprim string can be supplied
to have the Scene Graph Details pane show the information for a
primitive at a specific path. The currentprim is usually in the
selection list, but it doesnt need to be. Passing None for layerid
or currentprim leave these values on the LOP Network unchanged.</p>
</dd></dl>

<dl class="method">
<dt id="hou.LopNode.sourceLayer">
<code class="descname">sourceLayer</code><span class="sig-paren">(</span><em>self</em>, <em>layerindex</em><span class="sig-paren">)</span> &#x2192; pxr.Sdf.Layer<a class="headerlink" href="#hou.LopNode.sourceLayer" title="Permalink to this definition"></a></dt>
<dd><p>Return a pxr.Sdf.Layer object representing the specific requested
USD layer that is used to build the stage that is the output of this
node.</p>
</dd></dl>

<dl class="method">
<dt id="hou.LopNode.sourceLayerCount">
<code class="descname">sourceLayerCount</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.LopNode.sourceLayerCount" title="Permalink to this definition"></a></dt>
<dd><p>Returns the number of source layers that are used to build the stage
at the output of this node. The result from this method will be one
greater than the maximum value that can be passed to the sourceLayer
method.</p>
</dd></dl>

<dl class="method">
<dt id="hou.LopNode.stage">
<code class="descname">stage</code><span class="sig-paren">(</span><em>self</em>, <em>apply_network_overrides=True</em><span class="sig-paren">)</span> &#x2192; pxr.Usd.Stage<a class="headerlink" href="#hou.LopNode.stage" title="Permalink to this definition"></a></dt>
<dd><p>Returns a pxr.Usd.Stage object representing the USD stage output
from this node. Set apply_network_overrides to True to return a
stage with its session layer set with any temporary activation or
visibility settings configured in the scene graph tree. Set it to
False to return the stage with an empty session layer.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.LopNode.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.LopNode.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.LopSelectionRule">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">LopSelectionRule</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.LopSelectionRule" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Stores a set of rules that define how to make a selection of scene graph
primitives.</p>
<dl class="method">
<dt id="hou.LopSelectionRule.collectionAwarePaths">
<code class="descname">collectionAwarePaths</code><span class="sig-paren">(</span><em>self</em>, <em>lopnode</em><span class="sig-paren">)</span> &#x2192; tuple of str<a class="headerlink" href="#hou.LopSelectionRule.collectionAwarePaths" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the scene graph primitive selection using the scene graph
from the provided Hom:hou.LopNode object.</p>
<p>Returns the full paths to every scene graph primitive or collection
matching the selection pattern. Unlike the expandedPaths method,
collections are not expanded to explicitly list their contents as
primitives. Instead the full path of the collection itself is
returned.</p>
<p>If the primitive pattern contains any exclusions the included
collections cannot be accurately tracked, so the results of this
method will be the same as for expandedPaths.</p>
</dd></dl>

<dl class="method">
<dt id="hou.LopSelectionRule.expandedPaths">
<code class="descname">expandedPaths</code><span class="sig-paren">(</span><em>self</em>, <em>lopnode</em><span class="sig-paren">)</span> &#x2192; tuple of str<a class="headerlink" href="#hou.LopSelectionRule.expandedPaths" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the scene graph primitive selection using the scene graph
from the provided Hom:hou.LopNode object.</p>
<p>Returns the full paths to every scene graph primitive matching the
selection rules. All collections in the path pattern are expanded to
list their included prims explicitly.</p>
</dd></dl>

<dl class="method">
<dt id="hou.LopSelectionRule.pathPattern">
<code class="descname">pathPattern</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.LopSelectionRule.pathPattern" title="Permalink to this definition"></a></dt>
<dd><p>Return the path pattern string used in this selection rule.</p>
</dd></dl>

<dl class="method">
<dt id="hou.LopSelectionRule.setPathPattern">
<code class="descname">setPathPattern</code><span class="sig-paren">(</span><em>self</em>, <em>pattern</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.LopSelectionRule.setPathPattern" title="Permalink to this definition"></a></dt>
<dd><p>Sets the path pattern string used in this selection rule.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.LopSelectionRule.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.LopSelectionRule.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.LopSessionEditor">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">LopSessionEditor</code><a class="headerlink" href="#hou.LopSessionEditor" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Used to edit the current session overlay layer that is applied to the
current LOP nodes scene graph.</p>
<p>This object is a context manager. You can create one using
hou.LopNode.networkSessionEditor. At the end of the with block, the
notification of the session edits is propagated to viewer panes.</p>
<dl class="method">
<dt id="hou.LopSessionEditor.layer">
<code class="descname">layer</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; pxr.Sdf.Layer<a class="headerlink" href="#hou.LopSessionEditor.layer" title="Permalink to this definition"></a></dt>
<dd><p>Return the pxr.Sdf.Layer object that contains all the current
session edits to the scene graph. This object can be modified using
the pxr.Sdf.Layer API to make further session modifications to the
scene graph.</p>
</dd></dl>

<dl class="method">
<dt id="hou.LopSessionEditor.stage">
<code class="descname">stage</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; pxr.Sdf.Stage<a class="headerlink" href="#hou.LopSessionEditor.stage" title="Permalink to this definition"></a></dt>
<dd><p>Return the pxr.Usd.Stage object that contains all the current
session edits to the scene graph. This object can be modified using
the pxr.Usd.Stage API to make further session modifications to the
scene graph.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.LopSessionEditor.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.LopSessionEditor.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.MatchDefinitionError">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">MatchDefinitionError</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.MatchDefinitionError" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.Error" title="hou.Error"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.Error</span></code></a></p>
<dl class="method">
<dt id="hou.MatchDefinitionError.description">
<code class="descname">description</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.MatchDefinitionError.description" title="Permalink to this definition"></a></dt>
<dd><p>Return a description of the class of exception. The description is
not related to the exception instance.</p>
</dd></dl>

<dl class="method">
<dt id="hou.MatchDefinitionError.exceptionTypeName">
<code class="descname">exceptionTypeName</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.MatchDefinitionError.exceptionTypeName" title="Permalink to this definition"></a></dt>
<dd><p>Return the name of the exception type. Instances of different
subclasses of hou.Error will return different names. Instances of
the base class will return Error.</p>
<p>You can also use str(e.__class__) to get the name of the subclass.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.MatchDefinitionError.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.MatchDefinitionError.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.Matrix2">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">Matrix2</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Matrix2" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A 2x2 matrix of floating point values.</p>
<dl class="method">
<dt id="hou.Matrix2.asTuple">
<code class="descname">asTuple</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of float<a class="headerlink" href="#hou.Matrix2.asTuple" title="Permalink to this definition"></a></dt>
<dd><p>Return the contents of the matrix as a tuple of 4 floats.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Matrix2.asTupleOfTuples">
<code class="descname">asTupleOfTuples</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of tuple of float<a class="headerlink" href="#hou.Matrix2.asTupleOfTuples" title="Permalink to this definition"></a></dt>
<dd><p>Return the contents of the matrix as a tuple of tuples of 2 floats.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Matrix2.at">
<code class="descname">at</code><span class="sig-paren">(</span><em>self</em>, <em>row</em>, <em>col</em><span class="sig-paren">)</span> &#x2192; double<a class="headerlink" href="#hou.Matrix2.at" title="Permalink to this definition"></a></dt>
<dd><p>Return the value of the matrix at the given row and column.</p>
<p>Raises IndexError if the row or column are not between 0 and 1,
inclusive. Note that negative indices will not index from the end.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Matrix2.determinant">
<code class="descname">determinant</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; double<a class="headerlink" href="#hou.Matrix2.determinant" title="Permalink to this definition"></a></dt>
<dd><p>Return the determinant of the matrix.</p>
<p>See Wikipedias determinant page.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Matrix2.inverted">
<code class="descname">inverted</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Matrix2<a class="headerlink" href="#hou.Matrix2.inverted" title="Permalink to this definition"></a></dt>
<dd><p>Return the inverse of this matrix.</p>
<p>Raises hou.OperationFailed if the matrix is not invertible.
Otherwise, (self * self.inverted()).isAlmostEqual(hou.Matrix2(1)) is
True.</p>
<p>See Wikipedias invertible matrix page for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Matrix2.isAlmostEqual">
<code class="descname">isAlmostEqual</code><span class="sig-paren">(</span><em>self</em>, <em>matrix2</em>, <em>tolerance=0.00001</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.Matrix2.isAlmostEqual" title="Permalink to this definition"></a></dt>
<dd><p>Returns whether this matrix is equal to another, within a tolerance.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Matrix2.preMult">
<code class="descname">preMult</code><span class="sig-paren">(</span><em>self</em>, <em>matrix2</em><span class="sig-paren">)</span> &#x2192; hou.Matrix2<a class="headerlink" href="#hou.Matrix2.preMult" title="Permalink to this definition"></a></dt>
<dd><p>Returns matrix2 * self. Note that __mul__ returns self * matrix2,
which is a different result because matrix multiplication is not
commutative.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Matrix2.setAt">
<code class="descname">setAt</code><span class="sig-paren">(</span><em>self</em>, <em>row</em>, <em>col</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Matrix2.setAt" title="Permalink to this definition"></a></dt>
<dd><p>Set the value of the matrix at the given row and column.</p>
<p>Raises IndexError if the row or column are not between 0 and 1,
inclusive. Note that negative indices will not index from the end.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Matrix2.setTo">
<code class="descname">setTo</code><span class="sig-paren">(</span><em>self</em>, <em>tuple</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Matrix2.setTo" title="Permalink to this definition"></a></dt>
<dd><p>Set this matrixs contents. The sequence may contain either 4 floats
or 2 sequences, each with 2 floats.</p>
<p>See hou.Matrix2.__init__ for examples of suitable parameter values.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Matrix2.setToIdentity">
<code class="descname">setToIdentity</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Matrix2.setToIdentity" title="Permalink to this definition"></a></dt>
<dd><p>Set this matrix to the multiplicative identity, having 1s in the
diagonal.</p>
<p>The matrix will contain the values [[1, 0], [0, 1]]. Note that you
can construct a new matrix with these values using hou.Matrix2(1).</p>
</dd></dl>

<dl class="method">
<dt id="hou.Matrix2.setToZero">
<code class="descname">setToZero</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Matrix2.setToZero" title="Permalink to this definition"></a></dt>
<dd><p>Set this matrix to contain all zeros.</p>
<p>Note that you can construct a new matrix with all zeros with
hou.Matrix2().</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.Matrix2.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.Matrix2.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

<dl class="method">
<dt id="hou.Matrix2.transposed">
<code class="descname">transposed</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Matrix2<a class="headerlink" href="#hou.Matrix2.transposed" title="Permalink to this definition"></a></dt>
<dd><p>Return the transpose of this matrix. The result is such that
self.at(i, j) == self.transposed().at(j, i) for 0 &lt;= i,j &lt;= 1.</p>
<p>See Wikipedias transpose page for more information.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.Matrix3">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">Matrix3</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Matrix3" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A 3x3 matrix of floating point values.</p>
<p>3x3 matrices are typically used in Houdini to represent a 3D rotation
(with a possible scale). Most places in Houdini use hou.Matrix4, which
can store generation 3D transformations (including translations).</p>
<p>Note that you can construct a general transformation Matrix4 from a
Matrix3 by writing hou.Matrix4(matrix3).</p>
<dl class="method">
<dt id="hou.Matrix3.asTuple">
<code class="descname">asTuple</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of float<a class="headerlink" href="#hou.Matrix3.asTuple" title="Permalink to this definition"></a></dt>
<dd><p>Return the contents of the matrix as a tuple of 9 floats.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Matrix3.asTupleOfTuples">
<code class="descname">asTupleOfTuples</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of tuple of float<a class="headerlink" href="#hou.Matrix3.asTupleOfTuples" title="Permalink to this definition"></a></dt>
<dd><p>Return the contents of the matrix as a tuple of tuples of 3 floats.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Matrix3.at">
<code class="descname">at</code><span class="sig-paren">(</span><em>self</em>, <em>row</em>, <em>col</em><span class="sig-paren">)</span> &#x2192; double<a class="headerlink" href="#hou.Matrix3.at" title="Permalink to this definition"></a></dt>
<dd><p>Return the value of the matrix at the given row and column.</p>
<p>Raises IndexError if the row or column are not between 0 and 2,
inclusive. Note that negative indices will not index from the end.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Matrix3.determinant">
<code class="descname">determinant</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; double<a class="headerlink" href="#hou.Matrix3.determinant" title="Permalink to this definition"></a></dt>
<dd><p>Return the determinant of the matrix.</p>
<p>See Wikipedias determinant page.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Matrix3.extractRotates">
<code class="descname">extractRotates</code><span class="sig-paren">(</span><em>self</em>, <em>rotate_order=&quot;xyz&quot;</em><span class="sig-paren">)</span> &#x2192; hou.Vector3<a class="headerlink" href="#hou.Matrix3.extractRotates" title="Permalink to this definition"></a></dt>
<dd><p>Return a Vector3 of Euler angles, in degrees, representing the
rotation component of this matrix. Rotating about the coordinate
axes in the specified order by these amounts will yield the rotation
contained in this matrix.</p>
<dl class="docutils">
<dt>rotate_order</dt>
<dd>A string containing a permutation of the letters x, y, and z
that determines the order in which rotations are performed about
the coordinate axes.</dd>
</dl>
<p>Raises hou.OperationFailed if the matrix does not represent a valid
rotation matrix (e.g. it is singular) or the rotate order is not a
permutation of the string xyz.</p>
<p>See also hou.Matrix4.explode and hou.Matrix4.extractRotates.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Matrix3.inverted">
<code class="descname">inverted</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Matrix3<a class="headerlink" href="#hou.Matrix3.inverted" title="Permalink to this definition"></a></dt>
<dd><p>Return the inverse of this matrix.</p>
<p>Raises hou.OperationFailed if the matrix is not invertible.
Otherwise, (self * self.inverted()).isAlmostEqual(hou.Matrix3(1)) is
True.</p>
<p>See Wikipedias invertible matrix page for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Matrix3.isAlmostEqual">
<code class="descname">isAlmostEqual</code><span class="sig-paren">(</span><em>self</em>, <em>matrix3</em>, <em>tolerance=0.00001</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.Matrix3.isAlmostEqual" title="Permalink to this definition"></a></dt>
<dd><p>Returns whether this matrix is equal to another, within a tolerance.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Matrix3.preMult">
<code class="descname">preMult</code><span class="sig-paren">(</span><em>self</em>, <em>matrix3</em><span class="sig-paren">)</span> &#x2192; hou.Matrix3<a class="headerlink" href="#hou.Matrix3.preMult" title="Permalink to this definition"></a></dt>
<dd><p>Returns matrix3 * self. Note that __mul__ returns self * matrix3,
which is a different result because matrix multiplication is not
commutative.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Matrix3.setAt">
<code class="descname">setAt</code><span class="sig-paren">(</span><em>self</em>, <em>row</em>, <em>col</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Matrix3.setAt" title="Permalink to this definition"></a></dt>
<dd><p>Set the value of the matrix at the given row and column.</p>
<p>Raises IndexError if the row or column are not between 0 and 2,
inclusive. Note that negative indices will not index from the end.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Matrix3.setTo">
<code class="descname">setTo</code><span class="sig-paren">(</span><em>self</em>, <em>tuple</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Matrix3.setTo" title="Permalink to this definition"></a></dt>
<dd><p>Set this matrixs contents. The sequence may contain either 9 floats
or 3 sequences, each with 3 floats.</p>
<p>See hou.Matrix3.__init__ for examples of suitable parameter values.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Matrix3.setToIdentity">
<code class="descname">setToIdentity</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Matrix3.setToIdentity" title="Permalink to this definition"></a></dt>
<dd><p>Set this matrix to the multiplicative identity, having 1s in the
diagonal.</p>
<p>The matrix will contain the values [[1, 0, 0], [0, 1, 0], [0, 0,
1]]. Note that you can construct a new matrix with these values
using hou.Matrix3(1).</p>
</dd></dl>

<dl class="method">
<dt id="hou.Matrix3.setToZero">
<code class="descname">setToZero</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Matrix3.setToZero" title="Permalink to this definition"></a></dt>
<dd><p>Set this matrix to contain all zeros.</p>
<p>Note that you can construct a new matrix with all zeros with
hou.Matrix3().</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.Matrix3.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.Matrix3.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

<dl class="method">
<dt id="hou.Matrix3.transposed">
<code class="descname">transposed</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Matrix3<a class="headerlink" href="#hou.Matrix3.transposed" title="Permalink to this definition"></a></dt>
<dd><p>Return the transpose of this matrix. The result is such that
self.at(i, j) == self.transposed().at(j, i) for 0 &lt;= i,j &lt;= 2.</p>
<p>See Wikipedias transpose page for more information.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.Matrix4">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">Matrix4</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Matrix4" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A 4x4 matrix of floating point values.</p>
<p>4x4 matrices are typically used in Houdini to represent a 3D
transformation (e.g. some combination of rotation, scaling, shearing,
and translation). A single matrix compactly represents a transformation,
and is much easier to deal with than multiple translate, rotate, scale,
shear, transformation order, and rotation order values.</p>
<p>Note that Houdinis matrices are stored in row-major format, and vectors
that are multiplied with matrices are treated as row vectors. So, if p
is a hou.Vector4 representing a point and M is a Matrix4, you write p*M,
<em>not</em> M*p. Similarly, p*M1*M2 will first transform p by M1, and then
transform it by M2.</p>
<dl class="docutils">
<dt>NOTE</dt>
<dd>Most mathematical notations treat vectors and points as column
vectors instead of row vectors. They will often use A*B*C (or simply
ABC) to refer to a combined transform that first applies Cs
transform, then Bs, and then applies As. However, the convention
is different in Houdini. To represent the equivalent matrix
expression in Houdini, you need to concatenate the transforms in the
reverse order. So, you would instead write C<a href="#id13"><span class="problematic" id="id14">*</span></a>B<a href="#id15"><span class="problematic" id="id16">*</span></a>A, where C, B,
A are the transpose of C, B, A respectively.</dd>
</dl>
<p>You can multiply Vector3s or Vector4s by Matrix4s. If you multiply a
Vector3, it is the same as multiplying a Vector4 where the fourth
component is 1 (see hou.Vector3.__mul__).</p>
<p>To transform a normal (as opposed to a point or vector), you need to
multiply by the inverse transpose of the matrix. For example, suppose:</p>
<dl class="docutils">
<dt>p</dt>
<dd>is a hou.Vector3 object representing a position (or a hou.Vector4
with v[4]==1)</dd>
<dt>v</dt>
<dd>is a hou.Vector4 object representing a vector (a direction with a
length but no fixed location in space), with v[3]==0</dd>
<dt>n</dt>
<dd>is a hou.Vector4 object representing a normal, with v[3]==0</dd>
<dt>m</dt>
<dd>is a Matrix4 object representing a transform matrix</dd>
</dl>
<p>Then you would write:</p>
<p>&gt; p * m # to transform the point
&gt; v * m # to transform the vector
&gt; n * m.inverted().transposed() # to transform the normal
&gt; # (note that m.inverted().transposed() is mathematically equivalent to m.transposed().inverted())</p>
<p>Here is a concrete example:</p>
<p>&gt; &gt;&gt;&gt; m = hou.hmath.buildTranslate((1, 1, 2))
&gt; &gt;&gt;&gt; m
&gt; &lt;hou.Matrix4 [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [1, 1, 2, 1]]&gt;
&gt; &gt;&gt;&gt; p = hou.Vector3(1, 2, 3)
&gt; &gt;&gt;&gt; p * m
&gt; &lt;hou.Vector3 [2, 3, 5]&gt;</p>
<p>Both VEX and the UT_DMatrix4 class in the Houdini Development Kit (HDK)
also store matrices in row-major format.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.hmath</li>
<li>hou.Matrix3</li>
<li>hou.Quaternion</li>
<li>hou.Vector3</li>
<li>hou.Vector4</li>
</ul>
</div></blockquote>
<dl class="method">
<dt id="hou.Matrix4.asTuple">
<code class="descname">asTuple</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of float<a class="headerlink" href="#hou.Matrix4.asTuple" title="Permalink to this definition"></a></dt>
<dd><p>Return the contents of the matrix as a tuple of 16 floats.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Matrix4.asTupleOfTuples">
<code class="descname">asTupleOfTuples</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of tuple of float<a class="headerlink" href="#hou.Matrix4.asTupleOfTuples" title="Permalink to this definition"></a></dt>
<dd><p>Return the contents of the matrix as a tuple of tuples of 4 floats.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Matrix4.at">
<code class="descname">at</code><span class="sig-paren">(</span><em>self</em>, <em>row</em>, <em>col</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#hou.Matrix4.at" title="Permalink to this definition"></a></dt>
<dd><p>Return the value of the matrix at the given row and column.</p>
<p>Raises IndexError if the row or column are not between 0 and 3,
inclusive. Note that negative indices will not index from the end.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Matrix4.determinant">
<code class="descname">determinant</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#hou.Matrix4.determinant" title="Permalink to this definition"></a></dt>
<dd><p>Return the determinant of the matrix.</p>
<p>See Wikipedias determinant page.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Matrix4.explode">
<code class="descname">explode</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Matrix4.explode" title="Permalink to this definition"></a></dt>
<dd><p>explode(self, transform_order=srt, rotate_order=xyz,
pivot=hou.Vector3(), pivot_rotate=hou.Vector3()) -&gt; dict of str to
hou.Vector3</p>
<blockquote>
<div><p>Return a dictionary with keys rotate, scale, translate, and
shear whose values are hou.Vector3 objects. When applied in the
specified order, the corresponding rotations, scales (and shears),
and translations will give this matrix.</p>
<p>The rotation is returned as a set of Euler angles, in degrees. See
Wikipedias Euler angles page for more information.</p>
<dl class="docutils">
<dt>transform_order</dt>
<dd><p class="first">A string containing a permutation of the letters s, r, and t.
The rotate, scale, and translate results are dependent on the
order in which you perform those operations, and this string
specifies that order.</p>
<p class="last">For example, imagine a transformation where you first translate
in x by one unit, then you rotate in z by 45 degrees. With a
transform order of trs (translate, rotate, scale), the
translate component is (1, 0, 0). However, this same
transformation could be constructed, for example, by first
scaling, then rotating, and then translating. For this
transformation order, the translate component would be (1.0 /
math.sqrt(2), 1.0 / math.sqrt(2), 0).</p>
</dd>
<dt>rotate_order</dt>
<dd>A string containing a permutation of the letters x, y, and z
that determines the order in which rotations are performed about
the coordinate axes.</dd>
<dt>pivot</dt>
<dd>A Vector3 containing a position about which rotations and scales
are performed. By default, this parameter is set to the origin.</dd>
<dt>pivot_rotate</dt>
<dd>A Vector3 containing the Euler angles about the x, y, and z
axes, in degrees, that specifies the base rotation about the
pivot. These angles are always processed in xyz order.</dd>
</dl>
<p>Raises hou.OperationFailed if the matrix does not represent a valid
transform matrix (e.g. it is singular), the transform order is not a
permutation of the string srt, or the rotate order is not a
permutation of the string xyz.</p>
<p>See hou.hmath.buildRotateAboutAxis for an example of how to convert
Euler angles into an axis and rotation.</p>
<p>See hou.ObjNode.setParmTransform for an example. This method is the
inverse of hou.hmath.buildTransform. See also the other functions in
hou.hmath that build transformation matrices.</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.Matrix4.extractRotates">
<code class="descname">extractRotates</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Matrix4.extractRotates" title="Permalink to this definition"></a></dt>
<dd><p>extractRotates(self, transform_order=srt, rotate_order=xyz,
pivot=hou.Vector3(), pivot_rotate=hou.Vector3()) -&gt; hou.Vector3</p>
<blockquote>
<div>A shortcut for self.explode(transform_order, rotate_order, pivot,
pivot_rotate)[rotate]. See hou.Matrix4.explode for more
information.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.Matrix4.extractRotationMatrix3">
<code class="descname">extractRotationMatrix3</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Matrix3<a class="headerlink" href="#hou.Matrix4.extractRotationMatrix3" title="Permalink to this definition"></a></dt>
<dd><p>Extracts the 3x3 rotation matrix from this matrix, assuming it is a
transformation matrix. If it fails to extract the rotation, for
example if scaling is zero on one axis, it returns the identity
matrix instead.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Matrix4.extractScales">
<code class="descname">extractScales</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Matrix4.extractScales" title="Permalink to this definition"></a></dt>
<dd><p>extractScales(self, transform_order=srt, pivot=hou.Vector3(),
pivot_rotate=hou.Vector3()) -&gt; hou.Vector3</p>
<blockquote>
<div>A shortcut for self.explode(transform_order, rotate_order, pivot,
pivot_rotate)[scale]. See hou.Matrix4.explode for more
information.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.Matrix4.extractShears">
<code class="descname">extractShears</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Matrix4.extractShears" title="Permalink to this definition"></a></dt>
<dd><p>extractShears(self, transform_order=srt, pivot=hou.Vector3(),
pivot_rotate=hou.Vector3()) -&gt; hou.Vector3</p>
<blockquote>
<div>A shortcut for self.explode(transform_order, rotate_order, pivot,
pivot_rotate)[shear]. See hou.Matrix4.explode for more
information.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.Matrix4.extractTranslates">
<code class="descname">extractTranslates</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Matrix4.extractTranslates" title="Permalink to this definition"></a></dt>
<dd><p>extractTranslates(self, transform_order=srt,
pivot_rotate=hou.Vector3()) -&gt; hou.Vector3</p>
<blockquote>
<div><blockquote>
<div>A shortcut for self.explode(transform_order, hou.Vector3(),
pivot_rotate)[translate]. See hou.Matrix4.explode for more
information.</div></blockquote>
<p>&gt; &gt;&gt;&gt; matrix = hou.hmath.buildTranslate(1, 0, 0) * hou.hmath.buildRotate(0, 0, 45)
&gt; &gt;&gt;&gt; matrix.extractTranslates(trs)
&gt; &lt;hou.Vector3 [4, 0, 0]&gt;
&gt; &gt;&gt;&gt; matrix.extractTranslates(srt)
&gt; &lt;hou.Vector3 [0.707107, 0.707107, 0]&gt;</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.Matrix4.inverted">
<code class="descname">inverted</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Matrix4<a class="headerlink" href="#hou.Matrix4.inverted" title="Permalink to this definition"></a></dt>
<dd><p>Return the inverse of this matrix.</p>
<p>Raises hou.OperationFailed if the matrix is not invertible.
Otherwise, (self *
self.inverted()).isAlmostEqual(hou.hmath.identityTransform()) is
True.</p>
<p>See Wikipedias invertible matrix page for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Matrix4.isAlmostEqual">
<code class="descname">isAlmostEqual</code><span class="sig-paren">(</span><em>self</em>, <em>matrix4</em>, <em>tolerance=0.00001</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.Matrix4.isAlmostEqual" title="Permalink to this definition"></a></dt>
<dd><p>Return whether this matrix is equal to another, within a tolerance.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Matrix4.preMult">
<code class="descname">preMult</code><span class="sig-paren">(</span><em>self</em>, <em>matrix4</em><span class="sig-paren">)</span> &#x2192; hou.Matrix4<a class="headerlink" href="#hou.Matrix4.preMult" title="Permalink to this definition"></a></dt>
<dd><p>Returns matrix4 * self. Note that __mul__ returns self * matrix4,
which is a different result because matrix multiplication is not
commutative.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Matrix4.setAt">
<code class="descname">setAt</code><span class="sig-paren">(</span><em>self</em>, <em>row</em>, <em>col</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Matrix4.setAt" title="Permalink to this definition"></a></dt>
<dd><p>Set the value of the matrix at the given row and column.</p>
<p>Raises IndexError if the row or column are not between 0 and 3,
inclusive. Note that negative indices will not index from the end.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Matrix4.setTo">
<code class="descname">setTo</code><span class="sig-paren">(</span><em>self</em>, <em>sequence</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Matrix4.setTo" title="Permalink to this definition"></a></dt>
<dd><p>Set this matrixs contents. The sequence may contain either 16
floats or 4 sequences, each with 4 floats.</p>
<p>See hou.Matrix4.__init__ for examples of suitable parameter values.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Matrix4.setToIdentity">
<code class="descname">setToIdentity</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Matrix4.setToIdentity" title="Permalink to this definition"></a></dt>
<dd><p>Set this matrix to the multiplicative identity, having 1s in the
diagonal.</p>
<p>The matrix will contain the values [[1, 0, 0, 0], [0, 1, 0, 0], [0,
0, 1, 0], [0, 0, 0, 1]]. Note that you can construct a new matrix
with these values using hou.hmath.identityTransform or
hou.Matrix4(1).</p>
</dd></dl>

<dl class="method">
<dt id="hou.Matrix4.setToZero">
<code class="descname">setToZero</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Matrix4.setToZero" title="Permalink to this definition"></a></dt>
<dd><p>Set this matrix to contain all zeros.</p>
<p>Note that you can construct a new matrix with all zeros with
hou.Matrix4().</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.Matrix4.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.Matrix4.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

<dl class="method">
<dt id="hou.Matrix4.transposed">
<code class="descname">transposed</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Matrix4<a class="headerlink" href="#hou.Matrix4.transposed" title="Permalink to this definition"></a></dt>
<dd><p>Return the transpose of this matrix. The result is such that
self.at(i, j) == self.transposed().at(j, i) for 0 &lt;= i,j &lt;= 3.</p>
<p>See Wikipedias transpose page for more information.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.MenuParmTemplate">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">MenuParmTemplate</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.MenuParmTemplate" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.ParmTemplate" title="hou.ParmTemplate"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.ParmTemplate</span></code></a></p>
<p>Describes a menu parameter containing evaluating to integer values. Note
that StringParmTemplates may also have menus.</p>
<p>REPLACES</p>
<blockquote>
<div><ul class="simple">
<li>opmenu</li>
</ul>
</div></blockquote>
<dl class="method">
<dt id="hou.MenuParmTemplate.defaultExpression">
<code class="descname">defaultExpression</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; string<a class="headerlink" href="#hou.MenuParmTemplate.defaultExpression" title="Permalink to this definition"></a></dt>
<dd><p>Return the expression, which when evaluated, returns the index of
the default menu item.</p>
<p>The default expression takes precendence over the default value. If
the default expression is not set (i.e. an empty string), then the
default value is used instead.</p>
<p>Note that the default expression language is needed to interpret the
meaning of the default expression.</p>
</dd></dl>

<dl class="method">
<dt id="hou.MenuParmTemplate.defaultExpressionLanguage">
<code class="descname">defaultExpressionLanguage</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.scriptLanguage<a class="headerlink" href="#hou.MenuParmTemplate.defaultExpressionLanguage" title="Permalink to this definition"></a></dt>
<dd><p>Return the default expression language.</p>
<p>The default expression language only applies if the default
expression is set. If the default expression is not set, then the
expression language is set to hou.scriptLanguage.Hscript.</p>
</dd></dl>

<dl class="method">
<dt id="hou.MenuParmTemplate.defaultValue">
<code class="descname">defaultValue</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.MenuParmTemplate.defaultValue" title="Permalink to this definition"></a></dt>
<dd><p>Return the index of the default menu item.</p>
<p>See also the defaultValueAsString method.</p>
</dd></dl>

<dl class="method">
<dt id="hou.MenuParmTemplate.defaultValueAsString">
<code class="descname">defaultValueAsString</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.MenuParmTemplate.defaultValueAsString" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.MenuParmTemplate.iconNames">
<code class="descname">iconNames</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of str<a class="headerlink" href="#hou.MenuParmTemplate.iconNames" title="Permalink to this definition"></a></dt>
<dd><p>Return the tuple of icons corresponding to the menu items. If there
are no icons, returns a tuple of empty strings.</p>
</dd></dl>

<dl class="method">
<dt id="hou.MenuParmTemplate.itemGeneratorScript">
<code class="descname">itemGeneratorScript</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.MenuParmTemplate.itemGeneratorScript" title="Permalink to this definition"></a></dt>
<dd><p>itemGeneratorScriptLanguage(self) -&gt; hou.scriptLanguage enum value</p>
<blockquote>
<div>Return the programming language for the script that generates menu
items.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.MenuParmTemplate.itemGeneratorScriptLanguage">
<code class="descname">itemGeneratorScriptLanguage</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.MenuParmTemplate.itemGeneratorScriptLanguage" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.MenuParmTemplate.menuItems">
<code class="descname">menuItems</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of str<a class="headerlink" href="#hou.MenuParmTemplate.menuItems" title="Permalink to this definition"></a></dt>
<dd><p>Return the tuple of internal menu names.</p>
<p>These internal menu names are not displayed in the UI, but they can
be passed to hou.Parm.set and will be returned by
hou.Parm.evalAsString for menu parameters.</p>
</dd></dl>

<dl class="method">
<dt id="hou.MenuParmTemplate.menuLabels">
<code class="descname">menuLabels</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of str<a class="headerlink" href="#hou.MenuParmTemplate.menuLabels" title="Permalink to this definition"></a></dt>
<dd><p>Return the tuple of menu labels displayed in the UI.</p>
</dd></dl>

<dl class="method">
<dt id="hou.MenuParmTemplate.menuType">
<code class="descname">menuType</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.menuType enum value<a class="headerlink" href="#hou.MenuParmTemplate.menuType" title="Permalink to this definition"></a></dt>
<dd><p>Return the type of menu. Note that some menu types only apply to
string parameters with menus, so the meaningful menu types for
MenuParmTemplates are hou.menuType.Normal (for standard menus) and
hou.menuType.Mini for menus that only display a dropdown arrow. See
hou.menuType for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.MenuParmTemplate.menuUseToken">
<code class="descname">menuUseToken</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.MenuParmTemplate.menuUseToken" title="Permalink to this definition"></a></dt>
<dd><p>Return whether the parameter is set to the token value instead of
the index.</p>
<p>See also the setMenuUseToken method.</p>
</dd></dl>

<dl class="method">
<dt id="hou.MenuParmTemplate.setDefaultExpression">
<code class="descname">setDefaultExpression</code><span class="sig-paren">(</span><em>self</em>, <em>default_expression</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.MenuParmTemplate.setDefaultExpression" title="Permalink to this definition"></a></dt>
<dd><p>Set the default expression, which when evaluated, returns the index
of the default menu item.</p>
<p>If default_expression is the empty string, then the default
expression is unset.</p>
</dd></dl>

<dl class="method">
<dt id="hou.MenuParmTemplate.setDefaultExpressionLanguage">
<code class="descname">setDefaultExpressionLanguage</code><span class="sig-paren">(</span><em>self</em>, <em>default_expression_language</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.MenuParmTemplate.setDefaultExpressionLanguage" title="Permalink to this definition"></a></dt>
<dd><p>Set the default expression language.</p>
<p>See the defaultExpressionLanguage method for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.MenuParmTemplate.setDefaultValue">
<code class="descname">setDefaultValue</code><span class="sig-paren">(</span><em>self</em>, <em>default_value</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.MenuParmTemplate.setDefaultValue" title="Permalink to this definition"></a></dt>
<dd><p>Set the index of the default menu item.</p>
<p>Note that if this index is out of range, it will be adjusted.</p>
</dd></dl>

<dl class="method">
<dt id="hou.MenuParmTemplate.setIconNames">
<code class="descname">setIconNames</code><span class="sig-paren">(</span><em>self</em>, <em>icon_names</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.MenuParmTemplate.setIconNames" title="Permalink to this definition"></a></dt>
<dd><p>Set the icon names to the given sequence of strings.</p>
</dd></dl>

<dl class="method">
<dt id="hou.MenuParmTemplate.setItemGeneratorScript">
<code class="descname">setItemGeneratorScript</code><span class="sig-paren">(</span><em>self</em>, <em>item_generator_script</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.MenuParmTemplate.setItemGeneratorScript" title="Permalink to this definition"></a></dt>
<dd><p>Set the script used to generate menu items.</p>
<p>See the itemGeneratorScript method for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.MenuParmTemplate.setItemGeneratorScriptLanguage">
<code class="descname">setItemGeneratorScriptLanguage</code><span class="sig-paren">(</span><em>self</em>, <em>language</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.MenuParmTemplate.setItemGeneratorScriptLanguage" title="Permalink to this definition"></a></dt>
<dd><p>Set the script language used to generate menu items to a
hou.scriptLanguage enum value.</p>
<p>See the itemGeneratorScriptLanguage method for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.MenuParmTemplate.setMenuItems">
<code class="descname">setMenuItems</code><span class="sig-paren">(</span><em>self</em>, <em>menu_items</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.MenuParmTemplate.setMenuItems" title="Permalink to this definition"></a></dt>
<dd><p>Set the internal menu names to the given sequence of strings.</p>
<p>See the menuItems method for more information.</p>
<p>If the new number of menu items is less than the old number, the
menu labels will be shortened and the default value will be modified
if it is out of range.</p>
</dd></dl>

<dl class="method">
<dt id="hou.MenuParmTemplate.setMenuLabels">
<code class="descname">setMenuLabels</code><span class="sig-paren">(</span><em>self</em>, <em>menu_labels</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.MenuParmTemplate.setMenuLabels" title="Permalink to this definition"></a></dt>
<dd><p>Set the menu labels displayed in the UI to the given sequence of
strings.</p>
<p>If the number of menu labels is less than the number of menu items,
Houdini uses the internal menu item names for the missing labels. If
the number of labels is more than the number of menu items, Houdini
discards the extra labels.</p>
<p>If you want to change both the menu items and menu labels, be sure
to change the menu items first.</p>
</dd></dl>

<dl class="method">
<dt id="hou.MenuParmTemplate.setMenuType">
<code class="descname">setMenuType</code><span class="sig-paren">(</span><em>self</em>, <em>menu_type</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.MenuParmTemplate.setMenuType" title="Permalink to this definition"></a></dt>
<dd><p>Set the type of menu to a hou.menuType enum value.</p>
<p>See the menuType method for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.MenuParmTemplate.setMenuUseToken">
<code class="descname">setMenuUseToken</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.MenuParmTemplate.setMenuUseToken" title="Permalink to this definition"></a></dt>
<dd><p>Set whether the parameter is set to the token value instead of the
index.</p>
<p>See also the menuUseToken method.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.MenuParmTemplate.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.MenuParmTemplate.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.NameConflict">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">NameConflict</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NameConflict" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.Error" title="hou.Error"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.Error</span></code></a></p>
<p>Exception raised when a name conflict is detected during an operation.</p>
<dl class="method">
<dt id="hou.NameConflict.description">
<code class="descname">description</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.NameConflict.description" title="Permalink to this definition"></a></dt>
<dd><p>Return a description of the class of exception. The description is
not related to the exception instance.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NameConflict.exceptionTypeName">
<code class="descname">exceptionTypeName</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.NameConflict.exceptionTypeName" title="Permalink to this definition"></a></dt>
<dd><p>Return the name of the exception type. Instances of different
subclasses of hou.Error will return different names. Instances of
the base class will return Error.</p>
<p>You can also use str(e.__class__) to get the name of the subclass.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.NameConflict.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.NameConflict.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.NetworkAnimValue">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">NetworkAnimValue</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NetworkAnimValue" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A value to adjust the appearance of a network editor without changing
the underlying node data.</p>
<p>The hou.NetworkEditor pane allows network items to be moved or resized
by user interactions without actually changing the node positions or
sizes. This is accomplished by associating each NetworkAnimValue with a
network item through the hou.NetworkEditor.setAdjustments method.
NetworkAnimValues can either represent a single value, or they can
represent an animation from one value to another. The actual animation
is displayed automatically by the network editor.</p>
<p>For example, to following code would animate the position of a couple of
nodes:</p>
<p>&gt; &gt;&gt;&gt; editor = hou.ui.paneTabOfType(hou.paneTabType.NetworkEditor)
&gt; &gt;&gt;&gt; n1 = hou.node(/obj/geo1)
&gt; &gt;&gt;&gt; pos1 = n1.position()
&gt; &gt;&gt;&gt; newpos1 = pos1 + hou.Vector2(5, 5)
&gt; &gt;&gt;&gt; anim1 = hou.NetworkAnimValue(1.0, pos1, newpos1)
&gt; &gt;&gt;&gt; n2 = hou.node(/obj/geo2)
&gt; &gt;&gt;&gt; pos2 = n2.position()
&gt; &gt;&gt;&gt; newpos2 = pos2 + hou.Vector2(5, 5)
&gt; &gt;&gt;&gt; anim2 = hou.NetworkAnimValue(1.0, pos2, newpos2)
&gt; &gt;&gt;&gt; editor.setAdjustments([n1, n2], [anim1, anim2], auto_remove=True)
&gt; &gt;&gt;&gt; n1.setPosition(newpos1)
&gt; &gt;&gt;&gt; n2.setPosition(newpos2)</p>
<p>Note that the new positions are set on the nodes immediately. But the
animation starts them at their original positions, and makes it look
like they move slowly to their new positions. Also note that the
auto_remove parameter in the call to setAdjustments() has been set to
True. This is because we are using the adjustments only to animate the
nodes to their new positions, which have already been set. Once the
animation is complete, the adjustments can be thrown away. Without this
parameter, the adjustments would remain on the network editor until the
next call the setAdjustments.</p>
<dl class="attribute">
<dt id="hou.NetworkAnimValue.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.NetworkAnimValue.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.NetworkBox">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">NetworkBox</code><a class="headerlink" href="#hou.NetworkBox" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.NetworkMovableItem" title="hou.NetworkMovableItem"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.NetworkMovableItem</span></code></a></p>
<p>Represents a network box.</p>
<p>To create a network box, use the hou.Node.createNetworkBox method on the
node inside which you want to create the box. To get an existing network
box, use the hou.Node.findNetworkBox method on the node containing the
network box. To get a list of all network boxes in a network, use the
hou.Node.networkBoxes method on the containing node.</p>
<p>REPLACES</p>
<blockquote>
<div><ul class="simple">
<li>nbcolor</li>
<li>nbget</li>
<li>nblocate</li>
<li>nbls</li>
<li>nblsop</li>
<li>nbname</li>
<li>nbop</li>
<li>nbrm</li>
<li>nbset</li>
<li>nbsize</li>
<li>opscript</li>
</ul>
</div></blockquote>
<dl class="method">
<dt id="hou.NetworkBox.addItem">
<code class="descname">addItem</code><span class="sig-paren">(</span><em>self</em>, <em>item</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NetworkBox.addItem" title="Permalink to this definition"></a></dt>
<dd><p>Adds a hou.NetworkMovableItem of any kind to the network box.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkBox.addNetworkBox">
<code class="descname">addNetworkBox</code><span class="sig-paren">(</span><em>self</em>, <em>netbox</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NetworkBox.addNetworkBox" title="Permalink to this definition"></a></dt>
<dd><p>Adds a hou.NetworkDot to the network box. This method is deprecated.
Use hou.NetworkBox.addItem instead.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkBox.addNode">
<code class="descname">addNode</code><span class="sig-paren">(</span><em>self</em>, <em>node</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NetworkBox.addNode" title="Permalink to this definition"></a></dt>
<dd><p>Adds a hou.Node to the network box. This method is deprecated. Use
hou.NetworkBox.addItem instead.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkBox.addStickyNote">
<code class="descname">addStickyNote</code><span class="sig-paren">(</span><em>self</em>, <em>stickynote</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NetworkBox.addStickyNote" title="Permalink to this definition"></a></dt>
<dd><p>Adds a hou.StickyNote to the network box. This method is deprecated.
Use hou.NetworkBox.addItem instead.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkBox.addSubnetIndirectInput">
<code class="descname">addSubnetIndirectInput</code><span class="sig-paren">(</span><em>self</em>, <em>indirect</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NetworkBox.addSubnetIndirectInput" title="Permalink to this definition"></a></dt>
<dd><p>Adds a hou.SubnetIndirectInput to the network box. This method is
deprecated. Use hou.NetworkBox.addItem instead.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkBox.asCode">
<code class="descname">asCode</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NetworkBox.asCode" title="Permalink to this definition"></a></dt>
<dd><p>asCode(self, brief=False, recurse=False, save_box_contents=False,
save_channels_only=False, save_creation_commands=False,
save_keys_in_frames=False, save_parm_values_only=False,
save_spare_parms=False, function_name=None) -&gt; string</p>
<blockquote>
<div><p>Prints the Python code necessary to recreate a network box.</p>
<p>See hou.Node.asCode for information on the keyword arguments.</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkBox.autoFit">
<code class="descname">autoFit</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.NetworkBox.autoFit" title="Permalink to this definition"></a></dt>
<dd><p>Returns the value of the auto fit flag on this network box.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkBox.comment">
<code class="descname">comment</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.NetworkBox.comment" title="Permalink to this definition"></a></dt>
<dd><p>Returns the comment for this network box.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkBox.destroy">
<code class="descname">destroy</code><span class="sig-paren">(</span><em>self</em>, <em>destroy_contents=False</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NetworkBox.destroy" title="Permalink to this definition"></a></dt>
<dd><p>Remove and delete the network box, optionally deleting the nodes it
contains.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkBox.fitAroundContents">
<code class="descname">fitAroundContents</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NetworkBox.fitAroundContents" title="Permalink to this definition"></a></dt>
<dd><p>Resizes the network box to fit its contents.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkBox.isMinimized">
<code class="descname">isMinimized</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.NetworkBox.isMinimized" title="Permalink to this definition"></a></dt>
<dd><p>Returns whether the network box is minimized.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkBox.items">
<code class="descname">items</code><span class="sig-paren">(</span><em>self</em>, <em>recurse=True</em><span class="sig-paren">)</span> &#x2192; tuple of hou.NetworkMovableItem<a class="headerlink" href="#hou.NetworkBox.items" title="Permalink to this definition"></a></dt>
<dd><p>Returns the items of any type inside the network box.</p>
<dl class="docutils">
<dt>recurse</dt>
<dd>If True, recurses down into nested network boxes.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkBox.minimizedSize">
<code class="descname">minimizedSize</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Vector2<a class="headerlink" href="#hou.NetworkBox.minimizedSize" title="Permalink to this definition"></a></dt>
<dd><p>Return the size of this items tile in the network editor graph if
it is minimized. Returned as a Vector2.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkBox.networkBoxes">
<code class="descname">networkBoxes</code><span class="sig-paren">(</span><em>self</em>, <em>recurse=True</em><span class="sig-paren">)</span> &#x2192; tuple of hou.NetworkBox<a class="headerlink" href="#hou.NetworkBox.networkBoxes" title="Permalink to this definition"></a></dt>
<dd><p>Returns the network boxes inside the network box.</p>
<dl class="docutils">
<dt>recurse</dt>
<dd>If True, recurses down into nested network boxes.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkBox.nodes">
<code class="descname">nodes</code><span class="sig-paren">(</span><em>self</em>, <em>recurse=True</em><span class="sig-paren">)</span> &#x2192; tuple of hou.Node<a class="headerlink" href="#hou.NetworkBox.nodes" title="Permalink to this definition"></a></dt>
<dd><p>Returns the nodes inside the network box.</p>
<dl class="docutils">
<dt>recurse</dt>
<dd>If True, recurses down into nested network boxes.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkBox.removeAllItems">
<code class="descname">removeAllItems</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NetworkBox.removeAllItems" title="Permalink to this definition"></a></dt>
<dd><p>Removes all items from the network box.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkBox.removeAllNodes">
<code class="descname">removeAllNodes</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NetworkBox.removeAllNodes" title="Permalink to this definition"></a></dt>
<dd><p>Removes all nodes from the network box. This method if deprecated.
Use hou.NetworkBox.removaAllItems or hou.NetworkBox.removeItems
instead.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkBox.removeItem">
<code class="descname">removeItem</code><span class="sig-paren">(</span><em>self</em>, <em>item</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NetworkBox.removeItem" title="Permalink to this definition"></a></dt>
<dd><p>Removes the given item from the network box.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkBox.removeNetworkBox">
<code class="descname">removeNetworkBox</code><span class="sig-paren">(</span><em>self</em>, <em>netbox</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NetworkBox.removeNetworkBox" title="Permalink to this definition"></a></dt>
<dd><p>Removes the given network box from the network box. This method if
deprecated. Use hou.NetworkBox.removaItem instead.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkBox.removeNode">
<code class="descname">removeNode</code><span class="sig-paren">(</span><em>self</em>, <em>node</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NetworkBox.removeNode" title="Permalink to this definition"></a></dt>
<dd><p>Removes the given node from the network box. This method if
deprecated. Use hou.NetworkBox.removaItem instead.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkBox.removeStickyNote">
<code class="descname">removeStickyNote</code><span class="sig-paren">(</span><em>self</em>, <em>stickynote</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NetworkBox.removeStickyNote" title="Permalink to this definition"></a></dt>
<dd><p>Removes the given sticky note from the network box. This method if
deprecated. Use hou.NetworkBox.removaItem instead.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkBox.removeSubnetIndirectInput">
<code class="descname">removeSubnetIndirectInput</code><span class="sig-paren">(</span><em>self</em>, <em>indirect</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NetworkBox.removeSubnetIndirectInput" title="Permalink to this definition"></a></dt>
<dd><p>Removes the given indirect input from the network box. This method
if deprecated. Use hou.NetworkBox.removaItem instead.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkBox.resize">
<code class="descname">resize</code><span class="sig-paren">(</span><em>self</em>, <em>vector2</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NetworkBox.resize" title="Permalink to this definition"></a></dt>
<dd><p>Resizes a network box by the increments in the given hou.Vector2.
Use setSize() to set the boxs absolute size.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkBox.restoredSize">
<code class="descname">restoredSize</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Vector2<a class="headerlink" href="#hou.NetworkBox.restoredSize" title="Permalink to this definition"></a></dt>
<dd><p>Return the size of this items tile in the network editor graph if
it is not minimized. Returned as a Vector2.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkBox.setAutoFit">
<code class="descname">setAutoFit</code><span class="sig-paren">(</span><em>self</em>, <em>auto_fit</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NetworkBox.setAutoFit" title="Permalink to this definition"></a></dt>
<dd><p>Set the value of the auto fit flag on this network box. The default
value is True which causes the network box to resize itself when
nodes that belong to the network box are moved outside the bounds of
the box. Setting this values to False prevents this automatic
resizing. The Network View will draw the network box around its
contents in any case. The default setting of True is primarily
useful for backward compatibility with the old network editor which
relies on this automatic resizing to draw the network box properly.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkBox.setBounds">
<code class="descname">setBounds</code><span class="sig-paren">(</span><em>self</em>, <em>bounds</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NetworkBox.setBounds" title="Permalink to this definition"></a></dt>
<dd><p>Sets the size and position of this sticky note to the given
hou.BoundingRect bounds argument. Equivalent to calling setSize then
setPosition.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkBox.setComment">
<code class="descname">setComment</code><span class="sig-paren">(</span><em>self</em>, <em>comment</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NetworkBox.setComment" title="Permalink to this definition"></a></dt>
<dd><p>Set the comment string for this network box. This comment is visible
in the network editor and can be used to describe the purpose of the
box.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkBox.setMinimized">
<code class="descname">setMinimized</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NetworkBox.setMinimized" title="Permalink to this definition"></a></dt>
<dd><p>Minimizes or restores the network box.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkBox.setSize">
<code class="descname">setSize</code><span class="sig-paren">(</span><em>self</em>, <em>size</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NetworkBox.setSize" title="Permalink to this definition"></a></dt>
<dd><p>Sets the size of this network box to the given hou.Vector2 size
parameter. Use resize() to set the boxs size relative to its
current size.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkBox.stickyNotes">
<code class="descname">stickyNotes</code><span class="sig-paren">(</span><em>self</em>, <em>recurse=True</em><span class="sig-paren">)</span> &#x2192; tuple of hou.StickyNote<a class="headerlink" href="#hou.NetworkBox.stickyNotes" title="Permalink to this definition"></a></dt>
<dd><p>Returns the sticky notes inside the network box.</p>
<dl class="docutils">
<dt>recurse</dt>
<dd>If True, recurses down into nested network boxes.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkBox.subnetIndirectInputs">
<code class="descname">subnetIndirectInputs</code><span class="sig-paren">(</span><em>self</em>, <em>recurse=True</em><span class="sig-paren">)</span> &#x2192; tuple of<a class="headerlink" href="#hou.NetworkBox.subnetIndirectInputs" title="Permalink to this definition"></a></dt>
<dd><p>hou.SubnetIndirectInput</p>
<p>Returns the subnet indirect inputs inside the network box.</p>
<dl class="docutils">
<dt>recurse</dt>
<dd>If True, recurses down into nested network boxes.</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="hou.NetworkBox.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.NetworkBox.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.NetworkDot">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">NetworkDot</code><a class="headerlink" href="#hou.NetworkDot" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.IndirectInput" title="hou.IndirectInput"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.IndirectInput</span></code></a></p>
<p>A small dot in a network that allows wires to be routed along specific
paths without affecting the data passing through them.</p>
<p>Network dots are allowed to have a single input, but may have many
outputs. They can be moved around to force a wire connecting two nodes
to follow a specific path. They can also be used as scaffolding for a
set of nodes that you want to be able to quickly add or remove in a
larger network.</p>
<p>New dots are created by calling hou.Node.createNetworkDot on the node
that will contain the dot. A list of all existing dots in a network can
be generated by calling hou.Node.networkDots.</p>
<dl class="method">
<dt id="hou.NetworkDot.destroy">
<code class="descname">destroy</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NetworkDot.destroy" title="Permalink to this definition"></a></dt>
<dd><p>Delete this dot. Connections in and out of the dot are automatically
re-established such that the behavior of the network will be
unchanged by the removal of this dot.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkDot.inputConnections">
<code class="descname">inputConnections</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.NodeConnection<a class="headerlink" href="#hou.NetworkDot.inputConnections" title="Permalink to this definition"></a></dt>
<dd><p>Returns a tuple of hou.NodeConnection objects for the connection
coming into this dot. The tuple will have a length of one if
anything is connected to the input of this dot. Returns an empty
tuple if nothing is connected.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkDot.insertInput">
<code class="descname">insertInput</code><span class="sig-paren">(</span><em>self</em>, <em>input_index</em>, <em>item_to_become_input</em>, <em>output_index=0</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NetworkDot.insertInput" title="Permalink to this definition"></a></dt>
<dd><p>Connects a network item to the input of this dot, exactly like the
two parameter form of setInput. But this method name and signature
matches the signature of hou.Node.insertInput, which allows code to
run on either a network dot or a node. The value of the input_index
is ignored.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkDot.isPinned">
<code class="descname">isPinned</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.NetworkDot.isPinned" title="Permalink to this definition"></a></dt>
<dd><p>Returns the pinned state of this dot. See hou.NetworkDot.setPinned
for a more detailed discussion of the meaning of a pinned dot.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkDot.setInput">
<code class="descname">setInput</code><span class="sig-paren">(</span><em>self</em>, <em>input_index</em>, <em>item_to_become_input</em>, <em>output_index=0</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NetworkDot.setInput" title="Permalink to this definition"></a></dt>
<dd><p>Connects a network item to the input of this dot, exactly like the
two parameter form of this function. But this second signature
matches the signature of hou.Node.setInput, which allows code to run
on either a network dot or a node. The value of the input_index is
ignored.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkDot.setPinned">
<code class="descname">setPinned</code><span class="sig-paren">(</span><em>self</em>, <em>pinned</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NetworkDot.setPinned" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Sets the boolean pinned state of this dot. Pinned dots are not
functionally different from unpinned dots, but are treated
differently by the network editor. A pinned dot remains even if its
input and output connections are removed. An unpinned dot will be
deleted automatically by the network editor if its input or last
output is cut.</p>
<p>The following code is a greatly simplified version of the code for
automatically deleting unconnected dots, which will delete any dots
that are not pinned and that dont have an input connection:</p>
</div></blockquote>
<p>&gt; &gt;&gt;&gt; net = hou.node(/obj)
&gt; &gt;&gt;&gt; net.createNetworkDot().setPinned(False)
&gt; &gt;&gt;&gt; net.createNetworkDot().setPinned(True)
&gt; &gt;&gt;&gt; net.networkDots()
&gt; (&lt;hou.NetworkDot dot1 in /obj&gt;, &lt;hou.NetworkDot dot2 in /obj&gt;)
&gt; &gt;&gt;&gt; for dot in net.networkDots():
&gt;    if not dot.isPinned():
&gt;      if dot.inputItem() is None:
&gt;        dot.destroy()
&gt; 
&gt; &gt;&gt;&gt; net.networkDots()
&gt; (&lt;hou.NetworkDot dot2 in /obj&gt;,)</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.NetworkDot.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.NetworkDot.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.NetworkEditor">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">NetworkEditor</code><a class="headerlink" href="#hou.NetworkEditor" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.PathBasedPaneTab" title="hou.PathBasedPaneTab"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.PathBasedPaneTab</span></code></a></p>
<p>Represents a Network Editor panetab.</p>
<dl class="method">
<dt id="hou.NetworkEditor.allVisibleRects">
<code class="descname">allVisibleRects</code><span class="sig-paren">(</span><em>self</em>, <em>ignore_items</em><span class="sig-paren">)</span> &#x2192; tuple of (hou.NetworkMovableItem,<a class="headerlink" href="#hou.NetworkEditor.allVisibleRects" title="Permalink to this definition"></a></dt>
<dd><p>hou.BoundingRect)</p>
<p>This method is equivalent to calling itemRect() for every network
item that is currently visible in the network editor. Getting these
results in a single method call is significantly faster, and
eliminates the need to test each item for visibility. This method is
used for finding items to snap against when moving nodes. The
ignore_items parameter is a tuple of hou.NetworkMovableItem objects
that should not be returned in the result tuple.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkEditor.autoAddToNetbox">
<code class="descname">autoAddToNetbox</code><span class="sig-paren">(</span><em>self</em>, <em>node</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NetworkEditor.autoAddToNetbox" title="Permalink to this definition"></a></dt>
<dd><p>This method is deprecated in the new network editor and does
nothing.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkEditor.autoPlaceNodes">
<code class="descname">autoPlaceNodes</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.NetworkEditor.autoPlaceNodes" title="Permalink to this definition"></a></dt>
<dd><p>This method is deprecated in the new network editor and always
returns False.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkEditor.autoScrollNodes">
<code class="descname">autoScrollNodes</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.NetworkEditor.autoScrollNodes" title="Permalink to this definition"></a></dt>
<dd><p>This method is deprecated in the new network editor and always
returns False.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkEditor.backgroundImages">
<code class="descname">backgroundImages</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.NetworkImage<a class="headerlink" href="#hou.NetworkEditor.backgroundImages" title="Permalink to this definition"></a></dt>
<dd><p>Return the descriptors for the current set of background images
being displayed in the network editor. This will be the tuple passed
into the last call to setBackgroundImages.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkEditor.badges">
<code class="descname">badges</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of tuple of str<a class="headerlink" href="#hou.NetworkEditor.badges" title="Permalink to this definition"></a></dt>
<dd><p>Return descriptions of the optional node badges that can be shown in
the network editor. Each tuple contained in the returned value
contains three strings describing the badge. The first is the
preference value that controls whether the badge is hidden, or
appears as a small or large icon. The second string is a description
of the badge. The third string is the name of the badge icon. These
values can be used to present an interface for configuring the
badges.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkEditor.closeTextEditor">
<code class="descname">closeTextEditor</code><span class="sig-paren">(</span><em>self</em>, <em>id</em>, <em>apply_changes = True</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NetworkEditor.closeTextEditor" title="Permalink to this definition"></a></dt>
<dd><p>Immediately closes and commits any changes made to input fields
opened with the openNameEditor(), openCommentEditor(), or
openNoteEditor() methods. The id parameter is the value returned by
the method that opened the editor. Set the apply_changes parameter
to False if the changes made to the input field should not be
applied.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkEditor.cursorMap">
<code class="descname">cursorMap</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; dict of (str, int) to str<a class="headerlink" href="#hou.NetworkEditor.cursorMap" title="Permalink to this definition"></a></dt>
<dd><p>Return the current mouse cursor configuration. This will just be the
dictionary passed into the last call to setCursorMap.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkEditor.cursorPosition">
<code class="descname">cursorPosition</code><span class="sig-paren">(</span><em>self</em>, <em>confine_to_view=True</em><span class="sig-paren">)</span> &#x2192; hou.Vector2<a class="headerlink" href="#hou.NetworkEditor.cursorPosition" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Return the current mouse cursor position expressed in network view
coordinates. If confine_to_view is True, the returned value will be
clipped to the area of the network currently visible in the network
editor.</p>
<p>Here is an example of moving a node underneath the mouse cursor:</p>
</div></blockquote>
<p>&gt; # Get the network editor.
&gt; net_editor = hou.ui.paneTabOfType(hou.paneTabType.NetworkEditor)
&gt; 
&gt; # Get the node.
&gt; node = hou.node(/obj/myNode)
&gt; 
&gt; # Set the nodes new position.
&gt; node.setPosition(net_editor.cursorPosition())</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkEditor.decoratedItem">
<code class="descname">decoratedItem</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.NetworkItem<a class="headerlink" href="#hou.NetworkEditor.decoratedItem" title="Permalink to this definition"></a></dt>
<dd><p>Return the currently set decorated item. This is just the item value
passed into the last call to setDecoratedItem.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkEditor.decorationInteractive">
<code class="descname">decorationInteractive</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.NetworkEditor.decorationInteractive" title="Permalink to this definition"></a></dt>
<dd><p>Return whether the currently decorated item is interactive. This is
just the interactive value passed into the last call to
setDecoratedItem.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkEditor.defaultCursor">
<code class="descname">defaultCursor</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.NetworkEditor.defaultCursor" title="Permalink to this definition"></a></dt>
<dd><p>Return the default mouse cursor set by the last call to
setDefaultCursor().</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkEditor.dropTargetItem">
<code class="descname">dropTargetItem</code><span class="sig-paren">(</span><em>self) -&gt; (hou.NetworkItem</em>, <em>str</em>, <em>int</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NetworkEditor.dropTargetItem" title="Permalink to this definition"></a></dt>
<dd><p>Return the currently set drop target item information. These are
just the values passed into the last call to setDropTargetItem.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkEditor.eventContextData">
<code class="descname">eventContextData</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.NetworkEditor.eventContextData" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.NetworkEditor.flashMessage">
<code class="descname">flashMessage</code><span class="sig-paren">(</span><em>self</em>, <em>image</em>, <em>message</em>, <em>duration</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NetworkEditor.flashMessage" title="Permalink to this definition"></a></dt>
<dd><p>Causes a message to appear briefly in the upper left corner of the
network editor, then fade away. The image parameter specifies an
icon or image file that should be displayed along with the text
specified in the message parameter. Either of these parameters may
be None if only an image or only text is desired. The duration
parameter specifies the time in seconds before the message should
fade away.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkEditor.footprints">
<code class="descname">footprints</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.NetworkFootprint<a class="headerlink" href="#hou.NetworkEditor.footprints" title="Permalink to this definition"></a></dt>
<dd><p>Return the current footprint configuration as a tuple of
hou.NetworkFootprint objects. These are just the values passed into
the last call to setFootprints.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkEditor.frameSelection">
<code class="descname">frameSelection</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NetworkEditor.frameSelection" title="Permalink to this definition"></a></dt>
<dd><p>Centers the nodes within the network editor to show the current
selection and zooms to its extents. This method wraps a call to
hou.NetworkEditor.setVisibleBounds.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkEditor.getPref">
<code class="descname">getPref</code><span class="sig-paren">(</span><em>self</em>, <em>pref</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.NetworkEditor.getPref" title="Permalink to this definition"></a></dt>
<dd><p>Return the value of the preference named pref. This preference may
be a global or local preference. The returned value is always a
string which can be interpreted as a number or other data structure
as appropriate for the specific preference.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkEditor.getPrefs">
<code class="descname">getPrefs</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; dict of str to str<a class="headerlink" href="#hou.NetworkEditor.getPrefs" title="Permalink to this definition"></a></dt>
<dd><p>Return all global and local preferences for this network editor as a
python dictionary mapping preference name strings to value strings.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkEditor.handleCurrentKeyboardEvent">
<code class="descname">handleCurrentKeyboardEvent</code><span class="sig-paren">(</span><em>self</em>, <em>resend=False</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NetworkEditor.handleCurrentKeyboardEvent" title="Permalink to this definition"></a></dt>
<dd><p>Requests that the network editor handle the current keyboard event.
This method only makes sense when handling a keyboard event.</p>
<p>If the resend parameter is set to True, the keyboard event is sent
to the network editors python handling code a second time rather
than the network editor handling the keyboard event itself. This is
useful if the network editor is in a state or mode that does not
know how to handle a key, but which the state recognizes as one that
should exit the current state, and possibly trigger some other
python event handling code. This parameter is used in the state for
selecting the position of a new node if the Tab key is pressed
(which exits the positions selection state, and triggers a new Tab
menu instead).</p>
<p>If this method is not called when handling a keyboard event, the
network editor assumes that the python event handling code has
handled the keyboard event.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkEditor.homeToSelection">
<code class="descname">homeToSelection</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NetworkEditor.homeToSelection" title="Permalink to this definition"></a></dt>
<dd><p>Centers the nodes within the network editor to show the current
selection. This method wraps a call to
hou.NetworkEditor.setVisibleBounds.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkEditor.insertIntoUnderlyingConnections">
<code class="descname">insertIntoUnderlyingConnections</code><span class="sig-paren">(</span><em>self</em>, <em>node</em>, <em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NetworkEditor.insertIntoUnderlyingConnections" title="Permalink to this definition"></a></dt>
<dd><p>This method is deprecated in the new network editor and does
nothing.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkEditor.isPosInside">
<code class="descname">isPosInside</code><span class="sig-paren">(</span><em>self</em>, <em>pos</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.NetworkEditor.isPosInside" title="Permalink to this definition"></a></dt>
<dd><p>Return True if the hou.Vector2 passed as the pos parameter is inside
the network view. The values in pos are mouse coordinates expressed
relative to the network editor pane.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkEditor.isShowingConnectors">
<code class="descname">isShowingConnectors</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.NetworkEditor.isShowingConnectors" title="Permalink to this definition"></a></dt>
<dd><p>Return True if the network editor zoom level is high enough that
input and output connectors are visible. This can be useful in
network editor event handlers that expect the user to click on a
connector. If the connectors are not visible, some alternative
interaction is required.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkEditor.isVolatileKeyDown">
<code class="descname">isVolatileKeyDown</code><span class="sig-paren">(</span><em>self</em>, <em>key</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.NetworkEditor.isVolatileKeyDown" title="Permalink to this definition"></a></dt>
<dd><p>Return True if the specified keyboard key is currently pressed. This
allows the current state of a volatile key to be tested without
seeing the keydown event triggered when the user pressed the key.
Calling this method with a key that has not been registered through
the setVolatileKeys method will always return False even if the key
is currently pressed. The key string is of the form returned by the
hou.ui.hotkeys method, which is a combination of the symbol on the
key, and any modifier keys involved, such as Ctrl+Shift+G.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkEditor.itemInputDir">
<code class="descname">itemInputDir</code><span class="sig-paren">(</span><em>self</em>, <em>item</em>, <em>input_index</em><span class="sig-paren">)</span> &#x2192; hou.Vector2<a class="headerlink" href="#hou.NetworkEditor.itemInputDir" title="Permalink to this definition"></a></dt>
<dd><p>Return a normalized vector indicating the direction at which the
wire connected to the specified input should emerge from its
connector. The item parameter may be a hou.Node or hou.NetworkDot.
The input_index specifies which input is of interest. This value
must be zero if the item is a network dot.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkEditor.itemInputPos">
<code class="descname">itemInputPos</code><span class="sig-paren">(</span><em>self</em>, <em>item</em>, <em>input_index</em>, <em>adjusted=True</em><span class="sig-paren">)</span> &#x2192; hou.Vector2<a class="headerlink" href="#hou.NetworkEditor.itemInputPos" title="Permalink to this definition"></a></dt>
<dd><p>Return the center point of the input connector of the hou.Node or
hou.NetworkDot specified by item. The input_index parameter
specifies the specific input of interest. For network dots, this
value must be zero. If the adjusted parameter is set to True, any
adjustments to this items size and position set in the most recent
call to setAdjustments() will be taken into account. If False, these
adjustments will be ignored.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkEditor.itemOutputDir">
<code class="descname">itemOutputDir</code><span class="sig-paren">(</span><em>self</em>, <em>item</em>, <em>output_index</em><span class="sig-paren">)</span> &#x2192; hou.Vector2<a class="headerlink" href="#hou.NetworkEditor.itemOutputDir" title="Permalink to this definition"></a></dt>
<dd><p>Return a normalized vector indicating the direction at which the
wire connected to the specified output should emerge from its
connector. The item parameter may be a hou.Node, hou.NetworkDot, or
hou.SubnetIndirectInput. The output_index specifies which output is
of interest. This value must be zero if the item is a network dot or
subnet indirect input.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkEditor.itemOutputPos">
<code class="descname">itemOutputPos</code><span class="sig-paren">(</span><em>self</em>, <em>item</em>, <em>output_index</em>, <em>adjusted=True</em><span class="sig-paren">)</span> &#x2192; hou.Vector2<a class="headerlink" href="#hou.NetworkEditor.itemOutputPos" title="Permalink to this definition"></a></dt>
<dd><p>Return the center point of the output connector of the hou.Node,
hou.NetworkDot, or hou.SubnetIndirectInput specified by item. The
output_index parameter specifies the specific output of interest.
For network dots and subnet indirect inputs, this value must be
zero. If the adjusted parameter is set to True, any adjustments to
this items size and position set in the most recent call to
setAdjustments() will be taken into account. If False, these
adjustments will be ignored.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkEditor.itemRect">
<code class="descname">itemRect</code><span class="sig-paren">(</span><em>self</em>, <em>item</em>, <em>adjusted=True</em><span class="sig-paren">)</span> &#x2192; hou.BoundingRect<a class="headerlink" href="#hou.NetworkEditor.itemRect" title="Permalink to this definition"></a></dt>
<dd><p>Return the bounding rectangle of the hou.NetworkMovableItem
specified by the item parameter. If the adjusted parameter is set to
True, any adjustments to this items size and position set in the
most recent call to setAdjustments() will be taken into account. If
False, these adjustments will be ignored. Note that for nodes, only
the node body is taken into account, not the node name, badges, or
other decorations.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkEditor.lengthFromScreen">
<code class="descname">lengthFromScreen</code><span class="sig-paren">(</span><em>self</em>, <em>len</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#hou.NetworkEditor.lengthFromScreen" title="Permalink to this definition"></a></dt>
<dd><p>Given a length value len, expressed in screen units (pixels), return
the equivalent length in network units. The result will depend on
the current zoom level of the network editor.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkEditor.lengthToScreen">
<code class="descname">lengthToScreen</code><span class="sig-paren">(</span><em>self</em>, <em>len</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#hou.NetworkEditor.lengthToScreen" title="Permalink to this definition"></a></dt>
<dd><p>Given a length value len, expressed in network units, return the
equivalent length in screen units (pixels). The result will depend
on the current zoom level of the network editor.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkEditor.listMode">
<code class="descname">listMode</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.NetworkEditor.listMode" title="Permalink to this definition"></a></dt>
<dd><p>Return True if the network editor is in list mode and False
otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkEditor.locatingEnabled">
<code class="descname">locatingEnabled</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.NetworkEditor.locatingEnabled" title="Permalink to this definition"></a></dt>
<dd><p>Return True if the network editor will highlight UI elementes under
the mouse, and allow clicking on those UI elements.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkEditor.modifyPositionForNode">
<code class="descname">modifyPositionForNode</code><span class="sig-paren">(</span><em>self</em>, <em>vector2</em>, <em>node</em><span class="sig-paren">)</span> &#x2192; Vector2<a class="headerlink" href="#hou.NetworkEditor.modifyPositionForNode" title="Permalink to this definition"></a></dt>
<dd><p>This method is deprecated in the new network editor, and simply
returns the position passed into the function.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkEditor.networkBoxPendingRemovals">
<code class="descname">networkBoxPendingRemovals</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.NetworkMovableItem<a class="headerlink" href="#hou.NetworkEditor.networkBoxPendingRemovals" title="Permalink to this definition"></a></dt>
<dd><p>Return the items currently pending remove from their network box.
These are just the values passed into the last call to
setNetworkBoxPendingRemovals.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkEditor.networkItemsInBox">
<code class="descname">networkItemsInBox</code><span class="sig-paren">(</span><em>self</em>, <em>pos1</em>, <em>pos2</em>, <em>for_drop=False</em>, <em>for_select=False</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NetworkEditor.networkItemsInBox" title="Permalink to this definition"></a></dt>
<dd><p>tuple of (hou.NetworkItem, str, int)</p>
<blockquote>
<div><p>Return any network items inside the bounding box defined by the
hou.Vector2 points pos1 and pos2. These points are specified in
screen space, which makes it easy to call this function given a
mouse position.</p>
<p>The returned tuple of triples are sorted in increasing distance from
the center of the specified bounding box. Each triple consists of a
network item (which may be a node, sticky note, wire, etc.), a
string which describes the part of the UI for that item that was
found in the box, and an optional index value which differentiates
between different instances of the same item/name combination. For
example, if the connector for input 2 of the node geo1 was the only
thing inside the provided box, the return value would be:</p>
</div></blockquote>
<p>&gt; &gt;&gt;&gt; editor = hou.ui.paneTabOfType(hou.paneTabType.NetworkEditor)
&gt; &gt;&gt;&gt; editor.networkItemsInBox(pos1, pos2)
&gt; ((&lt;hou.ObjNode of type subnet at /obj/subnet1&gt;, input, 2),)</p>
<blockquote>
<div>One of for_drop or for_select may be set to True to use a different
criteria for deciding what a valid target is. By default, any UI
widget that highlights with the mouse over it will be returned by
this method. Setting for_drop to True will return only UI widgets
that can be drop targets. Setting for_select to True will only
return UI widgets that result in the item being selected when box
picking.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkEditor.nodeShapes">
<code class="descname">nodeShapes</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of str<a class="headerlink" href="#hou.NetworkEditor.nodeShapes" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Return a list of all valid node shape names. These are the values
that can be set into the user data of a node to control the shape of
a specific node. They are also the shape names that can be used as
defaults for node types.</p>
<p>This code sets a node to a random shape:</p>
</div></blockquote>
<p>&gt; &gt;&gt;&gt; import random
&gt; &gt;&gt;&gt; editor = hou.ui.paneTabOfType(hou.paneTabType.NetworkEditor)
&gt; &gt;&gt;&gt; shapes = editor.nodeShapes()
&gt; &gt;&gt;&gt; hou.node(/obj/geo1).setUserData(nodeshape, random.choice(shapes))</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkEditor.openCommentEditor">
<code class="descname">openCommentEditor</code><span class="sig-paren">(</span><em>self</em>, <em>item</em>, <em>select_all = False</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.NetworkEditor.openCommentEditor" title="Permalink to this definition"></a></dt>
<dd><p>Opens an input field for editing the comment of the network box
specified in the item parameter. Returns an integer id which is
passed to the network editor as part of an event indicating when the
user finishes editing the text.</p>
<p>If select_all is set to True, the editor is opened with all text
selected.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkEditor.openNameEditor">
<code class="descname">openNameEditor</code><span class="sig-paren">(</span><em>self</em>, <em>item</em>, <em>select_all = False</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.NetworkEditor.openNameEditor" title="Permalink to this definition"></a></dt>
<dd><p>Opens an input field for editing the name of the node specified in
the item parameter. Returns an integer id which is passed to the
network editor as part of an event indicating when the user finishes
editing the text.</p>
<p>If select_all is set to True, the editor is opened with all text
selected.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkEditor.openNodeMenu">
<code class="descname">openNodeMenu</code><span class="sig-paren">(</span><em>self</em>, <em>node = None</em>, <em>items = []</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NetworkEditor.openNodeMenu" title="Permalink to this definition"></a></dt>
<dd><p>Brings up a node context menu under the current mouse position. The
two parameters contol which node(s) will be affected by the menu
option chosen by the user. If a hou.Node object is specified in the
node parameter, the menu operation will affect that node, and, if
that node is currently selected, all other selected network items
will also be affected. If the items parameter is passed a non-empty
list of hou.NetworkMovableItem objects, those items and only those
items will be affected by the menu, regardless of the current
selection.</p>
<p>If the chosen menu item only operates on a single node, the original
node parameter value or the last hou.Node object in the items list
will be affected. If the selected menu item can affect multiple
nodes, all nodes will be affected. And in the few cases where
network items other than nodes may be altered by a menu item, all
items (nodes or otherwise) will be affected.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkEditor.openNoteEditor">
<code class="descname">openNoteEditor</code><span class="sig-paren">(</span><em>self</em>, <em>stickynote</em>, <em>select_all = False</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.NetworkEditor.openNoteEditor" title="Permalink to this definition"></a></dt>
<dd><p>Opens an input field for editing the text of the sticky note
specified in the stickynote parameter. Returns an integer id which
is passed to the network editor as part of an event indicating when
the user finishes editing the text.</p>
<p>If select_all is set to True, the editor is opened with all text
selected.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkEditor.openTabMenu">
<code class="descname">openTabMenu</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NetworkEditor.openTabMenu" title="Permalink to this definition"></a></dt>
<dd><p>openTabMenu(self, key=None, auto_place=False, branch=False,
src_item=None, src_connector_index=-1, dest_item=None,
dest_connector_index=-1, node_position=None, src_items=[],
src_indexes=[], dest_items=[], dest_indexes=[])</p>
<blockquote>
<div><p>Opens the tab menu in the network editor. When the user chooses a
tool from the tab menu, the parameters passed to this function
determine the context information that will be sent to the tool
script. Generally, most tools treat these parameters in a consistent
way as described below.</p>
<dl class="docutils">
<dt>key</dt>
<dd>The key used (if any) to open the menu. This same key pressed
with the menu up will cause the menu to close.</dd>
<dt>auto_place</dt>
<dd>Set to True to make the tab menu turn on auto placement when a
tool is chosen from the menu. The new node will be placed at a
position determined automatically by the tab menu based on the
source and destination nodes.</dd>
<dt>branch</dt>
<dd>Set to True to cause the new node to create a new branch instead
of inserting the new node between the source and destination
nodes.</dd>
<dt>src_item</dt>
<dd>The node, dot, or subnet indirect input that will be connected
to the input of the new node created by the tab menu.</dd>
<dt>src_item_connector_index</dt>
<dd>The output index of the node that will be connected to the input
of the new node created by the tab menu.</dd>
<dt>dest_item</dt>
<dd>The node or dot that will be connected to the output of the new
node created by the tab menu.</dd>
<dt>dest_connector_index</dt>
<dd>The input index of the node or dot that will be connected to the
output of the new node created by the tab menu.</dd>
<dt>node_position</dt>
<dd>The location to use for the new node created by the tab menu.</dd>
<dt>src_items</dt>
<dd>A list of nodes, dot, or subnet indirect inputs that will be
connected to the input of the new node created by the tab menu.
This parameter (and all other list-based source and destination
paramaters) take precedence over the single item parameters if
both are specified.</dd>
<dt>src_item_connector_indexes</dt>
<dd>A list of output indexes of the nodes that will be connected to
the input of the new node created by the tab menu.</dd>
<dt>dest_items</dt>
<dd>A list of nodes or dots that will be connected to the output of
the new node created by the tab menu.</dd>
<dt>dest_connector_indexes</dt>
<dd>A list of input indexes of the nodes or dots that will be
connected to the output of the new node created by the tab menu.</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkEditor.openVopEffectsMenu">
<code class="descname">openVopEffectsMenu</code><span class="sig-paren">(</span><em>self</em>, <em>node</em>, <em>input_index</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NetworkEditor.openVopEffectsMenu" title="Permalink to this definition"></a></dt>
<dd><p>Brings up the VOP node effects menu for the hou.VopNode specified in
the node parameter, at the input specified by the input_index
parameter.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkEditor.openVopOutputInfoMenu">
<code class="descname">openVopOutputInfoMenu</code><span class="sig-paren">(</span><em>self</em>, <em>node</em>, <em>output_index</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NetworkEditor.openVopOutputInfoMenu" title="Permalink to this definition"></a></dt>
<dd><p>Brings up the VOP node output info menu for the hou.VopNode
specified in the node parameter, at the output specified by the
output_index parameter. This menu is used to control the behavior of
the VOP node when the Debug or Bypass flags are enabled.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkEditor.overviewPosFromScreen">
<code class="descname">overviewPosFromScreen</code><span class="sig-paren">(</span><em>self</em>, <em>pos</em><span class="sig-paren">)</span> &#x2192; hou.Vector2<a class="headerlink" href="#hou.NetworkEditor.overviewPosFromScreen" title="Permalink to this definition"></a></dt>
<dd><p>Given a position value pos as a hou.Vector2, expressed in screen
units (pixels) within the overview gadget, return the equivalent
position in network units. This method returns a value that assumes
the overview area is visible, even if it is not. If the provided
position is outside the overview area, this method returns a value
that assumes the overview gadget extends as far as required to reach
the specified coordinates.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkEditor.overviewPosToScreen">
<code class="descname">overviewPosToScreen</code><span class="sig-paren">(</span><em>self</em>, <em>pos</em><span class="sig-paren">)</span> &#x2192; hou.Vector2<a class="headerlink" href="#hou.NetworkEditor.overviewPosToScreen" title="Permalink to this definition"></a></dt>
<dd><p>Given a position value pos as a hou.Vector2, expressed in network
units, return the equivalent position in screen units (pixels)
within the overview gadget in the network editor. This method
returns a value that assumes the overview area is visible, even if
it is not.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkEditor.overviewVisible">
<code class="descname">overviewVisible</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.NetworkEditor.overviewVisible" title="Permalink to this definition"></a></dt>
<dd><p>Return a boolean indicating whether or not the overview gadget is
currently visible. This result reflects the true state of the
overview gadget even if the overview is configured to display
automatically.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkEditor.overviewVisibleIfAutomatic">
<code class="descname">overviewVisibleIfAutomatic</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.NetworkEditor.overviewVisibleIfAutomatic" title="Permalink to this definition"></a></dt>
<dd><p>Return a boolean indicating whether or not the overview gadget would
currently be visible if it was configured to display automatically.
In other words, this method returns True if any part of the network
is currently outside the visible bounds of the editor.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkEditor.popEventContext">
<code class="descname">popEventContext</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.NetworkEditor.popEventContext" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.NetworkEditor.posFromScreen">
<code class="descname">posFromScreen</code><span class="sig-paren">(</span><em>self</em>, <em>pos</em><span class="sig-paren">)</span> &#x2192; hou.Vector2<a class="headerlink" href="#hou.NetworkEditor.posFromScreen" title="Permalink to this definition"></a></dt>
<dd><p>Given a position value pos as a hou.Vector2, expressed in screen
units (pixels), return the equivalent position in network units. The
result will depend on both the current zoom level and view position
of the network editor.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkEditor.posToScreen">
<code class="descname">posToScreen</code><span class="sig-paren">(</span><em>self</em>, <em>pos</em><span class="sig-paren">)</span> &#x2192; hou.Vector2<a class="headerlink" href="#hou.NetworkEditor.posToScreen" title="Permalink to this definition"></a></dt>
<dd><p>Given a position value pos as a hou.Vector2, expressed in network
units, return the equivalent position in screen units (pixels). The
result will depend on both the current zoom level and view position
of the network editor.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkEditor.preSelectedItems">
<code class="descname">preSelectedItems</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.NetworkItem<a class="headerlink" href="#hou.NetworkEditor.preSelectedItems" title="Permalink to this definition"></a></dt>
<dd><p>Return the currently pre-selected items. These are just the values
passed into the last call to setPreSelectedItems.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkEditor.prompt">
<code class="descname">prompt</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.NetworkEditor.prompt" title="Permalink to this definition"></a></dt>
<dd><p>Return the current prompt string. This is the value that was last
passed to the setPromptText() method.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkEditor.pushEventContext">
<code class="descname">pushEventContext</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.NetworkEditor.pushEventContext" title="Permalink to this definition"></a></dt>
<dd><p>eventContextData(self) -&gt; dict</p>
<blockquote>
<div>Accesses the context data passed into the most recent call to the
hou.NetworkEditor.pushEventContext method. If no calls have been
made to this method, there is still a python dict available to store
any global information that may be used by the network editor event
handling code. As an example, the current view bounds for each
network visited by the editor are stored as part of this context
data dictionary.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkEditor.redraw">
<code class="descname">redraw</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NetworkEditor.redraw" title="Permalink to this definition"></a></dt>
<dd><p>Forces the network editor to redraw. This may be necessary in cases
where your code updates aspects of your Houdini session which
indirectly affect the drawing of the network editor (such as
changing default node shapes and colors). Direct changes to the
network (such as changing the shape or color of a specific node)
should automatically cause the network editor to redraw. Only use
this function when you see that a redraw is not being triggered
automatically by the your code.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkEditor.registerPref">
<code class="descname">registerPref</code><span class="sig-paren">(</span><em>self</em>, <em>pref</em>, <em>value</em>, <em>global</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NetworkEditor.registerPref" title="Permalink to this definition"></a></dt>
<dd><p>Registers a preference with the name pref, and default value value.
If global is True, this preference is treated as a global preference
that is applied to all network editors and saved in
$HOUDINI_USER_PREF_DIR/networkeditor.pref. Otherwise the preference
is considered local to each network editor, and will be saved to the
desk file with each network editor instance.</p>
<p>Registering a preference is required to ensure the preference is
saved when it is not a preference used internally by the network
editor. The preference that enables snapping, or the one to enable
dropping a node onto an existing wire are examples of preferences
that are only used by the python event handling code, and so must be
explicitly registered. This registration should be done in response
to the network editor initialization event which is sent once to
each network editor when it is first created.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkEditor.reloadNodeShapes">
<code class="descname">reloadNodeShapes</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of str<a class="headerlink" href="#hou.NetworkEditor.reloadNodeShapes" title="Permalink to this definition"></a></dt>
<dd><p>Forces all node shape files to be reloaded. This may cause new
shapes to become available, or existing shapes to be removed.
Returns a tuple of strings that indicate the name of each loaded
node shape, and any error messages generated while parsing each
shape. Use nodeShapes() to get a simple list of all successfully
loaded shapes after calling this method.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkEditor.scheduleTimerEvent">
<code class="descname">scheduleTimerEvent</code><span class="sig-paren">(</span><em>self</em>, <em>seconds</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.NetworkEditor.scheduleTimerEvent" title="Permalink to this definition"></a></dt>
<dd><p>Requests that a timer event be sent to the network editor after
seconds has elapsed. The returned integer id is included in the
triggered event to differentiate between timers if more than one is
scheduled at a time.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkEditor.screenBounds">
<code class="descname">screenBounds</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.BoundingRect<a class="headerlink" href="#hou.NetworkEditor.screenBounds" title="Permalink to this definition"></a></dt>
<dd><p>Return the screen space bounds of the network editor viewing area.
This does not include the menu bar, toolbar, or other UI elements.
Only the area where the network contents are displayed is returned.
The bounds are relative to the network area itself, so the lower
left corner of the returned bounding box will always be (0, 0).</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkEditor.selectPosition">
<code class="descname">selectPosition</code><span class="sig-paren">(</span><em>input_node=None</em>, <em>output_index=0</em>, <em>output_node=None</em>, <em>input_index=0</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NetworkEditor.selectPosition" title="Permalink to this definition"></a></dt>
<dd><p>selectPosition(self, input_node=None, output_index=0, output_node=None,
input_index=0) -&gt; hou.Vector2</p>
<blockquote>
<div><blockquote>
<div><p>This method wraps a call to hou.NetworkEditor.pushEventContext, with
the event context set to nodegraphselectpos, and appropriate
context data to give behavior similar to the old network editor.</p>
<p>Prompt the user to select a position in the network editor for a new
node to be placed. The network editor visualizes the position with a
dotted outline of a node placeholder. The user can then move the
mouse to change the position and [LMB] to confirm. The user can also
press [Esc] instead to cancel the selection.</p>
<p>You can optionally pass in hou.Node objects to the input_node and
output_node arguments to visualize the node placeholder with
connections to the specified input and output nodes.</p>
<p>Return a hou.Vector2 containing the x,y coordinates of the selected
position.</p>
<p>Raise hou.OperationInterrupted if the user canceled the selection.
Raise hou.OperationFailed if the network editor is in list mode.</p>
<p>This method can be useful for scripts that create new nodes and
prompts for node positions. Here is an example:</p>
</div></blockquote>
<p>&gt; 
&gt; # Get the input and output nodes that the new node will connect to.
&gt; input_node = hou.node(/obj/myInput)
&gt; output_node = hou.node(/obj/myOutput)
&gt; 
&gt; # Set the new node to connect to the first output of the input node
&gt; # and the second input of the output node.
&gt; output_index = 0
&gt; input_index = 1
&gt; 
&gt; # Get the network editor.
&gt; network_editor = hou.ui.curDesktop().paneTabOfType(
&gt;     hou.paneTabType.NetworkEditor)
&gt; 
&gt; # Prompt the user to select a position for the new node.
&gt; position = network_editor.selectPosition(
&gt;     input_node, output_index, output_node, input_index)
&gt; 
&gt; # Create the new node.
&gt; new_node = hou.node(/obj).createNode(geo)
&gt; 
&gt; # Position the new node and wire it to the input and output nodes.
&gt; new_node.move(position)
&gt; new_node.setInput(0, input_node, output_index)
&gt; output_node.setInput(input_index, new_node, 0)</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkEditor.setAdjustments">
<code class="descname">setAdjustments</code><span class="sig-paren">(</span><em>self</em>, <em>items</em>, <em>adjustments</em>, <em>auto_remove=False</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NetworkEditor.setAdjustments" title="Permalink to this definition"></a></dt>
<dd><p>Configures temporary adjustments to the sizes and locations of
network items in the editor. The items parameter is a tuple of
hou.NetworkMovableItem objects. The adjustments parameter is a tuple
of hou.NetworkAnimValue objects to associate with each network item
in the items tuple. See the documentation of that class for more
information about specifying adjustments.</p>
<p>The auto_remove parameter may be set to True to indicate that the
network editor should automatically delete the adjustments once the
animation on them has completed. This is useful for animations
performed at the end of a user action, where the following events do
not relate to the changes being made, and so it is easier not to
have to manage the reset of the adjustment values explicitly in the
future.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkEditor.setBackgroundImages">
<code class="descname">setBackgroundImages</code><span class="sig-paren">(</span><em>self</em>, <em>images</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NetworkEditor.setBackgroundImages" title="Permalink to this definition"></a></dt>
<dd><p>Configures the background images to be displayed in the network
editor. The network editor saves and loads the image descriptions
into the user data for each network, which allows a different set of
background images for each network. The images are specified as a
tuple of hou.NetworkImage objects. See the documentation of that
class for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkEditor.setCursorMap">
<code class="descname">setCursorMap</code><span class="sig-paren">(</span><em>self</em>, <em>cursors</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NetworkEditor.setCursorMap" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Tells the network editor which mouse cursor to use based on what UI
widget is under the mouse. This configuration is specified as a
dictionary mapping a tuple to a string. The string is the name of
the cursor, which can be any of the cursor file names from the
$HFS/houdini/config/Cursors directory. Each tuple consists of a
string and an integer. The string is the name of the UI widget, and
the integer represents the specific index value within that UI
widget.</p>
<p>The following code sets the network editor to show a connect
cursor for all node inputs and outputs:</p>
</div></blockquote>
<p>&gt; &gt;&gt;&gt; editor = hou.ui.paneTabOfType(hou.paneTabType.NetworkEditor)
&gt; &gt;&gt;&gt; editor.setCursorMap({
&gt;  (input, -1): wire,
&gt;  (output, -1): wire
&gt;  })</p>
<blockquote>
<div>The following code sets the network editor to show an appropriate
resize icon based on the specific section of the sticky note border
under the mouse:</div></blockquote>
<p>&gt; &gt;&gt;&gt; editor = hou.ui.paneTabOfType(hou.paneTabType.NetworkEditor)
&gt; &gt;&gt;&gt; editor.setCursorMap({
&gt;  (stickynoteborder, 0): arrowSWNE,
&gt;  (stickynoteborder, 1): arrowLeftRight,
&gt;  (stickynoteborder, 2): arrowNWSE,
&gt;  (stickynoteborder, 3): arrowUpDown,
&gt;  (stickynoteborder, 4): arrowSWNE,
&gt;  (stickynoteborder, 5): arrowLeftRight,
&gt;  (stickynoteborder, 6): arrowNWSE,
&gt;  (stickynoteborder, 7): arrowUpDown
&gt;  })</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkEditor.setCursorPosition">
<code class="descname">setCursorPosition</code><span class="sig-paren">(</span><em>self</em>, <em>pos</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NetworkEditor.setCursorPosition" title="Permalink to this definition"></a></dt>
<dd><p>Moves the mouse cursor to the position specified by the hou.Vector2
pos parameter.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkEditor.setDecoratedItem">
<code class="descname">setDecoratedItem</code><span class="sig-paren">(</span><em>self</em>, <em>item</em>, <em>interactive</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NetworkEditor.setDecoratedItem" title="Permalink to this definition"></a></dt>
<dd><p>This method is similar to setDropTargetItem in that it tells the
network editor to highlight a particular item when drawing it. In
the case of the decorated item, however, only the network item needs
to be provided. The result of setting a node as the decorated item
is to bring up the node ring. Network dots may also be the decorated
item, in which case the input and output connectors for the dot are
shown. The interactive boolean flag indicates whether the user is
allowed to interact with the decorations. If not, the node ring is
drawn faded, and its buttons cannot be clicked. This non-interactive
mode corresponds to having the Control key pressed while moving the
mouse around the network editor.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkEditor.setDefaultCursor">
<code class="descname">setDefaultCursor</code><span class="sig-paren">(</span><em>self</em>, <em>cursor_name</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NetworkEditor.setDefaultCursor" title="Permalink to this definition"></a></dt>
<dd><p>Tells the network editor which mouse cursor to use when none of the
UI mentioned in the dictionary sent to setCursorMap() is under the
mouse.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkEditor.setDragSourceData">
<code class="descname">setDragSourceData</code><span class="sig-paren">(</span><em>self</em>, <em>items</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NetworkEditor.setDragSourceData" title="Permalink to this definition"></a></dt>
<dd><p>Controls the network items that are put into the drag and drop
buffer. The values in this buffer are only used when dragging items
out of the network editor (such as when the user drags a node from
the network editor onto a textport, or a parameter dialog.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkEditor.setDropTargetItem">
<code class="descname">setDropTargetItem</code><span class="sig-paren">(</span><em>self</em>, <em>item</em>, <em>name</em>, <em>index</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NetworkEditor.setDropTargetItem" title="Permalink to this definition"></a></dt>
<dd><p>When the user is performing a drag and drop operation within the
network editor, it is important that they receive some feedback
about where the thing they are dragging will be dropped if they let
go of the mouse button. This indication is provided by highlighting
the drop target in the UI. This method allows the current drop
target to be specified in python code. Usually the item, name, and
index will be values returned in one of the tuples from the
networkItemsInBox method.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkEditor.setFootprints">
<code class="descname">setFootprints</code><span class="sig-paren">(</span><em>self</em>, <em>footprints</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NetworkEditor.setFootprints" title="Permalink to this definition"></a></dt>
<dd><p>Configure the footprint rings that the network editor should
display. The footprints parameter must be a tuple of
hou.NetworkFootprint objects. See that class for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkEditor.setListMode">
<code class="descname">setListMode</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NetworkEditor.setListMode" title="Permalink to this definition"></a></dt>
<dd><p>Set the network editor to enter list mode if on is True and to exit
list mode if on is False.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkEditor.setLocatingEnabled">
<code class="descname">setLocatingEnabled</code><span class="sig-paren">(</span><em>self</em>, <em>enabled</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NetworkEditor.setLocatingEnabled" title="Permalink to this definition"></a></dt>
<dd><p>Enables or disables highlighting of UI elementes under the mouse in
the network editor. When disabled, mouse events sent to the network
editor event processing code will never specify a located or
selected UI element. In some modes (such as when in a viewing state
where mouse events only modify the view) it is desirable to disable
this behavior.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkEditor.setNetworkBoxPendingRemovals">
<code class="descname">setNetworkBoxPendingRemovals</code><span class="sig-paren">(</span><em>self</em>, <em>items</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NetworkEditor.setNetworkBoxPendingRemovals" title="Permalink to this definition"></a></dt>
<dd><p>When moving items around the network, network boxes automatically
resize to contain their child items as they move. To indicate that
items will be removed from their network box, pass them as a tuple
to this method. Doing so will cause their network box containers to
not resize to fit the items as they move.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkEditor.setOverlayShapes">
<code class="descname">setOverlayShapes</code><span class="sig-paren">(</span><em>self</em>, <em>shapes</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NetworkEditor.setOverlayShapes" title="Permalink to this definition"></a></dt>
<dd><p>The shapes parameter specifies a tuple of hou.NetworkShape objects
which will be drawn into the overlay layer of the network editor
canvas. See documentation of the network shape class and its
subclasses for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkEditor.setPreSelectedItems">
<code class="descname">setPreSelectedItems</code><span class="sig-paren">(</span><em>self</em>, <em>items</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NetworkEditor.setPreSelectedItems" title="Permalink to this definition"></a></dt>
<dd><p>When box selecting items in the network, it is useful to be able to
see what will be selected if the mouse button is released. These
items are drawn to the overlay layer of the network editor canvas in
a light blue color with transparency. The network items passed as a
tuple to this method are the ones that get drawn with this pre-
selection highlight.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkEditor.setPref">
<code class="descname">setPref</code><span class="sig-paren">(</span><em>self</em>, <em>pref</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NetworkEditor.setPref" title="Permalink to this definition"></a></dt>
<dd><p>Sets the preference named pref to value. The value is always a
string, and must be converted to or from a number, enum, or other
format as appropriate. If the preference specified by pref is a
global preference, all network editors will automatically update
with the new value. Otherwise the change will only affect this
network editor.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkEditor.setPrefs">
<code class="descname">setPrefs</code><span class="sig-paren">(</span><em>self</em>, <em>prefs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NetworkEditor.setPrefs" title="Permalink to this definition"></a></dt>
<dd><p>Sets a number of preference values with a single method call. The
prefs parameter must be a python dictionary mapping preference name
strings to value strings. The preferences may be local or global,
but this method is most often used for saving and loading the local
preferences for a single network editor.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkEditor.setPrompt">
<code class="descname">setPrompt</code><span class="sig-paren">(</span><em>self</em>, <em>prompt</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NetworkEditor.setPrompt" title="Permalink to this definition"></a></dt>
<dd><p>Sets the prompt text that appears at the bottom of the network
editor. This string should generally be set to correspond to the
network item currently under the mouse cursor. This text should be
fairly brief. More detailed information can be put into the tooltip
through the setTooltip() method.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkEditor.setShapes">
<code class="descname">setShapes</code><span class="sig-paren">(</span><em>self</em>, <em>shapes</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NetworkEditor.setShapes" title="Permalink to this definition"></a></dt>
<dd><p>The shapes parameter specifies a tuple of hou.NetworkShape objects
which will be drawn into the network editor. See documentation of
the network shape class and its subclasses for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkEditor.setTooltip">
<code class="descname">setTooltip</code><span class="sig-paren">(</span><em>self</em>, <em>tooltip</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NetworkEditor.setTooltip" title="Permalink to this definition"></a></dt>
<dd><p>Sets the tooltip string that should be shown under the mouse if it
remains stationary for a short time. This string should generally be
set to correspond to the network item currently under the mouse
cursor. Because it appears after a delay, it is okay to make this
text more verbose than the prompt text passed to setPromptText().</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkEditor.setVisibleBounds">
<code class="descname">setVisibleBounds</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NetworkEditor.setVisibleBounds" title="Permalink to this definition"></a></dt>
<dd><p>setVisibleBounds(self, bounds, transition_time=0.0, max_scale=0.0,
set_center_when_scale_rejected=False)</p>
<blockquote>
<div><p>Sets the visible bounds of the network editor viewing area,
expressed in network space coordinates. This method will never alter
the screen space size or location of the network editor. If the area
specified by the bounds parameter has a different aspect ratio from
the actual network editor, this method will automatically adjust the
bounds to ensure that the area specified is fully visible.</p>
<dl class="docutils">
<dt>bounds</dt>
<dd>A hou.BoundingRect specifying the area that should be visible in
the network editor.</dd>
<dt>transition_time</dt>
<dd>The amount of time, in seconds, over which the network editor
will animate the transition from the current visible bounds to
the new visible bounds.</dd>
<dt>max_scale</dt>
<dd>If set to a non-zero value, this parameter controls the maximum
zoom level that will be allowed. The default maximum scale used
by the network editor code is 100.</dd>
<dt>set_centered_when_scale_rejected</dt>
<dd>If set to True, but the new zoom level is determined to be the
same as the previous zoom, no change is made to the bounds at
all. This prevents a bounds change, that was intended as a pure
zoom, from inadvertently panning the view if the zoom doesnt
actually change.</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkEditor.setVolatileKeys">
<code class="descname">setVolatileKeys</code><span class="sig-paren">(</span><em>self</em>, <em>keys</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NetworkEditor.setVolatileKeys" title="Permalink to this definition"></a></dt>
<dd><p>The keys parameter specifies a tuple of keyboard keys that should be
processed as volatile keys. This means they generate a keydown
event when the key is pressed, and a keyup event when the key is
released. All other keys simply send a keyhit event after the key
is released, with no notification when the key is first pressed. The
key strings are of the form returned by the hou.ui.hotkeys method,
which is a combination of the symbol on the key, and any modifier
keys involved, such as Ctrl+Shift+G.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkEditor.sizeFromScreen">
<code class="descname">sizeFromScreen</code><span class="sig-paren">(</span><em>self</em>, <em>size</em><span class="sig-paren">)</span> &#x2192; hou.Vector2<a class="headerlink" href="#hou.NetworkEditor.sizeFromScreen" title="Permalink to this definition"></a></dt>
<dd><p>Given a box size value size as a hou.Vector2, expressed in screen
units (pixels), return the equivalent size in network units. This is
equivalent to making two separate calls to lengthFromScreen() for
the width and height. The result will depend on the current zoom
level of the network editor.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkEditor.sizeToScreen">
<code class="descname">sizeToScreen</code><span class="sig-paren">(</span><em>self</em>, <em>size</em><span class="sig-paren">)</span> &#x2192; hou.Vector2<a class="headerlink" href="#hou.NetworkEditor.sizeToScreen" title="Permalink to this definition"></a></dt>
<dd><p>Given a box size value size as a hou.Vector2, expressed in network
units, return the equivalent size in screen units (pixels). This is
equivalent to making two separate calls to lengthToScreen() for the
width and height. The result will depend on the current zoom level
of the network editor.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkEditor.textBadges">
<code class="descname">textBadges</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of tuple of str<a class="headerlink" href="#hou.NetworkEditor.textBadges" title="Permalink to this definition"></a></dt>
<dd><p>Return descriptions of the optional node text that can be shown in
the network editor. Each tuple contained in the returned value
contains three strings describing the text. The first is the
preference value that controls whether the text is hidden, or
appears as truncated or full text. The second string is a
description of the text. The third string is the name of an icon
that can be used to represent the meaning of the text. These values
can be used to present an interface for configuring the text.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.NetworkEditor.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.NetworkEditor.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkEditor.tooltip">
<code class="descname">tooltip</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.NetworkEditor.tooltip" title="Permalink to this definition"></a></dt>
<dd><p>Return the current tooltip string. This is the value that was last
passed to the setTooltip() method.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkEditor.visibleBounds">
<code class="descname">visibleBounds</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.BoundingRect<a class="headerlink" href="#hou.NetworkEditor.visibleBounds" title="Permalink to this definition"></a></dt>
<dd><p>Return the network space bounds of the network editor viewing area.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.NetworkFootprint">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">NetworkFootprint</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NetworkFootprint" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Describes the conditions under which a footprint ring should be
displayed for a node in a network editor pane.</p>
<p>A footprint in the network editor is a ring drawn behind the node in the
network editor, such as the blue display flag ring around the wave1
node and the orange output flag ring around the wave2 node:</p>
<p>This class describes to the network editor which nodes should be drawn
with a footprint, and the color and position of that footprint. A tuple
of these objects is passed to the hou.NetworkEditor.setFootprints
method. This tuple should be updated every time the current network
changes to a new node type category.</p>
<p>The default footprint setup for SOP nodes is the following:</p>
<p>&gt; &gt;&gt;&gt; editor = hou.ui.paneTabOfType(hou.paneTabType.NetworkEditor)
&gt; &gt;&gt;&gt; editor.setFootprints([
&gt;         hou.NetworkFootprint(
&gt;             hou.nodeFlag.Display,
&gt;             hou.ui.colorFromName(GraphDisplayHighlight), 1, True
&gt;         ),
&gt;         hou.NetworkFootprint(
&gt;             hou.nodeFlag.Render,
&gt;             hou.ui.colorFromName(GraphRenderHighlight), 0, True
&gt;         ),
&gt;         hou.NetworkFootprint(
&gt;             hou.nodeFlag.Template,
&gt;             hou.ui.colorFromName(GraphTemplateHighlight), 2, True
&gt;         ),
&gt;         hou.NetworkFootprint(
&gt;             hou.nodeFlag.Footprint,
&gt;             hou.ui.colorFromName(GraphTemplateHighlight), 2, True
&gt;         ),
&gt;         hou.NetworkFootprint(
&gt;             output,
&gt;             hou.ui.colorFromName(GraphOutputHighlight), 1, True
&gt;         )
&gt;     ])</p>
<dl class="attribute">
<dt id="hou.NetworkFootprint.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.NetworkFootprint.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.NetworkImage">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">NetworkImage</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NetworkImage" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Describes a background image that can be displayed in a network editor
pane.</p>
<p>The network editor pane can display any number of images in the
background behind the nodes of the network. These background images are
described using this class, and set in the network editor using the
hou.NetworkEditor.setBackgroundImages method.</p>
<p>This code sets a single background image in the network editor:</p>
<p>&gt; 
&gt; editor = hou.ui.paneTabOfType(hou.paneTabType.NetworkEditor)
&gt; image = hou.NetworkImage()
&gt; image.setPath($HFS/houdini/pic/Mandril.pic)
&gt; image.setRect(hou.BoundingRect(0, 0, 5, 5))
&gt; editor.setBackgroundImages([image])</p>
<p>The network editor pane provides a mode for creating and editing
background images directly in the pane. The resulting image layout is
saved into the user data for the current network so that the image
arrangement is automatically saved and restored with the hip file.</p>
<dl class="method">
<dt id="hou.NetworkImage.brightness">
<code class="descname">brightness</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#hou.NetworkImage.brightness" title="Permalink to this definition"></a></dt>
<dd><p>Return the brightness adjustment for displaying this image in the
network editor. This value should range from 0 to 1. Values less
than 1 cause the image to be blended with the background of the
network editor. An image with a brightness of 0 will appear as the
background color, not black as is normally indicated by a brightness
value of 0.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkImage.path">
<code class="descname">path</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.NetworkImage.path" title="Permalink to this definition"></a></dt>
<dd><p>Return the path to the image file.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkImage.rect">
<code class="descname">rect</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.BoundingRect<a class="headerlink" href="#hou.NetworkImage.rect" title="Permalink to this definition"></a></dt>
<dd><p>Returns the bounding rectangle that defines the size and position of
the image within the network. If the relativeToPath() value is set,
then the rectangle is translated by the position of the network item
to which this image is tied.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkImage.relativeToPath">
<code class="descname">relativeToPath</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.NetworkImage.relativeToPath" title="Permalink to this definition"></a></dt>
<dd><p>Images can be tied to network items such as nodes, network boxes, or
sticky notes. This method returns the path to the network item to
which this image is tied (or an empty string if its location is not
relative to any network item).</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkImage.setBrightness">
<code class="descname">setBrightness</code><span class="sig-paren">(</span><em>self</em>, <em>brightness</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NetworkImage.setBrightness" title="Permalink to this definition"></a></dt>
<dd><p>Sets the brightness adjustment for displaying this image in the
network editor. This value should range from 0 to 1. Values less
than 1 cause the image to be blended with the background of the
network editor. An image with a brightness of 0 will appear as the
background color, not black as is normally indicated by a brightness
value of 0.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkImage.setPath">
<code class="descname">setPath</code><span class="sig-paren">(</span><em>self</em>, <em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NetworkImage.setPath" title="Permalink to this definition"></a></dt>
<dd><p>Sets the path to the image file.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkImage.setRect">
<code class="descname">setRect</code><span class="sig-paren">(</span><em>self</em>, <em>rect</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NetworkImage.setRect" title="Permalink to this definition"></a></dt>
<dd><p>Sets the bounding rectangle that defines the size and position of
the image within the network. If the relativeToPath() value is set,
then the rectangle will be translated by the position of the network
item to which this image is tied.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkImage.setRelativeToPath">
<code class="descname">setRelativeToPath</code><span class="sig-paren">(</span><em>self</em>, <em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NetworkImage.setRelativeToPath" title="Permalink to this definition"></a></dt>
<dd><p>Images can be tied to network items such as nodes, network boxes, or
sticky notes. This method sets the path to the network item to which
this image is tied. Passing in an empty string indicates the
location is not relative to any network item.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.NetworkImage.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.NetworkImage.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.NetworkItem">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">NetworkItem</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NetworkItem" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>The base class for all visible elements within a network.</p>
<p>This class has no methods, and only exists as a base class for
hou.NetworkMovableItem and Hou.NodeConnection, both of which are visible
in the network editor, but which have no real meaningful base class. By
providing a common base class, items of these two types can be passed in
or returned from hou.NetworkEditor functions.</p>
<dl class="method">
<dt id="hou.NetworkItem.networkItemType">
<code class="descname">networkItemType</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.NetworkItem.networkItemType" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.NetworkItem.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.NetworkItem.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.NetworkMovableItem">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">NetworkMovableItem</code><a class="headerlink" href="#hou.NetworkMovableItem" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.NetworkItem" title="hou.NetworkItem"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.NetworkItem</span></code></a></p>
<p>The base class for all visible elements within a network, such as Nodes,
Network Boxes, and Sticky Notes.</p>
<p>Each movable item has a position, color, and other attributes that allow
for common interactions in the network editor. All movable items will
have a parent network (except the node represented by hou.node(/)),
and may be contained by a hou.NetworkBox. Not all movable items have a
name, but all have a numeric session id, which is a unique number within
a given Houdini session for a given subclass of NetworkMovableItem.</p>
<dl class="method">
<dt id="hou.NetworkMovableItem.color">
<code class="descname">color</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Color<a class="headerlink" href="#hou.NetworkMovableItem.color" title="Permalink to this definition"></a></dt>
<dd><p>Return the color of this items tile in the network editor.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkMovableItem.digitsInName">
<code class="descname">digitsInName</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.NetworkMovableItem.digitsInName" title="Permalink to this definition"></a></dt>
<dd><p>Return the value of the last set of digits inside the nodes name,
or 0 if there are no digits.</p>
<p>For example, the result is 102 for a node named geo102, and 34 for a
node named light12to34.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkMovableItem.isPicked">
<code class="descname">isPicked</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.NetworkMovableItem.isPicked" title="Permalink to this definition"></a></dt>
<dd><p>Equivalent to calling hou.NetworkMovableItem.isSelected.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkMovableItem.isSelected">
<code class="descname">isSelected</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.NetworkMovableItem.isSelected" title="Permalink to this definition"></a></dt>
<dd><p>Return whether this item is selected.</p>
<p>See also hou.selectedNodes.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkMovableItem.move">
<code class="descname">move</code><span class="sig-paren">(</span><em>self</em>, <em>vector2</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NetworkMovableItem.move" title="Permalink to this definition"></a></dt>
<dd><p>Moves this items tile in the network editor graph by the increments
in the given hou.Vector2.</p>
<p>To position a item absolutely, use setPosition().</p>
<p>To get the items current graph position, use position().</p>
<p>Raises hou.InvalidInput if the item cannot move to the position
specified.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkMovableItem.name">
<code class="descname">name</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.NetworkMovableItem.name" title="Permalink to this definition"></a></dt>
<dd><p>Return this nodes name. See also hou.NetworkMovableItem.path.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkMovableItem.parent">
<code class="descname">parent</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Node<a class="headerlink" href="#hou.NetworkMovableItem.parent" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Return the node that contains this item.</p>
<p>Note that this method returns None if the item is the root node
(i.e. /).</p>
</div></blockquote>
<p>&gt; &gt;&gt;&gt; hou.node(/obj/box_object1).parent()
&gt; &lt;hou.Node at /obj&gt;
&gt; &gt;&gt;&gt; print hou.node(/).parent()
&gt; None</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkMovableItem.parentNetworkBox">
<code class="descname">parentNetworkBox</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.NetworkBox or None<a class="headerlink" href="#hou.NetworkMovableItem.parentNetworkBox" title="Permalink to this definition"></a></dt>
<dd><p>Returns the parent network box which contains this item, or None if
it is not inside a network box.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkMovableItem.path">
<code class="descname">path</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.NetworkMovableItem.path" title="Permalink to this definition"></a></dt>
<dd><p>Return the full path (i.e. starting with /) of this node in the
network.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkMovableItem.position">
<code class="descname">position</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Vector2<a class="headerlink" href="#hou.NetworkMovableItem.position" title="Permalink to this definition"></a></dt>
<dd><p>Return the position of this items tile in the network editor graph
as a Vector2. See also move() and setPosition().</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkMovableItem.relativePathTo">
<code class="descname">relativePathTo</code><span class="sig-paren">(</span><em>self</em>, <em>base_node</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.NetworkMovableItem.relativePathTo" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Return a relative path to another node object from this node.</div></blockquote>
<p>&gt; &gt;&gt;&gt; box1 = hou.node(/obj/box_object1/box1)
&gt; &gt;&gt;&gt; sphere1 = hou.node(/obj/sphere_object1/sphere1)
&gt; &gt;&gt;&gt; box1.relativePathTo(sphere1)
&gt; ../../sphere_object1/sphere1
&gt; &gt;&gt;&gt; hou.node(/obj).relativePathTo(box1)
&gt; box_object1/box1
&gt; &gt;&gt;&gt; box1.relativePathTo(box1)
&gt; .</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkMovableItem.sessionId">
<code class="descname">sessionId</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NetworkMovableItem.sessionId" title="Permalink to this definition"></a></dt>
<dd><p>Returns an integer value that uniquely identifies this item in a
given Houdini session. This id is only guaranteed to be unique in a
single Houdini process. It is useful as a quick and easy way to save
a restore a reference to an item. It is also only unique for a
specific item subclass. So there may be a Node with the same session
id as a NetworkBox.</p>
<p>See hou.nodeBySessionId to turn a session id back into a node, or
hou.networkBoxBySessionId to turn a session id back into a network
box, or more generally, hou.itemBySessionId to turn a session id
combined with an enum value indicating the item subclass into an
item of that type.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkMovableItem.setColor">
<code class="descname">setColor</code><span class="sig-paren">(</span><em>self</em>, <em>color</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NetworkMovableItem.setColor" title="Permalink to this definition"></a></dt>
<dd><p>Sets the color of this items tile in the network editor to the
given hou.Color.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkMovableItem.setName">
<code class="descname">setName</code><span class="sig-paren">(</span><em>self</em>, <em>name</em>, <em>unique_name=False</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NetworkMovableItem.setName" title="Permalink to this definition"></a></dt>
<dd><p>Set the name of this node. Raises hou.OperationFailed if the new
name contains characters other than letters, numbers, periods,
dashes, or underscores. Raises hou.OperationFailed if the node could
not be renamed (for example, another node already exists with the
name, the node is the root node or top-level manager (e.g. /obj), or
the node is inside a locked asset). If the unique_name parameter is
set to True, the supplied name may be changed to ensure that it
doesnt match the name of any existing node.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkMovableItem.setPicked">
<code class="descname">setPicked</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NetworkMovableItem.setPicked" title="Permalink to this definition"></a></dt>
<dd><p>Equivalent to calling hou.NetworkMovableItem.setSelected with
default values for all optional parameters.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkMovableItem.setPosition">
<code class="descname">setPosition</code><span class="sig-paren">(</span><em>self</em>, <em>vector2</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NetworkMovableItem.setPosition" title="Permalink to this definition"></a></dt>
<dd><p>Sets the position of this items tile in the network editor graph.
Raises hou.InvalidInput if the item cannot have the given position.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkMovableItem.setSelected">
<code class="descname">setSelected</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NetworkMovableItem.setSelected" title="Permalink to this definition"></a></dt>
<dd><p>setSelected(self, on, clear_all_selected=False,
show_asset_if_selected=False)</p>
<blockquote>
<div>Select or deselect this item, optionally deselecting all other
selected items in this network. If show_asset_if_selected is True,
and this item is a Node, then the panes will show the top-level
asset of the selected item instead.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkMovableItem.shiftPosition">
<code class="descname">shiftPosition</code><span class="sig-paren">(</span><em>self</em>, <em>vector2</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NetworkMovableItem.shiftPosition" title="Permalink to this definition"></a></dt>
<dd><p>Equivalent to calling hou.NetworkMovableItem.move.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NetworkMovableItem.size">
<code class="descname">size</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Vector2<a class="headerlink" href="#hou.NetworkMovableItem.size" title="Permalink to this definition"></a></dt>
<dd><p>Return the size of this items tile in the network editor graph as a
Vector2.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.NetworkMovableItem.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.NetworkMovableItem.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.NetworkShape">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">NetworkShape</code><a class="headerlink" href="#hou.NetworkShape" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>The base class for extra shapes that can be drawn into a network editor.</p>
<p>The network editor pane can be instructed to draw additional shapes to
either the main canvas, or to the overlay area of the pane (drawn on top
of the actual network). Each element that is drawn is described as a
subclass of this NetworkShape base class, then passed to the network
editor through either the hou.NetworkEditor.setShapes or
hou.NetworkEditor.setOverlayShapes methods.</p>
<dl class="attribute">
<dt id="hou.NetworkShape.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.NetworkShape.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.NetworkShapeBox">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">NetworkShapeBox</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NetworkShapeBox" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.NetworkShape" title="hou.NetworkShape"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.NetworkShape</span></code></a></p>
<p>Describes a rectangular area that can be drawn into a network editor.</p>
<p>This subclass of hou.NetworkShape describes a rectangle that can be
drawn into a network editor pane.</p>
<dl class="attribute">
<dt id="hou.NetworkShapeBox.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.NetworkShapeBox.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.NetworkShapeConnection">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">NetworkShapeConnection</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NetworkShapeConnection" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.NetworkShape" title="hou.NetworkShape"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.NetworkShape</span></code></a></p>
<p>Describes a wire that can be drawn into a network editor.</p>
<p>This subclass of hou.NetworkShape describes a wire that can be drawn
into a network editor pane. This wire is drawn using the same wire style
set on the current network.</p>
<dl class="attribute">
<dt id="hou.NetworkShapeConnection.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.NetworkShapeConnection.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.NetworkShapeLine">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">NetworkShapeLine</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NetworkShapeLine" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.NetworkShape" title="hou.NetworkShape"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.NetworkShape</span></code></a></p>
<p>Describes a line that can be drawn into a network editor.</p>
<p>This subclass of hou.NetworkShape describes a line that can be drawn
into a network editor pane.</p>
<dl class="attribute">
<dt id="hou.NetworkShapeLine.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.NetworkShapeLine.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.NetworkShapeNodeShape">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">NetworkShapeNodeShape</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NetworkShapeNodeShape" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.NetworkShape" title="hou.NetworkShape"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.NetworkShape</span></code></a></p>
<p>Describes a node shape that can be drawn into a network editor.</p>
<p>This subclass of hou.NetworkShape describes a node shape that can be
drawn into a network editor pane. This can draw any of the node shapes
available to the nodes in the network through the Shape Palette.</p>
<dl class="attribute">
<dt id="hou.NetworkShapeNodeShape.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.NetworkShapeNodeShape.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.Node">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">Node</code><a class="headerlink" href="#hou.Node" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.NetworkMovableItem" title="hou.NetworkMovableItem"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.NetworkMovableItem</span></code></a></p>
<p>The base class for all nodes in Houdini (objects, SOPs, COPs, etc.) An
instance of this class corresponds to exactly one instance of a node in
Houdini.</p>
<p>Each node has a unique path that defines its location in the tree of
nodes. The node path hierarchy is similar to the hierarchy of folders
and files in a file system. Some nodes, called networks, may contain
other nodes inside them, much like a file folder would, while other
nodes may not. For example, an object node instance and a SOP subnetwork
node instance may contain SOP nodes, but a box SOP instance may not.</p>
<dl class="docutils">
<dt>TIP</dt>
<dd>Be careful not to confuse nodes with node types. A node is an
instance of a node type. For example suppose /obj/geo1/box1 is a box
SOP. It has its own unique name (box1) and its own copies of
parameter values. It is an instance of the box SOP node type. This
node type defines what parameters are common to all box SOP node
instances, as well as the algorithm that each BOX SOP performs. The
class that represents a node type is hou.NodeType.</dd>
</dl>
<p>You cannot create instances of hou.Node using hou.Node.__init__.
Instead, you look up Node objects corresponding to existing Houdini
nodes with hou.node(). To create a new Houdini node instance inside
another node, use hou.Node.createNode. To delete a Houdini node, use
hou.Node.destroy.</p>
<p>Note that a Node object internally stores a reference to the
corresponding Houdini node, and that their lifetimes are different. If a
Python node object is deleted because its reference count in Python goes
to zero, the Houdini node will be unaffected. On the other hand, if you
have a Node object in a Python variable and the Houdini node is deleted,
the Python variable will still exist, and Python will not crash.
Instead, if you later call a method on that Python Node object, Houdini
will raise a hou.ObjectWasDeleted exception.</p>
<p>Be careful not to confuse this class with the function hou.node.</p>
<dl class="method">
<dt id="hou.Node.addControlParmFolder">
<code class="descname">addControlParmFolder</code><span class="sig-paren">(</span><em>self</em>, <em>folder_name=None</em>, <em>parm_name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.addControlParmFolder" title="Permalink to this definition"></a></dt>
<dd><p>Adds a control parameter folder as the front-most folder at the top-
level. This is used to increase visibility of customized control
parameters. If a folder of the same name already exists, no new
folder will be created. If folder_name is None, it will be set as
Controls. If parm_name is None, it will be set as folder.</p>
<p>If there are no current folders present, the existing parameters
will be grouped together and stored into a new folder named
Parameters and placed after the new control parameter folder.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.addEventCallback">
<code class="descname">addEventCallback</code><span class="sig-paren">(</span><em>self</em>, <em>event_types</em>, <em>callback</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.addEventCallback" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Registers a Python callback that Houdini will call whenever a
particular action, or event, occurs on _this particular node
<a href="#id63"><span class="problematic" id="id64">instance_</span></a>.</p>
<p>Callbacks only persist for the current session. For example, they
are not saved to the .hip file. If you want persistent callbacks in
every session, you can add them in code in 456.py (runs when the
user opens a .hip file). See where to add Python scripting for more
information.</p>
<dl class="docutils">
<dt>event_types</dt>
<dd>A sequence of hou.nodeEventType enumeration values describing
the event types that will cause Houdini to call the callback
function.</dd>
<dt>callback</dt>
<dd><blockquote class="first">
<div><p>A callable Python object, such as a function or bound method.
Houdini will call this function whenever one of the event types
in event_types occurs.</p>
<p>Houdini calls the function with an event_type keyword argument
containing the hou.nodeEventType value corresponding to the
event that triggered the callback.</p>
<p>Houdini will pass additional keyword arguments depending on the
event type. For example, in a callback for the ParmTupleChanged
event, Houdini will pass a parm_tuple keyword argument
containing a hou.ParmTuple reference to the parameter that
changed. See hou.nodeEventType for the extra arguments (if any)
passed for each event type.</p>
<p>You can add <a href="#id17"><span class="problematic" id="id18">**</span></a>kwargs to the argument list to accept all keyword
arguments, to allow the same callback to be used for different
events, or to be safe from future changes:</p>
</div></blockquote>
<p class="last">&gt; def event_callback(event_type, <a href="#id19"><span class="problematic" id="id20">**</span></a>kwargs):
&gt;     </p>
</dd>
<dt>NOTE</dt>
<dd>If you try to add the exact same callback function more than
once, Houdini will still only call the function only once in
response to an event. However, it may be useful to add the
same function if you want to register it with different
event_types.</dd>
</dl>
<p>Raises hou.OperationFailed if the event_types list argument is
empty.</p>
<p>The following example shows to set up a function thats called
whenever a certain nodes name changes:</p>
</div></blockquote>
<p>&gt; 
&gt; def name_changed(node, event_type, <a href="#id21"><span class="problematic" id="id22">**</span></a>kwargs):
&gt;     print(The geometry object is now named, node.name())
&gt; 
&gt; hou.node(/obj/geo1).addEventCallback(hou.nodeEventType.NameChanged, name_changed)</p>
<blockquote>
<div>See also hou.Node.removeEventCallback and
hou.Node.removeAllEventCallbacks.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.Node.addNodeGroup">
<code class="descname">addNodeGroup</code><span class="sig-paren">(</span><em>self</em>, <em>name=None</em><span class="sig-paren">)</span> &#x2192; hou.NodeGroup<a class="headerlink" href="#hou.Node.addNodeGroup" title="Permalink to this definition"></a></dt>
<dd><p>Add a node group to the node and return the new group.</p>
<p>If a group of the given name already exists then this function
simply returns the existing group without adding a new one. If the
name of the group is None or an empty string, then a unique default
name is automatically chosen.</p>
<p>This function can only be called on nodes that are networks. If it
is called on a node that is not a network, then it raises
hou.OperationFailed.</p>
<p>To remove a node group, use hou.NodeGroup.destroy.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.addSpareParmFolder">
<code class="descname">addSpareParmFolder</code><span class="sig-paren">(</span><em>folder_name</em>, <em>in_folder=()</em>, <em>parm_name=None</em>, <em>create_missing_folders=False</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.addSpareParmFolder" title="Permalink to this definition"></a></dt>
<dd><p>addSpareParmFolder(self, folder_name, in_folder=(), parm_name=None,
create_missing_folders=False)</p>
<blockquote>
<div><p>Adds a folder to the spare parameters.</p>
<p>Note that all the folders in a set correspond to one parameter. If
this is the first folder to go in the set, parm_name will be used as
the parameter name. Otherwise, parm_name will be ignored and the
parameter name of the first folder in the set is used.</p>
<p>If this is the first folder in the set and parm_name is None, it
will default to sparefolder0. If parm_name is already in use, a
unique name will be automatically generated.</p>
<p>If create_missing_folders is True, this method will create the
folders in in_folder that dont exist. So, this method can be used
to add spare folders and a spare parameter at the same time.</p>
<p>Note that you can add folders by passing a hou.FolderParmTemplate to
the addSpareParmTuple method, so this method is deprecated. Note
also that addSpareParmTuple is deprecated in favor of
setParmTemplateGroup.</p>
<p>See also the removeSpareParmFolder and addSpareParmTuple methods.</p>
<p>This method is deprecated in favor of setParmTemplateGroup.</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.Node.addSpareParmTuple">
<code class="descname">addSpareParmTuple</code><span class="sig-paren">(</span><em>parm_template</em>, <em>in_folder=()</em>, <em>create_missing_folders=False</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.addSpareParmTuple" title="Permalink to this definition"></a></dt>
<dd><p>addSpareParmTuple(self, parm_template, in_folder=(),
create_missing_folders=False) -&gt; hou.ParmTuple</p>
<blockquote>
<div><p>Add a spare parameter tuple to the end of the parameters on the
node. If in_folder is not an empty sequence, this method adds the
parameters to the end of the parameters in a particular folder.</p>
<dl class="docutils">
<dt>parm_template</dt>
<dd>A hou.ParmTemplate subclass instance that specifies the type of
parameter tuple, the default value, range, etc.</dd>
<dt>in_folder</dt>
<dd>A sequence of folder names specifying which folder will hold the
parameter. If this parameter is an empty sequence (e.g. ()),
Houdini will not put the parameter inside a folder. If it is,
for example, (Misc, Controls), Houdini puts it inside the
Controls folder thats inside the Misc folder. If it is, for
example, (Misc,), Houdini puts it inside the Misc folder.</dd>
<dt>create_missing_folders</dt>
<dd>If True, and the folder location specified by in_folder does not
exist, this method creates the missing containing folders.</dd>
</dl>
<p>Note that this method can add a single folder by passing a
hou.FolderParmTemplate for parm_template.</p>
<p>See also the removeSpareParmTuple() and addSpareParmFolder()
methods.</p>
<p>This method is deprecated in favor of setParmTemplateGroup.</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.Node.allItems">
<code class="descname">allItems</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.NetworkMovableItem<a class="headerlink" href="#hou.Node.allItems" title="Permalink to this definition"></a></dt>
<dd><p>Return a tuple containing all the children of this node. Unlike
children, this method will also return hou.NetworkBox,
hou.SubnetIndirectInput, hou.StickyNote, and hou.NetworkDot objects.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.allNodes">
<code class="descname">allNodes</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; generator of hou.Node<a class="headerlink" href="#hou.Node.allNodes" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Recursively return a sequence of all nodes contained in this node
including this node. This method differs from
hou.Node.allSubChildren in the following ways:</div></blockquote>
<ul>
<li><p class="first">It includes this node in the returned sequence.</p>
</li>
<li><p class="first">It does not guarantee a top-down or bottom-up traversal order.</p>
</li>
<li><p class="first">The method is a generator and does not return a tuple so it is not
safe to create or delete nodes while looping through the return
value.</p>
<p>Here is an example of printing out the paths for all nodes under
/obj:</p>
</li>
</ul>
<p>&gt; root_node = hou.node(/obj)
&gt; for node in root_node.allNodes():
&gt;     print node.path()</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.allParms">
<code class="descname">allParms</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; generator of hou.Parm<a class="headerlink" href="#hou.Node.allParms" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Recursively return a sequence of all the parameters on all of the
nodes contained in this node including this node.</p>
<p>This method is a generator and does not return a tuple.</p>
<p>Here is an example of printing out the parameter paths for all nodes
under /obj:</p>
</div></blockquote>
<p>&gt; root_node = hou.node(/obj)
&gt; for parm in root_node.allParms():
&gt;     print parm.path()</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.allSubChildren">
<code class="descname">allSubChildren</code><span class="sig-paren">(</span><em>self</em>, <em>top_down=True</em>, <em>recurse_in_locked_nodes=True</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.allSubChildren" title="Permalink to this definition"></a></dt>
<dd><p>tuple of hou.Node</p>
<blockquote>
<div><p>Recursively return all sub children of this node. For example,
hou.node(/).allSubChildren() will return all the nodes in the hip
file.</p>
<dl class="docutils">
<dt>top_down</dt>
<dd>If True, this function will do a top-down traversal, placing a
node in the returned tuple before its children. If False, it
will do a bottom-up traversal, placing children before their
parents.</dd>
<dt>recurse_in_locked_nodes</dt>
<dd><p class="first">If True, the function will recurse inside locked child nodes
(child nodes for which the isEditable() method returns False)
and include children of the locked child nodes in the returned
tuple.</p>
<p>If False, the function will not recurse inside locked children
nodes, and children of the locked child nodes will not be
included in the returned tuple. (The locked child nodes,
however, will be included.)</p>
<p class="last">For example if &lt;recurse_in_locked_nodes&gt; is True and
hou.node(/obj) contains a Simple Female node (a locked node),
then the tuple returned by hou.node(/obj).allSubChildren()
will include the Simple Female node and its child nodes. If
&lt;recurse_in_locked_nodes&gt; is False, the returned tuple will
contain the Simple Female node, but not its child nodes.</p>
</dd>
</dl>
<p>Note that a tuple is returned, not a generator. This means that it
is safe to delete or create nodes while looping through the return
value.</p>
<p>The following function deletes all children of a particular type
that appear anywhere inside a given node:</p>
</div></blockquote>
<p>&gt; def removeSubChildrenOfType(node, node_type):
&gt;     Recursively delete all children of a particular type.
&gt;     for child in node.allSubChildren():
&gt;         if child.type() == node_type:
&gt;             child.destroy()</p>
<blockquote>
<div>This code, for example, removes all the visibility SOPs anywhere
under /obj:</div></blockquote>
<p>&gt; &gt;&gt;&gt; removeSubChildrenOfType(hou.node(/obj), hou.sopNodeTypeCategory().nodeTypes()[visibility])</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.allowEditingOfContents">
<code class="descname">allowEditingOfContents</code><span class="sig-paren">(</span><em>self</em>, <em>propagate=False</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.allowEditingOfContents" title="Permalink to this definition"></a></dt>
<dd><p>Unlocks a digital asset so its contents can be edited.</p>
<p>To use this function, you must have permission to modify the HDA.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.appendComment">
<code class="descname">appendComment</code><span class="sig-paren">(</span><em>self</em>, <em>comment</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.appendComment" title="Permalink to this definition"></a></dt>
<dd><p>Appends the given text to the comment associated with this node.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.asCode">
<code class="descname">asCode</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.asCode" title="Permalink to this definition"></a></dt>
<dd><p>asCode(self, brief=False, recurse=False, save_channels_only=False,
save_creation_commands=True, save_keys_in_frames=False,
save_outgoing_wires=False, save_parm_values_only=False,
save_spare_parms=True, function_name=None) -&gt; str</p>
<blockquote>
<div><p>Prints the Python code necessary to recreate a node.</p>
<dl class="docutils">
<dt>brief</dt>
<dd>Do not set values if they are the parameters default. Applies
to the contents of the node if either recurse or
save_box_contents is True.</dd>
<dt>recurse</dt>
<dd>Recursively apply to the entire operator hierarchy.</dd>
<dt>save_box_contents</dt>
<dd>Script the contents of the node.</dd>
<dt>save_channels_only</dt>
<dd>Only output channels. Applies to the contents of the node if
either recurse or save_box_contents is True.</dd>
<dt>save_creation_commands</dt>
<dd>Generate a creation script for the node. If set to False, the
generated script assumes that the network box already exists.
When set to True, the script will begin by creating the network
box.</dd>
<dt>save_keys_in_frames</dt>
<dd>Output channel and key times in samples (frames) instead of
seconds. Applies to the contents of the node if either recurse
or save_box_contents is True.</dd>
<dt>save_parm_values_only</dt>
<dd>Evaluate parameters, saving their values instead of the
expressions. Applies to the contents of the node if either
recurse or save_box_contents is True.</dd>
<dt>save_spare_parms</dt>
<dd>Save spare parameters as well. When save_creation_commands is
True, commands for creating spare parameters will also be
output. Applies to the contents of the node if either recurse or
save_box_contents is True.</dd>
<dt>function_name</dt>
<dd>If a function_name is specified, the output will be wrapped in a
Python function.</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.Node.cachedUserData">
<code class="descname">cachedUserData</code><span class="sig-paren">(</span><em>self</em>, <em>name</em><span class="sig-paren">)</span> &#x2192; str or None<a class="headerlink" href="#hou.Node.cachedUserData" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Return the user-defined cached data with this name, or None if no
data with this name exists.</p>
<p>See hou.Node.setCachedUserData for more information.</p>
<p>This method can be implemented as follows:</p>
</div></blockquote>
<p>&gt; def cachedUserData(self, name):
&gt;     return self.cachedUserDataDict().get(name)</p>
<blockquote>
<div>Note that None is a valid value for a key, so the most reliable way
to check if a key is valid is to check if it is in the result of
cachedUserDataDict:</div></blockquote>
<p>&gt; &gt;&gt;&gt; n = hou.node(/obj).createNode(geo)
&gt; &gt;&gt;&gt; n.cachedUserDataDict()
&gt; {}
&gt; &gt;&gt;&gt; print n.cachedUserData(foo)
&gt; None
&gt; &gt;&gt;&gt; foo in n.cachedUserDataDict()
&gt; False
&gt; &gt;&gt;&gt; n.setCachedUserData(foo, None)
&gt; &gt;&gt;&gt; n.cachedUserDataDict()
&gt; {foo: None}
&gt; &gt;&gt;&gt; print n.cachedUserData(foo)
&gt; None
&gt; &gt;&gt;&gt; foo in n.cachedUserDataDict()
&gt; True</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.cachedUserDataDict">
<code class="descname">cachedUserDataDict</code><span class="sig-paren">(</span><em>self</em>, <em>name</em><span class="sig-paren">)</span> &#x2192; dict of str to str<a class="headerlink" href="#hou.Node.cachedUserDataDict" title="Permalink to this definition"></a></dt>
<dd><p>Return a dictionary containing all the user-defined name/string
pairs for this node.</p>
<p>See hou.Node.setCachedUserData for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.canCreateDigitalAsset">
<code class="descname">canCreateDigitalAsset</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.Node.canCreateDigitalAsset" title="Permalink to this definition"></a></dt>
<dd><p>Return True if hou.Node.createDigitalAsset can succeed.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.canGenerateCookCode">
<code class="descname">canGenerateCookCode</code><span class="sig-paren">(</span><em>self</em>, <em>check_parent=False</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.Node.canGenerateCookCode" title="Permalink to this definition"></a></dt>
<dd><p>Return True if the node can generate compiled cook code and False
otherwise.</p>
<p>If check_parent is true, the parents in the ancestor hierarchy are
tested if any of them can generate code.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.changeNodeType">
<code class="descname">changeNodeType</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.changeNodeType" title="Permalink to this definition"></a></dt>
<dd><p>changeNodeType(self, new_node_type, keep_name=True, keep_parms=True,
keep_network_contents=True, force_change_on_node_type_match=False) -&gt;
hou.Node</p>
<blockquote>
<div><p>Changes the node to a new type (within the same context).
new_node_type is the internal string name of the type you want to
change to.</p>
<p>Keep_name, keep_parms, and keep_network_contents indicate that the
node should keep the same name, parameter values, and contents,
respectively, after its type has changed.
force_change_on_node_type_match indicates whether to perform the
change even when is already of the specified type.</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.Node.childTypeCategory">
<code class="descname">childTypeCategory</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.NodeTypeCategory<a class="headerlink" href="#hou.Node.childTypeCategory" title="Permalink to this definition"></a></dt>
<dd><p>Return the hou.NodeTypeCategory corresponding to the children of
this node. For example, if this node is a geometry object, the
children are SOPs. If it is an object subnet, the children are
objects.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.children">
<code class="descname">children</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.Node<a class="headerlink" href="#hou.Node.children" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Return a list of nodes that are children of this node. Using the
file system analogy, a nodes children are like the contents of a
folder/directory.</p>
<p>To find the number of children nodes, use len(node.children()).</p>
<p>The order of the children in the result is the same as the user
defined ordering in Houdini. To see this order, switch the network
view pane into list mode, and ensure that the list order is set to
user defined. To reorder nodes, drag and drop them in the list.</p>
</div></blockquote>
<p>&gt; def pc(node):
&gt;     Print the names of the children of a particular node.  This function
&gt;        can be handy when working interactively in the Python shell.
&gt;     for child in node.children():
&gt;         print child.name()
&gt; 
&gt; def ls():
&gt;     Print the names of the nodes under the current node.
&gt;     pc(hou.pwd())</p>
<blockquote>
<div>The following expression evaluates to a list of children of a
particular node type:</div></blockquote>
<p>&gt; [c for c in node.children() if c.type() == node_type]</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.clearParmAliases">
<code class="descname">clearParmAliases</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.clearParmAliases" title="Permalink to this definition"></a></dt>
<dd><p>Removes all alias names from parameters on the node.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.collapseIntoSubnet">
<code class="descname">collapseIntoSubnet</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.collapseIntoSubnet" title="Permalink to this definition"></a></dt>
<dd><p>collapseIntoSubnet(self, child_nodes, subnet_name=None,
subnet_type=None) -&gt; hou.Node</p>
<blockquote>
<div><blockquote>
<div><p>Given a sequence of children nodes of this node, collapse them into
a subnetwork. In other words, create a subnet inside this nodes
network and move the specified children of this network inside that
subnet.</p>
<dl class="docutils">
<dt>child_nodes</dt>
<dd>The children nodes of this node that will go in the new subnet.</dd>
<dt>subnet_name</dt>
<dd>The name for the new subnet node, or None if you want Houdini to
automatically choose a name.</dd>
<dt>subnet_name</dt>
<dd>The type for the new subnet node, or None if you want Houdini to
automatically choose a primary subnetwork type, which is
recommended.</dd>
</dl>
<p>Raises hou.OperationFailed if a node inside child_nodes is not a
child of this network, or if child_nodes is an empty sequence.</p>
<p>This example function takes a single node and replaces it with a
subnet, moving the node into the subnet..</p>
</div></blockquote>
<p>&gt; def collapseSingleNodeIntoSubnet(node, subnet_name=None):
&gt;     node.parent().collapseIntoSubnet((node,), subnet_name=None)</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.Node.comment">
<code class="descname">comment</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.Node.comment" title="Permalink to this definition"></a></dt>
<dd><p>Return the nodes comment string.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.cook">
<code class="descname">cook</code><span class="sig-paren">(</span><em>self</em>, <em>force=False</em>, <em>frame_range=()</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.cook" title="Permalink to this definition"></a></dt>
<dd><p>Asks or forces the node to re-cook.</p>
<dl class="docutils">
<dt>frame_range</dt>
<dd>The frames at which to cook the object. This should be a tuple
of 2 or 3 ints giving the start frame, end frame, and optionally
a frame increment, in that order. If you supply a two-tuple
(start, end), the increment is 1.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hou.Node.cookCodeGeneratorNode">
<code class="descname">cookCodeGeneratorNode</code><span class="sig-paren">(</span><em>self</em>, <em>check_parent=False</em><span class="sig-paren">)</span> &#x2192; hou.Node<a class="headerlink" href="#hou.Node.cookCodeGeneratorNode" title="Permalink to this definition"></a></dt>
<dd><p>Return the node itself or a network node that contains this node and
can generate compiled cook code. For example, the generator node for
a VOP node could be the SHOP node or SOP node that contains it for
example.</p>
<p>Return None if this node cannot generate code and is not contained
in a code generating node either either.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.cookCodeLanguage">
<code class="descname">cookCodeLanguage</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.Node.cookCodeLanguage" title="Permalink to this definition"></a></dt>
<dd><p>Return the language of the generated cook code (i.e. VEX, RSL).</p>
<p>Raises hou.OperationFailed if this node cannot generate compiled
code.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.cookCount">
<code class="descname">cookCount</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.Node.cookCount" title="Permalink to this definition"></a></dt>
<dd><p>Returns the number of times this node has cooked in the current
session.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.copyItems">
<code class="descname">copyItems</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.copyItems" title="Permalink to this definition"></a></dt>
<dd><p>copyItems(self, items, channel_reference_originals = False,
relative_references = True, connect_outputs_to_multi_inputs = True) -&gt;
tuple of hou.NetworkMovableItem</p>
<blockquote>
<div><p>Create copies of all specified items in this network. The items do
not need to be children of this network, but all items must be
contained in the same parent network.</p>
<p>If channel_reference_originals is True, the parameters of all new
nodes are set to channel reference the original nodes. If a copied
node is a sub-network, only the top level node establishes channel
references to the original. Child nodes inside the sub-network will
be simple copies of the original child nodes. The
relative_references parameter controls whether the channel
references use relative or absolute paths to the source nodes.</p>
<p>If connect_outputs_to_multi_inputs is True, and any items being
copied have outputs connected to a multi-input node (like a Merge),
then the new item copies will also be connected to the multi-input
node. Normally copied nodes do not have any outputs to nodes outside
the copied set.</p>
<p>Returns a tuple of all the new network items.</p>
<p>Raises hou.OperationFailed if this node cannot contain children.
Raises hou.PermissionError if this node is inside a locked asset.</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.Node.copyItemsToClipboard">
<code class="descname">copyItemsToClipboard</code><span class="sig-paren">(</span><em>self</em>, <em>items</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.copyItemsToClipboard" title="Permalink to this definition"></a></dt>
<dd><p>Given a sequence of child items (nodes, network boxes, sticky notes,
etc), save them to the clipboard so they can be pasted into this or
another network.</p>
<dl class="docutils">
<dt>items</dt>
<dd>A sequence of hou.NetworkMovableItems that are children of this
node.</dd>
</dl>
<p>Raises hou.OperationFailed if any of the nodes or network boxes are
node children of this node. Raises hou.PermissionError if you do not
have permission to read the contents of this node.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.copyNetworkBox">
<code class="descname">copyNetworkBox</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.copyNetworkBox" title="Permalink to this definition"></a></dt>
<dd><p>copyNetworkBox(self, network_box_to_copy, new_name=None,
channel_reference_original=False) -&gt; hou.NetworkBox</p>
<blockquote>
<div><p>Copies a network box and returns the copy.</p>
<p>If new_name is given, the network box will be copied to a new
network box named new_name (a different name will be generated if
there is already a network box with that name).</p>
<p>If channel_reference_original is True, all operators created by the
copy will have their animatable parameters set to reference the
original operators.</p>
<p>Raises hou.OperationFailed if this node is not a network or if the
node child type does not match the network boxs node type.</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.Node.copyStickyNote">
<code class="descname">copyStickyNote</code><span class="sig-paren">(</span><em>self</em>, <em>network_box_to_copy</em>, <em>new_name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.copyStickyNote" title="Permalink to this definition"></a></dt>
<dd><p>hou.StickyNote</p>
<p>Copies a sticky note and returns the copy.</p>
<p>If new_name is given, the sticky note will be copied to a new sticky
note named new_name (a different name will be generated if there is
already a sticky note with that name).</p>
<p>Raises hou.OperationFailed if this node is not a network or if the
node child type does not match the sticky notes node type.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.copyTo">
<code class="descname">copyTo</code><span class="sig-paren">(</span><em>destination_node</em><span class="sig-paren">)</span> &#x2192; hou.Node<a class="headerlink" href="#hou.Node.copyTo" title="Permalink to this definition"></a></dt>
<dd><p>Copy this node to a new place in the node hierarchy. The new node is
placed inside the given destination node. This method returns the
new node.</p>
<p>Raises hou.OperationFailed if the destination node cannot contain
the new node. Raises hou.PermissionError if the destination node is
inside a locked asset.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.createCompiledDigitalAsset">
<code class="descname">createCompiledDigitalAsset</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.createCompiledDigitalAsset" title="Permalink to this definition"></a></dt>
<dd><p>createCompiledDigitalAsset(self, name=None, hda_file_name=None,
description=None)</p>
<blockquote>
<div><p>Create a compiled digital asset from this node. You would typically
call this method on vop network nodes, such as Material Shader
Builder SHOP, Surface Shader Builder SHOP, or VEX Surface SHOP Type
VOPNET. The digital asset does not have contents section, which
means it does not have vop network inside, but instead relies on the
saved VEX code sections to provide the shader code.</p>
<p>After the creation of a compiled HDA, if its VEX code section is
ever changed manually, the corresponding vex object code section can
be recompiled using hou.HDADefinition.compileCodeSection.</p>
<dl class="docutils">
<dt>name</dt>
<dd>The name of the node type that the new digital asset will
define.</dd>
<dt>hda_file_name</dt>
<dd>The name of the hda file where Houdini will save the digital
asset. If None Houdini will use
$HOME/houdiniX.Y/hda/OPcustom.hda.</dd>
<dt>description</dt>
<dd>The name that will appear in the tab menu. If None, Houdini will
use the name for the description.</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.Node.createDigitalAsset">
<code class="descname">createDigitalAsset</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.createDigitalAsset" title="Permalink to this definition"></a></dt>
<dd><p>createDigitalAsset(self, name=None, hda_file_name=None,
description=None, min_num_inputs=None, max_num_inputs=None,
compress_contents=False, comment=None, version=None,
save_as_embedded=False, ignore_external_references=False,
change_node_type=True, create_backup=True) -&gt; Node</p>
<blockquote>
<div><p>Create a digital asset from this node. You would typically call this
method on subnet nodes.</p>
<dl class="docutils">
<dt>name</dt>
<dd>The name of the node type that the new digital asset will
define.</dd>
<dt>hda_file_name</dt>
<dd>The name of the hda file where Houdini will save the digital
asset. If None Houdini will use
$HOME/houdiniX.Y/hda/OPcustom.hda.</dd>
<dt>description</dt>
<dd>The name that will appear in the tab menu. If None, Houdini will
use the name for the description.</dd>
<dt>min_num_inputs</dt>
<dd>The minimum number of inputs that need to be wired into
instances of the digital asset. See
hou.HDADefinition.minNumInputs for more information.</dd>
<dt>max_num_inputs</dt>
<dd>The number of input connectors available on instances of the
digital asset for input connections. See
hou.HDADefinition.minNumInputs for more information.</dd>
<dt>compress_contents</dt>
<dd>Whether or not the contents of this digital asset are compressed
inside the hda file. See hou.HDAOptions.compressContents for
more information.</dd>
<dt>comment</dt>
<dd>A user-defined comment string. See hou.HDADefinition.comment for
more information.</dd>
<dt>version</dt>
<dd>A user-defined version string. See hou.HDADefinition.version for
more information.</dd>
<dt>save_as_embedded</dt>
<dd>Whether or not the digital assets definition will be saved with
the hip file instead of an hda file. When this parameter is
True, Houdini ignores the hda_file_name parameter. Setting this
parameter to True is equivalent to setting this parameter to
False and setting the hda_file_name parameter to Embedded.</dd>
<dt>ignore_external_references</dt>
<dd>If True, Houdini will not generate warnings if the contents of
this digital asset reference nodes outside the asset.</dd>
<dt>change_node_type</dt>
<dd>Normally, Houdini will change the node creating the digital
asset into the new digital asset type. Setting this flag to
false will cause the node to remain unchanged.</dd>
<dt>create_backup</dt>
<dd>Create a backup before modifying an existing hda file.</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.Node.createInputNode">
<code class="descname">createInputNode</code><span class="sig-paren">(</span><em>input_index</em>, <em>node_type_name</em>, <em>node_name=None</em>, <em>run_init_scripts=True</em>, <em>load_contents=True</em>, <em>exact_type_name=False</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.createInputNode" title="Permalink to this definition"></a></dt>
<dd><p>createInputNode(self, input_index, node_type_name, node_name=None,
run_init_scripts=True, load_contents=True, bool exact_type_name=False)</p>
<blockquote>
<div><p>Create a new node and connect it to one of this nodes inputs.
Return the new node.</p>
<dl class="docutils">
<dt>input_index</dt>
<dd>The index of this nodes input connector.</dd>
<dt>node_type_name</dt>
<dd>The name of the type of node to create. See the createNode
method for more information.</dd>
<dt>node_name</dt>
<dd>See the createNode method for more information.</dd>
<dt>run_init_scripts</dt>
<dd>See the createNode method for more information.</dd>
<dt>load_contents</dt>
<dd>See the createNode method for more information.</dd>
<dt>exact_type_name</dt>
<dd>See the createNode method for more information.</dd>
</dl>
<p>See also the createOutputNode method.</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.Node.createNetworkBox">
<code class="descname">createNetworkBox</code><span class="sig-paren">(</span><em>self</em>, <em>name=None</em><span class="sig-paren">)</span> &#x2192; hou.NetworkBox<a class="headerlink" href="#hou.Node.createNetworkBox" title="Permalink to this definition"></a></dt>
<dd><p>Creates a network box inside this network. Raises
hou.OperationFailed if this node is not a network.</p>
<p>If you dont specify a name, Houdini gives the box a default name.</p>
<p>Network box names are not displayed in the network editor pane.
Instead, a comment can be specified with the
hou.NetworkBox.setComment method, and this comment will appear in
the title bar of the network box.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.createNetworkDot">
<code class="descname">createNetworkDot</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.NetworkDot<a class="headerlink" href="#hou.Node.createNetworkDot" title="Permalink to this definition"></a></dt>
<dd><p>Creates a network dot inside this network. Raises
hou.OperationFailed if this node is not a network.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.createNode">
<code class="descname">createNode</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.createNode" title="Permalink to this definition"></a></dt>
<dd><p>createNode(self, node_type_name, node_name=None, run_init_scripts=True,
load_contents=True, exact_type_name=False) -&gt; hou.Node</p>
<blockquote>
<div><blockquote>
<div><p>Create a new node of type node_type_name as a child of this node.</p>
<dl class="docutils">
<dt>node_name</dt>
<dd>The name of the new node. If not specified, Houdini appends a
number to the node type name, incrementing that number until a
unique node name is found. If you specify a name and a node
already exists with that name, Houdini will append a number to
create a unique name.</dd>
<dt>run_init_scripts</dt>
<dd>If True, the initialization script associated with the node type
will be run on the new node.</dd>
<dt>load_contents</dt>
<dd>If True, any subnet contents will be loaded for custom subnet
operators.</dd>
<dt>exact_type_name</dt>
<dd>If True, the nodes type name will be exactly as specified in
the node_type_name. Otherwise, a preferred operator type that
matches the given node_type_name may be used. For example, the
given hda may match a newer version hda::2.0, or if there
are two available operators namespaceA::hda and
namespaceB::hda, and the namespaceB has precedence, then the
created node will be of type namespaceB::hda.</dd>
</dl>
<p>Raises hou.OperationFailed if this node cannot contain children.
Raises hou.PermissionError if this node is inside a locked asset.</p>
</div></blockquote>
<p>&gt; &gt;&gt;&gt; obj = hou.node(/obj)
&gt; 
&gt; # Let Houdini choose a name based on the node type name.
&gt; &gt;&gt;&gt; obj.createNode(geo)
&gt; &lt;hou.ObjNode of type geo at /obj/geo1&gt;
&gt; 
&gt; # Let Houdini choose a unique name.
&gt; &gt;&gt;&gt; obj.createNode(geo)
&gt; &lt;hou.ObjNode of type geo at /obj/geo2&gt;
&gt; 
&gt; # Give the node a specific name.
&gt; &gt;&gt;&gt; obj.createNode(geo, foo)
&gt; &lt;hou.ObjNode of type geo at /obj/foo&gt;
&gt; 
&gt; # Let Houdini create a unique name from our suggested name.  Also, dont
&gt; # run the geometry object init scripts so the contents are empty.
&gt; &gt;&gt;&gt; obj.createNode(geo, geo1, run_init_scripts=False)
&gt; &lt;hou.ObjNode of type geo at /obj/geo3&gt;
&gt; &gt;&gt;&gt; obj.node(geo1).children()
&gt; (&lt;hou.SopNode of type file at /obj/geo1/file1&gt;,)
&gt; &gt;&gt;&gt; obj.node(geo3).children()
&gt; ()</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.Node.createOrMoveVisualizer">
<code class="descname">createOrMoveVisualizer</code><span class="sig-paren">(</span><em>self</em>, <em>output_index</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.createOrMoveVisualizer" title="Permalink to this definition"></a></dt>
<dd><p>Creates a node for visualizing the data from a particular output of
this node. If a visualizer node already exists in the current
network, it is moved and connected to the specified output_index.
This method is only implemented for SOP and VOP nodes. Other node
types do nothing when this method is called.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.createOutputNode">
<code class="descname">createOutputNode</code><span class="sig-paren">(</span><em>node_type_name</em>, <em>node_name=None</em>, <em>run_init_scripts=True</em>, <em>load_contents=True</em>, <em>exact_type_name=False</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.createOutputNode" title="Permalink to this definition"></a></dt>
<dd><p>createOutputNode(self, node_type_name, node_name=None,
run_init_scripts=True, load_contents=True, bool exact_type_name=False)</p>
<blockquote>
<div><p>Create a new node and connect its first input to this nodes (first)
output. Return the new node.</p>
<p>See the createNode method for more information on the parameters.</p>
<p>See also the createInputNode method.</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.Node.createStickyNote">
<code class="descname">createStickyNote</code><span class="sig-paren">(</span><em>self</em>, <em>name=None</em><span class="sig-paren">)</span> &#x2192; hou.StickyNote<a class="headerlink" href="#hou.Node.createStickyNote" title="Permalink to this definition"></a></dt>
<dd><p>Creates a sticky note inside this network. Raises
hou.OperationFailed if this node is not a network.</p>
<p>If you dont specify a name, Houdini gives the note a default name.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.creationTime">
<code class="descname">creationTime</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; datetime.datetime<a class="headerlink" href="#hou.Node.creationTime" title="Permalink to this definition"></a></dt>
<dd><p>Return the date and time when the node was created.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.creator">
<code class="descname">creator</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.creator" title="Permalink to this definition"></a></dt>
<dd><p>isBuiltExplicitly(self) -&gt; bool</p>
<blockquote>
<div>Return whether this node was built explicitly (defaults to True).
Most nodes are built explicitly, but some are implicitly created by
Houdini. For example, if you select geometry from multiple SOPs and
then perform an operation, Houdini will put down an implicit merge
SOP before performing that operation. When reselecting geometry in
SOPs, Houdini will automatically delete any SOPs that were created
implicitly.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.Node.creatorState">
<code class="descname">creatorState</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.Node.creatorState" title="Permalink to this definition"></a></dt>
<dd><p>This returns the name of the viewport tool that was used to be
created. This name is not set by default and is usually the empty
string.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.dataBlock">
<code class="descname">dataBlock</code><span class="sig-paren">(</span><em>self</em>, <em>key</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.Node.dataBlock" title="Permalink to this definition"></a></dt>
<dd><p>Returns the data block stored under the given key. This method will
only work if the specified data block is has a type that can be
represented by a python object. Otherwise None is returned.</p>
<p>Raises hou.ValueError if the provided key is not assocaited with any
data block on this node.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.dataBlockKeys">
<code class="descname">dataBlockKeys</code><span class="sig-paren">(</span><em>self</em>, <em>blocktype</em><span class="sig-paren">)</span> &#x2192; tuple of str<a class="headerlink" href="#hou.Node.dataBlockKeys" title="Permalink to this definition"></a></dt>
<dd><p>Return the names of all data blocks stored on this node that are of
the data type specified by the blocktype parameter.</p>
<p>Data blocks are similar to user data in that they can contain any
extra data that may be useful to attach to a specific node. They
differ from user data in that data blocks are designed to more
efficiently handle large blocks of data. Data blocks can also
contain binary data, and have a data type associated with each
block.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.dataBlockType">
<code class="descname">dataBlockType</code><span class="sig-paren">(</span><em>self</em>, <em>key</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.Node.dataBlockType" title="Permalink to this definition"></a></dt>
<dd><p>Return the data type of the block specified by the key parameter.</p>
<p>Raises hou.ValueError if the provided key is not assocaited with any
data block on this node.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.deleteItems">
<code class="descname">deleteItems</code><span class="sig-paren">(</span><em>self</em>, <em>items</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.deleteItems" title="Permalink to this definition"></a></dt>
<dd><p>Destroys all the items in the provided tuple of
hou.NetworkMovableItem objects. This is significantly more efficient
than looping over the items and calling destroy() on each one. It
also safely handles cases where one object may not be allowed to be
deleted unless another object is also deleted.</p>
<p>Raises hou.OperationFailed if one or more of the provided items is
not a child of this node. Raises hou.PermissionError if this node is
or is inside a locked digital asset.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.deleteScript">
<code class="descname">deleteScript</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.Node.deleteScript" title="Permalink to this definition"></a></dt>
<dd><p>Return the script that will run when this node is deleted.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.dependents">
<code class="descname">dependents</code><span class="sig-paren">(</span><em>self</em>, <em>include_children = True</em><span class="sig-paren">)</span> &#x2192; tuple of hou.Node<a class="headerlink" href="#hou.Node.dependents" title="Permalink to this definition"></a></dt>
<dd><p>Return a tuple of nodes that are reference this node, either through
parameter expressions, referring to the node by name, or using
expressions which rely on the data generated by this node. These
reflect all the other ways (besides connecting to an input) in which
one node may affect another.</p>
<p>Note that the result can differ depending last cook of the nodes.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.destroy">
<code class="descname">destroy</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.destroy" title="Permalink to this definition"></a></dt>
<dd><p>Delete this node.</p>
<p>If you call methods on a Node instance after it has been destroyed,
Houdini will raise hou.ObjectWasDeleted.</p>
<p>Raises hou.OperationFailed if you try to delete a node inside a
locked asset.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.destroyCachedUserData">
<code class="descname">destroyCachedUserData</code><span class="sig-paren">(</span><em>self</em>, <em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.destroyCachedUserData" title="Permalink to this definition"></a></dt>
<dd><p>Remove the user-defined cached data with this name.</p>
<p>See hou.Node.setCachedUserData for more information.</p>
<p>Raises hou.OperationFailed if no user data with this name exists.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.destroyUserData">
<code class="descname">destroyUserData</code><span class="sig-paren">(</span><em>self</em>, <em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.destroyUserData" title="Permalink to this definition"></a></dt>
<dd><p>Remove the user-defined data with this name.</p>
<p>See hou.Node.setUserData for more information.</p>
<p>Raises hou.OperationFailed if no user data with this name exists.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.editableInputString">
<code class="descname">editableInputString</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.editableInputString" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.Node.errors">
<code class="descname">errors</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of str<a class="headerlink" href="#hou.Node.errors" title="Permalink to this definition"></a></dt>
<dd><p>Return the text of any errors from the last cook of this node, or an
empty tuple if there were no errors.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.evalParm">
<code class="descname">evalParm</code><span class="sig-paren">(</span><em>self</em>, <em>parm_path</em><span class="sig-paren">)</span> &#x2192; int, float, or str<a class="headerlink" href="#hou.Node.evalParm" title="Permalink to this definition"></a></dt>
<dd><p>Evaluates the specified parameter and returns the result.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.evalParmTuple">
<code class="descname">evalParmTuple</code><span class="sig-paren">(</span><em>self</em>, <em>parm_path</em><span class="sig-paren">)</span> &#x2192; tuple of int, float, or str<a class="headerlink" href="#hou.Node.evalParmTuple" title="Permalink to this definition"></a></dt>
<dd><p>Evaluates the specified parameter tuple and returns the result.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.eventCallbacks">
<code class="descname">eventCallbacks</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.eventCallbacks" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.Node.expressionLanguage">
<code class="descname">expressionLanguage</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.exprLanguage enum value<a class="headerlink" href="#hou.Node.expressionLanguage" title="Permalink to this definition"></a></dt>
<dd><p>Return the nodes default expression language.</p>
<p>When you enter an expression in a parameter that does not already
contain an expression, the nodes expression language is used to
determine how that expression should be evaluated. You can change a
nodes expression language in the parameter dialog in the GUI.</p>
<p>Changing the nodes expression language will not change the language
in parameters already containing expressions (i.e. parameters with
keyframes).</p>
<p>Note that if a parameter already contains an expression and you
change that expression in the GUI, the expression language will not
change, regardless of the value of the nodes expression language.
To change the language of an existing expression in a parameter from
Python, use hou.Parm.setExpression, as in
parm.setExpression(parm.expression(), language).</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.extractAndDelete">
<code class="descname">extractAndDelete</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.NetworkMovableItem<a class="headerlink" href="#hou.Node.extractAndDelete" title="Permalink to this definition"></a></dt>
<dd><p>Move the children of this subnet node to become siblings of this
node, and then delete this node. The method is the opposite of
collapseIntoSubnet(). Returns a tuple containing all extracted
items.</p>
<p>Raises hou.InvalidNodeType if this node is not a subnetwork.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.findNetworkBox">
<code class="descname">findNetworkBox</code><span class="sig-paren">(</span><em>self</em>, <em>name</em><span class="sig-paren">)</span> &#x2192; hou.NetworkBox<a class="headerlink" href="#hou.Node.findNetworkBox" title="Permalink to this definition"></a></dt>
<dd><p>Return a network box with the given name inside this node, or None
if no network box with the given name exists.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.findNetworkBoxes">
<code class="descname">findNetworkBoxes</code><span class="sig-paren">(</span><em>self</em>, <em>pattern</em><span class="sig-paren">)</span> &#x2192; tuple of hou.NetworkBox<a class="headerlink" href="#hou.Node.findNetworkBoxes" title="Permalink to this definition"></a></dt>
<dd><p>Return a list of network boxes inside this node whose names match a
pattern.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.findNodesThatProcessedObject">
<code class="descname">findNodesThatProcessedObject</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.findNodesThatProcessedObject" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.Node.findOrCreateMotionEffectsNetwork">
<code class="descname">findOrCreateMotionEffectsNetwork</code><span class="sig-paren">(</span><em>self</em>, <em>create=True</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.findOrCreateMotionEffectsNetwork" title="Permalink to this definition"></a></dt>
<dd><p>hou.chopNetNodeTypeCategory</p>
<p>Return a CHOP network node suitable for storing Motion Effects. By
default, if the node doesnt exist, it will be created.</p>
<p>See also hou.Parm.storeAsClip and hou.Node.motionEffectsNetworkPath.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.findStickyNote">
<code class="descname">findStickyNote</code><span class="sig-paren">(</span><em>self</em>, <em>name</em><span class="sig-paren">)</span> &#x2192; hou.StickyNote<a class="headerlink" href="#hou.Node.findStickyNote" title="Permalink to this definition"></a></dt>
<dd><p>Return a sticky note with the given name inside this node, or None
if no sticky note with the given name exists.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.findStickyNotes">
<code class="descname">findStickyNotes</code><span class="sig-paren">(</span><em>self</em>, <em>pattern</em><span class="sig-paren">)</span> &#x2192; tuple of hou.StickyNote<a class="headerlink" href="#hou.Node.findStickyNotes" title="Permalink to this definition"></a></dt>
<dd><p>Return a list of sticky notes inside this node whose names match a
pattern.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.glob">
<code class="descname">glob</code><span class="sig-paren">(</span><em>self</em>, <em>pattern</em>, <em>ignore_case=False</em><span class="sig-paren">)</span> &#x2192; tuple of hou.Node<a class="headerlink" href="#hou.Node.glob" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Return a tuple of children nodes name matches the pattern.</p>
<p>The pattern may contain multiple pieces, separated by spaces. An
asterisk (*) in a pattern piece will match any character. By
default, Houdini will add the nodes from each pattern piece to those
already matched. However, if the pattern piece begins with a caret
(^), Houdini will remove the matches for that piece from the result.</p>
<p>By default the pattern match is case-sensitive. Set ignore_case to
True for case-insensitive pattern matching. Note that case
insensitivity only applies when matching node names. It does not
apply when matching group, network box or bundle names.</p>
<p>This method returns an empty tuple if you pass in an empty pattern.</p>
</div></blockquote>
<p>&gt; &gt;&gt;&gt; obj = hou.node(/obj)
&gt; &gt;&gt;&gt; obj.createNode(geo, geo1)
&gt; &lt;hou.ObjNode of type geo at /obj/geo1&gt;
&gt; &gt;&gt;&gt; obj.createNode(geo, geo2)
&gt; &lt;hou.ObjNode of type geo at /obj/geo2&gt;
&gt; &gt;&gt;&gt; obj.createNode(geo, grid)
&gt; &lt;hou.ObjNode of type geo at /obj/grid&gt;
&gt; &gt;&gt;&gt; obj.createNode(geo, garbage)
&gt; &lt;hou.ObjNode of type geo at /obj/garbage&gt;
&gt; &gt;&gt;&gt; obj.createNode(geo, box)
&gt; &lt;hou.ObjNode of type geo at /obj/box&gt;
&gt; 
&gt; &gt;&gt;&gt; def names(nodes):
&gt;  return [node.name() for node in nodes]
&gt; 
&gt; &gt;&gt;&gt; names(obj.glob(g*))
&gt; [geo1, geo2, grid, garbage]
&gt; &gt;&gt;&gt; names(obj.glob(ge* ga*))
&gt; [geo1, geo2, garbage]
&gt; &gt;&gt;&gt; names(obj.glob(g* ^ga*))
&gt; [geo1, geo2, grid]</p>
<blockquote>
<div>See also hou.Node.recursiveGlob.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.Node.globParms">
<code class="descname">globParms</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.globParms" title="Permalink to this definition"></a></dt>
<dd><p>globParms(self, pattern, ignore_case=False, search_label=False,
single_pattern=False) -&gt; tuple of hou.Parm</p>
<blockquote>
<div><p>Return a tuple of parameters matching the pattern.</p>
<p>The pattern may contain multiple pieces, separated by spaces. An
asterisk (*) in a pattern piece will match any character. By
default, Houdini will add the parameters from each pattern piece to
those already matched. However, if the pattern piece begins with a
caret (^), Houdini will remove the matches for that piece from the
result.</p>
<p>By default the pattern match is case-sensitive. Set ignore_case to
True for case-insensitive pattern matching. Note that case
insensitivity only applies when matching node and parameter names.
It does not apply when matching group, network box or bundle names.</p>
<p>By default, only parameters with names matching the pattern are
returned. Set search_label to True to also return parameters with
labels matching the pattern.</p>
<p>If single_pattern is True, the pattern will be treated as one
pattern even if there are spaces in the pattern.</p>
<p>This method returns an empty tuple if you pass in an empty pattern.</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.Node.hdaModule">
<code class="descname">hdaModule</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.hdaModule" title="Permalink to this definition"></a></dt>
<dd><p>hm(self) -&gt; hou.HDAModule</p>
<blockquote>
<div><p>This method is a shortcut for self.hdaModule().</p>
<p>See also hou.phm.</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.Node.hide">
<code class="descname">hide</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.hide" title="Permalink to this definition"></a></dt>
<dd><p>Hide or show a node in the network editor. See hou.Node.isHidden for
more information about hidden nodes.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.hm">
<code class="descname">hm</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.hm" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.Node.indirectInputs">
<code class="descname">indirectInputs</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.SubnetIndirectInput<a class="headerlink" href="#hou.Node.indirectInputs" title="Permalink to this definition"></a></dt>
<dd><p>Return the hou.SubnetIndirectInput objects of a subnet.</p>
<p>Raises hou.InvalidNodeType if this node is not a subnetwork.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.infoTree">
<code class="descname">infoTree</code><span class="sig-paren">(</span><em>self</em>, <em>verbose=False</em>, <em>debug=False</em><span class="sig-paren">)</span> &#x2192; hou.NodeInfoTree<a class="headerlink" href="#hou.Node.infoTree" title="Permalink to this definition"></a></dt>
<dd><p>Returns a tree structure containing information about the node and
its most recently cooked data. The contents of the tree vary widely
depending on the node type, and the nature of its cooked data. This
tree of data is used to generate the node information window
contents.</p>
<p>Setting verbose to True will cause some additional information to be
generated. In particular data that is expensive to calculate, or
which will generate a large amount of information tends to be
generated only if this option is turned on.</p>
<p>Setting debug to True will, in a few cases, cause additional
information to be displayed which generally will be most useful when
debugging the internal opreation of Houdini. For example, geometry
attributes will display their data ids, which can be helpful when
tracking down errors in SOPs written with the HDK.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.inputAncestors">
<code class="descname">inputAncestors</code><span class="sig-paren">(</span><em>self</em>, <em>include_ref_inputs=True</em>, <em>follow_subnets=False</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.inputAncestors" title="Permalink to this definition"></a></dt>
<dd><p>tuple of hou.Node</p>
<p>Return a tuple of all input ancestors of this node. If
include_ref_inputs is False, then reference inputs are not
traversed. If follow_subnets is True, then instead of treating
subnetwork nodes as a single node, we also traverse its children
starting with its display node.</p>
<p>See also the inputs() method.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.inputConnections">
<code class="descname">inputConnections</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.NodeConnection<a class="headerlink" href="#hou.Node.inputConnections" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Returns a tuple of hou.NodeConnection objects for the connections
coming into the top of this node. The tuple will have a length equal
to the number of connections coming into the node. Returns an empty
tuple if nothing is connected to this node.</p>
<p>To get a list of the connected nodes themselves, use
hou.Node.inputs. To get a list of all possible connection sites
(whether or not anything is connected to them), use
hou.Node.inputConnectors.</p>
</div></blockquote>
<p>&gt; &gt;&gt;&gt; cookie = hou.node(/obj).createNode(geo).createNode(cookie)
&gt; &gt;&gt;&gt; cookie.setInput(1, cookie.parent().createNode(box))
&gt; &gt;&gt;&gt; cookie.inputConnections()
&gt; (&lt;hou.NodeConnection from grid1 output 0 to cookie input 1&gt;,)
&gt; &gt;&gt;&gt; cookie.inputConnectors()
&gt; ((), (&lt;hou.NodeConnection from grid1 output 0 to cookie input 1&gt;,))</p>
<blockquote>
<div>See also hou.Node.inputConnectors.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.Node.inputConnectors">
<code class="descname">inputConnectors</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of tuple of hou.NodeConnection<a class="headerlink" href="#hou.Node.inputConnectors" title="Permalink to this definition"></a></dt>
<dd><p>Return a tuple of tuples of hou.NodeConnection objects. The length
of the result tuple is equal to the maximum number of inputs that
can be connected to this node. Each subtuple contains exactly one
node connection if something is wired into the connector; otherwise
it is the empty tuple.</p>
<p>See also hou.NodeConnection and hou.Node.inputConnections.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.inputIndex">
<code class="descname">inputIndex</code><span class="sig-paren">(</span><em>self</em>, <em>input_name</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.inputIndex" title="Permalink to this definition"></a></dt>
<dd><p>Obtains an index of a node input that has the given name.</p>
<p>For the node categories that use input names, it returns the index
of the input with the given name. For VOP nodes, the name may also
be a node parameter name that has a corresponding input.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.inputLabels">
<code class="descname">inputLabels</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of str<a class="headerlink" href="#hou.Node.inputLabels" title="Permalink to this definition"></a></dt>
<dd><p>Returns a tuple of all input labels for this node. Labels for input
connectors that are hidden are also included.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.inputNames">
<code class="descname">inputNames</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of str<a class="headerlink" href="#hou.Node.inputNames" title="Permalink to this definition"></a></dt>
<dd><p>Returns a tuple of all input names for this node. Names for input
connectors that are hidden are also included.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.inputs">
<code class="descname">inputs</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.Node<a class="headerlink" href="#hou.Node.inputs" title="Permalink to this definition"></a></dt>
<dd><p>Return a tuple of the nodes connected to this nodes inputs. If an
input is connected to a hou.SubnetIndirectInput, the node connected
to the corresponding input on the parent subnet is returned. In
other words the presence of the indirect input is hidden. This means
the resulting nodes may not all be siblings of the calling node.</p>
<p>If a particular input is not connected (or is connected to an
indirect input and the corresponding subnet parent input is not
connected), a None value is placed in the tuple at that location.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.insertInput">
<code class="descname">insertInput</code><span class="sig-paren">(</span><em>self</em>, <em>input_index</em>, <em>item_to_become_input</em>, <em>output_index=0</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.insertInput" title="Permalink to this definition"></a></dt>
<dd><p>Insert an input wire. In other words, for each input connector after
input_index, shift the contents of that input connector to the next
one, and then call hou.Node.setInput. See hou.Node.setInput for the
meanings of the parameters.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.isBuiltExplicitly">
<code class="descname">isBuiltExplicitly</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.isBuiltExplicitly" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.Node.isCompiled">
<code class="descname">isCompiled</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.isCompiled" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.Node.isCurrent">
<code class="descname">isCurrent</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.Node.isCurrent" title="Permalink to this definition"></a></dt>
<dd><p>Return a boolean to indicate of the node is the last selected node
in its network.</p>
<p>Each network (i.e. node containing children) stores its own list of
selected nodes, and the last selected node has special meaning. For
example, it is the node displayed in unpinned parameter panes.</p>
<p>See also hou.selectedNodes to get a tuple of all the selected nodes
in all networks in Houdini. The last node in this list also has
special meaning in Houdini, and corresponds to the global current
node.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.isDisplayDescriptiveNameFlagSet">
<code class="descname">isDisplayDescriptiveNameFlagSet</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.Node.isDisplayDescriptiveNameFlagSet" title="Permalink to this definition"></a></dt>
<dd><p>Return a boolean to indicate of the node should display its
descriptive name in the network editor.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.isEditable">
<code class="descname">isEditable</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.Node.isEditable" title="Permalink to this definition"></a></dt>
<dd><p>Return True if the node is editable. This is similar to the
hou.Node.isEditableInsideLockedHDA method except that it will return
True for nodes that are not inside a locked HDA. This function is
the simplest way to determine if most node modifications (changing
inputs, changing parameters, changing flags) will be allowed on the
node.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.isEditableInsideLockedHDA">
<code class="descname">isEditableInsideLockedHDA</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.Node.isEditableInsideLockedHDA" title="Permalink to this definition"></a></dt>
<dd><p>Return True if the node is an editable node contained inside a
locked HDA node and False otherwise. In particular this function
will return False for a node that is not inside a locked HDA.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.isFlagReadable">
<code class="descname">isFlagReadable</code><span class="sig-paren">(</span><em>self</em>, <em>flag</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.Node.isFlagReadable" title="Permalink to this definition"></a></dt>
<dd><p>Return True if the specified flag is readable and False otherwise.</p>
<p>flag must be a hou.nodeFlag value.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.isFlagWritable">
<code class="descname">isFlagWritable</code><span class="sig-paren">(</span><em>self</em>, <em>flag</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.Node.isFlagWritable" title="Permalink to this definition"></a></dt>
<dd><p>Return True if the specified flag is writable and False otherwise.</p>
<p>flag must be a hou.nodeFlag value.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.isGenericFlagSet">
<code class="descname">isGenericFlagSet</code><span class="sig-paren">(</span><em>self</em>, <em>flag</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.Node.isGenericFlagSet" title="Permalink to this definition"></a></dt>
<dd><p>Returns the value of the specific flag.</p>
<p>flag must be a hou.nodeFlag value.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.isHidden">
<code class="descname">isHidden</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.isHidden" title="Permalink to this definition"></a></dt>
<dd><p>Return whether the node is hidden in the network editor. Note that
Houdini also uses the term exposed to refer to nodes that are not
hidden.</p>
<p>If a visible node is connected to a hidden node, the network editor
will display dashed lines for the wire going from the visible node
to the hidden node.</p>
<p>See also hou.Node.hide.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.isInsideLockedHDA">
<code class="descname">isInsideLockedHDA</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.Node.isInsideLockedHDA" title="Permalink to this definition"></a></dt>
<dd><p>Return whether this node is inside a locked digital asset. If this
node is not inside a locked HDA, the node may deviate from the HDA
definition.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.isLockedHDA">
<code class="descname">isLockedHDA</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.Node.isLockedHDA" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>If this node is an instance of a digital asset, return whether or
not it is locked. Otherwise, return False.</p>
<p>To differentiate between unlocked digital assets and nodes that are
not instances of digital assets, check if the nodes type has a
definition:</p>
</div></blockquote>
<p>&gt; def isUnlockedAsset(node):
&gt;     return not node.isLockedHDA() and node.type().definition() is not None</p>
<blockquote>
<div>See hou.HDADefinition.updateFromNode for an example of how to save
and lock all unlocked digital asset instances.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.Node.isNetwork">
<code class="descname">isNetwork</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.Node.isNetwork" title="Permalink to this definition"></a></dt>
<dd><p>Return True if this node is a network, in other words a node that
may contain child nodes. Otherwise return False which indicates that
several other methods such as hou.Node.createNode will raise
hou.OperationFailed if they are called.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.isSubNetwork">
<code class="descname">isSubNetwork</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.isSubNetwork" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.Node.isTimeDependent">
<code class="descname">isTimeDependent</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.Node.isTimeDependent" title="Permalink to this definition"></a></dt>
<dd><p>Return whether the node is time dependent. A time dependent node is
re-evaluated every time the frame changes.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.item">
<code class="descname">item</code><span class="sig-paren">(</span><em>self</em>, <em>item_path</em><span class="sig-paren">)</span> &#x2192; hou.NetworkMovableItem or None<a class="headerlink" href="#hou.Node.item" title="Permalink to this definition"></a></dt>
<dd><p>Return the network item at the given path, or None if no such item
exists. If you pass in a relative path (i.e. the path does not start
with /), searches are performed relative to this node.</p>
<p>If the path is an absolute path (i.e. it starts with /), this method
is a shortcut for hou.item(node_path). Otherwise, it is a shortcut
for hou.item(self.path() + / + item_path). See also hou.item.</p>
<p>Note that the return value may be an instance of a subclass of
NetworkMovableItem. For example, if the item being found is an
object node, the return value will be a hou.ObjNode instance. If the
item is a nework box, the return value will be a hou.NetworkBox
instance.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.items">
<code class="descname">items</code><span class="sig-paren">(</span><em>self</em>, <em>item_path_tuple</em><span class="sig-paren">)</span> &#x2192; tuple of hou.NetworkMovableItem or None<a class="headerlink" href="#hou.Node.items" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>This is like item() but takes multiple paths and returns multiple
NetworkMovableItem objects. This is the equivalent of:</div></blockquote>
<p>&gt; items = [self.item(path) for path in paths]</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.iterNetworkBoxes">
<code class="descname">iterNetworkBoxes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.iterNetworkBoxes" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.Node.iterStickyNotes">
<code class="descname">iterStickyNotes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.iterStickyNotes" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.Node.layoutChildren">
<code class="descname">layoutChildren</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.layoutChildren" title="Permalink to this definition"></a></dt>
<dd><p>layoutChildren(self, items=(), horizontal_spacing=-1.0,
vertical_spacing=-1.0)</p>
<blockquote>
<div><p>Automatically position all or some children of this node in the
network editor.</p>
<dl class="docutils">
<dt>items</dt>
<dd>A sequence of child hou.NetworkMovableItem objects to position.
This may include nodes, dots, and/or subnet inputs. If this
sequence is empty, this method will reposition all child items
of this node.</dd>
<dt>horizontal_spacing</dt>
<dd>A fraction of the width and height of a tile that affects the
space between nodes with common inputs. If this parameter is -1,
Houdini uses the default spacing.</dd>
<dt>vertical_spacing</dt>
<dd>A fraction of the width and height of a tile that affects the
space between a node and its output nodes. If this parameter is
-1, Houdini uses the default spacing.</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.Node.loadChildrenFromFile">
<code class="descname">loadChildrenFromFile</code><span class="sig-paren">(</span><em>self</em>, <em>file_name</em>, <em>ignore_load_warnings=False</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.loadChildrenFromFile" title="Permalink to this definition"></a></dt>
<dd><p>Calls hou.Node.loadItemsFromFile. Provided for backward
compatibility. New code should call loadItemsFromFile directly.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.loadItemsFromFile">
<code class="descname">loadItemsFromFile</code><span class="sig-paren">(</span><em>self</em>, <em>file_name</em>, <em>ignore_load_warnings=False</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.loadItemsFromFile" title="Permalink to this definition"></a></dt>
<dd><p>Load the contents of a file (saved with hou.Node.saveItemsToFile)
into the contents of this node.</p>
<p>Raises hou.OperationFailed if the file does not exist or it is not
the correct type of file. Raises hou.PermissionError if this node is
a locked instance of a digital asset. Raises hou.LoadWarning if the
load succeeds but with warnings and ignore_load_warnings is False.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.loadParmClip">
<code class="descname">loadParmClip</code><span class="sig-paren">(</span><em>file_name</em>, <em>sample_rate=0</em>, <em>start=None</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.loadParmClip" title="Permalink to this definition"></a></dt>
<dd><p>auto-insert ocstring: HOM_Node::loadParmClip</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.localVariables">
<code class="descname">localVariables</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.localVariables" title="Permalink to this definition"></a></dt>
<dd><p>Return a list of local variables that can be referenced in parameter
expressions on this node.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.matchCurrentDefinition">
<code class="descname">matchCurrentDefinition</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.matchCurrentDefinition" title="Permalink to this definition"></a></dt>
<dd><p>If this node is an unlocked digital asset, change its contents to
match what is stored in the definition and lock it. The parameter
values are unchanged.</p>
<p>If this node is locked or is not a digital asset, this method has no
effect.</p>
<p>See also hou.Node.matchesCurrentDefinition and hou.Node.isLocked.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.matchesCurrentDefinition">
<code class="descname">matchesCurrentDefinition</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.Node.matchesCurrentDefinition" title="Permalink to this definition"></a></dt>
<dd><p>Return whether the contents of the node are locked to its type
definition.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.messages">
<code class="descname">messages</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of str<a class="headerlink" href="#hou.Node.messages" title="Permalink to this definition"></a></dt>
<dd><p>Return the text of any messages from the last cook of this node, or
an empty tuple if there were no messages.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.modificationTime">
<code class="descname">modificationTime</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; datetime.datetime<a class="headerlink" href="#hou.Node.modificationTime" title="Permalink to this definition"></a></dt>
<dd><p>Return the date and time when the node was last modified.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.motionEffectsNetworkPath">
<code class="descname">motionEffectsNetworkPath</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.Node.motionEffectsNetworkPath" title="Permalink to this definition"></a></dt>
<dd><p>Return a node path representing the location for storing clips. This
location may or may not exist. To find or create such a network, use
hou.Node.findOrCreateMotionEffectsNetwork.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.moveToGoodPosition">
<code class="descname">moveToGoodPosition</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.moveToGoodPosition" title="Permalink to this definition"></a></dt>
<dd><p>moveToGoodPosition(self, relative_to_inputs=True, move_inputs=True,
move_outputs=True, move_unconnected=True) -&gt; hou.Vector2</p>
<blockquote>
<div>Moves a node to a well-spaced position near its inputs or outputs
and returns the new position of the node.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.Node.needsToCook">
<code class="descname">needsToCook</code><span class="sig-paren">(</span><em>self</em>, <em>time=hou.time()</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.Node.needsToCook" title="Permalink to this definition"></a></dt>
<dd><p>Asks if the node needs to re-cook.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.networkBoxes">
<code class="descname">networkBoxes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.networkBoxes" title="Permalink to this definition"></a></dt>
<dd><p>iterNetworkBoxes(self) -&gt; generator of hou.NetworkBox</p>
<blockquote>
<div>Return a generator that iterates through all the network boxes
inside this node.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.Node.networkDots">
<code class="descname">networkDots</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.NetworkDot<a class="headerlink" href="#hou.Node.networkDots" title="Permalink to this definition"></a></dt>
<dd><p>Returns a tuple of all dots in this network.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.node">
<code class="descname">node</code><span class="sig-paren">(</span><em>self</em>, <em>node_path</em><span class="sig-paren">)</span> &#x2192; hou.Node or None<a class="headerlink" href="#hou.Node.node" title="Permalink to this definition"></a></dt>
<dd><p>Return the node at the given path, or None if no such node exists.
If you pass in a relative path (i.e. the path does not start with
/), searches are performed relative to this node.</p>
<p>For example, to get the parent node of a node in the the variable n,
use n.node(..). To get a child node named geo5, use
n.node(geo5). To get a sibling node named light3, use
n.node(../light3).</p>
<p>Note that the return value may be an instance of a subclass of Node.
For example, if the node being found is an object node, the return
value will be a hou.ObjNode instance.</p>
<p>If the path is an absolute path (i.e. it starts with /), this method
is a shortcut for hou.node(node_path). Otherwise, it is a shortcut
for hou.node(self.path() + / + node_path). See also <a class="reference internal" href="#hou.node">hou.node</a>.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.nodeGroup">
<code class="descname">nodeGroup</code><span class="sig-paren">(</span><em>self</em>, <em>name</em><span class="sig-paren">)</span> &#x2192; hou.NodeGroup<a class="headerlink" href="#hou.Node.nodeGroup" title="Permalink to this definition"></a></dt>
<dd><p>Return a node group contained by the node with the given name, or
None if the group does not exist.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.nodeGroups">
<code class="descname">nodeGroups</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.NodeGroup<a class="headerlink" href="#hou.Node.nodeGroups" title="Permalink to this definition"></a></dt>
<dd><p>Return the list of node groups in this node.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.nodes">
<code class="descname">nodes</code><span class="sig-paren">(</span><em>self</em>, <em>node_path_tuple</em><span class="sig-paren">)</span> &#x2192; tuple of hou.Node or None<a class="headerlink" href="#hou.Node.nodes" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>This is like node() but takes multiple paths and returns multiple
Node objects. This is the equivalent of:</div></blockquote>
<p>&gt; nodes = [self.node(path) for path in paths]</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.numItems">
<code class="descname">numItems</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.numItems" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.Node.numOrderedInputs">
<code class="descname">numOrderedInputs</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.Node.numOrderedInputs" title="Permalink to this definition"></a></dt>
<dd><p>Some nodes can have a small number of dedicated inputs with specific
meanings, followed by an arbitrary number of additional inputs,
where gaps are not permitted between the inputs (these are referred
to as unordere inputs). This is common in DOP nodes such as the
Multiple Solver DOP. This function returns the number of dedicated
(or ordered) inputs that occur before the unordered inputs begin.
This function will only return non-zero valus if the
hou.NodeType.hasUnorderedInputs function for this nodes
hou.Node.type object returns True.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.outputConnections">
<code class="descname">outputConnections</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.NodeConnection<a class="headerlink" href="#hou.Node.outputConnections" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Return a tuple of NodeConnection objects for the connections going
out of the bottom of this node. If nothing is wired into the output
of this node, return an empty tuple.</p>
<p>To get a list of the connected nodes themselves, use
hou.Node.outputs.</p>
<p>Note that this method is a shortcut for: reduce(lambda a, b: a+b,
self.outputConnectors(), ()). Since most nodes have only one output
connector, though, this method is usually equivalent to
self.outputConnectors()[0].</p>
</div></blockquote>
<p>&gt; &gt;&gt;&gt; box = hou.node(/obj).createNode(geo).createNode(box)
&gt; &gt;&gt;&gt; box.parent().createNode(xform).setFirstInput(box)
&gt; &gt;&gt;&gt; box.parent().createNode(subdivide).setFirstInput(box)
&gt; &gt;&gt;&gt; box.outputConnections()
&gt; (&lt;hou.NodeConnection from box1 output 0 to xform1 output 0&gt;, &lt;hou.NodeConnection from box1 output 0 to subdivide1 input 0&gt;)</p>
<blockquote>
<div>See also hou.node.outputConnectors.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.Node.outputConnectors">
<code class="descname">outputConnectors</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of tuple of hou.NodeConnection<a class="headerlink" href="#hou.Node.outputConnectors" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Return a a tuple of tuples of hou.NodeConnection objects. The length
of the result tuple is equal to the number of output connectors on
this node. Each subtuple contains all the connections going out of
that connector, and is empty if nothing is wired to that connector.</div></blockquote>
<p>&gt; &gt;&gt;&gt; split = hou.node(/obj).createNode(dopnet).createNode(split)
&gt; &gt;&gt;&gt; split.parent().createNode(rbdsolver).setFirstInput(split)
&gt; &gt;&gt;&gt; split.parent().createNode(gravity).setFirstInput(split, 1)
&gt; &gt;&gt;&gt; split.parent().createNode(merge).setFirstInput(split, 1)
&gt; &gt;&gt;&gt; split.outputConnectors()
&gt; ((&lt;hou.NodeConnection from split1 output 0 to rbdsolver1 input 0&gt;,), (&lt;hou.NodeConnection from split1 output 1 to gravity2 input 0&gt;, &lt;hou.NodeConnection from split1 output 1 to merge1 input 0&gt;), (), ())</p>
<blockquote>
<div>See also hou.NodeConnection and hou.Node.outputConnections.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.Node.outputIndex">
<code class="descname">outputIndex</code><span class="sig-paren">(</span><em>self</em>, <em>output_name</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.outputIndex" title="Permalink to this definition"></a></dt>
<dd><p>Obtains an index of a node output that has the given name.</p>
<p>For the node categories that use input names, it returns the index
of the output with the given name.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.outputLabels">
<code class="descname">outputLabels</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of str<a class="headerlink" href="#hou.Node.outputLabels" title="Permalink to this definition"></a></dt>
<dd><p>Returns a tuple of all output labels for this node.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.outputNames">
<code class="descname">outputNames</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of str<a class="headerlink" href="#hou.Node.outputNames" title="Permalink to this definition"></a></dt>
<dd><p>Returns a tuple of all output names for this node.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.outputs">
<code class="descname">outputs</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.Node<a class="headerlink" href="#hou.Node.outputs" title="Permalink to this definition"></a></dt>
<dd><p>Return a tuple of the nodes connected to this nodes outputs.</p>
<p>This method is a shortcut for [connection.inputNode() for connection
in self.outputConnections()].</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.parm">
<code class="descname">parm</code><span class="sig-paren">(</span><em>self</em>, <em>parm_path</em><span class="sig-paren">)</span> &#x2192; hou.Parm or None<a class="headerlink" href="#hou.Node.parm" title="Permalink to this definition"></a></dt>
<dd><p>Return the parameter at the given path, or None if the parameter
doesnt exist.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.parmAliases">
<code class="descname">parmAliases</code><span class="sig-paren">(</span><em>self</em>, <em>recurse=False</em><span class="sig-paren">)</span> &#x2192; dict of hou.Parm to str<a class="headerlink" href="#hou.Node.parmAliases" title="Permalink to this definition"></a></dt>
<dd><p>Return a dictionary of parameter aliases on the nodes parameters.
The keys in the dictionary are the parameters that have aliases and
the values are the alias names.</p>
<dl class="docutils">
<dt>recurse</dt>
<dd>Return the parameter aliases for this node _and its <a href="#id65"><span class="problematic" id="id66">children_</span></a>.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hou.Node.parmClipData">
<code class="descname">parmClipData</code><span class="sig-paren">(</span><em>start=None</em>, <em>end=None</em>, <em>binary=True</em>, <em>use_blosc_compression=True</em>, <em>sample_rate=0</em>, <em>scoped_only=False</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.parmClipData" title="Permalink to this definition"></a></dt>
<dd><p>parmClipData(start=None, end=None, binary=True,
use_blosc_compression=True, sample_rate=0, scoped_only=False) -&gt; str</p>
<blockquote>
<div><p>Returns the clip data for the parameters of this node. This method
is similar to hou.Node.saveParmClip, except that it returns the clip
data (file contents) instead of saving the animation to a clip file.</p>
<p>&lt;start&gt;, &lt;end&gt;, &lt;sample_rate&gt;, and &lt;scoped_only&gt; behave the same as
in hou.Node.saveParmClip.</p>
<p>If &lt;binary&gt; is True, return binary clip data, otherwise return plain
text (ASCII) clip data.</p>
<p>If &lt;use_blosc_compression&gt; is True, blosc compress the binary clip
data. This cannot be used for plain text (ASCII) clip data.</p>
<p>Raises a hou.OperationFailed exception if none of the parameters of
this tuple have animation.</p>
<p>Raises a hou.InvalidInput exception if start &gt;= end. If specifying
only &lt;start&gt;, ensure that the specified value is less than the
global end frame. Likewise, if specifying only &lt;end&gt;, ensure it is
larger than the global start frame.</p>
<p>Raises a hou.InvalidInput exception if binary = False and
use_blosc_compression = True.</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.Node.parmTemplateGroup">
<code class="descname">parmTemplateGroup</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.parmTemplateGroup" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.Node.parmTuple">
<code class="descname">parmTuple</code><span class="sig-paren">(</span><em>self</em>, <em>parm_path</em><span class="sig-paren">)</span> &#x2192; hou.ParmTuple or None<a class="headerlink" href="#hou.Node.parmTuple" title="Permalink to this definition"></a></dt>
<dd><p>Return the parm tuple at the given path, or None if it doesnt
exist.</p>
<p>This method is similar to parm(), except it returns a hou.ParmTuple
instead of a hou.Parm.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.parmTuples">
<code class="descname">parmTuples</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.ParmTuple<a class="headerlink" href="#hou.Node.parmTuples" title="Permalink to this definition"></a></dt>
<dd><p>Return a list of all parameter tuples on this node.</p>
<p>This method is similar to parms(), except it returns a list of
hou.ParmTuple instead of hou.Parm.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.parmTuplesInFolder">
<code class="descname">parmTuplesInFolder</code><span class="sig-paren">(</span><em>self</em>, <em>folder_names</em><span class="sig-paren">)</span> &#x2192; tuple of hou.ParmTuple<a class="headerlink" href="#hou.Node.parmTuplesInFolder" title="Permalink to this definition"></a></dt>
<dd><p>Return a list of the parameter tuples in a folder on this node. This
method is similar to parmsInFolder(), except it returns a list of
hou.ParmTuple instead of hou.Parm. See parmsInFolder() above for
information about the arguments.</p>
<p>See also hou.Parm.containingFolders and
hou.Parm.containingFolderSetParmTuples</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.parms">
<code class="descname">parms</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.Parm<a class="headerlink" href="#hou.Node.parms" title="Permalink to this definition"></a></dt>
<dd><p>Return a list of the parameters on this node.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.parmsInFolder">
<code class="descname">parmsInFolder</code><span class="sig-paren">(</span><em>self</em>, <em>folder_names</em><span class="sig-paren">)</span> &#x2192; tuple of hou.Parm<a class="headerlink" href="#hou.Node.parmsInFolder" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Return a list of parameters in a folder on this node. Returns all
parameters in the folder and its subfolders (if any).</p>
<dl class="docutils">
<dt>folder_names</dt>
<dd><p class="first">A sequence of folder name strings. For example, to get a list of
the parameters in the Shading folder of the Render folder, use
(Render, Shading). Note that by folder name, we mean the
label used in the parameter dialog, not the internal parameter
name.</p>
<p class="last">If this sequence is empty, the method returns all parameters on
the node, the same as if you called parms().</p>
</dd>
</dl>
<p>Raises hou.OperationFailed if the folder specified by folder_names
does not exist.</p>
<p>For example, suppose a node had a Render folder that contained a
Shading subfolder. Then this line of code would return the
parameters in the Render folder:</p>
</div></blockquote>
<p>&gt; # Note the trailing comma after Render to tell Python that Render is
&gt; # contained in a tuple/sequence as opposed to just a single string with
&gt; # parentheses around it.
&gt; &gt;&gt;&gt; node.parmsInFolder((Render, ))</p>
<blockquote>
<div>And this line of code would return the parameters in the Shading
subfolder.</div></blockquote>
<p>&gt; &gt;&gt;&gt; node.parmsInFolder((Render, Shading))</p>
<blockquote>
<div>See also hou.Parm.containingFolders and
hou.Parm.containingFolderSetParmTuples</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.Node.parmsReferencingThis">
<code class="descname">parmsReferencingThis</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.Parm<a class="headerlink" href="#hou.Node.parmsReferencingThis" title="Permalink to this definition"></a></dt>
<dd><p>Return a list of the parameters that reference this node.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.pasteItemsFromClipboard">
<code class="descname">pasteItemsFromClipboard</code><span class="sig-paren">(</span><em>self</em>, <em>position = None</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.pasteItemsFromClipboard" title="Permalink to this definition"></a></dt>
<dd><p>Load the contents of a file saved with hou.Node.copyItemsToClipboard
into the contents of this node. If the position parameter is given
as a tuple of two float values (or equivalent, like a hou.Vector2),
the pasted items are moved such that they are centered around the
provided position.</p>
<p>Raises hou.OperationFailed if this node is not a network, or if
there are errors loading the items from the clipboard. Raises
hou.PermissionError if this node is a locked instance of a digital
asset.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.recursiveGlob">
<code class="descname">recursiveGlob</code><span class="sig-paren">(</span><em>self</em>, <em>pattern</em>, <em>filter=hou.nodeTypeFilter.NoFilter</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.recursiveGlob" title="Permalink to this definition"></a></dt>
<dd><p>tuple of hou.Node</p>
<p>Like hou.Node.glob, return a tuple of children nodes whose name
matches the pattern. However, any matching child will have all its
children added, recursively. As well, the result may be filtered by
node type.</p>
<p>Houdini first matches children nodes against the pattern, then
recursively adds the subchildren of matching children, and then
applies the filter.</p>
<dl class="docutils">
<dt>pattern</dt>
<dd>Child node names will be matched against this string pattern.
See hou.Node.glob and hou.NodeBundle for information about the
pattern syntax. Note that if a child node matches the pattern,
all of its subchildren will be added to the result (subject to
filtering), regardless of the pattern.</dd>
<dt>filter</dt>
<dd>A hou.nodeTypeFilter enumeration value to limit matched nodes to
a particular type (e.g. object nodes, geometry object nodes,
surface shader SHOPs, etc.).</dd>
</dl>
<p>The pattern and filter behavior is very similar to that used by node
bundles in Houdini. See hou.NodeBundle for more information.</p>
<p>Raises hou.OperationFailed if the pattern is invalid.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.references">
<code class="descname">references</code><span class="sig-paren">(</span><em>self</em>, <em>include_children = True</em><span class="sig-paren">)</span> &#x2192; tuple of hou.Node<a class="headerlink" href="#hou.Node.references" title="Permalink to this definition"></a></dt>
<dd><p>Return a tuple of nodes that are referenced by this node, either
through parameter expressions, referring to the node by name, or
using expressions which rely on the data generated by another node.
These reflect all the other ways (besides connecting to an input) in
which one node may affect another.</p>
<p>Note that the result can differ depending last cook of the nodes.
Its recommended that you first call cook() on the node first.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.removeAllEventCallbacks">
<code class="descname">removeAllEventCallbacks</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.removeAllEventCallbacks" title="Permalink to this definition"></a></dt>
<dd><p>Remove all event callbacks for all event types from this node.</p>
<p>See hou.Node.addEventCallback for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.removeEventCallback">
<code class="descname">removeEventCallback</code><span class="sig-paren">(</span><em>self</em>, <em>event_types</em>, <em>callback</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.removeEventCallback" title="Permalink to this definition"></a></dt>
<dd><p>Given a callback that was previously added on this node and a
sequence of hou.nodeEventType enumerated values, remove those event
types from the set of event types for the callback. If the remaining
set of event types is empty, the callback will be removed entirely
from this node.</p>
<p>Raises hou.OperationFailed if the callback had not been previously
added.</p>
<p>See hou.Node.addEventCallback for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.removeSpareParmFolder">
<code class="descname">removeSpareParmFolder</code><span class="sig-paren">(</span><em>self</em>, <em>folder</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.removeSpareParmFolder" title="Permalink to this definition"></a></dt>
<dd><p>Removes an empty folder from the spare parameters.</p>
<p>folder is a sequence of folder names. So, to remove the Output
folder, use (Output,) instead of Output.</p>
<p>See also addSpareParmFolder(), hou.ParmTemplateGroup.remove, and
hou.ParmTemplateGroup.findFolder.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.removeSpareParmTuple">
<code class="descname">removeSpareParmTuple</code><span class="sig-paren">(</span><em>self</em>, <em>parm_tuple</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.removeSpareParmTuple" title="Permalink to this definition"></a></dt>
<dd><p>Removes the specified spare parameter tuple.</p>
<p>See also addSpareParmTuple().</p>
<p>This method is deprecated in favor of setParmTemplateGroup.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.removeSpareParms">
<code class="descname">removeSpareParms</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.removeSpareParms" title="Permalink to this definition"></a></dt>
<dd><p>Removes all spare parameters from this node.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.replaceSpareParmTuple">
<code class="descname">replaceSpareParmTuple</code><span class="sig-paren">(</span><em>self</em>, <em>parm_tuple_name</em>, <em>parm_template</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.replaceSpareParmTuple" title="Permalink to this definition"></a></dt>
<dd><p>Replace an existing spare parameter tuple with a new one. The old
parameter tuple is removed and the new one is added in its place.</p>
<dl class="docutils">
<dt>parm_tuple_name</dt>
<dd>The name of the spare parameter tuple to replace. Raises
hou.OperationFailed if no parameter tuple exists with this name,
or if it is the name of a non-spare parameter.</dd>
<dt>parm_template</dt>
<dd>A hou.ParmTemplate describing the new parameter tuple.</dd>
</dl>
<p>The new parameter tuple may or may not have the same name as the old
one. By providing a parameter tuple with the same name, you can
modify an existing spare parameter tuple.</p>
<p>Note that you cannot replace non-spare parameter tuples. However,
you can change the visibility of non-spare parameters using
hou.ParmTuple.hide.</p>
<p>To change a parameter for all instances of digital asset, use
hou.HDADefinition.replaceParmTuple.</p>
<p>This method is deprecated in favor of setParmTemplateGroup.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.runInitScripts">
<code class="descname">runInitScripts</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.runInitScripts" title="Permalink to this definition"></a></dt>
<dd><p>Runs the initialization script associated with this nodes type.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.saveChildrenToFile">
<code class="descname">saveChildrenToFile</code><span class="sig-paren">(</span><em>self</em>, <em>nodes</em>, <em>network_boxes</em>, <em>file_name</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.saveChildrenToFile" title="Permalink to this definition"></a></dt>
<dd><p>Combines separate lists of nods and network boxes into a single
sequence, and calls hou.Node.saveItemsToFile. This method is
provided for backward compatibility. New code should call
saveItemsToFile directly.</p>
<dl class="docutils">
<dt>nodes</dt>
<dd>A sequence of hou.Nodes that are children of this node.</dd>
<dt>network_boxes</dt>
<dd>A sequence of hou.NetworkBoxes that are contained in this node.
Note that the contents of the network boxes are not
automatically saved, so it is up to you to put them in the list
of nodes.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hou.Node.saveCodeToFile">
<code class="descname">saveCodeToFile</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.saveCodeToFile" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.Node.saveCompiledCookCodeToFile">
<code class="descname">saveCompiledCookCodeToFile</code><span class="sig-paren">(</span><em>self</em>, <em>file_name</em>, <em>context_name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.saveCompiledCookCodeToFile" title="Permalink to this definition"></a></dt>
<dd><p>Saves compiled VEX code to a disk file (for nodes that support
this). See hou.Node.saveCookCodeToFile for a description of the
arguments.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.saveCookCodeToFile">
<code class="descname">saveCookCodeToFile</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.saveCookCodeToFile" title="Permalink to this definition"></a></dt>
<dd><p>saveCookCodeToFile(self, file_name, skip_header=False,
context_name=None)</p>
<blockquote>
<div><p>Saves VEX/RSL source code to a disk file (on nodes that support
this).</p>
<dl class="docutils">
<dt>file_name</dt>
<dd>The file path in which to save the generated code.</dd>
<dt>skip_header</dt>
<dd>If True, the method does not write a header comment at the
beginning of the file containing the file name and node path
from which the code was generated and a time stamp.</dd>
<dt>context_name</dt>
<dd><blockquote class="first">
<div><p>A string containing name of the shader context for the code.
This option applies to nodes such as the Material Shader Builder
which can generate code for multiple context types.</p>
<p>For example, a Material network might contain both surface and
displacement shaders, so you must specify which type of shader
code to generate:</p>
</div></blockquote>
<p>&gt; node(/shop/vopmaterial1).saveCookCodeToFile(myfile.vfl, context_name=surface)</p>
<blockquote class="last">
<div><p>On single-context nodes this argument is ignored.</p>
<p>For VEX materials, possible values are surface, displacement,
light, shadow, fog, image3d, photon, or cvex.</p>
<p>For RSL materials, possible values are surface, displacement,
light, volume, or imager.</p>
</div></blockquote>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.Node.saveItemsToFile">
<code class="descname">saveItemsToFile</code><span class="sig-paren">(</span><em>self</em>, <em>items</em>, <em>file_name</em>, <em>save_hda_fallbacks = False</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.saveItemsToFile" title="Permalink to this definition"></a></dt>
<dd><p>Given a sequence of child items (nodes, network boxes, sticky notes,
etc), save a file containing those items. You can load this file
using hou.Node.loadItemsFromFile.</p>
<dl class="docutils">
<dt>items</dt>
<dd>A sequence of hou.NetworkMovableItems that are children of this
node.</dd>
<dt>file_name</dt>
<dd>The name of the file to write the contents to. You can use any
extension for this file name.</dd>
<dt>save_hda_fallbacks</dt>
<dd>Set to True to save simplified definitions for HDAs into the
file along with the child nodes. Doing this allows the generated
file to be safely loaded into any houdini session, even if the
assets used in the file are not already loaded into the houdini
session. Depending on the use of the generated file, this
information is often not required and makes the files
unnecessarily large.</dd>
</dl>
<p>Raises hou.OperationFailed if any of the nodes or network boxes are
node children of this node, or if the file could not be written to.
Raises hou.PermissionError if you do not have permission to read the
contents of this node.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.saveParmClip">
<code class="descname">saveParmClip</code><span class="sig-paren">(</span><em>file_name</em>, <em>start=None</em>, <em>end=None</em>, <em>sample_rate=0</em>, <em>scoped_only=False</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.saveParmClip" title="Permalink to this definition"></a></dt>
<dd><p>saveParmClip(self, file_name, start=None, end=None, sample_rate=0,
scoped_only=False)</p>
<blockquote>
<div><blockquote>
<div><p>Saves the animation associated with the parameters of this node to
the clip file specified by &lt;file_name&gt;. The extension of &lt;file_name&gt;
determines the format of the saved file.</p>
<p>You can use one of the following extensions:</p>
</div></blockquote>
<ul>
<li><p class="first">.clip: save animation as plain text (ASCII) clip file.</p>
</li>
<li><p class="first">.bclip: save animation as a bclip (binary clip) file.</p>
</li>
<li><p class="first">.bclip.sc: save animation as a bclip file using Blosc compression.</p>
<p>Set &lt;sample_rate&gt; to a non-zero, non-negative value to specify the
sample_rate to be used for the clip file. For example, if the
current frame rate is 24 (hou.fps), and &lt;sample_rate&gt; is set to 12,
the animation will be sampled every second frame since &lt;sample_rate&gt;
is half of the current frame rate.</p>
<p>If &lt;start&gt; is not None, start saving the animation from the
specified frame (inclusive). Otherwise, the animation will be saved
from the global start frame (inclusive).</p>
<p>Similarly, if &lt;end&gt; is not None, stop saving the animation at the
specified frame (inclusive). Otherwise, the animation will be saved
until the global end frame (inclusive).</p>
<p>The global start and end frame are specified in the Global Animation
Options window.</p>
<p>If &lt;scoped_only&gt; is True, only the animation associated with scoped
parameters will be saved. If there are no scoped parameters, the
animation associated with auto-scoped parameters will be saved.</p>
<p>If &lt;scoped_only&gt; is False, animation associated with any of the
parameters of this node will be saved.</p>
<p>Raises a hou.OperationFailed exception if none of the parameters of
this node have animation. If &lt;scoped_only&gt; is True, this exception
can be raised if none of the scoped parameters have animation, or if
none of the auto-scoped parameters have animation (if the node has
no scoped parameters).</p>
<p>Raises a hou.OperationFailed exception if there is an error saving
the animation to file.</p>
<p>Raises a hou.InvalidInput exception if start &gt;= end. If specifying
only &lt;start&gt;, ensure that the specified value is less than the
global end frame. Likewise, if specifying only &lt;end&gt;, ensure it is
larger than the global start frame.</p>
</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.Node.saveToCompiledVexFile">
<code class="descname">saveToCompiledVexFile</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.saveToCompiledVexFile" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.Node.selectedChildren">
<code class="descname">selectedChildren</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.selectedChildren" title="Permalink to this definition"></a></dt>
<dd><p>selectedChildren(self, include_hidden=False,
include_hidden_support_nodes=False) -&gt; tuple of hou.Node</p>
<blockquote>
<div><blockquote>
<div><p>Return a tuple containing the children of this node that are
selected. Note that the last selected node has special meaning, and
can also be retrieved with hou.Node.isCurrent.</p>
<dl class="docutils">
<dt>include_hidden</dt>
<dd>If False, hidden nodes are not included in the result, even if
they are selected.</dd>
<dt>include_hidden_support_nodes</dt>
<dd>If True, include in the returned tuple any hidden nodes that
exist solely to support nodes that are actually selected. This
specifically refers to VOP Parameter nodes, but may include
other support nodes as well.</dd>
</dl>
<p>The following example will print the names of all selected objects
in /obj:</p>
</div></blockquote>
<p>&gt; for n in hou.node(/obj).selectedChildren():
&gt;     print n.name()</p>
<blockquote>
<div>To find the total number of selected children nodes, use
len(node.selectedChildren()).</div></blockquote>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.Node.selectedItems">
<code class="descname">selectedItems</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.selectedItems" title="Permalink to this definition"></a></dt>
<dd><p>selectedItems(self, include_hidden=False,
include_hidden_support_nodes=False) -&gt; tuple of hou.NetworkMovableItem</p>
<blockquote>
<div><blockquote>
<div><p>Return a tuple containing the children of this node that are
selected. Unlike selectedChildren, this method will also return any
selected hou.NetworkBox, hou.SubnetIndirectInput, hou.StickyNote,
and hou.NetworkDot objects.</p>
<dl class="docutils">
<dt>include_hidden</dt>
<dd>If False, hidden nodes are not included in the result, even if
they are selected. Other network item types cannot be hidden,
and so are unaffected by the value of this parameter.</dd>
<dt>include_hidden_support_nodes</dt>
<dd>If True, include in the returned tuple any hidden nodes that
exist solely to support nodes that are actually selected. This
specifically refers to VOP Parameter nodes, but may include
other support nodes as well.</dd>
</dl>
<p>The following example will print the positions of all selected items
in /obj:</p>
</div></blockquote>
<p>&gt; for n in hou.node(/obj).selectedItems():
&gt;     print n.position()</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.Node.setBuiltExplicitly">
<code class="descname">setBuiltExplicitly</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.setBuiltExplicitly" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.Node.setCachedUserData">
<code class="descname">setCachedUserData</code><span class="sig-paren">(</span><em>self</em>, <em>name</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.setCachedUserData" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Add/set a named value on this node instance. Unlike setUserData,
values set using this method are not saved with the hip file.</p>
<p>name: A unique name (key) for the user-defined data. By using
different names, you can attach multiple pieces of user-defined data
to a node. value: The value to store. Unlike setUserData, this value
may be any Python object.</p>
<p>This name/value pair is not stored with the hip file. It is useful
for nodes implemented in Python that want to save temporary values
between cooks, to avoid recomputing them on subsequent cooks.</p>
<p>The following example illustrates how to set, access, and delete
cached user-defined data:</p>
</div></blockquote>
<p>&gt; &gt;&gt;&gt; n = hou.node(/obj).createNode(geo)
&gt; &gt;&gt;&gt; n.setCachedUserData(my data, [1, 2, {a: b, c: d}])
&gt; &gt;&gt;&gt; n.cachedUserData(my data)
&gt; [1, 2, {a: b, c: d}]
&gt; &gt;&gt;&gt; n.cachedUserDataDict()
&gt; {my data: [1, 2, {a: b, c: d}]}
&gt; &gt;&gt;&gt; n.destroyCachedUserData(my data)
&gt; &gt;&gt;&gt; n.cachedUserDataDict()
&gt; {}
&gt; &gt;&gt;&gt; print n.cachedUserData(my data)
&gt; None</p>
<blockquote>
<div>See per-node user-defined data for more information and examples.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.Node.setComment">
<code class="descname">setComment</code><span class="sig-paren">(</span><em>self</em>, <em>comment</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.setComment" title="Permalink to this definition"></a></dt>
<dd><p>Sets the comment associated with this node. See also
appendComment().</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.setCreatorState">
<code class="descname">setCreatorState</code><span class="sig-paren">(</span><em>self</em>, <em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.setCreatorState" title="Permalink to this definition"></a></dt>
<dd><p>This sets the name of the tool that created this node. If you call
this with a name that differs from the node type name, you should
also call setBuiltExplicitly(False).</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.setCurrent">
<code class="descname">setCurrent</code><span class="sig-paren">(</span><em>self</em>, <em>on</em>, <em>clear_all_selected=False</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.setCurrent" title="Permalink to this definition"></a></dt>
<dd><p>Set or unset this node as the last selected one.</p>
<p>Each network (i.e. node containing children) stores its own list of
selected nodes, and the last selected node has special meaning. For
example, it is the node displayed in unpinned parameter panes.</p>
<p>If on is True, this node will become the last selected node. If it
is False and this node was the last selected one, it will be
unselected and the second-last selected node will become the last
selected node.</p>
<p>If clear_all_selected is true, Houdini will unselect every node in
this network before performing the operation.</p>
<p>See also hou.Node.setSelected and hou.selectedNodes.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.setDataBlock">
<code class="descname">setDataBlock</code><span class="sig-paren">(</span><em>self</em>, <em>key</em>, <em>block</em>, <em>blocktype</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.setDataBlock" title="Permalink to this definition"></a></dt>
<dd><p>Stores the provided data block on the node under the provided key
name, marking it with the provided data type.</p>
<p>Passing a block value of None will remove any data block with the
specified key.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.setDeleteScript">
<code class="descname">setDeleteScript</code><span class="sig-paren">(</span><em>self</em>, <em>script_text</em>, <em>language=hou.scriptLanguage.Python</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.setDeleteScript" title="Permalink to this definition"></a></dt>
<dd><p>Sets the script that will run when this node is deleted.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.setDisplayDescriptiveNameFlag">
<code class="descname">setDisplayDescriptiveNameFlag</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.setDisplayDescriptiveNameFlag" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.Node.setEditableInputString">
<code class="descname">setEditableInputString</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.setEditableInputString" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.Node.setExpressionLanguage">
<code class="descname">setExpressionLanguage</code><span class="sig-paren">(</span><em>self</em>, <em>language</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.setExpressionLanguage" title="Permalink to this definition"></a></dt>
<dd><p>Set the nodes default expression language. See expressionLanguage()
for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.setFirstInput">
<code class="descname">setFirstInput</code><span class="sig-paren">(</span><em>self</em>, <em>item_to_become_input</em>, <em>output_index=0</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.setFirstInput" title="Permalink to this definition"></a></dt>
<dd><p>A shortcut for self.setInput(0, item_to_become_input). See
hou.Node.setInput for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.setGenericFlag">
<code class="descname">setGenericFlag</code><span class="sig-paren">(</span><em>self</em>, <em>flag</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.setGenericFlag" title="Permalink to this definition"></a></dt>
<dd><p>Sets the value of the specified flag based on the bool value
argument.</p>
<p>flag must be a hou.nodeFlag value.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.setInput">
<code class="descname">setInput</code><span class="sig-paren">(</span><em>self</em>, <em>input_index</em>, <em>item_to_become_input</em>, <em>output_index=0</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.setInput" title="Permalink to this definition"></a></dt>
<dd><p>If item_to_become_input is not None, connect the output connector of
another node to an input connector of this node. Otherwise,
disconnect anything connected to the input connector.</p>
<dl class="docutils">
<dt>input_index</dt>
<dd>The index of this nodes input connector.</dd>
<dt>item_to_become_input</dt>
<dd>If None this method disconnects everything from the input
connector. If a hou.Node or a hou.SubnetIndirectInput, this
method connects its output to this nodes input connector.</dd>
<dt>output_index</dt>
<dd>The index of the other nodes output connector.</dd>
</dl>
<p>Raises hou.InvalidInput if output_index is invalid. Raises
hou.OperationFailed if item_to_become_input is not in the same
network as this node. Raises hou.PermissionError if the node is
inside a locked asset.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.setNamedInput">
<code class="descname">setNamedInput</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.setNamedInput" title="Permalink to this definition"></a></dt>
<dd><p>setNamedInput(self, input_name, item_to_become_input,
output_name_or_index)</p>
<blockquote>
<div>Connects an output on this node (specified by either an output name
or an output index) to the input on the item_to_become_input
specified by input_name.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.Node.setNextInput">
<code class="descname">setNextInput</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.setNextInput" title="Permalink to this definition"></a></dt>
<dd><p>setNextInput(self, item_to_become_input, output_index=0,
unordered_only=False)</p>
<blockquote>
<div><blockquote>
<div><p>Connect the output connector from another node into the first
unconnected input connector or a multi-input connector of this node.
If a node has some ordered inputs followed by a multi-input
connector, the unordered_only parameter can be used to force the
input to connect to the unordered multi-input connection instead of
any of the ordered input which may not be connected.</p>
<p>This method is roughly equivalent to:</p>
</div></blockquote>
<p>&gt; for input_index, conectors in enumerate(self.inputConnectors()):
&gt;     if len(connectors) == 0:
&gt;         self.setInput(input_index, item_to_become_input, output_index)
&gt;     raise hou.InvalidInput(All inputs are connected)</p>
<blockquote>
<div>Raises hou.InvalidInput if all inputs are connected. See
hou.Node.setInput for more information.</div></blockquote>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.Node.setParmClipData">
<code class="descname">setParmClipData</code><span class="sig-paren">(</span><em>data</em>, <em>binary=True</em>, <em>blosc_compressed=True</em>, <em>sample_rate=0</em>, <em>start=None</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.setParmClipData" title="Permalink to this definition"></a></dt>
<dd><p>auto-insert ocstring: HOM_Node::setParmClipData</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.setParmExpressions">
<code class="descname">setParmExpressions</code><span class="sig-paren">(</span><em>parm_dict</em>, <em>language=None</em>, <em>replace_expressions=True</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.setParmExpressions" title="Permalink to this definition"></a></dt>
<dd><p>setParmExpressions(self, parm_dict, language=None,
replace_expressions=True)</p>
<blockquote>
<div><blockquote>
<div><p>Given a dictionary mapping parm names to expression strings, set
each of the corresponding parms on this node to the given expression
string in the dictionary.</p>
<p>See hou.Parm.setExpression for a description of the language and
replace_expressions parms.</p>
<p>The following example expressions set the tx and sy parameters at
once:</p>
</div></blockquote>
<p>&gt; &gt;&gt;&gt; node = hou.node(/obj).createNode(geo)
&gt; &gt;&gt;&gt; node.setParmExpressions({tx: ch(ty), sy: sin($F)})</p>
<blockquote>
<div><p>Raises hou.OperationFailed if any of the parameter names are not
valid.</p>
<p>See also the setParms method.</p>
</div></blockquote>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.Node.setParmTemplateGroup">
<code class="descname">setParmTemplateGroup</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.setParmTemplateGroup" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.Node.setParms">
<code class="descname">setParms</code><span class="sig-paren">(</span><em>self</em>, <em>parm_dict</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.setParms" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Given a dictionary mapping parm names to values, set each of the
corresponding parms on this node to the given value in the
dictionary.</p>
<p>The following example sets the tx and sy parameters at once:</p>
</div></blockquote>
<p>&gt; &gt;&gt;&gt; node = hou.node(/obj).createNode(geo)
&gt; &gt;&gt;&gt; node.setParms({tx: 1, sy: 3})</p>
<blockquote>
<div><p>Raises hou.OperationFailed if any of the parameter names are not
valid.</p>
<p>See also the setParmExpressions method.</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.Node.setParmsPending">
<code class="descname">setParmsPending</code><span class="sig-paren">(</span><em>self</em>, <em>parm_dict</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.setParmsPending" title="Permalink to this definition"></a></dt>
<dd><p>Given a dictionary mapping parm names to values, sets the pending
value of each of the corresponding parms on this node.</p>
<p>Raises hou.OperationFailed if any of the parameter names are not
valid.</p>
<p>See also the setPending method.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.setUserData">
<code class="descname">setUserData</code><span class="sig-paren">(</span><em>self</em>, <em>name</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.setUserData" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Add/set a named string on this node instance.</p>
<dl class="docutils">
<dt>name</dt>
<dd>A unique name (key) for the user-defined data. By using
different names, you can attach multiple pieces of user-defined
data to a node.</dd>
<dt>value</dt>
<dd>The string to store.</dd>
</dl>
<p>This name/value pair is stored with the hip file and is included in
the output from opscript and hou.Node.asCode.</p>
<p>The following example illustrates how to set, access, and delete
user-defined data:</p>
</div></blockquote>
<p>&gt; &gt;&gt;&gt; n = hou.node(/obj).createNode(geo)
&gt; &gt;&gt;&gt; n.setUserData(my data, my data value)
&gt; &gt;&gt;&gt; n.userData(my data)
&gt; my data value
&gt; &gt;&gt;&gt; n.userDataDict()
&gt; {my data: my data value}
&gt; &gt;&gt;&gt; n.destroyUserData(my data)
&gt; &gt;&gt;&gt; n.userDataDict()
&gt; {}
&gt; &gt;&gt;&gt; print n.userData(my data)
&gt; None</p>
<blockquote>
<div><p>See per-node user-defined data for more information and examples.</p>
<dl class="docutils">
<dt>TIP</dt>
<dd>If you prefix a user data key with <a href="#id67"><span class="problematic" id="id68">nodeinfo_</span></a>, the key (without
the prefix) and the value will be shown as a custom field in the
node info popup window.</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.Node.simulation">
<code class="descname">simulation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.simulation" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.Node.spareParms">
<code class="descname">spareParms</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.Parm<a class="headerlink" href="#hou.Node.spareParms" title="Permalink to this definition"></a></dt>
<dd><p>Return a list of the spare (user-defined) parameters on this node.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.stampValue">
<code class="descname">stampValue</code><span class="sig-paren">(</span><em>self</em>, <em>parm_name</em>, <em>default_value</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.stampValue" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Return a copy stamping floating point or string value. This node
must be a downstream stamping operator, such as a Copy SOP, Cache
SOP, LSystem SOP, or Copy CHOP.</p>
<dl class="docutils">
<dt>parm_name</dt>
<dd>The name of the stamping variable.</dd>
<dt>default_value</dt>
<dd>The value that this function returns if Houdini is not currently
performing stamping, or if parm_name is not a valid variable
name. This value may be a float or a string.</dd>
</dl>
<p>You might put the following expression in a Python parameter:</p>
</div></blockquote>
<p>&gt; node(../copy1).stampValue(sides, 5)</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.stickyNotes">
<code class="descname">stickyNotes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.stickyNotes" title="Permalink to this definition"></a></dt>
<dd><p>iterStickyNotes(self) -&gt; generator of hou.StickyNote</p>
<blockquote>
<div>Return a generator that iterates through all the sticky notes inside
this node.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.Node.subnetOutputs">
<code class="descname">subnetOutputs</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.Node<a class="headerlink" href="#hou.Node.subnetOutputs" title="Permalink to this definition"></a></dt>
<dd><p>Return the hou.Node objects that are produce the subnets outputs.</p>
<p>Raises hou.InvalidNodeType if this node is not a subnetwork.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.supportsMultiCookCodeContexts">
<code class="descname">supportsMultiCookCodeContexts</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.Node.supportsMultiCookCodeContexts" title="Permalink to this definition"></a></dt>
<dd><p>Return True if this node can generate compiled cook code for
multiple contexts (i.e. surface context, displacement context, etc.)
and False otherwise.</p>
<p>Raises hou.OperationFailed if this node cannot generate compiled
code.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.syncNodeVersionIfNeeded">
<code class="descname">syncNodeVersionIfNeeded</code><span class="sig-paren">(</span><em>self</em>, <em>from_version</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.syncNodeVersionIfNeeded" title="Permalink to this definition"></a></dt>
<dd><p>Synchronize the node from the specified version to the current
version of its HDA definition. See also hou.HDADefinition.version.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.Node.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.Node.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.type">
<code class="descname">type</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.NodeType<a class="headerlink" href="#hou.Node.type" title="Permalink to this definition"></a></dt>
<dd><p>Return the hou.NodeType object for this node.</p>
<p>For example, all camera node instances share the same node type.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.updateParmStates">
<code class="descname">updateParmStates</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Node.updateParmStates" title="Permalink to this definition"></a></dt>
<dd><p>Update the UI states, such as hidden and disabled, for each
parameter in the node.</p>
<p>UI states can be expressed as conditionals (i.e. Disable When) which
require evaluation. Typically in graphical Houdini the Parameter
Pane performs the evaluation when the node is selected in order to
determine how the node parameters should look in the pane. However
in non-graphical Houdini or if the Parameter Pane has not yet loaded
the node, then the evaluation does not occur and the UI states
remain at their defaults causing methods such as hou.Parm.isDisabled
and hou.Parm.isHidden to return incorrect values. In these cases, it
is recommended that hou.Node.updateParmStates is called.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.userData">
<code class="descname">userData</code><span class="sig-paren">(</span><em>self</em>, <em>name</em><span class="sig-paren">)</span> &#x2192; str or None<a class="headerlink" href="#hou.Node.userData" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Return the user-defined data with this name, or None if no data with
this name exists.</p>
<p>See hou.Node.setUserData for more information.</p>
<p>This method can be implemented as follows:</p>
</div></blockquote>
<p>&gt; def userData(self, name):
&gt;     return self.userDataDict().get(name)</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.userDataDict">
<code class="descname">userDataDict</code><span class="sig-paren">(</span><em>self</em>, <em>name</em><span class="sig-paren">)</span> &#x2192; dict of str to str<a class="headerlink" href="#hou.Node.userDataDict" title="Permalink to this definition"></a></dt>
<dd><p>Return a dictionary containing all the user-defined name/string
pairs for this node.</p>
<p>See hou.Node.setUserData for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Node.warnings">
<code class="descname">warnings</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of str<a class="headerlink" href="#hou.Node.warnings" title="Permalink to this definition"></a></dt>
<dd><p>Return the text of any warnings from the last cook of this node, or
an empty tuple if there were no warnings.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.NodeConnection">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">NodeConnection</code><a class="headerlink" href="#hou.NodeConnection" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.NetworkItem" title="hou.NetworkItem"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.NetworkItem</span></code></a></p>
<p>Represents a connection (wire) between two Nodes.</p>
<p>OVERVIEW</p>
<blockquote>
<div><p>You can get a list of NodeConnection objects from a hou.Node
instance using hou.Node.inputConnections and
hou.Node.outputConnections.</p>
<dl class="docutils">
<dt>NOTE</dt>
<dd>It is probably easier to use the hou.Node..inputs and
hou.Node.outputs methods (which return the endpoints of a nodes
connections) to traverse the network, rather than dealing with
the connections themselves.</dd>
</dl>
<p>This object is read-only. To create or edit connections, use
methods on the node, such as hou.Node.setNamedInput,
hou.Node.setInput, hou.Node.setFirstInput, hou.Node.setNextInput,
hou.Node.createInputNode, and hou.Node.createOutputNode.</p>
</div></blockquote>
<p>INPUT AND OUTPUT MEANING</p>
<blockquote>
<div><p>The hou.NodeConnection.outputNode and hou.NodeConnection.inputNode
are named in relation to the _nodes_, <em>not</em> the input and output
ends of the _connector_.</p>
<p>So, outputNode() returns the node whose _output_ is this connector.
In the diagram, outputNode() on the highlighted connection would
return node A. inputNode() returns the node whose input is this
connector. In the diagram, inputNode() on the highlighted connection
would return node C.</p>
</div></blockquote>
<p>CONNECTION INDEXES</p>
<blockquote>
<div><p>Some nodes have multiple inputs and/or multiple outputs. For
example, most VOPs have several inputs and outputs. The Split DOP
has multiple outputs.</p>
<p>A node with a multi-input, such as the Merge SOP, has multiple
inputs for each connection, even though in the network editor it
is drawn with one connection point at the top.</p>
<p>Inputs and outputs are always addressed by their position (index).</p>
</div></blockquote>
<dl class="method">
<dt id="hou.NodeConnection.inputDataType">
<code class="descname">inputDataType</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.NodeConnection.inputDataType" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.NodeConnection.inputIndex">
<code class="descname">inputIndex</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.NodeConnection.inputIndex" title="Permalink to this definition"></a></dt>
<dd><p>Returns the index of the input connection on the node that the
output side of this connections connects to.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NodeConnection.inputItem">
<code class="descname">inputItem</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.NetworkMovableItem<a class="headerlink" href="#hou.NodeConnection.inputItem" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>If this connection has a subnet indirect input connected to it,
return the corresponding hou.SubnetIndirectInput object. If this
connection has a node connected to it, return the corresponding
hou.Node object. Otherwise, return None. This method is essentially
equivalent to the following:</div></blockquote>
<p>&gt; def getInputItem(node_connection):
&gt;     if node_connection.subnetIndirectInput() is not None:
&gt;         return node_connection.subnetIndirectInput()
&gt;     return node_connection.inputNode()</p>
</dd></dl>

<dl class="method">
<dt id="hou.NodeConnection.inputItemOutputIndex">
<code class="descname">inputItemOutputIndex</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.NodeConnection.inputItemOutputIndex" title="Permalink to this definition"></a></dt>
<dd><p>Returns zero if this connection has a subnet indirect input
connected to it. Otherwise return the index of the output connection
on the node that the input side of this connections connects to. In
combination with the inputItem method, node and subnet indirect
inputs can be processed through a common code path for many use
cases.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NodeConnection.inputLabel">
<code class="descname">inputLabel</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.NodeConnection.inputLabel" title="Permalink to this definition"></a></dt>
<dd><p>Returns the label of the input connection on the node that the
output side of this connections connects to.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NodeConnection.inputName">
<code class="descname">inputName</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.NodeConnection.inputName" title="Permalink to this definition"></a></dt>
<dd><p>Returns the name of the input connection on the node that the output
side of this connections connects to.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NodeConnection.inputNode">
<code class="descname">inputNode</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Node<a class="headerlink" href="#hou.NodeConnection.inputNode" title="Permalink to this definition"></a></dt>
<dd><p>Return the node on the input side of this connection. This is the
node that the connection comes from, in the direction of data flow.
If this connection goes through an indirect input, this will return
the node connected to the parent node (or None if nothing is
connected).</p>
</dd></dl>

<dl class="method">
<dt id="hou.NodeConnection.isSelected">
<code class="descname">isSelected</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.NodeConnection.isSelected" title="Permalink to this definition"></a></dt>
<dd><p>Return True if this connection is selected.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NodeConnection.outputDataType">
<code class="descname">outputDataType</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.NodeConnection.outputDataType" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.NodeConnection.outputIndex">
<code class="descname">outputIndex</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.NodeConnection.outputIndex" title="Permalink to this definition"></a></dt>
<dd><p>Returns the index of the output connection on the node that the
input side of this connections connects to. If this connection goes
through an indirect input, this will return the index of the output
connected to the parent node (or 0 if nothing is connected).</p>
</dd></dl>

<dl class="method">
<dt id="hou.NodeConnection.outputItem">
<code class="descname">outputItem</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.NetworkMovableItem<a class="headerlink" href="#hou.NodeConnection.outputItem" title="Permalink to this definition"></a></dt>
<dd><p>Return the node or network dot on the output side of this
connection. This is the node or dot that the connection goes to, in
the direction of data flow. This method should never return None.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NodeConnection.outputLabel">
<code class="descname">outputLabel</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.NodeConnection.outputLabel" title="Permalink to this definition"></a></dt>
<dd><p>Returns the label of the output connection on the node that the
input side of this connections connects to.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NodeConnection.outputName">
<code class="descname">outputName</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.NodeConnection.outputName" title="Permalink to this definition"></a></dt>
<dd><p>Returns the name of the output connection on the node that the input
side of this connections connects to.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NodeConnection.outputNode">
<code class="descname">outputNode</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Node<a class="headerlink" href="#hou.NodeConnection.outputNode" title="Permalink to this definition"></a></dt>
<dd><p>Return the node on the output side of this connection. This is the
node that the connection goes to, in the direction of data flow. If
this connection has a network dot as its output, this method returns
None.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NodeConnection.setSelected">
<code class="descname">setSelected</code><span class="sig-paren">(</span><em>self</em>, <em>selected</em>, <em>clear_all_selected = False</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NodeConnection.setSelected" title="Permalink to this definition"></a></dt>
<dd><p>Selects or de-selects this connection. If the clear_all_selected
parameter is set to True, all other selections (both connections,
and nodes, network boxes, etc.) will be cleared before this
connection is selected.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NodeConnection.subnetIndirectInput">
<code class="descname">subnetIndirectInput</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.SubnetIndirectInput<a class="headerlink" href="#hou.NodeConnection.subnetIndirectInput" title="Permalink to this definition"></a></dt>
<dd><p>If this connection has a subnet indirect input connected to it
instead of a node, return the corresponding object. Otherwise,
return None. See hou.SubnetIndirectInput for information on subnet
indirect inputs.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.NodeConnection.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.NodeConnection.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.NodeError">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">NodeError</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NodeError" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.Error" title="hou.Error"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.Error</span></code></a></p>
<p>Exception class used to set errors on nodes implemented via Python.</p>
<p>Raise instances of this class from within Python SOPs, objects, etc. to
set an error flag on the node. See Writing Python SOPs for more
information.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.NodeWarning</li>
<li>hou.Error</li>
</ul>
</div></blockquote>
<dl class="method">
<dt id="hou.NodeError.description">
<code class="descname">description</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.NodeError.description" title="Permalink to this definition"></a></dt>
<dd><p>Return a description of the class of exception. The description is
not related to the exception instance.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NodeError.exceptionTypeName">
<code class="descname">exceptionTypeName</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.NodeError.exceptionTypeName" title="Permalink to this definition"></a></dt>
<dd><p>Return the name of the exception type. Instances of different
subclasses of hou.Error will return different names. Instances of
the base class will return Error.</p>
<p>You can also use str(e.__class__) to get the name of the subclass.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.NodeError.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.NodeError.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.NodeGroup">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">NodeGroup</code><a class="headerlink" href="#hou.NodeGroup" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Represents a node group.</p>
<p>In Houdini, a node group contains a set of nodes from the same network.
Each group is named, and you can edit a groups contents from the
network view pane by selecting Viewing Controls &gt; Show Groups from its
right-mouse menu.</p>
<p>A node bundle, on the other hand, may contain nodes from multiple
networks, and corresponds to a hou.NodeBundle object. You can edit a
node bundle from the bundle list pane.</p>
<dl class="method">
<dt id="hou.NodeGroup.addNode">
<code class="descname">addNode</code><span class="sig-paren">(</span><em>self</em>, <em>node</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NodeGroup.addNode" title="Permalink to this definition"></a></dt>
<dd><p>Add a hou.Node to this group.</p>
<p>If the node is already in the group, this method does nothing. If
the node is not in the correct network for this group, raises
hou.OperationFailed.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NodeGroup.asCode">
<code class="descname">asCode</code><span class="sig-paren">(</span><em>self</em>, <em>save_creation_commands=False</em>, <em>function_name=None</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.NodeGroup.asCode" title="Permalink to this definition"></a></dt>
<dd><p>Returns the Python code necessary to recreate this group.</p>
<dl class="docutils">
<dt>save_creation_commands</dt>
<dd>Generate a creation script for the node group. If set to False
(the default), the generated script assumes that the node group
already exists. When set to True, the script will begin by
creating the node group.</dd>
<dt>function_name</dt>
<dd>If a function_name is specified, the output will be wrapped in a
Python function.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hou.NodeGroup.clear">
<code class="descname">clear</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NodeGroup.clear" title="Permalink to this definition"></a></dt>
<dd><p>Remove all nodes from this group.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NodeGroup.destroy">
<code class="descname">destroy</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NodeGroup.destroy" title="Permalink to this definition"></a></dt>
<dd><p>Delete this group. Does not delete the nodes that were contained in
it.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NodeGroup.name">
<code class="descname">name</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.NodeGroup.name" title="Permalink to this definition"></a></dt>
<dd><p>Returns the name of this group.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NodeGroup.nodes">
<code class="descname">nodes</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.Node<a class="headerlink" href="#hou.NodeGroup.nodes" title="Permalink to this definition"></a></dt>
<dd><p>Return a tuple containing the nodes in this group.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NodeGroup.parent">
<code class="descname">parent</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Node<a class="headerlink" href="#hou.NodeGroup.parent" title="Permalink to this definition"></a></dt>
<dd><p>Returns the network node containing this group.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NodeGroup.removeNode">
<code class="descname">removeNode</code><span class="sig-paren">(</span><em>self</em>, <em>node</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NodeGroup.removeNode" title="Permalink to this definition"></a></dt>
<dd><p>Remove a hou.Node from this group.</p>
<p>Raises hou.OperationFailed if the node is not in the group.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.NodeGroup.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.NodeGroup.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.NodeInfoTree">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">NodeInfoTree</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NodeInfoTree" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A tree structure designed to contain information about nodes and the
data they generate.</p>
<p>This class represents a tree structure, where each branch of the tree
can have any number of named sub-trees, as well as a two dimensional
grid of strings. Most often this grid has two columns (Property and
Value), with some number of rows to represent arbitrary key/value
pairs. But the grid can also contain more complex data (such as the
volume information in geometry data).</p>
<dl class="method">
<dt id="hou.NodeInfoTree.branchOrder">
<code class="descname">branchOrder</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of str<a class="headerlink" href="#hou.NodeInfoTree.branchOrder" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Returns the natural order of the child branches in the dictionary
returned by branches(). This ordering is often not very important,
but in situations where there are a large number of branches that do
have some sort of natural order (such as the branches for each DOP
object returned by a DOP node) this method can help organize the
information.</p>
<p>This code iterates through all child branches of a nodes info tree
in their natural order, assuming an RBD simulation created from a
default sphere and torus object:</p>
</div></blockquote>
<p>&gt; &gt;&gt;&gt; nodeinfo = hou.node(/obj/AutoDopNetwork/output).infoTree()
&gt; &gt;&gt;&gt; dopinfo = nodeinfo.branches()[DOP Info]
&gt; &gt;&gt;&gt; objinfo = dopinfo.branches()[Objects]
&gt; &gt;&gt;&gt; objbranches = objinfo.branches()
&gt; &gt;&gt;&gt; for objname in objinfo.branchOrder():
&gt;    obj = objbranches[objname]
&gt;    print objname, :, obj.branches()
&gt; 
&gt; torus_object1 : {Geometry: &lt;hou.NodeInfoTree&gt;}
&gt; sphere_object1 : {Geometry: &lt;hou.NodeInfoTree&gt;}</p>
</dd></dl>

<dl class="method">
<dt id="hou.NodeInfoTree.branches">
<code class="descname">branches</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; dict of str to hou.NodeInfoTree<a class="headerlink" href="#hou.NodeInfoTree.branches" title="Permalink to this definition"></a></dt>
<dd><p>Return a dictionary of all child branches. Each branch has a name,
and is a full tree, which may have its own branches, and so on.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NodeInfoTree.headings">
<code class="descname">headings</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of str<a class="headerlink" href="#hou.NodeInfoTree.headings" title="Permalink to this definition"></a></dt>
<dd><p>Returns the titles of the columns for the data returned by the
rows() method. Usually this will be simply (Property, Value),
for rows that are simply key/value pairs. But in some cases the
headings can help interpret the returned information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NodeInfoTree.infoType">
<code class="descname">infoType</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.NodeInfoTree.infoType" title="Permalink to this definition"></a></dt>
<dd><p>Returns a string that can be used to describe the type of data
stored in this tree. For example, a tree holding geometry
information (generated either by a SOP node or a DOP node) will
return Geometry from this method.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NodeInfoTree.name">
<code class="descname">name</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.NodeInfoTree.name" title="Permalink to this definition"></a></dt>
<dd><p>Returns the name of this branch of the tree.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NodeInfoTree.rows">
<code class="descname">rows</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of tuple of str<a class="headerlink" href="#hou.NodeInfoTree.rows" title="Permalink to this definition"></a></dt>
<dd><p>Return a two dimensional grid of strings. The returned tuple
represents the rows of the grid. The contained tuples each represent
one row. All contained tuples will be the same length, which will be
the length of the tuple returned by the headings() method.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.NodeInfoTree.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.NodeInfoTree.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.NodeType">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">NodeType</code><a class="headerlink" href="#hou.NodeType" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Information common to all instances of a type of node, such as the
parameters.</p>
<p>For example, the Geometry object and Subdivide SOP are node types.
/obj/geo1 and /obj/geo2, on the other hand, are Node instances of the
Geometry object node type.</p>
<p>A digital asset defines a node type. The nodes contained inside the
assets definition implement the node types algorithm, and you can
customize the parameters in the node type using the Type Properties
dialog,</p>
<p>You can get a NodeType object from a Node object with hou.Node.type. For
example, if /obj/geo1 is a geometry object, hou.node(/obj/geo1).type()
will return the NodeType corresponding to all geometry objects.</p>
<p>All the node types in Houdini are organized into categories, and a node
type is uniquely identified by its category and node type name. For
example, objects, SOPs, POPs, etc. are node type categories. You can
also access a NodeType object from a category with
hou.NodeTypeCategory.nodeTypes. Similarly, you can call <a href="#id69"><span class="problematic" id="id70">hou.nodeType_</span></a>
with the category and node type name.</p>
<p>See also hou.Node and hou.NodeTypeCategory.</p>
<dl class="method">
<dt id="hou.NodeType.addAlias">
<code class="descname">addAlias</code><span class="sig-paren">(</span><em>self</em>, <em>alias</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NodeType.addAlias" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Add an alias for this node type. You can use this alias when
creating new nodes.</div></blockquote>
<p>&gt; &gt;&gt;&gt; geo_type = hou.nodeType(hou.objNodeTypeCategory(), geo)
&gt; &gt;&gt;&gt; geo_type.addAlias(transformable)
&gt; &gt;&gt;&gt; geo_type.aliases()
&gt; (transformable,)
&gt; &gt;&gt;&gt; hou.node(/obj).createNode(transformable)
&gt; &lt;hou.ObjNode of type geo at /obj/geo1&gt;</p>
</dd></dl>

<dl class="method">
<dt id="hou.NodeType.aliases">
<code class="descname">aliases</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of str<a class="headerlink" href="#hou.NodeType.aliases" title="Permalink to this definition"></a></dt>
<dd><p>Return all current aliases for this node type. See
hou.NodeType.addAlias for an example.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NodeType.allInstalledDefinitions">
<code class="descname">allInstalledDefinitions</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.HDADefinition<a class="headerlink" href="#hou.NodeType.allInstalledDefinitions" title="Permalink to this definition"></a></dt>
<dd><p>Search all installed operator type libraries and return a tuple of
available hou.HDADefinition objects providing definitions for this
node type.</p>
<p>Houdini allows multiple otl files to be loaded at the same time that
each contain definitions for the same node type. The definition in
use is called the current definition. See also
hou.HDADefinition.isCurrent.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NodeType.areContentsViewable">
<code class="descname">areContentsViewable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.NodeType.areContentsViewable" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.NodeType.category">
<code class="descname">category</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.NodeTypeCategory<a class="headerlink" href="#hou.NodeType.category" title="Permalink to this definition"></a></dt>
<dd><p>Return the node type category for this node type. For example, for
the geometry object, the result is the object returned by
hou.objNodeTypeCategory.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NodeType.childTypeCategory">
<code class="descname">childTypeCategory</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.NodeType.childTypeCategory" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.NodeType.containedNodeTypes">
<code class="descname">containedNodeTypes</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of str<a class="headerlink" href="#hou.NodeType.containedNodeTypes" title="Permalink to this definition"></a></dt>
<dd><p>Return a tuple of all NodeType names of the contents of an HDA.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NodeType.defaultColor">
<code class="descname">defaultColor</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Color<a class="headerlink" href="#hou.NodeType.defaultColor" title="Permalink to this definition"></a></dt>
<dd><p>Return the color used to display a node of this type in the network
view if the nodes hou.nodeFlag.ColorDefault flag is set.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NodeType.defaultHelpUrl">
<code class="descname">defaultHelpUrl</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.NodeType.defaultHelpUrl" title="Permalink to this definition"></a></dt>
<dd><p>Return a generic URL that the help system will try to resolve to the
actual location that stores the node type documentation. The generic
URL is in the form operator:table/optypename and may include
additional information such as a namespace or a version.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NodeType.defaultShape">
<code class="descname">defaultShape</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.NodeType.defaultShape" title="Permalink to this definition"></a></dt>
<dd><p>Return the name of the shape used to display a node of this type in
the network view if no shape is explcictly assigned to the node.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NodeType.definition">
<code class="descname">definition</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.HDADefinition<a class="headerlink" href="#hou.NodeType.definition" title="Permalink to this definition"></a></dt>
<dd><p>If this node type corresponds to a digital asset, return the
hou.HDADefinition. Otherwise, return None.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NodeType.deprecated">
<code class="descname">deprecated</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.NodeType.deprecated" title="Permalink to this definition"></a></dt>
<dd><p>Return whether or not this node type has been marked deprecated. See
also hou.NodeType.deprecationInfo.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NodeType.deprecationInfo">
<code class="descname">deprecationInfo</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; dict of str to str or hou.NodeType<a class="headerlink" href="#hou.NodeType.deprecationInfo" title="Permalink to this definition"></a></dt>
<dd><p>If the node type has been marked deprecated, this call will return
the deprecation information as a dictionary.</p>
<p>The currently supported keys are:</p>
<dl class="docutils">
<dt>version</dt>
<dd>The version of Houdini where this operator got deprecated. The
form is either major.minor, or major.minor.build (e.g. 14.0 or
14.5.122). This item is always present.</dd>
<dt>new_type</dt>
<dd>The new node type this node was replaced with. This can be used
to create a system of automatic node replacement.</dd>
<dt>reason</dt>
<dd>This lists the reason given for the deprecation, in case there
is no new node to replace with.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hou.NodeType.description">
<code class="descname">description</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.NodeType.description" title="Permalink to this definition"></a></dt>
<dd><p>Return the description of this node type that appears in the tab
menu. For example, for the geometry object, the description is
Geometry. This description is also called the operator label in
Houdini.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NodeType.embeddedHelp">
<code class="descname">embeddedHelp</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.NodeType.embeddedHelp" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Return the help text embedded in this node type. Return an empty
string if no embedded help exists.</p>
<p>The embedded help is searched for in two different places in the
following order:</p>
</div></blockquote>
<ul class="simple">
<li>If an HDK node, the text given by its OP_Operator::getHDKHelp()
override</li>
<li>If an HDA node, the corresponding result of
hou.HDADefinition.embeddedHelp()</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="hou.NodeType.generatorFlag">
<code class="descname">generatorFlag</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NodeType.generatorFlag" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.NodeType.hasEditableInputData">
<code class="descname">hasEditableInputData</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.NodeType.hasEditableInputData" title="Permalink to this definition"></a></dt>
<dd><p>Return True if nodes of this node type allow the user to associate
data with each input to the node. The purpose of this data may vary
from one node type to another. This data can be accessed with
methods such as hou.Node.editableInputName and
hou.Node.setEditableInputName.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NodeType.hasPermanentUserDefaults">
<code class="descname">hasPermanentUserDefaults</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.NodeType.hasPermanentUserDefaults" title="Permalink to this definition"></a></dt>
<dd><p>Returns whether a user has set permanent defaults for this node
type.</p>
<p>See also hou.Parm.hasTemporaryDefaults</p>
</dd></dl>

<dl class="method">
<dt id="hou.NodeType.hasUnorderedInputs">
<code class="descname">hasUnorderedInputs</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.NodeType.hasUnorderedInputs" title="Permalink to this definition"></a></dt>
<dd><p>Return whether it is impossible for this node type to have gaps in
its connected inputs. For example, the cookie SOP has two inputs,
and its possible for only the second input to be connected, so this
method would return False. However, the merge SOP cannot have any
gaps in its inputs, so this method would return True.</p>
<p>See also hou.Node.inputs, hou.Node.inputConnections, and
hou.Node.inputConnectors.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NodeType.hdaModule">
<code class="descname">hdaModule</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.HDAModule<a class="headerlink" href="#hou.NodeType.hdaModule" title="Permalink to this definition"></a></dt>
<dd><p>Return the HDAModule object for this node type. If the type is not
for a digital asset, the module is empty. Otherwise, the module
contains the functions, constants, classes, etc. in the user-defined
PythonModule section of the digital asset.</p>
<p>You can use hou.Node.hdaModule as a shortcut to access the HDAModule
from a node instance.</p>
<p>See hou.HDAModule for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NodeType.helpUrl">
<code class="descname">helpUrl</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.NodeType.helpUrl" title="Permalink to this definition"></a></dt>
<dd><p>Return the URL where the node type stores the documentation, e.g., a
file name or an HDA section path. May return an empty string if node
type does not know where the documentation is.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NodeType.hidden">
<code class="descname">hidden</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.NodeType.hidden" title="Permalink to this definition"></a></dt>
<dd><p>Return whether or not this node type appears in the tab menu. See
also hou.NodeType.setHidden.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NodeType.icon">
<code class="descname">icon</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.NodeType.icon" title="Permalink to this definition"></a></dt>
<dd><p>Return the name or path of the icon for this node type. Note that
node types that ship with Houdini use a name instead of a full path,
and Houdini uses its search path to locate the icon with that name.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NodeType.instances">
<code class="descname">instances</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.Node<a class="headerlink" href="#hou.NodeType.instances" title="Permalink to this definition"></a></dt>
<dd><p>Return a tuple of all the nodes of this type in the current scene.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NodeType.isGenerator">
<code class="descname">isGenerator</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.NodeType.isGenerator" title="Permalink to this definition"></a></dt>
<dd><p>Return if this node type has been flagged as a generator. For
example, a grid SOP generates new geometry, while a subdivide SOP
does not, and instead processes the geometry passed into it. See
also hou.NodeType.minNumInputs.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NodeType.isManager">
<code class="descname">isManager</code><span class="sig-paren">(</span><em>self</em>, <em>include_management_types=True</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.NodeType.isManager" title="Permalink to this definition"></a></dt>
<dd><p>Return whether this NodeType is a manager. The manager node
instances are /obj, /out, /part, /ch, /shop, /img, and /vex.</p>
<p>If include_management_types is set to True then this method will
additionally return True if this node type is a management node type
such as a SHOP network, or VOP network, etc.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NodeType.isReadable">
<code class="descname">isReadable</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.NodeType.isReadable" title="Permalink to this definition"></a></dt>
<dd><p>Return True if this node type is readable and False otherwise. A
readable node type is one that you can create node instances from.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NodeType.isWritable">
<code class="descname">isWritable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.NodeType.isWritable" title="Permalink to this definition"></a></dt>
<dd><p>areContentsViewable(self) -&gt; bool</p>
<blockquote>
<div>Return True if the node network contained in the node type is
viewable and False otherwise.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.NodeType.managerFlag">
<code class="descname">managerFlag</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NodeType.managerFlag" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.NodeType.maxNumInputs">
<code class="descname">maxNumInputs</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.NodeType.maxNumInputs" title="Permalink to this definition"></a></dt>
<dd><p>Return the maximum number of inputs that nodes of this type can
have. Return 9999 if this node type can accept an unlimited number
of inputs (e.g. the merge SOP).</p>
</dd></dl>

<dl class="method">
<dt id="hou.NodeType.maxNumOutputs">
<code class="descname">maxNumOutputs</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.NodeType.maxNumOutputs" title="Permalink to this definition"></a></dt>
<dd><p>Return the maximum number of outputs that nodes of this type can
have. Most node types have only one output, but some, like the split
dop, can have multiple.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NodeType.minNumInputs">
<code class="descname">minNumInputs</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.NodeType.minNumInputs" title="Permalink to this definition"></a></dt>
<dd><p>Return the minimum number of inputs that nodes of this type can
have. If these inputs are not connected, the node will generate an
error.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NodeType.name">
<code class="descname">name</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.NodeType.name" title="Permalink to this definition"></a></dt>
<dd><p>Return the name of this node type. For example, for the geometry
object type, the name is geo. The name and the node type category
together uniquely identify a node type.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NodeType.nameComponents">
<code class="descname">nameComponents</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of str<a class="headerlink" href="#hou.NodeType.nameComponents" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Returns a tuple of node type name components that constitute the
full node type name. The components in the tuple appear in the
following order: scope network type, node type namespace, node type
core name, and version.</div></blockquote>
<p>&gt; # parse the full name into components
&gt; &gt;&gt;&gt; node_type = hou.nodeType(hou.dopNodeTypeCategory(), pyrosolver::2.0)
&gt; &gt;&gt;&gt; node_type.nameComponents()
&gt; (, , pyrosolver, 2.0)</p>
</dd></dl>

<dl class="method">
<dt id="hou.NodeType.nameWithCategory">
<code class="descname">nameWithCategory</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.NodeType.nameWithCategory" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Return the name of the node type, prefixed with the name of the node
type category. For example, for the geometry object, this function
returns Object/geo. The category name and type name together
uniquely identify a node type.</div></blockquote>
<p>&gt; &gt;&gt;&gt; hou.nodeType(hou.objNodeTypeCategory(), geo).nameWithCategory()
&gt; Object/geo</p>
</dd></dl>

<dl class="method">
<dt id="hou.NodeType.namespaceOrder">
<code class="descname">namespaceOrder</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of str<a class="headerlink" href="#hou.NodeType.namespaceOrder" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Returns a node type name list sorted in the descending namespace
precedence order. The node types in the list have the same base type
as this node type. They have different namespace and/or version.</p>
<p>Houdini uses this list when resolving an unqualified type name in
hou.Node.createNode(); it will use the first entry in that list that
matches the name specified in the function.</p>
</div></blockquote>
<p>&gt; # parse the full name into components
&gt; &gt;&gt;&gt; node_type = hou.nodeType(hou.dopNodeTypeCategory(), pyrosolver)
&gt; &gt;&gt;&gt; node_type.namespaceOrder()
&gt; (pyrosolver::2.0, pyrosolver)</p>
</dd></dl>

<dl class="method">
<dt id="hou.NodeType.parmTemplateGroup">
<code class="descname">parmTemplateGroup</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.ParmTemplateGroup<a class="headerlink" href="#hou.NodeType.parmTemplateGroup" title="Permalink to this definition"></a></dt>
<dd><p>Return the group of parm templates corresponding to this node types
parameter interface.</p>
<p>See hou.ParmTemplateGroup for more information on parm template
groups. To change the parameter interface for a node type defined by
a digital asset, see hou.HDADefinition.setParmTemplateGroup.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NodeType.parmTemplates">
<code class="descname">parmTemplates</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.ParmTemplate<a class="headerlink" href="#hou.NodeType.parmTemplates" title="Permalink to this definition"></a></dt>
<dd><p>Return a tuple of parm templates for the parameters on this node
type. Note that spare parameters on individual node instances are
not included in this tuple, since they are independent from the node
type.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NodeType.removeAlias">
<code class="descname">removeAlias</code><span class="sig-paren">(</span><em>self</em>, <em>alias</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NodeType.removeAlias" title="Permalink to this definition"></a></dt>
<dd><p>Remove an alias for this node type.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NodeType.setDefaultColor">
<code class="descname">setDefaultColor</code><span class="sig-paren">(</span><em>self</em>, <em>color</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NodeType.setDefaultColor" title="Permalink to this definition"></a></dt>
<dd><p>Set the color used to display a node of this type in the network
view if the nodes hou.nodeFlag.ColorDefault flag is set. Pass None
as the color parameter to remove the type-specific default.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NodeType.setDefaultShape">
<code class="descname">setDefaultShape</code><span class="sig-paren">(</span><em>self</em>, <em>shape</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NodeType.setDefaultShape" title="Permalink to this definition"></a></dt>
<dd><p>Set the name of the shape used to display a node of this type in the
network view if no shape is explcictly assigned to the node. Pass
None as the shape parameter to remove the type-specific default.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NodeType.setHidden">
<code class="descname">setHidden</code><span class="sig-paren">(</span><em>self</em>, <em>hidden</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NodeType.setHidden" title="Permalink to this definition"></a></dt>
<dd><p>Set whether or not this node type appears in the tab menu. See also
hou.NodeType.hidden.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NodeType.source">
<code class="descname">source</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.nodeTypeSource enum value<a class="headerlink" href="#hou.NodeType.source" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Return a hou.nodeTypeSource enumerated value to indicate if this
node type is implemented in VEX, RSL, or the HDK (in C++), or if it
is a built-in node type that ships with Houdini.</div></blockquote>
<p>&gt; &gt;&gt;&gt; obj_cat = hou.objNodeTypeCategory()
&gt; &gt;&gt;&gt; sop_cat = hou.sopNodeTypeCategory()
&gt; &gt;&gt;&gt; hou.nodeType(obj_cat, biped_auto_rig).source()
&gt; nodeTypeSource.Subnet
&gt; &gt;&gt;&gt; hou.nodeType(sop_cat, mountain).source()
&gt; nodeTypeSource.VexCode</p>
</dd></dl>

<dl class="method">
<dt id="hou.NodeType.sourceNetwork">
<code class="descname">sourceNetwork</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Node or None<a class="headerlink" href="#hou.NodeType.sourceNetwork" title="Permalink to this definition"></a></dt>
<dd><p>If this node type is a digital asset, return the Node instance whose
contents define the digital asset. Otherwise, return None.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NodeType.sourcePath">
<code class="descname">sourcePath</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.NodeType.sourcePath" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Return the path to the source for this node type, or Internal if
it is a built-in node type. If the node was created using the HDK,
return the path to the shared object/dll for the node type.</div></blockquote>
<p>&gt; &gt;&gt;&gt; obj_cat = hou.objNodeTypeCategory()
&gt; &gt;&gt;&gt; hou.nodeType(obj_cat, biped_auto_rig).sourcePath()
&gt; oplib:/Object/biped_auto_rig?Object/biped_auto_rig
&gt; &gt;&gt;&gt; hou.nodeType(obj_cat, geo).sourcePath()
&gt; Internal</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.NodeType.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.NodeType.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

<dl class="method">
<dt id="hou.NodeType.uninstallFromPath">
<code class="descname">uninstallFromPath</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.NodeType.uninstallFromPath" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.NodeType.unorderedInputsFlag">
<code class="descname">unorderedInputsFlag</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NodeType.unorderedInputsFlag" title="Permalink to this definition"></a></dt>
<dd><p>hasUnorderedInputs(self) -&gt; bool</p>
<blockquote>
<div><p>Return whether it is impossible for this node type to have gaps in
its connected inputs. For example, the cookie SOP has two inputs,
and its possible for only the second input to be connected, so this
method would return False. However, the merge SOP cannot have any
gaps in its inputs, so this method would return True.</p>
<p>See also hou.Node.inputs, hou.Node.inputConnections, and
hou.Node.inputConnectors.</p>
</div></blockquote>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.NodeTypeCategory">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">NodeTypeCategory</code><a class="headerlink" href="#hou.NodeTypeCategory" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Represents a category of node types, such as surface nodes (SOPs) or
particle nodes (POPs).</p>
<p>Use hou.nodeTypeCategories to get a dict of node type category names to
NodeTypeCategory objects. You can use hou.objNodeTypeCategory,
hou.sopNodeTypeCategory, etc. to directly access a particular node type
category.</p>
<p>See also hou.NodeType and hou.Node.</p>
<p>&gt; # Get the names of all the node type categories.
&gt; &gt;&gt;&gt; hou.nodeTypeCategories().keys()
&gt; [Shop, Cop2, CopNet, Particle, ChopNet, Object, Driver, Pop,
&gt; Chop, Sop, Manager, Vop, Director, Dop, VopNet]</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.nodeTypeCategories</li>
<li>hou.objNodeTypeCategory</li>
<li>hou.sopNodeTypeCategory</li>
<li>hou.popNodeTypeCategory</li>
<li>hou.dopNodeTypeCategory</li>
<li>hou.cop2NodeTypeCategory</li>
<li><a href="#id71"><span class="problematic" id="id72">hou.shopNodeTypeCategory_</span></a></li>
<li>hou.vopNodeTypeCategory</li>
<li>hou.ropNodeTypeCategory</li>
<li>hou.chopNodeTypeCategory</li>
<li>hou.popNetNodeTypeCategory</li>
<li>hou.cop2NetNodeTypeCategory</li>
<li>hou.vopNetNodeTypeCategory</li>
<li>hou.chopNetNodeTypeCategory</li>
<li>hou.managerNodeTypeCategory</li>
<li>hou.rootNodeTypeCategory</li>
</ul>
</div></blockquote>
<dl class="method">
<dt id="hou.NodeTypeCategory.clearDefaultColors">
<code class="descname">clearDefaultColors</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.NodeTypeCategory.clearDefaultColors" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.NodeTypeCategory.clearDefaultShapes">
<code class="descname">clearDefaultShapes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.NodeTypeCategory.clearDefaultShapes" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.NodeTypeCategory.defaultColor">
<code class="descname">defaultColor</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.NodeTypeCategory.defaultColor" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.NodeTypeCategory.defaultShape">
<code class="descname">defaultShape</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.NodeTypeCategory.defaultShape" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.NodeTypeCategory.defaultWireStyle">
<code class="descname">defaultWireStyle</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.NodeTypeCategory.defaultWireStyle" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.NodeTypeCategory.hasSubNetworkType">
<code class="descname">hasSubNetworkType</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.NodeTypeCategory.hasSubNetworkType" title="Permalink to this definition"></a></dt>
<dd><p>Return True if the category contains a node type that creates sub-
network nodes.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NodeTypeCategory.label">
<code class="descname">label</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.NodeTypeCategory.label" title="Permalink to this definition"></a></dt>
<dd><p>Returns the descriptive of this node type category that appears in
network editor panes.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NodeTypeCategory.loadDSO">
<code class="descname">loadDSO</code><span class="sig-paren">(</span><em>self</em>, <em>dso_path</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NodeTypeCategory.loadDSO" title="Permalink to this definition"></a></dt>
<dd><p>Loads the HDK custom operator identified by the given file path for
this node type category. It will use the HOUDINI_DSO_PATH
environment variable to find it if necessary.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NodeTypeCategory.name">
<code class="descname">name</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.NodeTypeCategory.name" title="Permalink to this definition"></a></dt>
<dd><p>Returns the name of this node type category.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NodeTypeCategory.nodeType">
<code class="descname">nodeType</code><span class="sig-paren">(</span><em>self</em>, <em>type_name</em><span class="sig-paren">)</span> &#x2192; hou.NodeType or None<a class="headerlink" href="#hou.NodeTypeCategory.nodeType" title="Permalink to this definition"></a></dt>
<dd><p>Returns a single node type that matched the provided type name.
Returns None if the type name doesnt match a node type in this
category.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NodeTypeCategory.nodeTypes">
<code class="descname">nodeTypes</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; dict of str to hou.NodeType<a class="headerlink" href="#hou.NodeTypeCategory.nodeTypes" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Return a dict mapping node type names to node types in this
category.</p>
<p>For example, if this node type category is SOPs, the keys in the
dictionary would be box, sphere, polyextrude, subdivide,
etc.</p>
<p>Note that the node types in this category may not all be instances
of the same class. For example, most node types in the SOP node type
category are instances of hou.SopNodeType, but some, like SHOP
networks, CHOP networks, etc. are not.</p>
</div></blockquote>
<p>&gt; # Access the box SOPs node type.
&gt; hou.sopNodeTypeCategory().nodeTypes()[box]
&gt; def findNodeTypes(node_type_category, pattern):
&gt;     Return a list of node types in a particular node type category
&gt;        whose names match a pattern.
&gt;     import fnmatch
&gt; 
&gt;     return [node_type
&gt;         for node_type_name, node_type in node_type_category.nodeTypes().items()
&gt;         if fnmatch.fnmatch(node_type_name, pattern)]</p>
<blockquote>
<div>See also <a href="#id73"><span class="problematic" id="id74">hou.nodeType_</span></a>.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.NodeTypeCategory.nodeVerb">
<code class="descname">nodeVerb</code><span class="sig-paren">(</span><em>self</em>, <em>name</em><span class="sig-paren">)</span> &#x2192; hou.SopVerb or None<a class="headerlink" href="#hou.NodeTypeCategory.nodeVerb" title="Permalink to this definition"></a></dt>
<dd><p>Return a specific verb from the provided verb name. Returns None if
no matching verb is found.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NodeTypeCategory.nodeVerbs">
<code class="descname">nodeVerbs</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; dict of str to hou.SopVerb<a class="headerlink" href="#hou.NodeTypeCategory.nodeVerbs" title="Permalink to this definition"></a></dt>
<dd><p>Return a dict mapping verb names to node verbs in this category.</p>
<p>Most verbs are named after their corresponding node type.
Alternatively, given a hou.SopNode, one can use hou.SopNode.verb to
extract the verb.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NodeTypeCategory.setDefaultColor">
<code class="descname">setDefaultColor</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.NodeTypeCategory.setDefaultColor" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.NodeTypeCategory.setDefaultShape">
<code class="descname">setDefaultShape</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.NodeTypeCategory.setDefaultShape" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.NodeTypeCategory.setDefaultWireStyle">
<code class="descname">setDefaultWireStyle</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.NodeTypeCategory.setDefaultWireStyle" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.NodeTypeCategory.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.NodeTypeCategory.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

<dl class="method">
<dt id="hou.NodeTypeCategory.typeName">
<code class="descname">typeName</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.NodeTypeCategory.typeName" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.NodeTypeCategory.viewerStates">
<code class="descname">viewerStates</code><span class="sig-paren">(</span><em>self</em>, <em>viewer_type</em><span class="sig-paren">)</span> &#x2192; tuple of hou.ViewerState<a class="headerlink" href="#hou.NodeTypeCategory.viewerStates" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.NodeWarning">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">NodeWarning</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NodeWarning" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.Error" title="hou.Error"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.Error</span></code></a></p>
<p>Exception class used to set warnings on nodes implemented via Python.</p>
<p>Raise instances of this class from within Python SOPs, objects, etc. to
set an warning messages on the node. See Writing Python SOPs for more
information.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.NodeError</li>
<li>hou.Error</li>
</ul>
</div></blockquote>
<dl class="method">
<dt id="hou.NodeWarning.description">
<code class="descname">description</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.NodeWarning.description" title="Permalink to this definition"></a></dt>
<dd><p>Return a description of the class of exception. The description is
not related to the exception instance.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NodeWarning.exceptionTypeName">
<code class="descname">exceptionTypeName</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.NodeWarning.exceptionTypeName" title="Permalink to this definition"></a></dt>
<dd><p>Return the name of the exception type. Instances of different
subclasses of hou.Error will return different names. Instances of
the base class will return Error.</p>
<p>You can also use str(e.__class__) to get the name of the subclass.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.NodeWarning.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.NodeWarning.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.NotAvailable">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">NotAvailable</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.NotAvailable" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.Error" title="hou.Error"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.Error</span></code></a></p>
<p>Exception class for when an operation attempted to use a feature that is
not available. This class is a subclass of hou.Error.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.Error</li>
</ul>
</div></blockquote>
<dl class="method">
<dt id="hou.NotAvailable.description">
<code class="descname">description</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.NotAvailable.description" title="Permalink to this definition"></a></dt>
<dd><p>Return a description of the class of exception. The description is
not related to the exception instance.</p>
</dd></dl>

<dl class="method">
<dt id="hou.NotAvailable.exceptionTypeName">
<code class="descname">exceptionTypeName</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.NotAvailable.exceptionTypeName" title="Permalink to this definition"></a></dt>
<dd><p>Return the name of the exception type. Instances of different
subclasses of hou.Error will return different names. Instances of
the base class will return Error.</p>
<p>You can also use str(e.__class__) to get the name of the subclass.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.NotAvailable.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.NotAvailable.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.ObjNode">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">ObjNode</code><a class="headerlink" href="#hou.ObjNode" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.Node" title="hou.Node"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.Node</span></code></a></p>
<p>An instance of an object node in the Houdini scene.</p>
<p>Each object has a transformation (or transform) encapsulating its
position (or translation), rotation, and scale. For a subnet object,
the subnets transform is applied to the objects inside the subnet. An
object can have additional transforms from parent objects on top of the
transform defined by its parameters, as well as a normally hidden
pretransform that defines the objects rest or zero position
(normally all zeros). An objects final position/rotation/scale in world
space is defined by (objects transform) * (pretransform) * (parent
transform).</p>
<dl class="docutils">
<dt>TIP</dt>
<dd>You can set an objects position/rotation/scale to certain world
space values regardless of parent/pre-transform values with the
hou.ObjNode.setWorldTransform method.</dd>
<dt>NOTE</dt>
<dd>Houdini does not support shear parameters on objects. If you try to
set an objects parameters to a transform containing shear, Houdini
will automatically remove the shear.</dd>
</dl>
<dl class="method">
<dt id="hou.ObjNode.alembicGetCameraDict">
<code class="descname">alembicGetCameraDict</code><span class="sig-paren">(</span><em>archivePaths</em>, <em>objectPath</em>, <em>sampleTime</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ObjNode.alembicGetCameraDict" title="Permalink to this definition"></a></dt>
<dd><p>Return camera information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ObjNode.buildLookatRotation">
<code class="descname">buildLookatRotation</code><span class="sig-paren">(</span><em>self</em>, <em>to_node</em>, <em>up_vector=None</em><span class="sig-paren">)</span> &#x2192; hou.Matrix4<a class="headerlink" href="#hou.ObjNode.buildLookatRotation" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Return a matrix that will rotate this object to look at the
specified object.</p>
<p>The returned hou.Matrix4 object transforms this object from its
current position in world space so that its negative z axis points
at the origin of the to_node object.</p>
<p>up_vector can either be a hou.Vector3 object or None. If it is None,
this method uses an up vector of hou.Vector3(0, 1, 0).</p>
<p>You can extract the rotation values from the return value with
hou.Matrix4.extractRotates. You can set an objects transform with
hou.ObjNode.setWorldTransform.</p>
</div></blockquote>
<p>&gt; # Set the cam1 objects transform so it points at geo1.
&gt; cam1 = hou.node(/obj/cam1)
&gt; lookat_obj = hou.node(/obj/geo1)
&gt; cam1.setWorldTransform(cam1.buildLookatRotation(lookat_obj))</p>
<blockquote>
<div>See also hou.ObjNode.setWorldTransform.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.ObjNode.combine">
<code class="descname">combine</code><span class="sig-paren">(</span><em>self</em>, <em>nodes</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ObjNode.combine" title="Permalink to this definition"></a></dt>
<dd><p>Combine the geometry from the given list of hou.ObjNodes into this
object. After this operation, the old objects will be deleted.</p>
<p>Raises hou.ObjectWasDeleted if any of the nodes no longer exist in
Houdini. Raises TypeError if any of the nodes are not of type
hou.ObjNode. These exceptions are raised prior to performing the
combine operation to avoid partial results.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ObjNode.displayNode">
<code class="descname">displayNode</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Node or None<a class="headerlink" href="#hou.ObjNode.displayNode" title="Permalink to this definition"></a></dt>
<dd><p>If this object contains SOPs or DOPs, return the one that has its
display flag on. Otherwise, return None.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ObjNode.getTransformFromPointToPoint">
<code class="descname">getTransformFromPointToPoint</code><span class="sig-paren">(</span><em>self</em>, <em>pos3</em>, <em>other_node</em>, <em>other_pos3</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ObjNode.getTransformFromPointToPoint" title="Permalink to this definition"></a></dt>
<dd><p>hou.Matrix4</p>
<blockquote>
<div>Return the transform matrix that rotates the point pos3 (in this
object nodes transform space) to the point other_pos3 (in another
object nodes transform space).</div></blockquote>
<p>&gt; obj1.getTransformFromPointToPoint(pos1, obj2, pos2)</p>
<blockquote>
<div>is equivalent to</div></blockquote>
<p>&gt; (obj1.worldTransform().inverted() *
&gt;     hou.hmath.buildTranslate(-pos1) *
&gt;     hou.hmath.buildTranslate(pos2) *
&gt;     obj2.worldTransform())</p>
<blockquote>
<div>See also the hou.ObjNode.getTransformToNode and
hou.ObjNode.worldTransform methods, and the functions in the
hou.hmath module.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.ObjNode.getTransformToNode">
<code class="descname">getTransformToNode</code><span class="sig-paren">(</span><em>self</em>, <em>obj_node</em><span class="sig-paren">)</span> &#x2192; hou.Matrix4<a class="headerlink" href="#hou.ObjNode.getTransformToNode" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Return a matrix that transforms this node to line up with the other
node.</p>
<p>The following invariant is true: node1.worldTransform() *
node1.getTransformToNode(node2) == node2.worldTransform().</p>
<p>This method can be implemented as follows:</p>
</div></blockquote>
<p>&gt; def getTransformToNode(self, obj_node):
&gt; self.worldTransform().inverted() * obj_node.worldTransform()</p>
<blockquote>
<div><p>To align node1 (an ObjNode object) with node2 (another ObjNode
object), you dont need to use getTransformToNode(). You can simply
write: node1.setWorldTransform(node2.worldTransform()).</p>
<p>See also hou.ObjNode.origin(), hou.ObjNode.worldTransform(), and
hou.ObjNode.setWorldTransform().</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.ObjNode.isDisplayFlagSet">
<code class="descname">isDisplayFlagSet</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.ObjNode.isDisplayFlagSet" title="Permalink to this definition"></a></dt>
<dd><p>Return whether or not this objects display flag is turned on. Note
that the display flag and the display parameter both determine
whether the object is actually displayed.</p>
<p>Use hou.ObjNode.isObjectDisplayed to determine if the object is
actually displayed.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ObjNode.isObjectDisplayed">
<code class="descname">isObjectDisplayed</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.ObjNode.isObjectDisplayed" title="Permalink to this definition"></a></dt>
<dd><p>Return whether or not this object is displayed. This method takes
into account both the display flag and the display parameter. If the
display parameter is enabled, because the tdisplay parameter is set,
this parameter overrides the flag.</p>
<p>See also hou.ObjNode.isDisplayFlagSet, which returns the current
state of the flag.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ObjNode.isSelectableInViewport">
<code class="descname">isSelectableInViewport</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.ObjNode.isSelectableInViewport" title="Permalink to this definition"></a></dt>
<dd><p>Return whether or not the selectable flag is set. When it is not
set, it is not possible to select this object or any of its geometry
interactively in the viewport.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ObjNode.isShowingOrigin">
<code class="descname">isShowingOrigin</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.ObjNode.isShowingOrigin" title="Permalink to this definition"></a></dt>
<dd><p>Return whether or not this object displays its local origin gnomon
in the viewport.</p>
<p>Note that you can change this setting by right-clicking on the node.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ObjNode.isUsingXray">
<code class="descname">isUsingXray</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.ObjNode.isUsingXray" title="Permalink to this definition"></a></dt>
<dd><p>Return whether or not this object displays its geometry in xray
mode. Houdini displays xrayed geometry in wireframe and makes it
visible even when it is hidden behind another surface.</p>
<p>Note that you can change this setting by right-clicking on the node.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ObjNode.localTransform">
<code class="descname">localTransform</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Matrix4<a class="headerlink" href="#hou.ObjNode.localTransform" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Return the matrix that transforms this objects geometry into space
of its input.</p>
<p>The local transform matrix contains the cumulative transforms of:</p>
</div></blockquote>
<ul>
<li><p class="first">The nodes pre-transform</p>
</li>
<li><p class="first">The transform defined by the nodes transform parameters</p>
</li>
<li><p class="first">The transform adjustment by the nodes lookat and path parameters</p>
<p>The local transform matrix, independent of the nodes pre-transform,
can be obtained as follows:</p>
</li>
</ul>
<p>&gt; def localTransformIgnorePreTransform(self):
&gt; return (self.localTransform() * self.preTransform().inverted())</p>
<blockquote>
<div>See also hou.ObjNode.localTransformAtTime and
hou.ObjNode.worldTransform.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.ObjNode.localTransformAtTime">
<code class="descname">localTransformAtTime</code><span class="sig-paren">(</span><em>self</em>, <em>time</em><span class="sig-paren">)</span> &#x2192; hou.Matrix4<a class="headerlink" href="#hou.ObjNode.localTransformAtTime" title="Permalink to this definition"></a></dt>
<dd><p>Return, for the specified time, the matrix that transforms this
objects geometry into the space of its input.</p>
<p>If the objects local transform is animated, this method provides a
way to get the transformation at a specific time.</p>
<p>See hou.ObjNode.localTransform for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ObjNode.material">
<code class="descname">material</code><span class="sig-paren">(</span><em>self</em>, <em>operation</em>, <em>parameter</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ObjNode.material" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Manages object-local overrides of material parameters. This is
basically the scripting equivalent of the Material Override menu in
the parameter editor for objects. It allows you to create parameters
on an object that override the equivalent values on the objects
material.</p>
<p>The operation argument should be one of the following strings:</p>
<dl class="docutils">
<dt>override</dt>
<dd>Create parameters on the object to override _all_ material
parameters.</dd>
<dt>select</dt>
<dd>Select and create object parameters to override material
parameters.</dd>
<dt>remove</dt>
<dd>Removes _all_ object parameter overrides.</dd>
<dt>rmdefault</dt>
<dd>Removes any unchanged object parameters (that is, that are
currently set to their default value).</dd>
<dt>sync</dt>
<dd>Synchronize the object parameter overrides with the parameter
definitions on the material.</dd>
<dt>revert</dt>
<dd>Revert any parameter overrides on the object to their values on
the material.</dd>
<dt>addlist</dt>
<dd>(Followed by a second argument containing a list of parameter
names strings.) Creates object parameters to override the named
parameters on the material.</dd>
</dl>
</div></blockquote>
<p>&gt; 
&gt; myobject = hou.node(/obj/obj1)
&gt; 
&gt; # Add all material overrides
&gt; myobject.material(override)
&gt; 
&gt; # Remove all material overrides
&gt; myobject.material(remove)
&gt; 
&gt; # Add specific overrides for baseColor and roughness parameters
&gt; myobject.material(addlist, [baseColor, roughness])</p>
</dd></dl>

<dl class="method">
<dt id="hou.ObjNode.moveParmRotateIntoPreTransform">
<code class="descname">moveParmRotateIntoPreTransform</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ObjNode.moveParmRotateIntoPreTransform" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Set this objects rotate values to zero and adjust the pre-transform
so that the objects world transform does not change.</p>
<p>Suppose:</p>
</div></blockquote>
<ul>
<li><p class="first">W is the world transform,</p>
</li>
<li><p class="first">L is the parameter transform without any rotate component,</p>
</li>
<li><p class="first">L is the existing parm transform,</p>
</li>
<li><p class="first">P is the desired new pre-transform,</p>
</li>
<li><p class="first">P is the current pre-transform,</p>
</li>
<li><p class="first">O is the parent transform combined with the containing subnets,
transform</p>
<p>Then,</p>
</li>
<li><p class="first">W = L * P * O and W = L * P * O</p>
</li>
<li><p class="first">L * P = L * P</p>
</li>
<li><p class="first">P = L^ * L * P So, this method is implemented approximately as
follows:</p>
</li>
</ul>
<p>&gt; def moveParmRotateIntoPreTransform(self):
&gt; old_parm_transform = self.parmTransform()
&gt; self.parmTuple(r).set((0.0, 0.0, 0.0))
&gt; self.setPreTransform(
&gt;     self.parmTransform() * old_parm_transform * self.preTransform())</p>
<blockquote>
<div>See also hou.ObjNode.preTransform and the class documentation.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.ObjNode.moveParmScaleIntoPreTransform">
<code class="descname">moveParmScaleIntoPreTransform</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ObjNode.moveParmScaleIntoPreTransform" title="Permalink to this definition"></a></dt>
<dd><p>Set this objects scale values to one and adjust the pre-transform
so that the world transform does not change.</p>
<p>See hou.ObjNode.moveParmRotateIntoPreTransform for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ObjNode.moveParmTransformIntoPreTransform">
<code class="descname">moveParmTransformIntoPreTransform</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ObjNode.moveParmTransformIntoPreTransform" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Set this objects parm transform to the identity and adjust the pre-
transform so that the world transform does not change.</p>
<p>This method is implemented approximately as follows:</p>
</div></blockquote>
<p>&gt; def moveParmTransformIntoPreTransform(self):
&gt; self.setPreTransform(self.parmTransform() * self.preTransform())
&gt; self.setParmTransform(hou.hmath.identityTransform())</p>
<blockquote>
<div>See also hou.ObjNode.moveParmRotateIntoPreTransform,
hou.ObjNode.moveParmScaleIntoPreTransform, and
hou.ObjNode.moveParmTranslateIntoPreTransform. Also see
hou.ObjNode.movePreTransformIntoParmTransform.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.ObjNode.moveParmTranslateIntoPreTransform">
<code class="descname">moveParmTranslateIntoPreTransform</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ObjNode.moveParmTranslateIntoPreTransform" title="Permalink to this definition"></a></dt>
<dd><p>Set this objects translate values to zero and adjust the pre-
transform so that the world transform does not change.</p>
<p>See hou.ObjNode.moveParmRotateIntoPreTransform for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ObjNode.movePreTransformIntoParmTransform">
<code class="descname">movePreTransformIntoParmTransform</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ObjNode.movePreTransformIntoParmTransform" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Set this objects pre-transform to the identity and adjust the parm
transform so that the world transform does not change.</p>
<p>This method is implemented approximately as follows:</p>
</div></blockquote>
<p>&gt; def movePreTransformIntoParmTransform(self):
&gt; self.setParmTransform(self.parmTransform() * self.preTransform())
&gt; self.setPreTransform(hou.hmath.identityTransform())</p>
<blockquote>
<div>See also hou.ObjNode.movePreTransformIntoParmTransform.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.ObjNode.origin">
<code class="descname">origin</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Vector3<a class="headerlink" href="#hou.ObjNode.origin" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Return the objects origin position, in world space.</p>
<p>obj.origin() is equivalent to obj.Vector3(0, 0, 0) *
obj.worldTransform().</p>
</div></blockquote>
<p>&gt; # To compute the world space vector from obj1s origin to obj2s origin, you
&gt; # can write:
&gt; obj2.origin() - obj1.origin()
&gt; 
&gt; # To compute the distance, in world space, between the origins of two
&gt; # objects, simply take the length of this vector:
&gt; (obj2.origin() - obj1.origin()).length()
&gt; 
&gt; # If there are no rotations or scales, the vtorigin() hscript expression
&gt; # function will return the same result as obj2.origin() - obj1.origin().
&gt; # If there are rotations or scales, though, it wont.  A Python equivalent
&gt; # of vtorigin() is defined by:
&gt; def vtorigin(obj1, obj2):
&gt;     return (obj2.worldTransform() * obj1.worldTransform().inverted()).extractTranslates()</p>
<blockquote>
<div>See also the hou.ObjNode.worldTransform and
hou.ObjNode.getTransformToNode methods.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.ObjNode.parentAndSubnetTransform">
<code class="descname">parentAndSubnetTransform</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Matrix4<a class="headerlink" href="#hou.ObjNode.parentAndSubnetTransform" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Return the input nodes world space transform (if there is an input
connected), combined with the world space transform of the
containing subnet object (if there is one). See the class
documentation for more information.</p>
<p>This method can approximately be implemented as follows:</p>
</div></blockquote>
<p>&gt; def parentAndSubnetTransform(self):
&gt; if len(self.inputConnectors()[0]) != 0:
&gt;     return self.inputs()[0].worldTransform()
&gt; 
&gt; containing_subnet = self.parent()
&gt; if containing_subnet.type().category() == hou.objNodeTypeCategory():
&gt;     return containing_subnet.worldTransform()
&gt; 
&gt; return hou.hmath.identityMatrix()</p>
</dd></dl>

<dl class="method">
<dt id="hou.ObjNode.parmPivotTransform">
<code class="descname">parmPivotTransform</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Matrix4<a class="headerlink" href="#hou.ObjNode.parmPivotTransform" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Return the pivot transform defined by the parameters on this node.</p>
<p>This method can approximately be implemented as follows:</p>
</div></blockquote>
<p>&gt; def parmPivotTransform(self):
&gt; pivot_transform = hou.hmath.buildTranslate(self.evalParmTuple(p))
&gt; return (
&gt;     hou.hmath.buildTransform({
&gt;         translate: self.evalParmTuple(p),
&gt;         rotate: self.evalParmTuple(pr)},
&gt;     transform_order=srt,
&gt;     rotate_order=xyz)</p>
<blockquote>
<div>See also hou.ObjNode.parmTransform.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.ObjNode.parmTransform">
<code class="descname">parmTransform</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Matrix4<a class="headerlink" href="#hou.ObjNode.parmTransform" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Return the transform defined by the parameters on this node.</p>
<p>This method can approximately be implemented as follows:</p>
</div></blockquote>
<p>&gt; def parmTransform(self):
&gt; pivot_transform = hou.hmath.buildTransform({
&gt;     translate:self.evalParmTuple(p),
&gt;     rotate:self.evalParmTuple(pr)},
&gt;     transform_order=srt,
&gt;     rotate_order=xyz)
&gt; return (
&gt;     pivot_transform.inverted() *
&gt;     hou.hmath.buildTransform({
&gt;         translate: self.evalParmTuple(t),
&gt;         rotate: self.evalParmTuple(r),
&gt;         scale: [self.evalParm(scale) * s
&gt;         for s in self.evalParmTuple(s)],
&gt;         shear: (0.0, 0.0, 0.0)},
&gt;     transform_order=self.parm(xOrd).evalAsString(),
&gt;     rotate_order=self.parm(rOrd).evalAsString()) *
&gt;     pivot_transform)</p>
<blockquote>
<div><p>See the class documentation for the relation between this transform
and the world space transform. See also hou.ObjNode.worldTransform.</p>
<p>NOTE: For Python Objects, the python code sets the parm transform as
well and wont necessarily have any visible parameters. To get the
local transform of an object (ie. the transform without any
parenting), use hou.ObjNode.localTransform.</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.ObjNode.preTransform">
<code class="descname">preTransform</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Matrix4<a class="headerlink" href="#hou.ObjNode.preTransform" title="Permalink to this definition"></a></dt>
<dd><p>Return this objects pretransform.</p>
<p>The pre-transform allows you to apply a transform after the
parameter transform but before input and containing object
transforms. See the class documentation for more details.</p>
<p>Unlike the parameter transform, the pretransform is not stored using
any parameters on the node. Instead, Houdini stores the pretransform
as a matrix. Because it is directly as a matrix, the pretransform
may contain shears.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ObjNode.renderNode">
<code class="descname">renderNode</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Node or None<a class="headerlink" href="#hou.ObjNode.renderNode" title="Permalink to this definition"></a></dt>
<dd><p>If this object contains SOPs or DOPs, return the one that has its
render flag on. Otherwise, return None.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ObjNode.setCookTransform">
<code class="descname">setCookTransform</code><span class="sig-paren">(</span><em>self</em>, <em>matrix</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ObjNode.setCookTransform" title="Permalink to this definition"></a></dt>
<dd><p>Set the parameter transform for the Python object thats cooking.
Call this method from objects implemented in Python to set the
result of the cook.</p>
<p>Note that an object implemented in Python controls the parameter
transform (i.e. the result of hou.ObjNode.parmTransform). The world
transform (i.e. the result of hou.ObjNode.worldTransform) is still
affected by parent nodes transforms, pre-transforms, etc.</p>
<p>This method raises hou.OperationFailed if you call it on an object
that is not implemented in Python or if you call it from outside
that objects Python cook code.</p>
<p>See the Transforms from Disk example.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ObjNode.setDisplayFlag">
<code class="descname">setDisplayFlag</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ObjNode.setDisplayFlag" title="Permalink to this definition"></a></dt>
<dd><p>Turn the objects display flag on or off. See also
hou.ObjNode.isDisplayFlagSet.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ObjNode.setParmPivotTransform">
<code class="descname">setParmPivotTransform</code><span class="sig-paren">(</span><em>self</em>, <em>matrix</em>, <em>fail_on_locked_parms=False</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ObjNode.setParmPivotTransform" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Sets the pivot transform controlled by this objects parameters.</p>
<p>This method will adjust the pivot translate and pivot rotate values
of this object to achieve the desired transform. It will not
compensate for any changes this causes to the world transform of
this object.</p>
<p>If fail_on_locked_parms is True, and any of the pivot translate or
pivot rotate rotate parameters of the object are locked, this method
will raise hou.OperationFailed. If it is False and any of those
parameters are locked, this method will change their values but
leave them locked.</p>
<p>See also hou.ObjNode.parmPivotTransform and
hou.ObjNode.setParmTransform.</p>
<p>This method can be approximately implemented as follows, ignoring
locked parameters:</p>
</div></blockquote>
<p>&gt; def setParmPivotTransform(self, matrix):
&gt; parm_values = matrix.explode(
&gt;     transform_order=self.parm(xOrd).evalAsString(),
&gt;     rotate_order=self.parm(rOrd).evalAsString(),
&gt;     pivot=hou.Vector3())
&gt; 
&gt; for parm_name, key in (p, translate), (pr, rotate):
&gt;     self.parmTuple(parm_name).set(parm_values[key])</p>
<blockquote>
<div>See also hou.Matrix4.explode.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.ObjNode.setParmTransform">
<code class="descname">setParmTransform</code><span class="sig-paren">(</span><em>self</em>, <em>matrix</em>, <em>fail_on_locked_parms=False</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ObjNode.setParmTransform" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Sets the transform controlled by this objects parameters.</p>
<p>This method will adjust the translate, rotate, and scale values of
this object to achieve the desired parameter, or local, transform.
It will account for the existing pivot position, transformation
order, and rotation order, and will leave them unchanged.</p>
<p>Note that object nodes do not currently have shears parameters, so
any shears in the matrix will be discarded.</p>
<p>If fail_on_locked_parms is True, and any of the translate, rotate,
or scale parameters of the object are locked, this method will raise
hou.OperationFailed. If it is False and any of those parameters are
locked, this method will change their values but leave them locked.</p>
<p>See also hou.ObjNode.parmTransform and
hou.ObjNode.setWorldTransform.</p>
<p>This method can be approximately implemented as follows, ignoring
locked parameters:</p>
</div></blockquote>
<p>&gt; def setParmTransform(self, matrix):
&gt; parm_values = matrix.explode(
&gt;     transform_order=self.parm(xOrd).evalAsString(),
&gt;     rotate_order=self.parm(rOrd).evalAsString(),
&gt;     pivot=hou.Vector3(self.evalParmTuple(p)))
&gt; 
&gt; for parm_name, key in (t, translate), (r, rotate), (s, scale):
&gt;     self.parmTuple(parm_name).set(parm_values[key])</p>
<blockquote>
<div>See also hou.Matrix4.explode.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.ObjNode.setPreTransform">
<code class="descname">setPreTransform</code><span class="sig-paren">(</span><em>self</em>, <em>matrix</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ObjNode.setPreTransform" title="Permalink to this definition"></a></dt>
<dd><p>Set this objects pretransform. See hou.ObjNode.preTransform for
more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ObjNode.setSelectableInViewport">
<code class="descname">setSelectableInViewport</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ObjNode.setSelectableInViewport" title="Permalink to this definition"></a></dt>
<dd><p>Set the objects selectable flag. See
hou.ObjNode.isSelectableInViewport for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ObjNode.setWorldTransform">
<code class="descname">setWorldTransform</code><span class="sig-paren">(</span><em>self</em>, <em>matrix</em>, <em>fail_on_locked_parms=False</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ObjNode.setWorldTransform" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Adjust this objects parameters to achieve the desired world
transformation.</p>
<p>This method will adjust the translate, rotate, and scale values of
this object to achieve the desired final world transform. It
accounts for the transforms of containing networks, parent
transforms, and pre-transforms.</p>
<p>If fail_on_locked_parms is True, and any of the translate, rotate,
or scale parameters of the object are locked, this method raises
hou.OperationFailed. If it is False and any of those parameters are
locked, this method will change their values but leave them locked.</p>
<p>Suppose:</p>
</div></blockquote>
<ul>
<li><p class="first">W is the desired new world transform,</p>
</li>
<li><p class="first">W is the existing world transform,</p>
</li>
<li><p class="first">L is the desired transform defined by the nodes parameters,</p>
</li>
<li><p class="first">L is the existing parm transform,</p>
</li>
<li><p class="first">P is the objects pre-transform,</p>
</li>
<li><p class="first">O is the parent transform combined with the containing subnets,
transform</p>
<p>Then, since W = L * P * O we have P = W * O^ * R^. So, this method
could be implemented as follows:</p>
</li>
</ul>
<p>&gt; def setWorldTransform(self):
&gt; self.setParmTransform(
&gt;     matrix * self.parentAndSubnetTransform().inverted() * self.preTransform().inverted(),
&gt;     fail_on_locked_parms)</p>
<blockquote>
<div>Alternately, we can derive L from W and L as follows:</div></blockquote>
<ul>
<li><p class="first">W = L * P * O</p>
</li>
<li><p class="first">so P * O = L^ * W</p>
</li>
<li><p class="first">and (P * O)^ = W^ * L and</p>
</li>
<li><p class="first">W = L * P * O</p>
</li>
<li><p class="first">so L = W * (P * O)^</p>
</li>
<li><p class="first">giving L = W * W^ * L</p>
<p>Thus, this method could also be implemented using the current world
and parm transforms as follows:</p>
</li>
</ul>
<p>&gt; def setWorldTransform(self):
&gt; self.setParmTransform(
&gt;     matrix * self.worldTransform().inverted() * self.parmTransform(),
&gt;     fail_on_locked_parms)</p>
<blockquote>
<div><p>Note that, because parm transforms cannot contain shears, it is
possible that the resulting world transform will not match the
desired transform. If r is a function that removes shears from a
transform then the new world transform will actually be L * P * O =
r(W * O^ * P^) * P * O.</p>
<p>See also hou.ObjNode.worldTransform and
hou.ObjNode.setParmTransform.</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.ObjNode.showOrigin">
<code class="descname">showOrigin</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ObjNode.showOrigin" title="Permalink to this definition"></a></dt>
<dd><p>Show or hide this objects local origin gnomon in the viewport. See
also hou.ObjNode.isShowingOrigin.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.ObjNode.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.ObjNode.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

<dl class="method">
<dt id="hou.ObjNode.useXray">
<code class="descname">useXray</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ObjNode.useXray" title="Permalink to this definition"></a></dt>
<dd><p>Turn this objects xray mode on or off. See also
hou.ObjNode.isUsingXray.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ObjNode.worldTransform">
<code class="descname">worldTransform</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Matrix4<a class="headerlink" href="#hou.ObjNode.worldTransform" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Return the matrix that transforms this objects geometry into world
space.</p>
<p>The world transform matrix contains the cumulative transforms of:</p>
</div></blockquote>
<ul>
<li><p class="first">The nodes pre-transform</p>
</li>
<li><p class="first">The transform defined by the nodes parameters</p>
</li>
<li><p class="first">The transforms of parent nodes or containing networks</p>
<p>This method can approximately be implemented as follows:</p>
</li>
</ul>
<p>&gt; def worldTransform(self):
&gt; return (self.localTransform() * self.parentAndSubnetTransform())</p>
<blockquote>
<div>See also hou.ObjNode.setWorldTransform and
hou.ObjNode.worldTransformAtTime.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.ObjNode.worldTransformAtTime">
<code class="descname">worldTransformAtTime</code><span class="sig-paren">(</span><em>self</em>, <em>time</em><span class="sig-paren">)</span> &#x2192; hou.Matrix4<a class="headerlink" href="#hou.ObjNode.worldTransformAtTime" title="Permalink to this definition"></a></dt>
<dd><p>Return, for the specified time, the matrix that transforms this
objects geometry into world space.</p>
<p>If the objects world transform is animated, this method provides a
way to get the transformation at a specific time.</p>
<p>See hou.ObjNode.worldTransform for more information.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.ObjectWasDeleted">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">ObjectWasDeleted</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ObjectWasDeleted" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.Error" title="hou.Error"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.Error</span></code></a></p>
<p>Exception class for when you use a stale variable to attempt to access
something that was deleted in Houdini. This class is a subclass of
hou.Error.</p>
<p>For example, setting a variable to a Node object, deleting that node in
Houdini, and attempting to call a method using the variable will raise
this exception.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.Error</li>
</ul>
</div></blockquote>
<dl class="method">
<dt id="hou.ObjectWasDeleted.description">
<code class="descname">description</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.ObjectWasDeleted.description" title="Permalink to this definition"></a></dt>
<dd><p>Return a description of the class of exception. The description is
not related to the exception instance.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ObjectWasDeleted.exceptionTypeName">
<code class="descname">exceptionTypeName</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.ObjectWasDeleted.exceptionTypeName" title="Permalink to this definition"></a></dt>
<dd><p>Return the name of the exception type. Instances of different
subclasses of hou.Error will return different names. Instances of
the base class will return Error.</p>
<p>You can also use str(e.__class__) to get the name of the subclass.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.ObjectWasDeleted.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.ObjectWasDeleted.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.OperationFailed">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">OperationFailed</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.OperationFailed" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.Error" title="hou.Error"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.Error</span></code></a></p>
<dl class="method">
<dt id="hou.OperationFailed.description">
<code class="descname">description</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.OperationFailed.description" title="Permalink to this definition"></a></dt>
<dd><p>Return a description of the class of exception. The description is
not related to the exception instance.</p>
</dd></dl>

<dl class="method">
<dt id="hou.OperationFailed.exceptionTypeName">
<code class="descname">exceptionTypeName</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.OperationFailed.exceptionTypeName" title="Permalink to this definition"></a></dt>
<dd><p>Return the name of the exception type. Instances of different
subclasses of hou.Error will return different names. Instances of
the base class will return Error.</p>
<p>You can also use str(e.__class__) to get the name of the subclass.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.OperationFailed.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.OperationFailed.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.OperationInterrupted">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">OperationInterrupted</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.OperationInterrupted" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.Error" title="hou.Error"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.Error</span></code></a></p>
<dl class="method">
<dt id="hou.OperationInterrupted.description">
<code class="descname">description</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.OperationInterrupted.description" title="Permalink to this definition"></a></dt>
<dd><p>Return a description of the class of exception. The description is
not related to the exception instance.</p>
</dd></dl>

<dl class="method">
<dt id="hou.OperationInterrupted.exceptionTypeName">
<code class="descname">exceptionTypeName</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.OperationInterrupted.exceptionTypeName" title="Permalink to this definition"></a></dt>
<dd><p>Return the name of the exception type. Instances of different
subclasses of hou.Error will return different names. Instances of
the base class will return Error.</p>
<p>You can also use str(e.__class__) to get the name of the subclass.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.OperationInterrupted.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.OperationInterrupted.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.OrboltURLHandler">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">OrboltURLHandler</code><a class="headerlink" href="#hou.OrboltURLHandler" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="method">
<dt id="hou.OrboltURLHandler.closeSplashScreen">
<code class="descname">closeSplashScreen</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.OrboltURLHandler.closeSplashScreen" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.OrboltURLHandler.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.OrboltURLHandler.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

<dl class="method">
<dt id="hou.OrboltURLHandler.updateProgressBar">
<code class="descname">updateProgressBar</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.OrboltURLHandler.updateProgressBar" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.OrientedBoundingRect">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">OrientedBoundingRect</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.OrientedBoundingRect" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>An oriented 2D rectangular region.</p>
<p>Computes an oriented bounding rectangle for a set of points.</p>
<dl class="method">
<dt id="hou.OrientedBoundingRect.center">
<code class="descname">center</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Vector2<a class="headerlink" href="#hou.OrientedBoundingRect.center" title="Permalink to this definition"></a></dt>
<dd><p>Returns the position of the center of the bounding rectangle.</p>
</dd></dl>

<dl class="method">
<dt id="hou.OrientedBoundingRect.isAlmostEqual">
<code class="descname">isAlmostEqual</code><span class="sig-paren">(</span><em>self</em>, <em>brect</em>, <em>tolerance=0.00001</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.OrientedBoundingRect.isAlmostEqual" title="Permalink to this definition"></a></dt>
<dd><p>Returns whether this bounding rectangle is equal to another, subject
to numerical tolerances.</p>
</dd></dl>

<dl class="method">
<dt id="hou.OrientedBoundingRect.orientation">
<code class="descname">orientation</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Matrix2<a class="headerlink" href="#hou.OrientedBoundingRect.orientation" title="Permalink to this definition"></a></dt>
<dd><p>Returns a hou.Matrix2 that defines the orientation of the bounding
rectangle.</p>
</dd></dl>

<dl class="method">
<dt id="hou.OrientedBoundingRect.sizevec">
<code class="descname">sizevec</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Vector2<a class="headerlink" href="#hou.OrientedBoundingRect.sizevec" title="Permalink to this definition"></a></dt>
<dd><p>Returns a vector describing the size of the box in the x and y axes.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.OrientedBoundingRect.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.OrientedBoundingRect.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.PackedFragment">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">PackedFragment</code><a class="headerlink" href="#hou.PackedFragment" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.PackedPrim" title="hou.PackedPrim"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.PackedPrim</span></code></a></p>
<p>A packed fragment primitive.</p>
<p>See packed primitives for more information.</p>
<dl class="method">
<dt id="hou.PackedFragment.setEmbeddedGeometry">
<code class="descname">setEmbeddedGeometry</code><span class="sig-paren">(</span><em>self</em>, <em>geo</em>, <em>attrib</em>, <em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.PackedFragment.setEmbeddedGeometry" title="Permalink to this definition"></a></dt>
<dd><p>Embeds into this primitive all primitives from geo with the value
name for the primitive attribute attrib. Use read-only frozen
geometry to share geometry between multiple packed fragment
primitives. See hou.Geometry.freeze for more information.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.PackedFragment.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.PackedFragment.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.PackedGeometry">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">PackedGeometry</code><a class="headerlink" href="#hou.PackedGeometry" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.PackedPrim" title="hou.PackedPrim"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.PackedPrim</span></code></a></p>
<p>A packed geometry primitive.</p>
<p>See packed primitives for more information.</p>
<dl class="method">
<dt id="hou.PackedGeometry.getEmbeddedGeometry">
<code class="descname">getEmbeddedGeometry</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.PackedGeometry.getEmbeddedGeometry" title="Permalink to this definition"></a></dt>
<dd><p>Returns the geometry of this primitive.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PackedGeometry.setEmbeddedGeometry">
<code class="descname">setEmbeddedGeometry</code><span class="sig-paren">(</span><em>self</em>, <em>geo</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.PackedGeometry.setEmbeddedGeometry" title="Permalink to this definition"></a></dt>
<dd><p>Embeds the provided geometry into this primitive. Use read-only
frozen geometry to share geometry between multiple packed geometry
primitives. See hou.Geometry.freeze for more information.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.PackedGeometry.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.PackedGeometry.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.PackedPrim">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">PackedPrim</code><a class="headerlink" href="#hou.PackedPrim" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.Prim" title="hou.Prim"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.Prim</span></code></a></p>
<p>A packed primitive.</p>
<p>See packed primitives for more information.</p>
<p>To set contents of the packed primitive, use the
hou.Prim.setIntrinsicValue method:</p>
<p>&gt; prim = myGeometry.createPacked(PackedDisk)
&gt; prim.setIntrinsicValue(unexpandedfilename, defgeo.bgeo)</p>
<p>To get the list of available intrinsic attributes you can set:</p>
<blockquote>
<div><ul>
<li><p class="first">View a packed primitive of the type you want in the geometry
spreadsheet and turn on display of intrinsic attributes.</p>
<p>_or_</p>
</li>
<li><p class="first">In a Houdini tools command line, type ginfo -IP to see a list of all
intrinsc attributes on all packed primitive types.</p>
</li>
</ul>
</div></blockquote>
<dl class="method">
<dt id="hou.PackedPrim.fullTransform">
<code class="descname">fullTransform</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Matrix4<a class="headerlink" href="#hou.PackedPrim.fullTransform" title="Permalink to this definition"></a></dt>
<dd><p>Returns the full 4x4 transform for this primitives geometry. This
includes translations due to points and any transforms inside the
primitive (for example, transforms inside an Alembic file).</p>
</dd></dl>

<dl class="method">
<dt id="hou.PackedPrim.setTransform">
<code class="descname">setTransform</code><span class="sig-paren">(</span><em>self</em>, <em>m4</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.PackedPrim.setTransform" title="Permalink to this definition"></a></dt>
<dd><p>Sets this primitives local transform. This sets the local 3x3
transform _and_ the translation of the point. This does not affect
any transforms inside the primitive (for example, transforms inside
an Alembic file).</p>
<p>Raises hou.GeometryPermissionError if this geometry is not
modifiable.</p>
<dl class="docutils">
<dt>m4</dt>
<dd>A hou.Matrix4 object containing the full transform.</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="hou.PackedPrim.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.PackedPrim.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

<dl class="method">
<dt id="hou.PackedPrim.transform">
<code class="descname">transform</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Matrix3<a class="headerlink" href="#hou.PackedPrim.transform" title="Permalink to this definition"></a></dt>
<dd><p>Returns the local 3x3 transform associated with this primitive. The
transform doesnt include the local point transform or any
transforms inside the primitive (for example, transforms inside an
Alembic file).</p>
</dd></dl>

<dl class="method">
<dt id="hou.PackedPrim.vertex">
<code class="descname">vertex</code><span class="sig-paren">(</span><em>self</em>, <em>index</em><span class="sig-paren">)</span> &#x2192; hou.Vertex<a class="headerlink" href="#hou.PackedPrim.vertex" title="Permalink to this definition"></a></dt>
<dd><p>A shortcut for self.vertices()[index]. You probably dont need to
call this method.</p>
<p>This method supports negative indices to index from the end, just
like self.vertices()[index] would. Also, like Pythons indexing
operator, it will raise IndexError when the index is out of range.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.Pane">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">Pane</code><a class="headerlink" href="#hou.Pane" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A rectangular area of the desktop that contains one or more pane tabs.</p>
<p>Desktops (and floating panels) are composed of one or more panes.
Initially a desktop contains one pane, and more panes are added to it by
splitting existing panes in two, either horizontally or vertically.</p>
<p>See hou.Desktop for more information about panes and pane tabs. See
hou.FloatingPanel for more information about floating panels.</p>
<dl class="method">
<dt id="hou.Pane.createTab">
<code class="descname">createTab</code><span class="sig-paren">(</span><em>self</em>, <em>type</em><span class="sig-paren">)</span> &#x2192; hou.PaneTab<a class="headerlink" href="#hou.Pane.createTab" title="Permalink to this definition"></a></dt>
<dd><p>Create a new pane tab with the desired type and return it. The new
pane tab will be current (i.e. it will be the pane tab thats open).</p>
</dd></dl>

<dl class="method">
<dt id="hou.Pane.currentTab">
<code class="descname">currentTab</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.PaneTab<a class="headerlink" href="#hou.Pane.currentTab" title="Permalink to this definition"></a></dt>
<dd><p>Return the currently focused pane tab.</p>
<p>See also hou.PaneTab.setIsCurrentTab.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Pane.desktop">
<code class="descname">desktop</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Desktop or None<a class="headerlink" href="#hou.Pane.desktop" title="Permalink to this definition"></a></dt>
<dd><p>Return the desktop in which this pane exists, or None if it is in a
floating panel thats not attached to the desktop.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Pane.floatingPanel">
<code class="descname">floatingPanel</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.Pane.floatingPanel" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.Pane.getSplitChild">
<code class="descname">getSplitChild</code><span class="sig-paren">(</span><em>self</em>, <em>index</em><span class="sig-paren">)</span> &#x2192; hou.Pane or None<a class="headerlink" href="#hou.Pane.getSplitChild" title="Permalink to this definition"></a></dt>
<dd><p>Return the split child Pane at index if the Pane is a split.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Pane.getSplitDirection">
<code class="descname">getSplitDirection</code><span class="sig-paren">(</span><em>self</em>, <em>dir</em><span class="sig-paren">)</span> &#x2192; double<a class="headerlink" href="#hou.Pane.getSplitDirection" title="Permalink to this definition"></a></dt>
<dd><p>Return the split direction of the parent split.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Pane.getSplitFraction">
<code class="descname">getSplitFraction</code><span class="sig-paren">(</span><em>self</em>, <em>fraction</em><span class="sig-paren">)</span> &#x2192; double<a class="headerlink" href="#hou.Pane.getSplitFraction" title="Permalink to this definition"></a></dt>
<dd><p>Return the split fraction of the parent split.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Pane.getSplitParent">
<code class="descname">getSplitParent</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Pane or None<a class="headerlink" href="#hou.Pane.getSplitParent" title="Permalink to this definition"></a></dt>
<dd><p>Return the parent split pane if the Pane is nested under a split.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Pane.id">
<code class="descname">id</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.Pane.id" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.Pane.isMaximized">
<code class="descname">isMaximized</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.Pane.isMaximized" title="Permalink to this definition"></a></dt>
<dd><p>Return True if this pane is maximized.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Pane.isSplit">
<code class="descname">isSplit</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.Pane.isSplit" title="Permalink to this definition"></a></dt>
<dd><p>Return True if the pane is a split.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Pane.isSplitMaximized">
<code class="descname">isSplitMaximized</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.Pane.isSplitMaximized" title="Permalink to this definition"></a></dt>
<dd><p>Return the true if the Pane is maximized on the split. A split cant
be minimized and maximized at the same time. In its default state, a
split is not minimized and not maximized.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Pane.isSplitMinimized">
<code class="descname">isSplitMinimized</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.Pane.isSplitMinimized" title="Permalink to this definition"></a></dt>
<dd><p>Return the true if the Pane is minimized on the split. A split cant
be minimized and maximized at the same time. In its default state, a
split is not minimized and not maximized.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Pane.setIsMaximized">
<code class="descname">setIsMaximized</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Pane.setIsMaximized" title="Permalink to this definition"></a></dt>
<dd><p>Set the maximized state of this pane.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Pane.setIsSplitMaximized">
<code class="descname">setIsSplitMaximized</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.Pane.setIsSplitMaximized" title="Permalink to this definition"></a></dt>
<dd><p>Set the maximized state of a split.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Pane.setSplitDirection">
<code class="descname">setSplitDirection</code><span class="sig-paren">(</span><em>self</em>, <em>dir</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Pane.setSplitDirection" title="Permalink to this definition"></a></dt>
<dd><p>Set the split direction of the parent split.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Pane.setSplitFraction">
<code class="descname">setSplitFraction</code><span class="sig-paren">(</span><em>self</em>, <em>fraction</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Pane.setSplitFraction" title="Permalink to this definition"></a></dt>
<dd><p>Set the split fraction of the parent split.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Pane.splitHorizontally">
<code class="descname">splitHorizontally</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Pane<a class="headerlink" href="#hou.Pane.splitHorizontally" title="Permalink to this definition"></a></dt>
<dd><p>Split the pane, adding a new pane to the right, and return the new
pane. The new pane will have a single tab whose type is the same as
the type of this panes current tab.</p>
<p>See also hou.Pane.splitVertically.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Pane.splitRotate">
<code class="descname">splitRotate</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Pane.splitRotate" title="Permalink to this definition"></a></dt>
<dd><p>Turn an horizontal split Pane into a vertical split Pane.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Pane.splitSwap">
<code class="descname">splitSwap</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Pane.splitSwap" title="Permalink to this definition"></a></dt>
<dd><p>Swap the left and right panes of an horizontal split Pane. Swap the
top and bottom panes of a vertical split Pane.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Pane.splitVertically">
<code class="descname">splitVertically</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Pane<a class="headerlink" href="#hou.Pane.splitVertically" title="Permalink to this definition"></a></dt>
<dd><p>Split the pane, adding a new pane to the bottom, and return the new
pane. The new pane will have a single tab whose type is the same as
the type of this panes current tab.</p>
<p>See also hou.Pane.splitHorizontally.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Pane.tabOfType">
<code class="descname">tabOfType</code><span class="sig-paren">(</span><em>self</em>, <em>type</em>, <em>index=0</em><span class="sig-paren">)</span> &#x2192; hou.PaneTab or None<a class="headerlink" href="#hou.Pane.tabOfType" title="Permalink to this definition"></a></dt>
<dd><p>Find and return a pane tab with the desired type, or None if no such
tab exists in the pane.</p>
<p>If there are multiple tabs in the pane with the desired type, then
the first found tab is returned. Use index to return the other tabs.
For example, use index=0 to return the first found tab, use index=1
to return the second found tab, etc.</p>
<p>See also hou.ui.paneTabOfType.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Pane.tabs">
<code class="descname">tabs</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.PaneTab<a class="headerlink" href="#hou.Pane.tabs" title="Permalink to this definition"></a></dt>
<dd><p>Return the pane tabs in this pane.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.Pane.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.Pane.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.PaneTab">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">PaneTab</code><a class="headerlink" href="#hou.PaneTab" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>One of the tabs inside a desktop pane.</p>
<p>Each pane type is of a particular type (e.g. scene viewer, network view,
parameters, etc.). A pane may contain multiple tabs and displays the
contents of one tab at a time.</p>
<p>See hou.Desktop for more information about panes and pane tabs.</p>
<dl class="method">
<dt id="hou.PaneTab.clone">
<code class="descname">clone</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.PaneTab<a class="headerlink" href="#hou.PaneTab.clone" title="Permalink to this definition"></a></dt>
<dd><p>Create a floating copy of the pane tab and return the cloned pane
tab. The new pane tab is in a new floating panel.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PaneTab.close">
<code class="descname">close</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.PaneTab.close" title="Permalink to this definition"></a></dt>
<dd><p>Close the pane tab.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PaneTab.contentSize">
<code class="descname">contentSize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.PaneTab.contentSize" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.PaneTab.floatingPanel">
<code class="descname">floatingPanel</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.FloatingPanel or None<a class="headerlink" href="#hou.PaneTab.floatingPanel" title="Permalink to this definition"></a></dt>
<dd><p>Return the floating panel that contains this pane tab or None if the
pane tab is not in a floating panel.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PaneTab.isCurrentTab">
<code class="descname">isCurrentTab</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.PaneTab.isCurrentTab" title="Permalink to this definition"></a></dt>
<dd><p>Return whether this tab is the selected tab in the containing pane.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PaneTab.isFloating">
<code class="descname">isFloating</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.PaneTab.isFloating" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Return whether this pane tab is in a floating panel.</p>
<p>This method can be approximately implemented as follows:</p>
</div></blockquote>
<p>&gt; def isFloating(self):
&gt;     return self.pane() is None or self.pane().floatingPanel() is not None</p>
</dd></dl>

<dl class="method">
<dt id="hou.PaneTab.isPin">
<code class="descname">isPin</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.PaneTab.isPin" title="Permalink to this definition"></a></dt>
<dd><p>Return whether this pane tab is pinned. This method is equivalent to
(self.linkGroup() == hou.paneLinkType.Pinned)</p>
<p>See also hou.PaneTab.linkGroup.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PaneTab.linkGroup">
<code class="descname">linkGroup</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.paneLinkType enum value<a class="headerlink" href="#hou.PaneTab.linkGroup" title="Permalink to this definition"></a></dt>
<dd><p>Return the link group that this pane tab belongs to.</p>
<p>See also hou.PaneTab.isPin.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PaneTab.name">
<code class="descname">name</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.PaneTab.name" title="Permalink to this definition"></a></dt>
<dd><p>Return the name of this tab.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PaneTab.pane">
<code class="descname">pane</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Pane or None<a class="headerlink" href="#hou.PaneTab.pane" title="Permalink to this definition"></a></dt>
<dd><p>Return the pane in the desktop that contains this pane tab. Note
that pane tabs in regular floating panels are always in a pane,
since regular floating panels contain one or more panes.</p>
<p>However, some floating panels have their content stripped down to
only contain one particular pane tab type, and do not display the
user interface to add more pane tabs, split the pane, etc. This
method returns None for these stripped down floating panels.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PaneTab.setIsCurrentTab">
<code class="descname">setIsCurrentTab</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.PaneTab.setIsCurrentTab" title="Permalink to this definition"></a></dt>
<dd><p>Set this tab as the selected tab in the containing pane.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PaneTab.setLinkGroup">
<code class="descname">setLinkGroup</code><span class="sig-paren">(</span><em>self</em>, <em>group</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.PaneTab.setLinkGroup" title="Permalink to this definition"></a></dt>
<dd><p>Set the link group membership of this pane tab.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PaneTab.setName">
<code class="descname">setName</code><span class="sig-paren">(</span><em>self</em>, <em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.PaneTab.setName" title="Permalink to this definition"></a></dt>
<dd><p>Set the name of this pane tab. A pane tab name may contain spaces.</p>
<p>Note that this name is the internal name of the tab, and is
different from the label displayed in the interface.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PaneTab.setPin">
<code class="descname">setPin</code><span class="sig-paren">(</span><em>self</em>, <em>pin</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.PaneTab.setPin" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>If pin is True, set the link group membership to
hou.paneLinkType.Pinned. Otherwise, set it to
hou.paneLinkType.FollowSelection. This method can be implemented
using hou.PaneTab.setLinkGroup as follows:</div></blockquote>
<p>&gt; def setPin(self, pin):
&gt;     if pin:
&gt;         self.setLinkGroup(hou.paneLinkType.Pinned)
&gt;     else:
&gt;         self.setLinkGroup(hou.paneLinkType.FollowSelection)</p>
<blockquote>
<div>See also hou.PaneTab.setLinkGroup.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.PaneTab.setType">
<code class="descname">setType</code><span class="sig-paren">(</span><em>self</em>, <em>type</em><span class="sig-paren">)</span> &#x2192; hou.PaneTab<a class="headerlink" href="#hou.PaneTab.setType" title="Permalink to this definition"></a></dt>
<dd><p>Create a new pane tab of the given type, replace this tab with it,
and return the new pane tab. Use the returned pane tab afterward;
references to this tab become invalid.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PaneTab.size">
<code class="descname">size</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.PaneTab.size" title="Permalink to this definition"></a></dt>
<dd><p>contentSize() -&gt; tuple of int</p>
<blockquote>
<div><p>Return a 2-tuple containing the pane tabs content area width and
height.</p>
<p>The width and height do not include the network navigation control
area (if any), pane tab borders or tab area.</p>
</div></blockquote>
</dd></dl>

<dl class="attribute">
<dt id="hou.PaneTab.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.PaneTab.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

<dl class="method">
<dt id="hou.PaneTab.type">
<code class="descname">type</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.paneTabType enum value<a class="headerlink" href="#hou.PaneTab.type" title="Permalink to this definition"></a></dt>
<dd><p>Return the type of this tab (i.e. whether it is a scene viewer,
parameter editor, network editor, etc.).</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.Parm">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">Parm</code><a class="headerlink" href="#hou.Parm" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A parameter in a node. Each parameter has a unique name within its node
and exists inside a parameter tuple.</p>
<p>REPLACES</p>
<blockquote>
<div><ul class="simple">
<li>chadd</li>
<li>chalias</li>
<li>chautoscope</li>
<li>chkey</li>
<li>chkeyget</li>
<li>chkeyls</li>
<li>chlock</li>
<li>chrefit</li>
<li>chreverse</li>
<li>chrm</li>
<li>chround</li>
<li>chscope</li>
<li>chstretch</li>
<li>opparm</li>
<li>opscript</li>
<li>ch()</li>
<li>chf()</li>
<li>chs()</li>
<li>chsraw()</li>
<li>cht()</li>
</ul>
</div></blockquote>
<dl class="method">
<dt id="hou.Parm.alias">
<code class="descname">alias</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.Parm.alias" title="Permalink to this definition"></a></dt>
<dd><p>Returns the parameters channel alias name. Returns an empty string
if no such name exists.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Parm.appendClip">
<code class="descname">appendClip</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.Parm.appendClip" title="Permalink to this definition"></a></dt>
<dd><p>appendClip(self, chop_node, apply_immediately, current_value_only,
create_locked, set_value_to_default)</p>
<blockquote>
<div><p>Appends this parameter to the specified Channel CHOP.</p>
<p>apply_immediately: If set to True, then the export flag on the
Channel CHOP will be set.</p>
<p>current_value_only: If set to True, then only the current value of
the parameter will be stored.</p>
<p>create_locked: If set to True, then the parameters are locked on
creation.</p>
<p>set_value_to_default: If set to True, then the parameters are
reverted to their default values on creation</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.Parm.asCode">
<code class="descname">asCode</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Parm.asCode" title="Permalink to this definition"></a></dt>
<dd><p>asCode(self, brief=False, save_values=True, save_keyframes=True,
save_keys_in_frames=False, save_flag_values=True, save_aliases=True,
function_name=None) -&gt; str</p>
<blockquote>
<div><blockquote>
<div><p>Returns a script of Python statements that can be executed to set
the parameter tuples values, flags and other properties. To run the
script, use either Pythons exec or execfile functions.</p>
<dl class="docutils">
<dt>brief</dt>
<dd>When &lt;brief&gt; is True, the output script omits commands for
setting values and flags that are set to the factory defaults.
The script also omits keyframe commands that set unused values,
slopes and accelerations. The value of &lt;brief&gt; must be either
True or False. save_values: When &lt;save_values&gt; is True, asCode
outputs commands for setting the parameter tuples values. The
value of &lt;save_values&gt; must be either True or False.</dd>
<dt>save_keyframes</dt>
<dd>When &lt;save_keyframes&gt; is True, asCode outputs commands for
creating the parameter tuples keyframes (if any). The value of
&lt;save_keyframes&gt; must be either True or False.</dd>
<dt>save_keys_in_frames</dt>
<dd>When &lt;save_keys_in_frames&gt; is True, asCode outputs commands for
setting channel and key times in samples (frames) instead of
seconds. This parameter has no effect if &lt;save_keyframes&gt; is set
to False. The value of &lt;save_keys_in_frames&gt; must be either True
or False.</dd>
<dt>save_flag_values</dt>
<dd>When &lt;save_flag_values&gt; is True, asCode outputs commands for
setting the parameter tuples flag values. The value of
&lt;save_flag_values&gt; must be either True or False.</dd>
<dt>save_aliases</dt>
<dd>When &lt;save_aliases&gt; is True, asCode outputs commands for setting
the parameter tuples channel aliases. The value of
&lt;save_aliases&gt; must be either True or False.</dd>
<dt>function_name</dt>
<dd>If &lt;function_name&gt; is specified, then the output script is
wrapped in a Python function definition with the given name.
&lt;function_name&gt; must be a non-zero length string consisting of
only alphanumeric and underscore characters. Any invalid
characters are internally converted to underscores.</dd>
</dl>
<p>The wrapper function takes in a single argument which must be a
reference to an existing node parameter tuple. For symmetry, the
function also returns the parameter tuple reference.</p>
<p>Here is an example of saving the output to a file and then loading
it back into Houdini:</p>
</div></blockquote>
<p>&gt; # Get a reference to the target parameter tuple.
&gt; pt = hou.parmTuple(/obj/geo1/t)
&gt; 
&gt; # Execute asCode and write the output script to file.
&gt; script = pt.asCode()
&gt; f = open(set_parm_tuple_properties.py, w)
&gt; f.write(script)
&gt; f.close()
&gt; 
&gt; # Execute the script.  This will set the values, flag values
&gt; # and other properties on /obj/geo1s t parameter tuple.  It will
&gt; # also store a reference to the t parameter tuple into a variable
&gt; # named hou_parm_tuple.
&gt; execfile(set_parm_tuple_properties.py)</p>
<blockquote>
<div>Here is an example of saving the output into a function and then
calling it in Houdini:</div></blockquote>
<p>&gt; # Get a reference to the target parameter tuple.
&gt; node = hou.parmTuple(/obj/geo1/t)
&gt; 
&gt; # Execute asCode and write the function definition to file.
&gt; func = p.asCode(function_name=setParmTupleProperties)
&gt; f = open(parmtuplelib.py, w)
&gt; f.write(func)
&gt; f.close()
&gt; 
&gt; # Call the function definition to set the properties on another
&gt; # parameter tuple.
&gt; import parmtuplelib
&gt; hou_parm_tuple = parmtuplelib.setParmTupleProperties(node.parm(t))</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.Parm.clipData">
<code class="descname">clipData</code><span class="sig-paren">(</span><em>start=None</em>, <em>end=None</em>, <em>binary=True</em>, <em>use_blosc_compression=True</em>, <em>sample_rate=0</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Parm.clipData" title="Permalink to this definition"></a></dt>
<dd><p>clipData(start=None, end=None, binary=True, use_blosc_compression=True,
sample_rate=0) -&gt; str</p>
<blockquote>
<div><p>Returns the clip data for this parameter. This method is similar to
hou.Parm.saveClip, except that it returns the clip data (file
contents) instead of saving the animation to a clip file.</p>
<p>&lt;start&gt;, &lt;end&gt;, and &lt;sample_rate&gt; behave the same as in
hou.Parm.saveClip.</p>
<p>If &lt;binary&gt; is True, return binary clip data, otherwise return plain
text (ASCII) clip data.</p>
<p>If &lt;use_blosc_compression&gt; is True, blosc compress the binary clip
data. This cannot be used for plain text (ASCII) clip data.</p>
<p>Raises a hou.OperationFailed exception if the parameter does not
have animation.</p>
<p>Raises a hou.InvalidInput exception if start &gt;= end. If specifying
only &lt;start&gt;, ensure that the specified value is less than the
global end frame. Likewise, if specifying only &lt;end&gt;, ensure it is
larger than the global start frame.</p>
<p>Raises a hou.InvalidInput exception if binary = False and
use_blosc_compression = True.</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.Parm.componentIndex">
<code class="descname">componentIndex</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.Parm.componentIndex" title="Permalink to this definition"></a></dt>
<dd><p>Returns the component index of this parameter.</p>
<p>For example, the translation parameter along the x-axis, tx, would
return a component index of 0, while the translation parameter along
the y-axis, ty would return a component index of 1.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Parm.containingFolderIndices">
<code class="descname">containingFolderIndices</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of int<a class="headerlink" href="#hou.Parm.containingFolderIndices" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Return a tuple of indices corresponding to the folders containing
this parameter. Each index refers to a folder in the corresponding
folder set parameter.</p>
<p>This method can be implemented as follows:</p>
</div></blockquote>
<p>&gt; def containingFolderIndices(self):
&gt; return tuple(
&gt;     list(folder_set_parm_tuple.parmTemplate().folderNames()).index(
&gt;     folder_name)
&gt;     for folder_set_parm_tuple, folder_name in zip(
&gt;     parm.containingFolderSetParmTuples(), parm.containingFolders()))</p>
<blockquote>
<div>This example makes a parameter visible in the parameter pane by
opening all the folders containing it.</div></blockquote>
<p>&gt; def makeParmVisible(parm):
&gt; for folder_set_parm_tuple, folder_index in zip(
&gt;     parm.containingFolderSetParmTuples(),
&gt;     parm.containingFolderIndices()):
&gt;     folder_set_parm_tuple[0].set(folder_index)</p>
</dd></dl>

<dl class="method">
<dt id="hou.Parm.containingFolderSetParmTuples">
<code class="descname">containingFolderSetParmTuples</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.ParmTuple<a class="headerlink" href="#hou.Parm.containingFolderSetParmTuples" title="Permalink to this definition"></a></dt>
<dd><p>Return a tuple of ParmTuples corresponding to the folders containing
this parameter.</p>
<p>For example, if this parameter is in the Shading folder and the
Shading folder is inside the Render folder, this method will return
a tuple containing the Render parm tuple and the Shading parm tuple.
Any parm tuples returned will be folder sets.</p>
<p>If this parameter is not inside a folder, an empty tuple is
returned.</p>
<p>See also the containingFolders() method, and hou.Node.parmsInFolder
and hou.Node.parmTuplesInFolder.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Parm.containingFolders">
<code class="descname">containingFolders</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of str<a class="headerlink" href="#hou.Parm.containingFolders" title="Permalink to this definition"></a></dt>
<dd><p>Returns a tuple of strings corresponding to the names of the folders
containing this parameter.</p>
<p>For example, if this parameter is in the Shading folder and the
Shading folder is inside the Render folder, this method will return
(Render, Shading). Note that by folder name, we mean the label
used in the parameter dialog, not the internal parameter name.</p>
<p>Returns an empty tuple if this parameter is not inside a folder.</p>
<p>Note that calling this method on many parameters may be slow. For a
faster alternative, see hou.Node.parmsInFolder.</p>
<p>See also the containingFolderSetParmTuples method, and
hou.Node.parmTuplesInFolder.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Parm.copyToParmClipboard">
<code class="descname">copyToParmClipboard</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Parm.copyToParmClipboard" title="Permalink to this definition"></a></dt>
<dd><p>Copies this to the parameter clipboard. See also
hou.parmClipboardContents.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Parm.createClip">
<code class="descname">createClip</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.Parm.createClip" title="Permalink to this definition"></a></dt>
<dd><p>createClip(self, parent_node, name, create_new, apply_immediately,
current_value_only, create_locked, set_value_to_default) -&gt; hou.ChopNode</p>
<blockquote>
<div><p>Creates a Channel CHOP representing this parameter. The Channel CHOP
is created with the given name as a child of the given parent node.
The parent_node is typically created via
hou.Node.findOrCreateMotionEffectsNetwork.</p>
<p>create_new: Always create a new Channel CHOP. If set to False, then
if a Channel CHOP already exists with the same name, it will be re-
used. If the parameter already exists on the Channel CHOP, the older
parameter will be removed first.</p>
<p>apply_immediately: If set to True, then the export flag on the
Channel CHOP will be set.</p>
<p>current_value_only: If set to True, then only the current value of
the parameter will be stored.</p>
<p>create_locked: If set to True, then the parameters are locked on
creation.</p>
<p>set_value_to_default: If set to True, then the parameters are
reverted to their default values on creation</p>
<p>See also hou.Node.findOrCreateMotionEffectsNetwork.</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.Parm.deleteAllKeyframes">
<code class="descname">deleteAllKeyframes</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Parm.deleteAllKeyframes" title="Permalink to this definition"></a></dt>
<dd><p>Removes all keyframes from this parameter.</p>
<p>This has no effect if there are no keyframes to delete. The value of
the parameter after all keyframes are removed will be the one it
evaluated to at the current frame.</p>
<p>This function will raise a hou.ObjectWasDeleted exception if it is
invoked on a parameter that does not exist in Houdini.</p>
<p>This function will raise a hou.PermissionError exception if writing
to the specified parameter is impossible.</p>
<p>See also hou.Parm.deleteKeyframeAtFrame and
hou.ParmTuple.deleteAllKeyframes.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Parm.deleteKeyframeAtFrame">
<code class="descname">deleteKeyframeAtFrame</code><span class="sig-paren">(</span><em>self</em>, <em>frame</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Parm.deleteKeyframeAtFrame" title="Permalink to this definition"></a></dt>
<dd><p>Removes a keyframe from this parameter at the given frame.</p>
<p>This function will raise a hou.ObjectWasDeleted exception if it is
invoked on a parameter that does not exist in Houdini.</p>
<p>This function will raise a hou.PermissionError exception if writing
to the specified parameter is impossible.</p>
<p>This function will raise a hou.OperationFailed exception the
parameter doesnt have a keyframe at the given frame.</p>
<p>See also hou.Parm.deleteAllKeyframes.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Parm.description">
<code class="descname">description</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.Parm.description" title="Permalink to this definition"></a></dt>
<dd><p>Returns this parameters label.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Parm.disable">
<code class="descname">disable</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Parm.disable" title="Permalink to this definition"></a></dt>
<dd><p>Sets the UI disable state of this parameter in its node. This is not
the same as locking a parameter, as the underlying value can still
be modified. Its closer to what a disable-when conditional does,
when a parameter is disabled automatically by it.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Parm.eval">
<code class="descname">eval</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; int, float, or str<a class="headerlink" href="#hou.Parm.eval" title="Permalink to this definition"></a></dt>
<dd><p>Evaluates this parameter at the current frame and returns the
result. See also the evalAtFrame and evalAtTime methods.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Parm.evalAsFloat">
<code class="descname">evalAsFloat</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#hou.Parm.evalAsFloat" title="Permalink to this definition"></a></dt>
<dd><p>Evaluates this parameter at the current frame and returns the result
as a float.</p>
<p>Raises hou.TypeError if the value cannot be converted to a float.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Parm.evalAsFloatAtFrame">
<code class="descname">evalAsFloatAtFrame</code><span class="sig-paren">(</span><em>self</em>, <em>frame</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#hou.Parm.evalAsFloatAtFrame" title="Permalink to this definition"></a></dt>
<dd><p>Evaluates this parameter at a certain frame and returns the result
as a float.</p>
<p>Raises hou.TypeError if the value cannot be converted to a float.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Parm.evalAsGeometry">
<code class="descname">evalAsGeometry</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Geometry<a class="headerlink" href="#hou.Parm.evalAsGeometry" title="Permalink to this definition"></a></dt>
<dd><p>Evaluates this parameter at the current frame and returns the result
as a geometry.</p>
<p>Raises hou.TypeError if the parameter is not a geometry.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Parm.evalAsGeometryAtFrame">
<code class="descname">evalAsGeometryAtFrame</code><span class="sig-paren">(</span><em>self</em>, <em>frame</em><span class="sig-paren">)</span> &#x2192; hou.Geometry<a class="headerlink" href="#hou.Parm.evalAsGeometryAtFrame" title="Permalink to this definition"></a></dt>
<dd><p>Evaluates this parameter at a certain frame and returns the result
as a geometry.</p>
<p>Raises hou.TypeError if the parameter is not a geometry.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Parm.evalAsInt">
<code class="descname">evalAsInt</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.Parm.evalAsInt" title="Permalink to this definition"></a></dt>
<dd><p>Evaluates this parameter at the current frame and returns the result
as an integer.</p>
<p>Raises hou.TypeError if the value cannot be converted to an integer.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Parm.evalAsIntAtFrame">
<code class="descname">evalAsIntAtFrame</code><span class="sig-paren">(</span><em>self</em>, <em>frame</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.Parm.evalAsIntAtFrame" title="Permalink to this definition"></a></dt>
<dd><p>Evaluates this parameter at a certain frame and returns the result
as an integer.</p>
<p>Raises hou.TypeError if the value cannot be converted to an integer.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Parm.evalAsJSONMap">
<code class="descname">evalAsJSONMap</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; dict of str to str<a class="headerlink" href="#hou.Parm.evalAsJSONMap" title="Permalink to this definition"></a></dt>
<dd><p>Evaluates this parameter at the current frame and returns the result
as a JSON map structure (i.e. Python dictionary).</p>
<p>Raises hou.TypeError or hou.OperationFailed if the parameter is not
a JSON map data parameter.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Parm.evalAsJSONMapAtFrame">
<code class="descname">evalAsJSONMapAtFrame</code><span class="sig-paren">(</span><em>self</em>, <em>frame</em><span class="sig-paren">)</span> &#x2192; hou.JSONMap<a class="headerlink" href="#hou.Parm.evalAsJSONMapAtFrame" title="Permalink to this definition"></a></dt>
<dd><p>Evaluates this parameter at a certain frame and returns the result
as a JSON map structure (i.e. Python dictionary).</p>
<p>Raises hou.TypeError or hou.OperationFailed if the parameter is not
a JSON map data parameter.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Parm.evalAsNode">
<code class="descname">evalAsNode</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Node<a class="headerlink" href="#hou.Parm.evalAsNode" title="Permalink to this definition"></a></dt>
<dd><p>Evaluates this parameter at the current frame and returns the result
as a hou.Node.</p>
<p>Raises hou.TypeError if the value cannot be converted to a hou.Node.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Parm.evalAsNodeAtFrame">
<code class="descname">evalAsNodeAtFrame</code><span class="sig-paren">(</span><em>self</em>, <em>frame</em><span class="sig-paren">)</span> &#x2192; hou.Node<a class="headerlink" href="#hou.Parm.evalAsNodeAtFrame" title="Permalink to this definition"></a></dt>
<dd><p>Evaluates this parameter at a certain frame and returns the result
as a hou.Node.</p>
<p>Raises hou.TypeError if the value cannot be converted to a hou.Node.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Parm.evalAsNodes">
<code class="descname">evalAsNodes</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.Node<a class="headerlink" href="#hou.Parm.evalAsNodes" title="Permalink to this definition"></a></dt>
<dd><p>Evaluates this parameter at the current frame and returns the result
as a tuple of hou.Node.</p>
<p>Raises hou.TypeError if the value cannot be converted to a hou.Node.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Parm.evalAsNodesAtFrame">
<code class="descname">evalAsNodesAtFrame</code><span class="sig-paren">(</span><em>self</em>, <em>frame</em><span class="sig-paren">)</span> &#x2192; tuple of hou.Node<a class="headerlink" href="#hou.Parm.evalAsNodesAtFrame" title="Permalink to this definition"></a></dt>
<dd><p>Evaluates this parameter at a certain frame and returns the result
as a tuple of hou.Node.</p>
<p>Raises hou.TypeError if the value cannot be converted to a hou.Node.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Parm.evalAsRamp">
<code class="descname">evalAsRamp</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Ramp<a class="headerlink" href="#hou.Parm.evalAsRamp" title="Permalink to this definition"></a></dt>
<dd><p>Evaluates this parameter at the current frame and returns the result
as a ramp.</p>
<p>Raises hou.TypeError if the parameter is not a ramp.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Parm.evalAsRampAtFrame">
<code class="descname">evalAsRampAtFrame</code><span class="sig-paren">(</span><em>self</em>, <em>frame</em><span class="sig-paren">)</span> &#x2192; hou.Ramp<a class="headerlink" href="#hou.Parm.evalAsRampAtFrame" title="Permalink to this definition"></a></dt>
<dd><p>Evaluates this parameter at a certain frame and returns the result
as a ramp.</p>
<p>Raises hou.TypeError if the parameter is not a ramp.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Parm.evalAsString">
<code class="descname">evalAsString</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.Parm.evalAsString" title="Permalink to this definition"></a></dt>
<dd><p>Evaluates this parameter at the current frame and returns the result
as a string.</p>
<p>If you want the string contents of the parameter before variable
expansion and expression evaluation then call
hou.Parm.unexpandedString.</p>
<p>Raises hou.TypeError if the value cannot be converted to a string.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Parm.evalAsStringAtFrame">
<code class="descname">evalAsStringAtFrame</code><span class="sig-paren">(</span><em>self</em>, <em>frame</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.Parm.evalAsStringAtFrame" title="Permalink to this definition"></a></dt>
<dd><p>Evaluates this parameter at a certain frame and returns the result
as a string.</p>
<p>If you want the string contents of the parameter before variable
expansion and expression evaluation then call
hou.Parm.unexpandedString.</p>
<p>Raises hou.TypeError if the value cannot be converted to a string.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Parm.evalAtFrame">
<code class="descname">evalAtFrame</code><span class="sig-paren">(</span><em>self</em>, <em>frame</em><span class="sig-paren">)</span> &#x2192; int, float, or str<a class="headerlink" href="#hou.Parm.evalAtFrame" title="Permalink to this definition"></a></dt>
<dd><p>Evalute this parameter at a given frame and return the result as an
integer, float or string.</p>
<p>See also evalAtTime.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Parm.evalAtTime">
<code class="descname">evalAtTime</code><span class="sig-paren">(</span><em>self</em>, <em>time</em><span class="sig-paren">)</span> &#x2192; int, float, or str<a class="headerlink" href="#hou.Parm.evalAtTime" title="Permalink to this definition"></a></dt>
<dd><p>Evalute this parameter at a given time and return the result as an
integer, float or string.</p>
<p>See also evalAtFrame.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Parm.expression">
<code class="descname">expression</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.Parm.expression" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Returns this parameters expression.</p>
<p>For example, a parameter might contain the Python expression frame()
* 2. In this case hou.Parm.eval at frame 2 would return the value 4,
while calling expression() would return the string frame() * 2.</p>
<p>If the parameter does not contain an expression, this method will
raise hou.OperationFailed. Also, if the parameter contains more than
one keyframe then it could contain multiple different expressions,
so it also raises hou.OperationFailed in that case.</p>
<p>This method is roughly equivalent to</p>
</div></blockquote>
<p>&gt; parm.keyframes()[0].expression()</p>
<blockquote>
<div>See also the setExpression(), expressionLanguage(), keyframes(), and
eval() methods.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.Parm.expressionLanguage">
<code class="descname">expressionLanguage</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.exprLanguage enum value<a class="headerlink" href="#hou.Parm.expressionLanguage" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Returns the parameters expressions language.</p>
<p>If the parameter does not contain an expression, this method will
raise hou.OperationFailed. Also, if the parameter contains more than
one keyframe then it could contain multiple different expressions,
so it also raises hou.OperationFailed in that case.</p>
<p>To change the expression language, use hou.Parm.setExpression and
explicitly specify the language:
parm.setExpression(parm.expression(), language).</p>
<p>This method is roughly equivalent to</p>
</div></blockquote>
<p>&gt; parm.keyframes()[0].expressionLanguage()</p>
<blockquote>
<div>See also the expression(), setExpression(), keyframes(), and
setExpressionLanguage() methods.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.Parm.getReferencedParm">
<code class="descname">getReferencedParm</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Parm<a class="headerlink" href="#hou.Parm.getReferencedParm" title="Permalink to this definition"></a></dt>
<dd><p>Returns the referenced parameter. If no parameter is referenced,
returns this parameter.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Parm.hasTemporaryDefaults">
<code class="descname">hasTemporaryDefaults</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.Parm.hasTemporaryDefaults" title="Permalink to this definition"></a></dt>
<dd><p>Returns whether a default has been explicitly set on the parameter.</p>
<p>See also the revertToDefaults() and
revertToAndRestorePermanentDefaults()methods.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Parm.hide">
<code class="descname">hide</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Parm.hide" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Sets the UI hidden state of this parameter in its node. Calling this
method has the same effect as changing the Invisible checkbox on the
Edit Parameter Interface dialog, or hiding the parameter with a
hide-when conditional.</p>
<p>However, changing the UI state with this function is transient and
does not affect node parameter templates, which means that the new
state is not saved to .hip file and can be restored when refreshing
the node to its spare parameter templates.</p>
<p>To permanently change the UI state of a parameter on a node, please
use hou.ParmTemplate.hide instead:</p>
</div></blockquote>
<p>&gt; parms = hou.node(/obj/node).parmTemplateGroup()
&gt; p = parms.find(lookatpath)
&gt; p.hide(True)
&gt; parms.replace(lookatpath, p)
&gt; hou.node(/obj/node).setParmTemplateGroup(parms)</p>
</dd></dl>

<dl class="method">
<dt id="hou.Parm.insertMultiParmInstance">
<code class="descname">insertMultiParmInstance</code><span class="sig-paren">(</span><em>self</em>, <em>index</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Parm.insertMultiParmInstance" title="Permalink to this definition"></a></dt>
<dd><p>Insert a new multi parm instance before the given index. To append a
new multi parm instance, set the index to be the current number of
instances. The current number can be queried by calling evalAsInt on
the this parameter.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Parm.isAtDefault">
<code class="descname">isAtDefault</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Parm.isAtDefault" title="Permalink to this definition"></a></dt>
<dd><p>isAtDefault(self, compare_temporary_defaults=True,
compare_expressions=False) -&gt; bool</p>
<blockquote>
<div><p>Returns whether the parameter is currently at its default.</p>
<p>compare_temporary_defaults: When &lt;compare_temporary_defaults&gt; is
True, isDefault also checks</p>
<p>compare_expressions: When &lt;compare_Expressions&gt; is True, isDefault
compares the actual</p>
<p>See also the revertToDefaults() and
revertToAndRestorePermanentDefaults()methods.</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.Parm.isAutoSelected">
<code class="descname">isAutoSelected</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.Parm.isAutoSelected" title="Permalink to this definition"></a></dt>
<dd><p>Returns whether this parameters autoselect property is on.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Parm.isAutoscoped">
<code class="descname">isAutoscoped</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.Parm.isAutoscoped" title="Permalink to this definition"></a></dt>
<dd><p>Returns whether this parameters autoscope property is on.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Parm.isConstrained">
<code class="descname">isConstrained</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.Parm.isConstrained" title="Permalink to this definition"></a></dt>
<dd><p>Returns True if the Parms parent node is an OBJ that is cooked and
has constraints.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Parm.isDisabled">
<code class="descname">isDisabled</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.Parm.isDisabled" title="Permalink to this definition"></a></dt>
<dd><p>Returns the disable state of the parameter, ignoring the lock state.
This can be used to read the result of a disable-when conditional.</p>
<p>It is recommended that hou.Node.updateParmStates is called before
executing this method either in non-graphical Houdini or when the
owner node has not yet been loaded into the Parameter Pane.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Parm.isHidden">
<code class="descname">isHidden</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.Parm.isHidden" title="Permalink to this definition"></a></dt>
<dd><p>Returns the hidden state of the parameter. This can be used to read
the result of a hide-when conditional.</p>
<p>It is recommended that hou.Node.updateParmStates is called before
executing this method either in non-graphical Houdini or when the
owner node has not yet been loaded into the Parameter Pane.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Parm.isLocked">
<code class="descname">isLocked</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.Parm.isLocked" title="Permalink to this definition"></a></dt>
<dd><p>Returns whether this parameter is locked (uneditable).</p>
</dd></dl>

<dl class="method">
<dt id="hou.Parm.isMultiParmInstance">
<code class="descname">isMultiParmInstance</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.Parm.isMultiParmInstance" title="Permalink to this definition"></a></dt>
<dd><p>Return whether this parameter is an instance of a multi parm. For
example, the pt0x, pt1x, pt2x, etc. parameters in an add SOP are
instances of a multiparm.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Parm.isScoped">
<code class="descname">isScoped</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.Parm.isScoped" title="Permalink to this definition"></a></dt>
<dd><p>isSelected(self) -&gt; bool</p>
<blockquote>
<div>Returns whether this parameters channel is selected. If it is
selected, then it is selected in the animation editor.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.Parm.isSelected">
<code class="descname">isSelected</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.Parm.isSelected" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.Parm.isSpare">
<code class="descname">isSpare</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.Parm.isSpare" title="Permalink to this definition"></a></dt>
<dd><p>Returns whether this parameter is a spare (user-defined)
parameter.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Parm.isTimeDependent">
<code class="descname">isTimeDependent</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.Parm.isTimeDependent" title="Permalink to this definition"></a></dt>
<dd><p>Returns whether this parameter is _time <a href="#id75"><span class="problematic" id="id76">dependent_</span></a>, that is, its
value changes depending on the point on the timeline at which its
evaluated. For example the parameter has an expression containing
the $F (current frame number) variable.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Parm.isVisible">
<code class="descname">isVisible</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.Parm.isVisible" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Returns whether or not this parameter would be visible in the
parameter dialog for this node. It checks both the parameters
template, and the hidden state of the parameter. This is equivalent
to the following code (but runs faster because it avoids creating
the hou.ParmTemplate):</div></blockquote>
<p>&gt; &gt;&gt;&gt; p = hou.parm(/obj/geo1/tx)
&gt; &gt;&gt;&gt; not p.isHidden() and not p.parmTemplate().isHidden()
&gt; True</p>
</dd></dl>

<dl class="method">
<dt id="hou.Parm.keyframeExtrapolation">
<code class="descname">keyframeExtrapolation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.Parm.keyframeExtrapolation" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.Parm.keyframes">
<code class="descname">keyframes</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.BaseKeyframe<a class="headerlink" href="#hou.Parm.keyframes" title="Permalink to this definition"></a></dt>
<dd><p>Returns the keyframes on this parameter.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Parm.keyframesAfter">
<code class="descname">keyframesAfter</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.Parm.keyframesAfter" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.Parm.keyframesBefore">
<code class="descname">keyframesBefore</code><span class="sig-paren">(</span><em>self</em>, <em>frame</em><span class="sig-paren">)</span> &#x2192; tuple of hou.BaseKeyframe<a class="headerlink" href="#hou.Parm.keyframesBefore" title="Permalink to this definition"></a></dt>
<dd><p>Returns a tuple of keyframes on this paramter that occur at or
before frame. If no keyframes are found an empty tuple is returned.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Parm.keyframesInRange">
<code class="descname">keyframesInRange</code><span class="sig-paren">(</span><em>self</em>, <em>start_frame</em>, <em>end_frame</em><span class="sig-paren">)</span> &#x2192; tuple of<a class="headerlink" href="#hou.Parm.keyframesInRange" title="Permalink to this definition"></a></dt>
<dd><p>hou.BaseKeyframe</p>
<p>Returns a tuple of keyframes on this parameter that fall in the
range start_frame to end_frame, inclusive. If no keyframes are found
an empty tuple is returned.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Parm.keyframesRefit">
<code class="descname">keyframesRefit</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.Parm.keyframesRefit" title="Permalink to this definition"></a></dt>
<dd><p>keyframesRefit(self, refit, refit_tol, refit_preserve_extremas,
refit_bezier, resample, resample_rate, resample_tol, range, range_start,
range_end, bake_chop)</p>
<blockquote>
<div><p>Performs a refitting operation with resampling and range controls.</p>
<dl class="docutils">
<dt>refit</dt>
<dd>If set to true, a cubic refitting will be performed with the
supplied refit options. If set to false, the refitting is
skipped and only the resampling or range operation will be
performed.</dd>
<dt>refit_tol</dt>
<dd>Refit Tolerance in absolute value.</dd>
<dt>refit_preserve_extremas</dt>
<dd>Preserves the keys that are local minimas or maximas.</dd>
<dt>refit_bezier</dt>
<dd>If True, the new keyframes will be set to use bezier() segments.
If False, the new keyframes will be set to use cubic() segments.</dd>
<dt>resample</dt>
<dd>If True, a resampling operation is performed prior to the
refitting. If False, the channel is used as is.</dd>
<dt>resample_rate</dt>
<dd>Resample rate in frames. If set to 1.0, a keyframe will be added
at every frame.</dd>
<dt>resample_tol</dt>
<dd>Resample Tolerance in frames. If set to 1.0, the resampling
wont happen if a frame exists within one frame.</dd>
<dt>range</dt>
<dd>If True, the range_start and range_end arguments are used. Its
useful when baking cycles when using cycle/cycle offset or
oscillate channel extrapolation. If False, the channel range
will be used based on the first and last keyframes.</dd>
<dt>range_start</dt>
<dd>Start frame of the range.</dd>
<dt>range_end</dt>
<dd>End frame of the range.</dd>
<dt>bake_chop</dt>
<dd>A hou.parmBakeChop enumaration value.</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.Parm.loadClip">
<code class="descname">loadClip</code><span class="sig-paren">(</span><em>file_name</em>, <em>sample_rate=0</em>, <em>start=None</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Parm.loadClip" title="Permalink to this definition"></a></dt>
<dd><p>auto-insert ocstring: HOM_Parm::loadClip</p>
</dd></dl>

<dl class="method">
<dt id="hou.Parm.lock">
<code class="descname">lock</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Parm.lock" title="Permalink to this definition"></a></dt>
<dd><p>Locks (lock(True)) or unlocks (lock(False)) this parameter (this is,
makes the value uneditable).</p>
<p>Raises hou.PermissionError if this parameter is part of a locked
digital asset.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Parm.menuItems">
<code class="descname">menuItems</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of str<a class="headerlink" href="#hou.Parm.menuItems" title="Permalink to this definition"></a></dt>
<dd><p>Returns a list of all possible menu items (for a menu parameter).
Raises hou.OperationFailed if this parameter is not a menu.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Parm.menuLabels">
<code class="descname">menuLabels</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of str<a class="headerlink" href="#hou.Parm.menuLabels" title="Permalink to this definition"></a></dt>
<dd><p>Returns a list of labels for all possible menu items (for a menu
parameter). Raises hou.OperationFailed if this parameter is not a
menu.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Parm.multiParmInstanceIndices">
<code class="descname">multiParmInstanceIndices</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of int<a class="headerlink" href="#hou.Parm.multiParmInstanceIndices" title="Permalink to this definition"></a></dt>
<dd><p>If this parameter is a multi-parameter instance, then return a tuple
of indices of where the parameter appears in the multi-parameter
block and any nested blocks. Indices for outer multi-parameter
blocks are listed first.</p>
<p>For example if this parameter appears as the fourth instance in the
multi-parameter block then (3,) is returned.</p>
<p>As another example if this parameter appears as the third instance
in the multi-parameter block and the block itself appears as the
first instance of an outer multi-parameter block then (0, 2) is
returned.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Parm.multiParmInstances">
<code class="descname">multiParmInstances</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.Parm<a class="headerlink" href="#hou.Parm.multiParmInstances" title="Permalink to this definition"></a></dt>
<dd><p>If this parameter corresponds to the number of instances for a
multiparm, return all the parameters corresponding to all instances
of this multiparm.</p>
<p>Returns an empty tuple if this parameter is not for a multiparm.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Parm.name">
<code class="descname">name</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.Parm.name" title="Permalink to this definition"></a></dt>
<dd><p>Returns this parameters name.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Parm.node">
<code class="descname">node</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Node<a class="headerlink" href="#hou.Parm.node" title="Permalink to this definition"></a></dt>
<dd><p>Returns the node on which this parameter exists.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Parm.overrideTrack">
<code class="descname">overrideTrack</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Track or None<a class="headerlink" href="#hou.Parm.overrideTrack" title="Permalink to this definition"></a></dt>
<dd><p>Returns the CHOP track overriding this parameter, if any.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Parm.parentMultiParm">
<code class="descname">parentMultiParm</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Parm<a class="headerlink" href="#hou.Parm.parentMultiParm" title="Permalink to this definition"></a></dt>
<dd><p>Return the parent multi-parameter if this parameter is a multi-
parameter instance and None otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Parm.parmTemplate">
<code class="descname">parmTemplate</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.ParmTemplate<a class="headerlink" href="#hou.Parm.parmTemplate" title="Permalink to this definition"></a></dt>
<dd><p>Returns the template for this parameter.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Parm.parmsReferencingThis">
<code class="descname">parmsReferencingThis</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.Parm<a class="headerlink" href="#hou.Parm.parmsReferencingThis" title="Permalink to this definition"></a></dt>
<dd><p>Return a tuple of all the parameters in the scene that have channel
references to this parameter.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Parm.path">
<code class="descname">path</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.Parm.path" title="Permalink to this definition"></a></dt>
<dd><p>Returns the full path to this parameter.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Parm.pressButton">
<code class="descname">pressButton</code><span class="sig-paren">(</span><em>self</em>, <em>arguments={}</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Parm.pressButton" title="Permalink to this definition"></a></dt>
<dd><p>Emulates clicking a button parameter to trigger its callback script.
Raises hou.OperationFailed if the callback script could not be run.
An optional dictionary of arguments can be passed to the callback
script. Raises hou.TypeError if a n argument value type is
unsupported.</p>
<dl class="docutils">
<dt>NOTE</dt>
<dd>This can be called on any type parameter to trigger its callback
script, it is not limited to only button parameters.</dd>
<dt>arguments</dt>
<dd>An optional dictionary of arguments for the callback script. The
dictionary is merged with the keyword values passed to the
callback. The arguments values are single values of the
following types: int, bool, float, str.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hou.Parm.rawValue">
<code class="descname">rawValue</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.Parm.rawValue" title="Permalink to this definition"></a></dt>
<dd><p>Returns the parameters raw text value without evaluation or
expansion. If the parameter has an expression then the expression is
returned otherwise the parameters plain text value is returned.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Parm.removeMultiParmInstance">
<code class="descname">removeMultiParmInstance</code><span class="sig-paren">(</span><em>self</em>, <em>index</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Parm.removeMultiParmInstance" title="Permalink to this definition"></a></dt>
<dd><p>Removes the multi parm instance at the given index.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Parm.revertToAndRestorePermanentDefaults">
<code class="descname">revertToAndRestorePermanentDefaults</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Parm.revertToAndRestorePermanentDefaults" title="Permalink to this definition"></a></dt>
<dd><p>Changes the value back to the default that ships with Houdini, and
restores that default.</p>
<p>See also the revertToDefaults() method, and
hou.ParmTuple.revertToAndRestorePermanentDefaults</p>
</dd></dl>

<dl class="method">
<dt id="hou.Parm.revertToDefaults">
<code class="descname">revertToDefaults</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Parm.revertToDefaults" title="Permalink to this definition"></a></dt>
<dd><p>Change the value back to the default(s). See also the
revertToAndRestoreFactoryDefaults() method.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Parm.saveClip">
<code class="descname">saveClip</code><span class="sig-paren">(</span><em>self</em>, <em>file_name</em>, <em>start=None</em>, <em>end=None</em>, <em>sample_rate=0</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Parm.saveClip" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Saves the animation associated with this parameter to the clip file
specified by &lt;file_name&gt;. The extension of &lt;file_name&gt; determines
the format of the saved file.</p>
<p>You can use one of the following extensions:</p>
</div></blockquote>
<ul>
<li><p class="first">.clip: save animation as plain text (ASCII) clip file.</p>
</li>
<li><p class="first">.bclip: save animation as a bclip (binary clip) file.</p>
</li>
<li><p class="first">.bclip.sc: save animation as a bclip file using Blosc compression.</p>
<p>Set &lt;sample_rate&gt; to a non-zero, non-negative value to specify the
sample_rate to be used for the clip file. For example, if the
current frame rate is 24 (hou.fps), and &lt;sample_rate&gt; is set to 12,
the animation will be sampled every second frame since &lt;sample_rate&gt;
is half of the current frame rate.</p>
<p>If &lt;start&gt; is not None, start saving the animation from the
specified frame (inclusive). Otherwise, the animation will be saved
from the global start frame (inclusive).</p>
<p>Similarly, if &lt;end&gt; is not None, stop saving the animation at the
specified frame (inclusive). Otherwise, the animation will be saved
until the global end frame (inclusive).</p>
<p>The global start and end frame are specified in the Global Animation
Options window.</p>
<p>Raises a hou.OperationFailed exception if the parameter does not
have animation.</p>
<p>Raises a hou.OperationFailed exception if there is an error saving
the animation to file.</p>
<p>Raises a hou.InvalidInput exception if start &gt;= end. If specifying
only &lt;start&gt;, ensure that the specified value is less than the
global end frame. Likewise, if specifying only &lt;end&gt;, ensure it is
larger than the global start frame.</p>
</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="hou.Parm.set">
<code class="descname">set</code><span class="sig-paren">(</span><em>self</em>, <em>value</em>, <em>language=None</em>, <em>follow_parm_reference=True</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Parm.set" title="Permalink to this definition"></a></dt>
<dd><p>Sets the parameter value at the current frame.</p>
<dl class="docutils">
<dt>value</dt>
<dd><p class="first">A float, integer, or string to set the parameter value to.</p>
<p>Pass in a hou.Ramp object, as the parameter value, to set the
value of a ramp parameter. The ramp objects type needs to match
the target ramps type.</p>
<p>Pass in a hou.Geometry object, as the parameter value, to set
the value of a geometry data parameter.</p>
<p class="last">Pass in a hou.Parm object to create a channel reference from
this parameter to the specified parameter.</p>
</dd>
<dt>language</dt>
<dd>This option only applies when setting to a hou.Parm value.
Specifies the expression language to use when creating a channel
reference from this parameter to the given parameter. Set this
option to an hou.exprLanguage object or None to choose the
default language.</dd>
<dt>follow_parm_reference</dt>
<dd>This option only applies when setting to a hou.Parm value. When
this option is set to True then this method will follow channel
references and create a channel reference from the referenced
parameter to the given parameter.</dd>
</dl>
<p>If this parameter currently contains a channel reference to another
parameter, then this method will follow channel references and
change the value of the referenced parameter. If this is not the
desired behavior, then first delete the channel reference with
hou.Parm.deleteAllKeyframes. Alternatively if you are setting the
value to another parameter and do not want to follow existing
channel references then set the optional follow_parm_reference
argument to False.</p>
<p>Raises hou.TypeError if the type of value does not match the type of
this parameter. Raises hou.PermissionError if this parameter is not
writable.</p>
<p>See also hou.Node.setParms.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Parm.setAlias">
<code class="descname">setAlias</code><span class="sig-paren">(</span><em>self</em>, <em>alias_name</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Parm.setAlias" title="Permalink to this definition"></a></dt>
<dd><p>Gives the parameter another name by which it can be referenced in
channels. You can pass in an empty string to remove an existing
alias name.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Parm.setAutoSelect">
<code class="descname">setAutoSelect</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Parm.setAutoSelect" title="Permalink to this definition"></a></dt>
<dd><p>Changes the autoselect property of the parameter. If this property
is on, this parameter defines the default selection state when it is
displayed in the animation editor.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Parm.setAutoscope">
<code class="descname">setAutoscope</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Parm.setAutoscope" title="Permalink to this definition"></a></dt>
<dd><p>Changes the autoscope property of the parameter. If this property is
on, this parameter is automatically scoped when the object is
selected.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Parm.setClipData">
<code class="descname">setClipData</code><span class="sig-paren">(</span><em>data</em>, <em>binary=True</em>, <em>blosc_compressed=True</em>, <em>sample_rate=0</em>, <em>start=None</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Parm.setClipData" title="Permalink to this definition"></a></dt>
<dd><p>auto-insert ocstring: HOM_Parm::setClipData</p>
</dd></dl>

<dl class="method">
<dt id="hou.Parm.setExpression">
<code class="descname">setExpression</code><span class="sig-paren">(</span><em>self</em>, <em>expression</em>, <em>language=None</em>, <em>replace_expression=True</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Parm.setExpression" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Sets this parameters expression.</p>
<p>expression: A string containing the expression that will go inside
the parameter.</p>
<p>language: Either a hou.exprLanguage enumeration value or None.</p>
<p>If language is None and the parameter does not already contain an
expression, the language will be the nodes expression language.
(See hou.Node.expressionLanguage.) Otherwise, if language is None
and the parameter already has an expression, the expression language
will not change.</p>
<p>replace_expression: This parameter only has effect if the parameter
already contains keyframes. If it is True, Houdini will replace the
keyframe before the current time with one containing the new
expression. Otherwise, it will always add a keyframe at the current
time. Note that this behavior matches what happens when you edit an
expression from Houdinis parameter dialog.</p>
<p>Unlike hou.Parm.set, this method does not follow channel references.
That is, if this parameter is referencing another parameter and you
call setExpression(), it change the channel reference expression
into the specified expression.</p>
<p>If the parameter does not already contain any keyframes, this method
is roughly equivalent to setting a keyframe at frame 1, where the
keyframes expression and language are the ones specified.</p>
<p>This method can be approximately implemented as follows:</p>
</div></blockquote>
<p>&gt; def setExpression(self, expression, language=None, replace_expression=None)
&gt; if self.template().type() == hou.parmTemplateType.String:
&gt;     k = hou.StringKeyframe()
&gt; else:
&gt;     k = hou.Keyframe()
&gt; 
&gt; k.setExpression(expression, language)
&gt; 
&gt; if len(self.keyframes()):
&gt;     if replace_expression:
&gt;     k.setTime(self.effectiveKeyframeAtFrame(hou.frame()).time())
&gt;     else:
&gt;     k.setTime(hou.time())
&gt; else
&gt;     k.setTime(0.0)
&gt; 
&gt; self.setKeyframe(k)</p>
<blockquote>
<div>See also the expression, expressionLanguage, and setKeyframe
methods, hou.Node.expressionLanguage, and hou.Node.setExpressions.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.Parm.setFromParm">
<code class="descname">setFromParm</code><span class="sig-paren">(</span><em>self</em>, <em>src</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Parm.setFromParm" title="Permalink to this definition"></a></dt>
<dd><p>Copies the value of an entire parameter, including channels, from
the provided src parameter.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Parm.setKeyframe">
<code class="descname">setKeyframe</code><span class="sig-paren">(</span><em>self</em>, <em>keyframe</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Parm.setKeyframe" title="Permalink to this definition"></a></dt>
<dd><p>Sets a keyframe on this parameter.</p>
<p>Raises hou.TypeError if keyframe is not of type hou.BaseKeyframe.
Raises hou.PermissionError if this parameter is not writable.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Parm.setKeyframeExtrapolation">
<code class="descname">setKeyframeExtrapolation</code><span class="sig-paren">(</span><em>self</em>, <em>before</em>, <em>extrapol</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Parm.setKeyframeExtrapolation" title="Permalink to this definition"></a></dt>
<dd><p>Sets a extrapolation on this parameter for time before the first
keyframe or after the last keyframe. Extrapolation defines how a
parm value is evaluated outside the keyframe range.</p>
<dl class="docutils">
<dt>before</dt>
<dd>If set to true, the extrapolation for evaluations before the
first keyframe will be set. If set to false, the extrapolation
for evaluations after the last keyframe will be set.</dd>
<dt>extrapol</dt>
<dd>A hou.parmExtrapolate enumaration value.</dd>
</dl>
<p>This function will raise a hou.ObjectWasDeleted exception if it is
invoked on a parameter that does not exist in Houdini.</p>
<p>This function will raise a hou.PermissionError exception if writing
to the specified parameter is impossible.</p>
<p>This function will raise a hou.OperationFailed exception the
parameter doesnt have a valid animation channel.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Parm.setKeyframes">
<code class="descname">setKeyframes</code><span class="sig-paren">(</span><em>self</em>, <em>keyframes</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Parm.setKeyframes" title="Permalink to this definition"></a></dt>
<dd><p>Sets multiple keyframe on this parameter. Calling this method is
more efficient than calling hou.Parm.setKeyframe several times
because it sends out only one update event to Houdini for the entire
batch of keyframes that are set.</p>
<p>keyframes must be a tuple or list of hou.BaseKeyframe objects.</p>
<p>Raises hou.PermissionError if this parameter is not writable.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Parm.setPending">
<code class="descname">setPending</code><span class="sig-paren">(</span><em>self</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Parm.setPending" title="Permalink to this definition"></a></dt>
<dd><p>Sets the parameter value at the current frame and marks it as
pending if the parameter is keyed.</p>
<p>Raises hou.TypeError if the type of value does not match this
parameters type. Raises hou.PermissionError if this parameter is
not writable.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Parm.setScope">
<code class="descname">setScope</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Parm.setScope" title="Permalink to this definition"></a></dt>
<dd><p>Changes the scope property of this parameters channel, which
affects whether it is loaded in the animation editor.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Parm.setSelect">
<code class="descname">setSelect</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Parm.setSelect" title="Permalink to this definition"></a></dt>
<dd><p>Changes the select property of this parameters channel, which
affects whether it is selected in the animation editor.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.Parm.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.Parm.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

<dl class="method">
<dt id="hou.Parm.tuple">
<code class="descname">tuple</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.ParmTuple<a class="headerlink" href="#hou.Parm.tuple" title="Permalink to this definition"></a></dt>
<dd><p>Returns the hou.ParmTuple associated with this parameter.</p>
<p>For example, calling this method on the Parm object for the
translation parameter tx, would return a ParmTuple that contains
Parm objects for the three translation parameters tx, ty and
tz. If no tuple is associated with the parameter, then the
parameter itself is returned in a tuple of size 1.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Parm.unexpandedString">
<code class="descname">unexpandedString</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.Parm.unexpandedString" title="Permalink to this definition"></a></dt>
<dd><p>Returns the contents of the parameter before dollar sign and back-
tick expansion.</p>
<p>Examples of unexpanded strings would be image$F.pic,
$HIP/split.hda, or chs(../font1/text). If you were to call
eval() on them, Houdini would perform variable expansion and back-
tick expression evaluation, so you would get back something like
image1.pic instead of image$F.pic.</p>
<p>Because only string parameters will attempt to do dollar sign and
string expansion, this method will raise hou.OperationFailed if
called from a non-string parameter.</p>
<p>Suppose a string parameter contains keyframes. In this situation,
Houdini will not attempt to do string expansion on the parameters
value, so calling this method will raise hou.OperationFailed.
Instead of calling this method, you can call expression() to access
the first Keyframes expression. If there are multiple keyframes,
you can call keyframes() to get a list of hou.StringKeyframe objects
and call expression() on those objects to retrieve the expression.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.ParmTemplate">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">ParmTemplate</code><a class="headerlink" href="#hou.ParmTemplate" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Describes a parameter tuple (its name, type, etc.). This is base class
for all parameter templates.</p>
<p>ParmTemplates are most often used when describing a parameter in a
digital asset definitions parameter interface or when describing an
individual nodes parameter layout (including its spare parameters). A
ParmTemplate describes a parameter and the type of data it holds, but it
does not store the current value of a parameter; only hou.Parm objects
inside hou.ParmTuple objects actually store parameter values. You can
think of a hou.ParmTuple as an instance of a ParmTemplate. For example,
the t parm tuple on geometry objects can be described by a
hou.FloatParmTemplate  it has a label of Transform, a data type of
hou.parmData.Float, 3 components, a naming scheme of
hou.parmNamingScheme.XYZW, etc. Each geometry object node has a
hou.ParmTuple named t that uses this ParmTemplate.</p>
<p>Note that ParmTemplate objects are just data containers, and they have
no live relationship with objects in Houdini. For example, a hou.Node
object corresponds directly to a node in Houdini, and if the node is
renamed in Houdini hou.Node.name will return the new name.
ParmTemplates, on the other hand, do not have a live relationship.
Creating a ParmTemplate based on a spare parameter or asset definition
parameter will simply copy the information into the ParmTemplate object,
and modifying the object will not affect the spare parameter/asset
parameter.</p>
<p>Note also that ParmTemplate objects are always instances of a subclass
of this class, so you cannot construct an instance of this class
directly.</p>
<p>To manipulate the parameters of a digital asset, you can retrieve the
assets current set of ParmTemplates into a hou.ParmTemplateGroup using
hou.HDADefinition.parmTemplateGroup. You can then modify the group,
adding parameters to it and replacing parameters in it, and save the
group back to the asset definition with
hou.HDADefinition.setParmTemplateGroup. Similarly, you can change a
nodes parameter layout with hou.Node.parmTemplateGroup and
hou.Node.setParmTemplateGroup.</p>
<p>You can also ask a hou.ParmTuple for its ParmTemplate in order to find
out information about the parameter, such as allowed ranges of values,
the label displayed to the user in the parameter pane, the parameters
popup help, etc.</p>
<dl class="method">
<dt id="hou.ParmTemplate.asCode">
<code class="descname">asCode</code><span class="sig-paren">(</span><em>self</em>, <em>function_name=None</em>, <em>variable_name=None</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.ParmTemplate.asCode" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Return a string containing Python statements that can be executed to
recreate the parameter template. To run the string, use Pythons
compile, or execfile functions or the exec statement.</p>
<dl class="docutils">
<dt>function_name</dt>
<dd><p class="first">If &lt;function_name&gt; is specified, then the code returned creates
a Python function with the given name. &lt;function_name&gt; must be a
non-zero length string consisting of only alphanumeric and
underscore characters. Any invalid characters are internally
converted to underscores.</p>
<p class="last">The function returns a reference to the newly created parameter
template object.</p>
</dd>
<dt>variable_name</dt>
<dd>The name of a Python variable that the result code will assign
to. If None, Houdini uses the variable name hou_parm_template.</dd>
</dl>
<p>Here is an example of saving the output to a file and then loading
it back into Houdini:</p>
</div></blockquote>
<p>&gt; # Get a reference to the target parameter template.
&gt; node = hou.node(/obj/geo1)
&gt; parm_template = node.parm(tx).parmTemplate()
&gt; 
&gt; # Execute asCode and write the output script to a file.
&gt; code = parm_template.asCode()
&gt; source_file = open(create_parm_template.py, w)
&gt; source_file.write(code)
&gt; source_file.close()
&gt; 
&gt; # Execute the script.  The new parameter template will be stored 
&gt; # in the hou_parm_template variable.
&gt; execfile(create_parm_template.py)
&gt; 
&gt; # Add a spare parameter to the node using the saved parameter
&gt; # template.
&gt; node.addSpareParmTuple(hou_parm_template)</p>
<blockquote>
<div>Here is an example of saving the output into a function in a file
and then calling it from Houdini:</div></blockquote>
<p>&gt; # Get a reference to the target parameter template.
&gt; node = hou.node(/obj/geo1)
&gt; parm_template = node.parm(tx).parmTemplate()
&gt; 
&gt; # Execute asCode and write the function definition to a file.
&gt; code = parm_template.asCode(function_name=createParmTemplate)
&gt; source_file = open(parmtemplatelib.py, w)
&gt; source_file.write(code)
&gt; source_file.close()
&gt; 
&gt; # Call the function definition.
&gt; import parmtemplatelib
&gt; hou_parm_template = parmtemplatelib.createParmTemplate()
&gt; 
&gt; # Add a spare parameter to the node using the saved parameter
&gt; # template.
&gt; node.addSpareParmTuple(hou_parm_template)</p>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTemplate.clone">
<code class="descname">clone</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.ParmTemplate<a class="headerlink" href="#hou.ParmTemplate.clone" title="Permalink to this definition"></a></dt>
<dd><p>Return a copy of this parm template.</p>
<p>This method can be called on an instance of a ParmTemplate subclass
and an instance of the subclass is properly returned.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTemplate.conditionals">
<code class="descname">conditionals</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; dict of [Hom:hou.parmCondType] enum value to<a class="headerlink" href="#hou.ParmTemplate.conditionals" title="Permalink to this definition"></a></dt>
<dd><p>string</p>
<p>Returns the set of conditionals currently affecting this parameter.</p>
<p>See the Conditionals section of the &lt;Operator Type Properties
window&gt; help for more information on this string.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTemplate.dataType">
<code class="descname">dataType</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.parmData enum value<a class="headerlink" href="#hou.ParmTemplate.dataType" title="Permalink to this definition"></a></dt>
<dd><p>Return the data type stored in hou.Parm instances inside
hou.ParmTuple instances corresponding to this ParmTemplate.</p>
<p>For example, suppose this parm tuple is a hou.FloatParmTemplate with
3 components. The corresponding hou.ParmTuple will have 3 hou.Parm
objects inside it, and each will store a floating point value. In
this example, this method would return hou.parmData.Float.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTemplate.disableWhen">
<code class="descname">disableWhen</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.ParmTemplate.disableWhen" title="Permalink to this definition"></a></dt>
<dd><p>This method is deprecated in favor of the conditionals method.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTemplate.help">
<code class="descname">help</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.ParmTemplate.help" title="Permalink to this definition"></a></dt>
<dd><p>Return the help that Houdini displays when you hover over the
parameter label in the parameter pane.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTemplate.hide">
<code class="descname">hide</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ParmTemplate.hide" title="Permalink to this definition"></a></dt>
<dd><p>Marks this parameter as visible or invisible in the parameter pane.</p>
<p>Note that hidden parameters still exist, and can be evaluated,
channel-referenced, etc. They simply will not be displayed in the
parameter pane.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTemplate.hideLabel">
<code class="descname">hideLabel</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ParmTemplate.hideLabel" title="Permalink to this definition"></a></dt>
<dd><p>Hide or show the label for this parameter in the parameter pane.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTemplate.isHidden">
<code class="descname">isHidden</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.ParmTemplate.isHidden" title="Permalink to this definition"></a></dt>
<dd><p>Return whether this parameter is hidden in the parameter pane.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTemplate.isLabelHidden">
<code class="descname">isLabelHidden</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.ParmTemplate.isLabelHidden" title="Permalink to this definition"></a></dt>
<dd><p>Return whether the label for this parameter is hidden in the
parameter pane.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTemplate.joinWithNext">
<code class="descname">joinWithNext</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.ParmTemplate.joinWithNext" title="Permalink to this definition"></a></dt>
<dd><p>This method is deprecated in favor of the joinsWithNext method.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTemplate.joinsWithNext">
<code class="descname">joinsWithNext</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.ParmTemplate.joinsWithNext" title="Permalink to this definition"></a></dt>
<dd><p>Return whether this parameter is displayed on the same line as the
next parameter in the parameter pane.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTemplate.label">
<code class="descname">label</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; string<a class="headerlink" href="#hou.ParmTemplate.label" title="Permalink to this definition"></a></dt>
<dd><p>Return the name of the parameter tuple that is displayed in the
parameter pane.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTemplate.look">
<code class="descname">look</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.parmLook enum value<a class="headerlink" href="#hou.ParmTemplate.look" title="Permalink to this definition"></a></dt>
<dd><p>Return the look of this parameter in the parameter pane. For
example, a tuple of 3 floats can be displayed as a 3D vector or as
an RGB color.</p>
<p>See hou.parmLook for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTemplate.name">
<code class="descname">name</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; string<a class="headerlink" href="#hou.ParmTemplate.name" title="Permalink to this definition"></a></dt>
<dd><p>Return the internal name of the parm template. This is the name that
hou.ParmTuple objects created from this parm template will have.</p>
<p>Note that the names of hou.Parm objects inside ParmTuples based off
this ParmTemplate are determined by this name, the number of
components in this parm template, and the naming scheme. See the
namingScheme method for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTemplate.namingScheme">
<code class="descname">namingScheme</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.parmNamingScheme enum value<a class="headerlink" href="#hou.ParmTemplate.namingScheme" title="Permalink to this definition"></a></dt>
<dd><p>Return the naming scheme used to name parameters inside the parm
tuple for this ParmTemplate.</p>
<p>For example, if the naming scheme is hou.parmNamingScheme.XYZW and
the parm template is named foo and has 3 components, the
parameters will be named foox, fooy, and fooz. On the other
hand, if the naming scheme was hou.parmNamingScheme.Base1, the
parameters would be named foo1, foo2, and foo3.</p>
<p>Note that when the parm template only has 1 component, the parm name
is the same as the parm tuple name.</p>
<p>See hou.parmNamingScheme for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTemplate.numComponents">
<code class="descname">numComponents</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.ParmTemplate.numComponents" title="Permalink to this definition"></a></dt>
<dd><p>Return the number of values stored inside hou.ParmTuple instances of
this ParmTemplate.</p>
<p>For example, if this parm template has 3 components, there will be 3
parameter fields displayed in the parameter pane and there will be 3
hou.Parm objects inside a hou.ParmTuple based off this parm
template.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTemplate.scriptCallback">
<code class="descname">scriptCallback</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.ParmTemplate.scriptCallback" title="Permalink to this definition"></a></dt>
<dd><p>Return the contents of the script that Houdini runs when this
parameter changes. This script is most commonly used in
hou.ButtonParmTemplate objects to respond to the button being
pressed.</p>
<p>Note that Houdini uses the tags dictionary to store the script
callback information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTemplate.scriptCallbackLanguage">
<code class="descname">scriptCallbackLanguage</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.scriptLanguage enum value<a class="headerlink" href="#hou.ParmTemplate.scriptCallbackLanguage" title="Permalink to this definition"></a></dt>
<dd><p>Return the language of the script that Houdini runs when this
parameter changes.</p>
<p>Note that Houdini uses the tags dictionary to store the script
callback information.</p>
<p>See also the scriptCallback method.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTemplate.setConditional">
<code class="descname">setConditional</code><span class="sig-paren">(</span><em>self</em>, <em>type</em>, <em>conditional</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ParmTemplate.setConditional" title="Permalink to this definition"></a></dt>
<dd><p>Set a conditional string of the given hou.parmCondType type for this
parameter. This string consists of rules on how this parameters
display behaves when other parameters change.</p>
<p>See the Conditionals section of the &lt;Operator Type Properties
window&gt; help for more information on this string.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTemplate.setDisableWhen">
<code class="descname">setDisableWhen</code><span class="sig-paren">(</span><em>self</em>, <em>disable_when</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ParmTemplate.setDisableWhen" title="Permalink to this definition"></a></dt>
<dd><p>This method is deprecated in favor of the setConditional method.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTemplate.setHelp">
<code class="descname">setHelp</code><span class="sig-paren">(</span><em>self</em>, <em>help</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ParmTemplate.setHelp" title="Permalink to this definition"></a></dt>
<dd><p>Set the help that Houdini displays when you hover over the parameter
label in the parameter pane.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTemplate.setJoinWithNext">
<code class="descname">setJoinWithNext</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ParmTemplate.setJoinWithNext" title="Permalink to this definition"></a></dt>
<dd><p>Sets whether this parameter is displayed on the same line as the
next parameter in the parameter pane.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTemplate.setLabel">
<code class="descname">setLabel</code><span class="sig-paren">(</span><em>self</em>, <em>label</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ParmTemplate.setLabel" title="Permalink to this definition"></a></dt>
<dd><p>Change the name of the label that is displayed in the parameter
pane.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTemplate.setLook">
<code class="descname">setLook</code><span class="sig-paren">(</span><em>self</em>, <em>look</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ParmTemplate.setLook" title="Permalink to this definition"></a></dt>
<dd><p>Set the look of this parameter to a hou.parmLook enum value.</p>
<p>See the look method for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTemplate.setName">
<code class="descname">setName</code><span class="sig-paren">(</span><em>self</em>, <em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ParmTemplate.setName" title="Permalink to this definition"></a></dt>
<dd><p>Change the internal name of this parm template. Remember that
ParmTemplates just store data, so the name change will not have any
effect unless this parm template is later used to modify a parameter
layout in Houdini.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTemplate.setNamingScheme">
<code class="descname">setNamingScheme</code><span class="sig-paren">(</span><em>self</em>, <em>naming_scheme</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ParmTemplate.setNamingScheme" title="Permalink to this definition"></a></dt>
<dd><p>Set the naming scheme used to name parameters inside the parm tuple
for this ParmTemplate to a hou.parmNamingScheme enum value.</p>
<p>See the namingScheme method for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTemplate.setNumComponents">
<code class="descname">setNumComponents</code><span class="sig-paren">(</span><em>self</em>, <em>num_components</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.ParmTemplate.setNumComponents" title="Permalink to this definition"></a></dt>
<dd><p>Set the number of values stored inside hou.ParmTuple instances of
this ParmTemplate.</p>
<p>Note that some ParmTemplate subclasses only support one component,
so calling this method with a value other than 1 may raise a
hou.OperationFailed exception. Also, changing the number of
components may automatically change the size of the tuple of default
values for some ParmTemplate subclasses.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTemplate.setScriptCallback">
<code class="descname">setScriptCallback</code><span class="sig-paren">(</span><em>self</em>, <em>script_callback</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ParmTemplate.setScriptCallback" title="Permalink to this definition"></a></dt>
<dd><p>Set the callback script to the given string. This script runs in
response to a parameter change.</p>
<p>See the scriptCallback method for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTemplate.setScriptCallbackLanguage">
<code class="descname">setScriptCallbackLanguage</code><span class="sig-paren">(</span><em>self</em>, <em>script_callback_language</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ParmTemplate.setScriptCallbackLanguage" title="Permalink to this definition"></a></dt>
<dd><p>Set the script callback language to a hou.scriptLanguage enum value.</p>
<p>See the scriptCallbackLanguage method for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTemplate.setTags">
<code class="descname">setTags</code><span class="sig-paren">(</span><em>self</em>, <em>tags</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ParmTemplate.setTags" title="Permalink to this definition"></a></dt>
<dd><p>Set the dictionary of extra data stored in this parm template.</p>
<p>See the tags method for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTemplate.tags">
<code class="descname">tags</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; dict of string to string<a class="headerlink" href="#hou.ParmTemplate.tags" title="Permalink to this definition"></a></dt>
<dd><p>Return a dictionary of extra data stored in the parm template.</p>
<p>Houdini uses this dictionary to attach arbitrary data to parm
templates. The keys in this dictionary vary depending on the
ParmTemplate type and its use.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.ParmTemplate.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.ParmTemplate.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTemplate.type">
<code class="descname">type</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.parmTemplateType enum value<a class="headerlink" href="#hou.ParmTemplate.type" title="Permalink to this definition"></a></dt>
<dd><p>Return the enumerated value identifying the type of this parameter.</p>
<p>Remember that ParmTemplate objects are always instances of a
subclass of this class. The following table shows the mapping
between hou.parmTemplateType enumeration values and ParmTemplate
subclasses:</p>
<dl class="docutils">
<dt>Enumerated Value</dt>
<dd>ParmTemplate Subclass</dd>
<dt>hou.parmTemplateType.Int</dt>
<dd>hou.IntParmTemplate</dd>
<dt>hou.parmTemplateType.Float</dt>
<dd>hou.FloatParmTemplate</dd>
<dt>hou.parmTemplateType.String</dt>
<dd>hou.StringParmTemplate</dd>
<dt>hou.parmTemplateType.Toggle</dt>
<dd>hou.ToggleParmTemplate</dd>
<dt>hou.parmTemplateType.Menu</dt>
<dd>hou.MenuParmTemplate</dd>
<dt>hou.parmTemplateType.Button</dt>
<dd>hou.ButtonParmTemplate</dd>
<dt>hou.parmTemplateType.FolderSet</dt>
<dd>hou.FolderSetParmTemplate</dd>
<dt>hou.parmTemplateType.Folder</dt>
<dd>hou.FolderParmTemplate</dd>
<dt>hou.parmTemplateType.Separator</dt>
<dd>hou.SeparatorParmTemplate</dd>
<dt>hou.parmTemplateType.Label</dt>
<dd>hou.LabelParmTemplate</dd>
<dt>hou.parmTemplateType.Ramp</dt>
<dd>hou.RampParmTemplate</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.ParmTemplateGroup">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">ParmTemplateGroup</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ParmTemplateGroup" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A group of parameter templates used to represent the parameter layout of
a node or the parameters in a digital asset definition.</p>
<p>This class stores a group of hou.ParmTemplate objects. You can create an
empty group, create a group from a sequence of parm templates, or create
a group from the parameter definitions of a digital asset or from a
particular nodes current parameter layout. Similarly, you can set an
assets parameters or a nodes parameter interface to the contents of a
parameter group.</p>
<p>You can get an assets parm templates with
hou.HDADefinition.parmTemplateGroup and set them with
hou.HDADefinition.setParmTemplateGroup. Similarly, you can get an
individual nodes parameter definition with hou.Node.parmTemplateGroup
and set it with hou.Node.setParmTemplateGroup. When setting a nodes
parameter interface, any parms that are not in the nodes types set of
parms will be added as spare parameters. Similarly, if parameters in the
nodes type are not present in the group, they will be automatically
added at the end and made invisible. Also, if they exist but the types,
labels, looks, naming schemes, etc are different, Houdini will discard
all changes you attempt to make to these reserved parameters except for
visibility settings.</p>
<p>Note that ParmTemplateGroups store their own copy of the parm templates.
Asking for the parm templates in a group will return a copy of the parm
templates; modifying those copies will not change the contents of the
group. For example, to change a parameter in a group you cannot simply
call find and modify the hou.ParmTemplate it returned. Instead, you must
call replace.</p>
<p>It is important to understand the difference between folder parm
templates and folder set parm templates when using ParmTemplateGroups.
Folder sets correspond directly to hou.ParmTuple objects  there is one
parm tuple (that contains one parm) for each set of folders, and
changing the value of that parm changes which folder is displayed.
Individual Folders, on the other hand, do not directly correspond to
hou.ParmTuple objects, but they are used in Houdinis &lt;Type Properties&gt;
dialog and they make it easy to add individual folders and control which
parameters are inside a folder. Unlike a hou.FolderSetParmTemplate, a
hou.FolderParmTemplate stores the set of parm templates inside that
folder. When a node or definitions parameters are set to the contents
of a parm template group, the folder sets are determined and the parm
tuple name for the set is the name of the first folder in that set. The
names of the other folders in the set are not used.</p>
<p>ParmTemplateGroups use folder parm templates instead of folder set parm
templates. Attempting to add a FolderSetParmTemplate to a group will
raise hou.OperationFailed. Asking a parm tuple for its parm template, on
the other hand, may return a folder set but will never return a folder.
Previously, folder parameter templates and parm template groups did not
exist, so the only way to add folders were with special methods like
hou.HDADefinition.addParmFolder and hou.Node.addSpareParmFolder. Now
that that they exist, you may create folders by passing folder parm
templates to hou.HDADefinition.addParmTuple and
hou.Node.addSpareParmTuple. However, using parm template groups is
preferred over calling these methods.</p>
<p>Note that folder parm templates are also used to represent multiparm
blocks, much like the &lt;Type Properties&gt; dialog does. The folder parm
templates hou.folderType determines whether it is a folder or a
multiparm block. Unlike folder parm templates, which do not correspond
directly to parameter instances, a multiparm parm template does
correspond to an integer parameter that controls the number of instances
of the multiparm.</p>
<dl class="method">
<dt id="hou.ParmTemplateGroup.addParmTemplate">
<code class="descname">addParmTemplate</code><span class="sig-paren">(</span><em>self</em>, <em>parm_template</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ParmTemplateGroup.addParmTemplate" title="Permalink to this definition"></a></dt>
<dd><p>This method is simply an alias for the append method.</p>
<p>It makes it easier to treat parm template groups and
hou.FolderParmTemplate objects uniformly, since
hou.FolderParmTemplate has an addParmTemplate method.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTemplateGroup.append">
<code class="descname">append</code><span class="sig-paren">(</span><em>self</em>, <em>parm_template</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ParmTemplateGroup.append" title="Permalink to this definition"></a></dt>
<dd><p>Add a parm template after all existing parm templates, outside of
any folder.</p>
<p>See also appendToFolder.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTemplateGroup.appendToFolder">
<code class="descname">appendToFolder</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.ParmTemplateGroup.appendToFolder" title="Permalink to this definition"></a></dt>
<dd><p>appendToFolder(self, label_or_labels_or_parm_template_or_indices,
parm_template)</p>
<blockquote>
<div><blockquote>
<div><p>Add a parm template to the bottom of an existing folder.</p>
<p>Note that you cannot add to a folder by simply looking up the folder
parm template and calling hou.FolderParmTemplate.addParmTemplate on
it, because asking for a folder will return a deep copy. The parm
templates inside the copied folder will be separate from those
inside this group, and modifying the folder will not affect the
group. Consider the following example:</p>
</div></blockquote>
<p>&gt; &gt;&gt;&gt; folder = group.findFolder(Transform)
&gt; # folder now has its own copy of the parms inside it.
&gt; &gt;&gt;&gt; folder.addParmTemplate(new_parm_template)
&gt; # folders parm templates are updated, but the groups parm templates are
&gt; # unchanged.
&gt; 
&gt; &gt;&gt;&gt; group.appendToFolder(folder, new_parm_template)
&gt; # The group is modified.  folders contents are unchanged.</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTemplateGroup.asCode">
<code class="descname">asCode</code><span class="sig-paren">(</span><em>self</em>, <em>function_name=None</em>, <em>variable_name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ParmTemplateGroup.asCode" title="Permalink to this definition"></a></dt>
<dd><p>Return Python code that will recreate this group.</p>
<dl class="docutils">
<dt>function_name</dt>
<dd>If not None, the returned code will create a Python function.</dd>
<dt>variable_name</dt>
<dd>The name of the variable that will be assigned the newly-created
parm template group.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTemplateGroup.asDialogScript">
<code class="descname">asDialogScript</code><span class="sig-paren">(</span><em>rename_conflicting_parms=False</em>, <em>full_info=False</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ParmTemplateGroup.asDialogScript" title="Permalink to this definition"></a></dt>
<dd><p>Return a string containing the dialog script file contents
corresponding to this parm template group.</p>
<p>Houdini saves parameter definitions in this format when saving
digital asset definitions (in the DialogScript section of the
digital asset) and when saving parameter layouts of nodes.</p>
<p>The default behaviour for reserved parameters is to output baseparm
tokens for reserved parameters so that it is resistant to changes in
their definition. To change this, use full_info=True.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTemplateGroup.clear">
<code class="descname">clear</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ParmTemplateGroup.clear" title="Permalink to this definition"></a></dt>
<dd><p>Remove all parm templates from this group.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTemplateGroup.containingFolder">
<code class="descname">containingFolder</code><span class="sig-paren">(</span><em>self</em>, <em>name_or_parm_template</em><span class="sig-paren">)</span> &#x2192; hou.FolderParmTemplate<a class="headerlink" href="#hou.ParmTemplateGroup.containingFolder" title="Permalink to this definition"></a></dt>
<dd><p>Return a copy of the hou.FolderParmTemplate in this group containing
a parm template.</p>
<dl class="docutils">
<dt>name_or_parm_template</dt>
<dd>Either the name of the parm template or another hou.ParmTemplate
object to compare against when searching for a match.</dd>
</dl>
<p>Raises hou.OperationFailed if the parameter is not inside the group
or is not inside a folder.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTemplateGroup.containingFolderIndices">
<code class="descname">containingFolderIndices</code><span class="sig-paren">(</span><em>self</em>, <em>name_or_parm_template_or_indices</em><span class="sig-paren">)</span> &#x2192; tuple<a class="headerlink" href="#hou.ParmTemplateGroup.containingFolderIndices" title="Permalink to this definition"></a></dt>
<dd><p>of int</p>
<p>Return the indices of the folder in this group containing a given
parm template. Return an empty tuple if no match was found.</p>
<p>See replace for a description of the parameter and findIndices for a
description of the return value.</p>
<p>Raises hou.OperationFailed if the parameter is not inside the group
or is not inside a folder.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTemplateGroup.entries">
<code class="descname">entries</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.ParmTemplate<a class="headerlink" href="#hou.ParmTemplateGroup.entries" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Return a tuple containing copies of the parm templates inside this
group.</p>
<p>Note that folders are returned as hou.FolderParmTemplate objects,
and each folder parm template contains the parm templates inside it.
Use hou.FolderParmTemplate.parmTemplates to access the elements in a
folder.</p>
<p>The following example creates a function named allParmTemplates that
returns a single sequence of parm templates, including folders, for
all parm templates in the group:</p>
</div></blockquote>
<p>&gt; def allParmTemplates(group_or_folder):
&gt;     for parm_template in group_or_folder.parmTemplates():
&gt;         yield parm_template
&gt; 
&gt;     # Note that we dont want to return parm templates inside multiparm
&gt;     # blocks, so we verify that the folder parm template is actually
&gt;     # for a folder.
&gt;         if (parm_template.type() == hou.parmTemplateType.Folder and
&gt;         parm_template.isActualFolder()):
&gt;             for sub_parm_template in allParmTemplates(parm_template):
&gt;                 yield sub_parm_template</p>
<blockquote>
<div>See also the parmTemplates method.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTemplateGroup.entriesWithoutFolders">
<code class="descname">entriesWithoutFolders</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.ParmTemplate<a class="headerlink" href="#hou.ParmTemplateGroup.entriesWithoutFolders" title="Permalink to this definition"></a></dt>
<dd><p>Return a tuple containing all the non-folder parm templates inside
this group. The output is the flattened set of parm templates in the
group, and includes the non-folder parms inside folders.</p>
<p>Like entries, this method returns a copy of the parm templates
inside this group.</p>
<p>Note that this function does not return parm templates for entries
inside multiparm blocks.</p>
<p>Also see the entries method for the example function
allParmTemplates.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTemplateGroup.entryAtIndices">
<code class="descname">entryAtIndices</code><span class="sig-paren">(</span><em>self</em>, <em>indices</em><span class="sig-paren">)</span> &#x2192; hou.ParmTemplate<a class="headerlink" href="#hou.ParmTemplateGroup.entryAtIndices" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Given a sequence of integer indices return a copy of the
hou.ParmTemplate object at that location. The indices are of the
format returned by findIndices.</p>
<p>Like the hou.ParmTemplate.find and hou.ParmTemplate.entries methods,
this method returns a copy of the parm template stored inside this
group. Modifying the copied parm template will not affect the
contents of this group. Use replace to change a parm template.</p>
<p>Raises hou.OperationFailed if the indices are invalid, including
when the indices sequence is empty.</p>
<p>This method could be implemented as follows:</p>
</div></blockquote>
<p>&gt; def entryAtIndices(self, indices):
&gt;     if len(indices) == 0:
&gt;         raise hou.OperationFailed(Invalid indices)
&gt;     parm_template = self.entries()[indices[0]]
&gt; 
&gt;     # If there are multiple indices then we should have just looked up
&gt;     # a folder parm template.
&gt;     for index in indices[1:]:
&gt;         parm_template = parm_template.parmTemplates()[index]
&gt;     return parm_template</p>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTemplateGroup.find">
<code class="descname">find</code><span class="sig-paren">(</span><em>self</em>, <em>name</em><span class="sig-paren">)</span> &#x2192; hou.ParmTemplate or None<a class="headerlink" href="#hou.ParmTemplateGroup.find" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Search in this group for a parm template whose name matches the
specified one. Return a copy of the parm template or None if no
match was found.</p>
<p>Note that this function returns a copy of the parm template stored
in this group. Modifying the copy will not affect the parameters in
this group. The following example shows how to use the find and
replace methods to modify the pos parm template in the group:</p>
</div></blockquote>
<p>&gt; &gt;&gt;&gt; parm_template = group.find(pos)
&gt; &gt;&gt;&gt; parm_template.setLabel(Position)
&gt; &gt;&gt;&gt; parm_template.replace(pos, parm_template)</p>
<blockquote>
<div><p>If you created the group from existing parameters, folder parm
templates in the same folder set will share the same name, so
searching for a folder using this method may return the first folder
in the folder set. To instead search for a folder by its folder
label, use findFolder.</p>
<p>Note that, in general, the group does not prevent you from adding
two parameters with the same name. In this case, searching for a
parameter with this name will return the first one. Note, though,
that when when setting this group to a node or asset definitions
parms, either the duplicate parameters will be renamed on an
exception will be raised. See the rename_conflicting_parms parameter
to hou.HDADefinition.setParmTemplateGroup for more information.</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTemplateGroup.findFolder">
<code class="descname">findFolder</code><span class="sig-paren">(</span><em>self</em>, <em>label_or_labels</em><span class="sig-paren">)</span> &#x2192; hou.FolderParmTemplate or None<a class="headerlink" href="#hou.ParmTemplateGroup.findFolder" title="Permalink to this definition"></a></dt>
<dd><p>Search in this group for a folder parm template with the given
label. Return a copy of the hou.FolderParmTemplate or None if the
folder wasnt found.</p>
<dl class="docutils">
<dt>label_or_labels</dt>
<dd>Either a string containing the folders label or a tuple of
strings containing the labels of containing folders as well as
the folders label.</dd>
</dl>
<p>Note that a folder parm templates label is what appears in the
interface in the parameter dialog. The folder parm templates name
is used to determine the name of the parm tuple for the folder set,
if the folder is the first in the folder set. See the documentation
for this class for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTemplateGroup.findIndices">
<code class="descname">findIndices</code><span class="sig-paren">(</span><em>self</em>, <em>name_or_parm_template</em><span class="sig-paren">)</span> &#x2192; tuple of int<a class="headerlink" href="#hou.ParmTemplateGroup.findIndices" title="Permalink to this definition"></a></dt>
<dd><p>Search in this group for a parm template and return a tuple of
integers corresponding to the indices of the parm in the group.
Return an empty tuple if no match was found.</p>
<dl class="docutils">
<dt>name_or_parm_template</dt>
<dd>Either the name of the parm template or another hou.ParmTemplate
object to compare against when searching for a match.</dd>
</dl>
<p>If the parm template was found and it is not inside any folders, the
result tuple will contain a single integer with the index of the
parm template. Otherwise, the first entry will be the index of a
folder inside the group, the next will be an index of a folder
inside that folder, and so on until the last index is an index of a
parm template inside a folder.</p>
<p>See also findIndicesForFolder.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTemplateGroup.findIndicesForFolder">
<code class="descname">findIndicesForFolder</code><span class="sig-paren">(</span><em>self</em>, <em>label_or_labels</em><span class="sig-paren">)</span> &#x2192; tuple of int<a class="headerlink" href="#hou.ParmTemplateGroup.findIndicesForFolder" title="Permalink to this definition"></a></dt>
<dd><p>Search in this group for a folder parm template with the given
label. Return an empty tuple if no match was found.</p>
<p>See findFolder for a description of the parameter and findIndices
for a description of the return value.</p>
<p>Note that this method does not accept a parm template. However, if
you have a folder parm template and want to find its indices, simply
call findIndices on the folder parm template.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTemplateGroup.hide">
<code class="descname">hide</code><span class="sig-paren">(</span><em>self</em>, <em>name_or_parm_template_or_indices</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ParmTemplateGroup.hide" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Hide a parameter by making it invisible. The parameter still exists
in the group, but parameter dialogs will not display it.</p>
<p>See replace for a description of the name/parm template/indices
parameter.</p>
<p>This method could be implemented as follows:</p>
</div></blockquote>
<p>&gt; def hide(self, name_or_parm_template_or_indices, on):
&gt;     parm_template = self.find(name_or_parm_template_or_indices)
&gt;     parm_template.hide(on)
&gt;     self.replace(name_or_parm_template_or_indices, parm_template)</p>
<blockquote>
<div>See also hideFolder and hou.ParmTemplate.hide.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTemplateGroup.hideFolder">
<code class="descname">hideFolder</code><span class="sig-paren">(</span><em>self</em>, <em>label_or_labels</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ParmTemplateGroup.hideFolder" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Hide a folder and all the parameters in it.</p>
<p>You may pass in either a string containing a single folder name or a
sequence of strings to indentify a nested folder. For example, the
sequence (Render, Dicing) identifies the Dicing folder inside
the Render folder. The folder is hidden if on is True and unhidden
if it is False.</p>
<p>The following example hides the Transform parameter in a geometry
object:</p>
</div></blockquote>
<p>&gt; &gt;&gt;&gt; group = geo_node.parmTemplateGroup()
&gt; &gt;&gt;&gt; group.hideFolder(Transform, True)
&gt; &gt;&gt;&gt; geo_node.setParmTemplateGroup(group)</p>
<blockquote>
<div>The following example hides the Dicing folder inside the Render
folder on a geometry object:</div></blockquote>
<p>&gt; &gt;&gt;&gt; group = geo_node.parmTemplateGroup()
&gt; &gt;&gt;&gt; group.hideFolder((Render, Dicing), True)
&gt; &gt;&gt;&gt; geo_node.setParmTemplateGroup(group)</p>
<blockquote>
<div>This method could be implemented as follows:</div></blockquote>
<p>&gt; def hideFolder(self, label_or_labels, on):
&gt;     self.hide(self.findFolder(label_or_labels), on)</p>
<blockquote>
<div>See also hide.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTemplateGroup.insertAfter">
<code class="descname">insertAfter</code><span class="sig-paren">(</span><em>self</em>, <em>name_or_parm_template_or_indices</em>, <em>parm_template</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ParmTemplateGroup.insertAfter" title="Permalink to this definition"></a></dt>
<dd><p>Insert a parm template inside this group after an existing one. The
new parm template will be in the same folder as the existing one.</p>
<p>See replace for a description of the name/ parm template/indices
parameter.</p>
<p>Use appendToFolder to add an entry to a empty folder. Use append to
add an entry to an empty parm template group.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTemplateGroup.insertBefore">
<code class="descname">insertBefore</code><span class="sig-paren">(</span><em>self</em>, <em>name_or_parm_template_or_indices</em>, <em>parm_template</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ParmTemplateGroup.insertBefore" title="Permalink to this definition"></a></dt>
<dd><p>Insert a parm template inside this group before an existing one. The
new parm template will be in the same folder as the existing one.</p>
<p>See replace for a description of the name/parm template/indices
parameter.</p>
<p>Use appendToFolder to add an entry to a empty folder. Use append to
add an entry to an empty parm template group.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTemplateGroup.isFolderHidden">
<code class="descname">isFolderHidden</code><span class="sig-paren">(</span><em>self</em>, <em>label_or_labels</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.ParmTemplateGroup.isFolderHidden" title="Permalink to this definition"></a></dt>
<dd><p>Return whether a folder or one of its containing folders is hidden.</p>
<p>Note that if a folder is inside a hidden folder but this folder is
not marked as hidden, calling hou.ParmTemplate.isHidden on the
folder parm template will return False, while this method will
return True.</p>
<p>You may pass in either a string containing a single folder name or a
sequence of strings to indentify a nested folder. For example, the
sequence (Render, Dicing) identifies the Dicing folder inside
the Render folder. The folder is hidden if on is True and unhidden
if it is False.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTemplateGroup.isHidden">
<code class="descname">isHidden</code><span class="sig-paren">(</span><em>self</em>, <em>name_or_parm_template_or_indices</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.ParmTemplateGroup.isHidden" title="Permalink to this definition"></a></dt>
<dd><p>Return whether the given parameter is itself hidden or lies inside a
hidden folder.</p>
<p>See replace for a description of the name/parm template/indices
parameter.</p>
<p>Note that if the parameter is inside a hidden folder but the
parameter is not marked as hidden, calling hou.ParmTemplate.isHidden
on the parm template will return False, while this method will
return True.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTemplateGroup.parmTemplates">
<code class="descname">parmTemplates</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.ParmTemplate<a class="headerlink" href="#hou.ParmTemplateGroup.parmTemplates" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>This method is simply an alias for the entries method.</p>
<p>It makes it easier to search down through a parm template group for
items nested in folders, since the hou.FolderParmTemplate class also
has a method named parmTemplates. The following example shows how to
look up the labels for a folder parameter given its indices:</p>
</div></blockquote>
<p>&gt; def folderLabels(parm_template_group, indices):
&gt;     container = parm_template_group
&gt;     result = []
&gt;     for index in indices:
&gt;         container = container.parmTemplates()[index]
&gt;         result.append(container.label())
&gt;     return result</p>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTemplateGroup.remove">
<code class="descname">remove</code><span class="sig-paren">(</span><em>self</em>, <em>name_or_parm_template_or_indices</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ParmTemplateGroup.remove" title="Permalink to this definition"></a></dt>
<dd><p>Remove a parm template from the group. Note that if you remove a
folder, all of the parm templates in the folder are also removed.</p>
<p>See replace for a description of the name/parm template/indices
parameter.</p>
<p>Raises hou.OperationFailed if the parm template could not be found.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTemplateGroup.replace">
<code class="descname">replace</code><span class="sig-paren">(</span><em>self</em>, <em>name_or_parm_template_or_indices</em>, <em>parm_template</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ParmTemplateGroup.replace" title="Permalink to this definition"></a></dt>
<dd><p>Replace a parm template inside this group with another parm
template.</p>
<dl class="docutils">
<dt>name_or_parm_template_or_indices</dt>
<dd>Either the name of the parm template being replaced, a copy of
the parm template, or a tuple of integer indices that identify
the parm template and any containing folders.</dd>
</dl>
<p>This method changes the contents of this group. Note that it stores
a copy of the parm template in the group, so future changes to the
parm template passed in will not affect the group.</p>
<p>See the find method for a simple example of how to use this method.</p>
<p>Note that parm templates for reserved parameters (for example, the
transform parameters in object-level digital assets) can be replaced
in the parm template group, but all aspects of reserved parameters
except for their visibility and join settings will be restored to
their defaults when you save this group to a node or asset
definition.</p>
<p>Raises hou.OperationFailed if the parm template doesnt exist.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTemplateGroup.setToDialogScript">
<code class="descname">setToDialogScript</code><span class="sig-paren">(</span><em>dialog_script</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ParmTemplateGroup.setToDialogScript" title="Permalink to this definition"></a></dt>
<dd><p>Set the contents of this group to match the parameters defined by
the given dialog script string.</p>
<p>Raises hou.OperationFailed if there is an error in the dialog script
contents.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTemplateGroup.sourceNode">
<code class="descname">sourceNode</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Node or None<a class="headerlink" href="#hou.ParmTemplateGroup.sourceNode" title="Permalink to this definition"></a></dt>
<dd><p>Return the node that the parameter template group was generated
from. If the group was not generated from a node, then return None.</p>
<p>Raises hou.ObjectWasDeleted if the source node has been destroyed.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTemplateGroup.sourceNodeType">
<code class="descname">sourceNodeType</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.NodeType or None<a class="headerlink" href="#hou.ParmTemplateGroup.sourceNodeType" title="Permalink to this definition"></a></dt>
<dd><p>Return the node type that the parameter template group was generated
from. If the group was not generated from a node type, then return
None.</p>
<p>Raises hou.ObjectWasDeleted if the source node type has been
destroyed.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.ParmTemplateGroup.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.ParmTemplateGroup.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.ParmTuple">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">ParmTuple</code><a class="headerlink" href="#hou.ParmTuple" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A tuple of one or more node parameters. Each parameter tuple has a
unique name within its node.</p>
<p>The ParmTuple class behaves like a Python sequence, so you can index
into it using square brackets, iterate over it, call len on it, etc. The
elements inside the parameter tuple are hou.Parm objects.</p>
<p>A parameter tuples name may only contain letters, numbers, and
underscores. For example, objects contain a parameter tuple named t
that contains three integer parameters. The names of the parameters
inside the tuple are determined from the parameter tuples name and its
naming scheme. For example, the t parameter uses the XYZW naming
scheme, so the three parameters inside it are named tx, ty, and
tz. Note that if the parameter tuple only contains one parameter, the
tuple and the parameter inside it may have the same name.</p>
<p>In addition to a name, a parameter tuple also has a label that is
displayed to the user in the parameter dialog. For example, the t
parameters label is Translate. The label may contain spaces and
punctuation characters.</p>
<p>Each parameter in a tuple stores a value. Different instances of parm
tuples in different nodes will store their own set of parameter values.
The value in a parameter may be animated, in which case the parameter
evaluates to a different result depending on the current time on the
playbar. See hou.Keyframe for more information about animated
parameters.</p>
<p>Each hou.NodeType has a set of parameter tuple descriptions associated
with it, and each instance of a hou.Node has a corresponding set of
parameter tuple instances. The parameter tuples store specific values
that are saved with the node. The descriptions of the parameter tuples,
however, are represented by a hou.ParmTemplate. A parameter template
describes the type, default values, ranges, etc. of a parameter tuple.</p>
<p>See also <a href="#id77"><span class="problematic" id="id78">hou.parmTuple_</span></a> and hou.Node.parmTuple.</p>
<dl class="method">
<dt id="hou.ParmTuple.appendClip">
<code class="descname">appendClip</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.ParmTuple.appendClip" title="Permalink to this definition"></a></dt>
<dd><p>appendClip(self, chop_node, apply_immediately, current_value_only,
create_locked, set_value_to_default)</p>
<blockquote>
<div><p>Appends this parameter to the specified Channel CHOP.</p>
<p>apply_immediately: If set to True, then the export flag on the
Channel CHOP will be set.</p>
<p>current_value_only: If set to True, then only the current value of
the parameter will be stored.</p>
<p>create_locked: If set to True, then the parameters are locked on
creation.</p>
<p>set_value_to_default: If set to True, then the parameters are
reverted to their default values on creation</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTuple.asCode">
<code class="descname">asCode</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ParmTuple.asCode" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.ParmTuple.clipData">
<code class="descname">clipData</code><span class="sig-paren">(</span><em>start=None</em>, <em>end=None</em>, <em>binary=True</em>, <em>use_blosc_compression=True</em>, <em>sample_rate=0</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ParmTuple.clipData" title="Permalink to this definition"></a></dt>
<dd><p>clipData(start=None, end=None, binary=True, use_blosc_compression=True,
sample_rate=0) -&gt; str</p>
<blockquote>
<div><p>Returns the clip data for the parameters of this tuple. This method
is similar to hou.ParmTuple.saveClip, except that it returns the
clip data (file contents) instead of saving the animation to a clip
file.</p>
<p>&lt;start&gt;, &lt;end&gt;, and &lt;sample_rate&gt; behave the same as in
hou.ParmTuple.saveClip.</p>
<p>If &lt;binary&gt; is True, return binary clip data, otherwise return plain
text (ASCII) clip data.</p>
<p>If &lt;use_blosc_compression&gt; is True, blosc compress the binary clip
data. This cannot be used for plain text (ASCII) clip data.</p>
<p>Raises a hou.OperationFailed exception if none of the parameters of
this tuple have animation.</p>
<p>Raises a hou.InvalidInput exception if start &gt;= end. If specifying
only &lt;start&gt;, ensure that the specified value is less than the
global end frame. Likewise, if specifying only &lt;end&gt;, ensure it is
larger than the global start frame.</p>
<p>Raises a hou.InvalidInput exception if binary = False and
use_blosc_compression = True.</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTuple.copyToParmClipboard">
<code class="descname">copyToParmClipboard</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ParmTuple.copyToParmClipboard" title="Permalink to this definition"></a></dt>
<dd><p>Copies this to the parameter clipboard. See also
hou.parmClipboardContents.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTuple.createClip">
<code class="descname">createClip</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.ParmTuple.createClip" title="Permalink to this definition"></a></dt>
<dd><p>createClip(self, parent_node, name, create_new, apply_immediately,
current_value_only, create_locked, set_value_to_default) -&gt; hou.ChopNode</p>
<blockquote>
<div><p>Creates a Channel CHOP representing this parameter. The Channel CHOP
is created with the given name as a child of the given parent node.
The parent_node is typically created via
hou.Node.findOrCreateMotionEffectsNetwork.</p>
<p>create_new: Always create a new Channel CHOP. If set to False, then
if a Channel CHOP already exists with the same name, it will be re-
used. If the parameter already exists on the Channel CHOP, the older
parameter will be removed first.</p>
<p>apply_immediately: If set to True, then the export flag on the
Channel CHOP will be set.</p>
<p>current_value_only: If set to True, then only the current value of
the parameter will be stored.</p>
<p>create_locked: If set to True, then the parameters are locked on
creation.</p>
<p>set_value_to_default: If set to True, then the parameters are
reverted to their default values on creation</p>
<p>See also hou.Node.findOrCreateMotionEffectsNetwork.</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTuple.deleteAllKeyframes">
<code class="descname">deleteAllKeyframes</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ParmTuple.deleteAllKeyframes" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Remove all the keyframes from this parameter tuple.</p>
<p>This method be approximately implemented as follows:</p>
</div></blockquote>
<p>&gt; def deleteAllKeyframes(self):
&gt; for parm in self:
&gt;     parm.deleteAllKeyframes()</p>
<blockquote>
<div>See also hou.Parm.deleteAllKeyframes.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTuple.description">
<code class="descname">description</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.ParmTuple.description" title="Permalink to this definition"></a></dt>
<dd><p>Return this parameter tuples label that is displayed in the
parameter dialog.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTuple.disable">
<code class="descname">disable</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ParmTuple.disable" title="Permalink to this definition"></a></dt>
<dd><p>Sets the UI disable state of this parameter tuple in its node. This
is not the same as locking a parameter, as the underlying value can
still be modified. Its closer to what a disable-when conditional
does, when a parameter is disabled automatically by it.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTuple.eval">
<code class="descname">eval</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of int, float, str, or hou.Ramp<a class="headerlink" href="#hou.ParmTuple.eval" title="Permalink to this definition"></a></dt>
<dd><p>Evalute this parameter tuple at the current frame and returns the
result as a tuple of integers, floats or strings, or a hou.Ramp
object, depending on the type of the parameter.</p>
<p>See also the evalAtFrame and evalAtTime methods.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTuple.evalAsFloats">
<code class="descname">evalAsFloats</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of float<a class="headerlink" href="#hou.ParmTuple.evalAsFloats" title="Permalink to this definition"></a></dt>
<dd><p>Evaluates this parameter tuple at the current frame and returns the
result as a tuple of floats.</p>
<p>Raises hou.TypeError if a value cannot be converted to a float.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTuple.evalAsFloatsAtFrame">
<code class="descname">evalAsFloatsAtFrame</code><span class="sig-paren">(</span><em>self</em>, <em>frame</em><span class="sig-paren">)</span> &#x2192; tuple of float<a class="headerlink" href="#hou.ParmTuple.evalAsFloatsAtFrame" title="Permalink to this definition"></a></dt>
<dd><p>Evaluates this parameter tuple at a certain frame and returns the
result as a tuple of floats.</p>
<p>Raises hou.TypeError if a value cannot be converted to a float.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTuple.evalAsGeometries">
<code class="descname">evalAsGeometries</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.Geometry<a class="headerlink" href="#hou.ParmTuple.evalAsGeometries" title="Permalink to this definition"></a></dt>
<dd><p>Evaluates this parameter tuple at the current frame and returns the
result as a tuple containing a hou.Geometry object.</p>
<p>Raises hou.TypeError if a value cannot be converted to a
hou.Geometry.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTuple.evalAsGeometriesAtFrame">
<code class="descname">evalAsGeometriesAtFrame</code><span class="sig-paren">(</span><em>self</em>, <em>frame</em><span class="sig-paren">)</span> &#x2192; tuple of hou.Geometry<a class="headerlink" href="#hou.ParmTuple.evalAsGeometriesAtFrame" title="Permalink to this definition"></a></dt>
<dd><p>Evaluates this parameter tuple at a certain frame and returns the
result as a tuple containing a hou.Geometry object.</p>
<p>Raises hou.TypeError if a value cannot be converted to a
hou.Geometry.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTuple.evalAsInts">
<code class="descname">evalAsInts</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of int<a class="headerlink" href="#hou.ParmTuple.evalAsInts" title="Permalink to this definition"></a></dt>
<dd><p>Evaluates this parameter tuple at the current frame and returns the
result as a tuple of integers.</p>
<p>Raises hou.TypeError if a value cannot be converted to an integer.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTuple.evalAsIntsAtFrame">
<code class="descname">evalAsIntsAtFrame</code><span class="sig-paren">(</span><em>self</em>, <em>frame</em><span class="sig-paren">)</span> &#x2192; tuple of int<a class="headerlink" href="#hou.ParmTuple.evalAsIntsAtFrame" title="Permalink to this definition"></a></dt>
<dd><p>Evaluates this parameter tuple at a certain frame and returns the
result as a tuple of integers.</p>
<p>Raises hou.TypeError if a value cannot be converted to an integer.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTuple.evalAsRamps">
<code class="descname">evalAsRamps</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Ramp<a class="headerlink" href="#hou.ParmTuple.evalAsRamps" title="Permalink to this definition"></a></dt>
<dd><p>Evaluates this parameter tuple at the current frame and returns the
result as a tuple containing a hou.Ramp object.</p>
<p>Raises hou.TypeError if this is not a ramp parameter.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTuple.evalAsRampsAtFrame">
<code class="descname">evalAsRampsAtFrame</code><span class="sig-paren">(</span><em>self</em>, <em>frame</em><span class="sig-paren">)</span> &#x2192; hou.Ramp<a class="headerlink" href="#hou.ParmTuple.evalAsRampsAtFrame" title="Permalink to this definition"></a></dt>
<dd><p>Evaluates this parameter tuple at a certain frame and returns the
result as a tuple containing a hou.Ramp object.</p>
<p>Raises hou.TypeError if this is not a ramp parameter.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTuple.evalAsStrings">
<code class="descname">evalAsStrings</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of str<a class="headerlink" href="#hou.ParmTuple.evalAsStrings" title="Permalink to this definition"></a></dt>
<dd><p>Evaluates this parameter tuple at the current frame and returns the
result as a tuple of strings.</p>
<p>Raises hou.TypeError if a value cannot be converted to a string.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTuple.evalAsStringsAtFrame">
<code class="descname">evalAsStringsAtFrame</code><span class="sig-paren">(</span><em>self</em>, <em>frame</em><span class="sig-paren">)</span> &#x2192; tuple of str<a class="headerlink" href="#hou.ParmTuple.evalAsStringsAtFrame" title="Permalink to this definition"></a></dt>
<dd><p>Evaluates the parameter tuple at a frame and returns the result as a
tuple of strings.</p>
<p>Raises hou.TypeError if a value cannot be converted to a string.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTuple.evalAtFrame">
<code class="descname">evalAtFrame</code><span class="sig-paren">(</span><em>self</em>, <em>frame</em><span class="sig-paren">)</span> &#x2192; tuple of int, float, str, or hou.Ramp<a class="headerlink" href="#hou.ParmTuple.evalAtFrame" title="Permalink to this definition"></a></dt>
<dd><p>Evalute the parameter tuple at a given frame and return the result
as a tuple of integers, floats, strings, or a Ramp object, depending
on the type of the parameter.</p>
<p>See also evalAtTime.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTuple.evalAtTime">
<code class="descname">evalAtTime</code><span class="sig-paren">(</span><em>self</em>, <em>time</em><span class="sig-paren">)</span> &#x2192; tuple of int, float, str, or hou.Ramp<a class="headerlink" href="#hou.ParmTuple.evalAtTime" title="Permalink to this definition"></a></dt>
<dd><p>Evalute the parameter tuple at a given time and return the result as
a tuple of integers, floats, strings, or a Ramp object, depending on
the type of the parameter.</p>
<p>See also evalAtFrame.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTuple.help">
<code class="descname">help</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.ParmTuple.help" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.ParmTuple.helpUrl">
<code class="descname">helpUrl</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.ParmTuple.helpUrl" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.ParmTuple.hide">
<code class="descname">hide</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ParmTuple.hide" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Sets the UI hidden state of this parameter tuple in its node.
Calling this method is equivalent to changing the Invisible checkbox
on the Edit Parameter Interface dialog, or hiding the parameter with
a hide-when conditional.</p>
<p>To hide a folder, use hou.Node.setParmTemplateGroup. This method
cannot be used to hide a folder because a parm tuple corresponds to
a set of folders, not an individual folder.</p>
<p>To change the visibility of all new instances of the node type
defined by a digital asset, use
hou.HDADefinition.setParmTemplateGroup as in the following example:</p>
</div></blockquote>
<p>&gt; def showParmTupleInDefinition(parm_tuple, visible):
&gt;     parm_tuple is a hou.ParmTuple on an instance of the digital asset.
&gt;     definition = parm_tuple.node().type().definition()
&gt;     parm_template_group = definition.parmTemplateGroup()
&gt;     parm_template = parm_template_group.find(parm_tuple.name())
&gt;     parm_template.hide(not visible)
&gt;     parm_template_group.replace(parm_tuple.name(), parm_template)
&gt;     definition.setParmTemplateGroup(parm_template_group)</p>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTuple.isAtDefault">
<code class="descname">isAtDefault</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ParmTuple.isAtDefault" title="Permalink to this definition"></a></dt>
<dd><p>isAtDefault(self, compare_temporary_defaults=True,
compare_expressions=False) -&gt; bool</p>
<blockquote>
<div><p>Returns whether the parameter tuple is currently at its defaults.</p>
<p>compare_temporary_defaults: When &lt;compare_temporary_defaults&gt; is
True, isDefault also checks</p>
<p>compare_expressions: When &lt;compare_Expressions&gt; is True, isDefault
compares the actual</p>
<p>See also the revertToDefaults() and
revertToAndRestorePermanentDefaults()methods.</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTuple.isConstrained">
<code class="descname">isConstrained</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.ParmTuple.isConstrained" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.ParmTuple.isDisabled">
<code class="descname">isDisabled</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.ParmTuple.isDisabled" title="Permalink to this definition"></a></dt>
<dd><p>Returns the disable state of the parameter tuple, ignoring the lock
state. This can be used to read the result of a disable-when
conditional.</p>
<p>It is recommended that hou.Node.updateParmStates is called before
executing this method either in non-graphical Houdini or when the
owner node has not yet been loaded into the Parameter Pane.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTuple.isHidden">
<code class="descname">isHidden</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.ParmTuple.isHidden" title="Permalink to this definition"></a></dt>
<dd><p>Returns the hidden state of the parameter tuple. This can be used to
read the result of a hide-when conditional.</p>
<p>It is recommended that hou.Node.updateParmStates is called before
executing this method either in non-graphical Houdini or when the
owner node has not yet been loaded into the Parameter Pane.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTuple.isMultiParmInstance">
<code class="descname">isMultiParmInstance</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.ParmTuple.isMultiParmInstance" title="Permalink to this definition"></a></dt>
<dd><p>Return whether this parameter is an instance of a multi parm. For
example, the pt0, pt1, pt2, etc. parameter tuples in an add SOP are
instances of a multiparm.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTuple.isSpare">
<code class="descname">isSpare</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.ParmTuple.isSpare" title="Permalink to this definition"></a></dt>
<dd><p>Returns whether the parameter is a spare (user-defined) parameter.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTuple.loadClip">
<code class="descname">loadClip</code><span class="sig-paren">(</span><em>file_name</em>, <em>sample_rate=0</em>, <em>start=None</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ParmTuple.loadClip" title="Permalink to this definition"></a></dt>
<dd><p>auto-insert ocstring: HOM_ParmTuple::loadClip</p>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTuple.lock">
<code class="descname">lock</code><span class="sig-paren">(</span><em>self</em>, <em>bool_values</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ParmTuple.lock" title="Permalink to this definition"></a></dt>
<dd><p>Lock or unlock all the parameters in this tuple. Houdini displays
locked parameters as disabled and does not let you change their
values.</p>
<dl class="docutils">
<dt>bool_values</dt>
<dd>A sequence of True or False values, where each value corresponds
to a component of this parameter. Where an element of
bool_values is True, that component will be locked (uneditable),
and where an element is False, the corresponding component will
be unlocked (editable).</dd>
</dl>
<p>For example, the parameter tuple for translation contains Parm
objects for translation along each of the axes, tx, ty and tz.
If lock is called with the following tuple of boolean values, (True,
True, False), then the parameter tx and ty will be locked and
made non-editable, while tz will be unlocked and made editable.</p>
<p>Raises hou.InvalidSize if bool_values has a different length than
this parameter tuple. Raises hou.PermissionError if any of the
parameters in this parameter tuple are not writable.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTuple.multiParmInstanceIndices">
<code class="descname">multiParmInstanceIndices</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.ParmTuple.multiParmInstanceIndices" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.ParmTuple.multiParmInstances">
<code class="descname">multiParmInstances</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.ParmTuple<a class="headerlink" href="#hou.ParmTuple.multiParmInstances" title="Permalink to this definition"></a></dt>
<dd><p>If this parameter corresponds to the number of instances for a
multiparm, return all the parameter tupless corresponding to all
instances of this multiparm.</p>
<p>Returns an empty tuple if this parameter is not for a multiparm.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTuple.name">
<code class="descname">name</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.ParmTuple.name" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Return the name of this parameter tuple. Note that the parameter
tuples name and its naming scheme determine the names of the
parameters inside it.</div></blockquote>
<p>&gt; &gt;&gt;&gt; node = hou.node(/obj).createNode(geo)
&gt; &gt;&gt;&gt; node.parmTuple(t).parmTemplate().namingScheme()
&gt; parmNamingScheme.XYZW
&gt; &gt;&gt;&gt; [parm.name() for parm in node.parmTuple(t)]
&gt; [tx, ty, tz]
&gt; 
&gt; &gt;&gt;&gt; parm_tuple = node.parent().createNode(cam).parmTuple(dcolor)
&gt; &gt;&gt;&gt; parm_tuple.parmTemplate().namingScheme()
&gt; parmNamingScheme.RGBA
&gt; &gt;&gt;&gt; [parm.name() for parm in parm_tuple]
&gt; [dcolorr, dcolorg, dcolorb]</p>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTuple.node">
<code class="descname">node</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Node<a class="headerlink" href="#hou.ParmTuple.node" title="Permalink to this definition"></a></dt>
<dd><p>Return the node containing this parameter tuple.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTuple.parentMultiParm">
<code class="descname">parentMultiParm</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Parm<a class="headerlink" href="#hou.ParmTuple.parentMultiParm" title="Permalink to this definition"></a></dt>
<dd><p>Return the parent multi-parameter if this parameter is a multi-
parameter instance and None otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTuple.parmTemplate">
<code class="descname">parmTemplate</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.ParmTemplate<a class="headerlink" href="#hou.ParmTuple.parmTemplate" title="Permalink to this definition"></a></dt>
<dd><p>Return this parameter tuples template.</p>
<p>Note that a folder parameter will have a hou.FolderSetParmTemplate
template and a multiparm parameter will have a
hou.FolderParmTemplate template.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTuple.revertToAndRestorePermanentDefaults">
<code class="descname">revertToAndRestorePermanentDefaults</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ParmTuple.revertToAndRestorePermanentDefaults" title="Permalink to this definition"></a></dt>
<dd><p>Changes the value back to the defaults that ship with Houdini, and
restore those defaults.</p>
<p>See also the revertToDefaults() method.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTuple.revertToDefaults">
<code class="descname">revertToDefaults</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ParmTuple.revertToDefaults" title="Permalink to this definition"></a></dt>
<dd><p>Changes the value back to the default(s). See also the
revertToAndRestoreFactoryDefaults() method.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTuple.saveClip">
<code class="descname">saveClip</code><span class="sig-paren">(</span><em>self</em>, <em>file_name</em>, <em>start=None</em>, <em>end=None</em>, <em>sample_rate=0</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ParmTuple.saveClip" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Saves the animation associated with the parameters of this tuple to
the clip file specified by &lt;file_name&gt;. The extension of &lt;file_name&gt;
determines the format of the saved file.</p>
<p>You can use one of the following extensions:</p>
</div></blockquote>
<ul>
<li><p class="first">.clip: save animation as plain text (ASCII) clip file.</p>
</li>
<li><p class="first">.bclip: save animation as a bclip (binary clip) file.</p>
</li>
<li><p class="first">.bclip.sc: save animation as a bclip file using Blosc compression.</p>
<p>Set &lt;sample_rate&gt; to a non-zero, non-negative value to specify the
sample_rate to be used for the clip file. For example, if the
current frame rate is 24 (hou.fps), and &lt;sample_rate&gt; is set to 12,
the animation will be sampled every second frame since &lt;sample_rate&gt;
is half of the current frame rate.</p>
<p>If &lt;start&gt; is not None, start saving the animation from the
specified frame (inclusive). Otherwise, the animation will be saved
from the global start frame (inclusive).</p>
<p>Similarly, if &lt;end&gt; is not None, stop saving the animation at the
specified frame (inclusive). Otherwise, the animation will be saved
until the global end frame (inclusive).</p>
<p>The global start and end frame are specified in the Global Animation
Options window.</p>
<p>Raises a hou.OperationFailed exception if none of the parameters of
this tuple have animation.</p>
<p>Raises a hou.OperationFailed exception if there is an error saving
the animation to file.</p>
<p>Raises a hou.InvalidInput exception if start &gt;= end. If specifying
only &lt;start&gt;, ensure that the specified value is less than the
global end frame. Likewise, if specifying only &lt;end&gt;, ensure it is
larger than the global start frame.</p>
</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTuple.set">
<code class="descname">set</code><span class="sig-paren">(</span><em>self</em>, <em>values</em>, <em>language=None</em>, <em>follow_parm_references=True</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ParmTuple.set" title="Permalink to this definition"></a></dt>
<dd><p>Sets the values of the parameters in the tuple at the current frame.</p>
<dl class="docutils">
<dt>values</dt>
<dd><p class="first">A sequence of floats, integers or strings, corresponding to the
components of this parameter tuple.</p>
<p>For example, the parameter tuple for translation contains
hou.Parm objects for translation along each of the axes, tx,
ty and tz. If set is called with the following tuple of
floats, (2.5, 4.0, 5.5), then the parameter tx with be set to
2.5, ty will be set to 4.0 and tz will be set to 5.5.</p>
<p class="last">You can also pass in a hou.ParmTuple object for this argument to
create channel references from the parameters in this tuple to
the parameters in the passed-in tuple. If this tuple has more
parameters than the passed-in tuple then no work is performed on
the extra parameters. If the passed-in tuple has more parameters
than this tuple then the the extra parameters are ignored.</p>
</dd>
<dt>language</dt>
<dd>This option only applies when setting to a hou.ParmTuple value.
Specifies the expression language to use when creating channel
references from this parameter tuple to the given parameter
tuple. Set this option to an hou.exprLanguage object or None to
choose the default language.</dd>
<dt>follow_parm_references</dt>
<dd>This option only applies when setting to a hou.ParmTuple value.
When this option is set to True then this method will follow
channel references and create channel references from the
referenced parameter tuple to the given parameter tuple.</dd>
</dl>
<p>If this parameter tuple currently contains channel references to
another parameter tuple, then this method will follow channel
references and change the value of the referenced parameter tuple.
If this is not the desired behavior, then first delete the channel
reference with hou.ParmTuple.deleteAllKeyframes. Alternatively if
you are setting the value to another parameter tuple and do not want
to follow existing channel references then set the optional
follow_parm_references argument to False.</p>
<p>Raises hou.InvalidSize if values has a different length than this
parameter tuple. Raises hou.PermissionError if any of the parameters
in this parameter tuple are not writable.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTuple.setAutoscope">
<code class="descname">setAutoscope</code><span class="sig-paren">(</span><em>self</em>, <em>bool_values</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ParmTuple.setAutoscope" title="Permalink to this definition"></a></dt>
<dd><p>Changes the autoscope property of components of this parameter
tuple.</p>
<dl class="docutils">
<dt>bool_values</dt>
<dd>A sequence of True or False values, where each value corresponds
to a component of this parameter. Where an element of
bool_values is True, that component will be autoscope.</dd>
</dl>
<p>For example, the parameter tuple for translation contains Parm
objects for translation along each of the axes, tx, ty and tz.
If setAutoscope is called with the following tuple of boolean
values, (True, True, False), then the parameter tx and ty will
be automatically scoped, while tz will not.</p>
<p>Raises hou.InvalidSize if values has a different length than this
parameter tuple. Raises hou.PermissionError if any of the parameters
in this parameter tuple are not writable.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTuple.setClipData">
<code class="descname">setClipData</code><span class="sig-paren">(</span><em>data</em>, <em>binary=True</em>, <em>blosc_compressed=True</em>, <em>sample_rate=0</em>, <em>start=None</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ParmTuple.setClipData" title="Permalink to this definition"></a></dt>
<dd><p>auto-insert ocstring: HOM_ParmTuple::setClipData</p>
</dd></dl>

<dl class="method">
<dt id="hou.ParmTuple.setPending">
<code class="descname">setPending</code><span class="sig-paren">(</span><em>self</em>, <em>values</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ParmTuple.setPending" title="Permalink to this definition"></a></dt>
<dd><p>Sets the value of a parameter in the tuple at the current frame and
marks it as pending if the parameter is keyed.</p>
<dl class="docutils">
<dt>values</dt>
<dd>A sequence of floats or strings, corresponding to the components
of this parameter tuple.</dd>
</dl>
<p>For example, the parameter tuple for translation contains Parm
objects for translation along each of the axes, tx, ty and tz.
If set is called with following tuple of floats, (2.5, 4.0, 5.5),
then the parameter tx with be set to 2.5, ty will be set to 4.0
and tz will be set to 5.5.</p>
<p>Raises hou.InvalidSize if values has a different length than this
parameter tuple. Raises hou.PermissionError if any of the parameters
in this parameter tuple are not writable.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.ParmTuple.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.ParmTuple.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.PathBasedPaneTab">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">PathBasedPaneTab</code><a class="headerlink" href="#hou.PathBasedPaneTab" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.PaneTab" title="hou.PaneTab"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.PaneTab</span></code></a></p>
<p>REPLACES</p>
<blockquote>
<div><ul class="simple">
<li>bookmark</li>
<li>pane</li>
<li>mousepath()</li>
</ul>
</div></blockquote>
<dl class="method">
<dt id="hou.PathBasedPaneTab.cd">
<code class="descname">cd</code><span class="sig-paren">(</span><em>self</em>, <em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.PathBasedPaneTab.cd" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.PathBasedPaneTab.currentNode">
<code class="descname">currentNode</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; Node<a class="headerlink" href="#hou.PathBasedPaneTab.currentNode" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.PathBasedPaneTab.pwd">
<code class="descname">pwd</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; Node<a class="headerlink" href="#hou.PathBasedPaneTab.pwd" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.PathBasedPaneTab.setCurrentNode">
<code class="descname">setCurrentNode</code><span class="sig-paren">(</span><em>self</em>, <em>node</em>, <em>pick_node = True</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.PathBasedPaneTab.setCurrentNode" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.PathBasedPaneTab.setPwd">
<code class="descname">setPwd</code><span class="sig-paren">(</span><em>self</em>, <em>node</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.PathBasedPaneTab.setPwd" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.PathBasedPaneTab.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.PathBasedPaneTab.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.PerfMonEvent">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">PerfMonEvent</code><a class="headerlink" href="#hou.PerfMonEvent" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.PerfMonEvent.object" title="hou.PerfMonEvent.object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Represents an event that is recorded by the performance monitor and used
to generate time and memory growth statistics for profiles.</p>
<p>Note that all methods in this class may raise an hou.OperationFailed
exception if the event was not actually recorded in the Performance
Monitor. This can happen if hou.perfMon.startEvent or
hou.perfMon.startCookEvent was called when the Performance Monitor was
not recording.</p>
<dl class="docutils">
<dt>NOTE</dt>
<dd>The stopTime(), memory() and time() methods have been removed.
Memory and time values are now returned by the stop() method.</dd>
</dl>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.perfMon</li>
<li>hou.PerfMonProfile</li>
<li>hou.PerfMonRecordOptions</li>
<li>Performance monitor pane</li>
</ul>
</div></blockquote>
<dl class="method">
<dt id="hou.PerfMonEvent.id">
<code class="descname">id</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.PerfMonEvent.id" title="Permalink to this definition"></a></dt>
<dd><p>Return the events unique identifier which is used internally by the
performance monitor.</p>
<p>This method is deprecated.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PerfMonEvent.isAutoNestEnabled">
<code class="descname">isAutoNestEnabled</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.PerfMonEvent.isAutoNestEnabled" title="Permalink to this definition"></a></dt>
<dd><p>Return True if the event will automatically nest other events that
are started and stopped while this event is running. When the event
is stopped, it will decrement the times and memory of its nested
events from its total time and memory. That way, the events total
time and memory will reflect the work performed in the event itself
and not in any of its nested events.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PerfMonEvent.isRunning">
<code class="descname">isRunning</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.PerfMonEvent.isRunning" title="Permalink to this definition"></a></dt>
<dd><p>Return true if the event is running, that is, if the event has been
started but not stopped.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PerfMonEvent.isTiming">
<code class="descname">isTiming</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.PerfMonEvent.isTiming" title="Permalink to this definition"></a></dt>
<dd><p>This method is deprecated in favor of isRunning.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PerfMonEvent.name">
<code class="descname">name</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.PerfMonEvent.name" title="Permalink to this definition"></a></dt>
<dd><p>Return the event name.</p>
<p>This method is deprecated.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PerfMonEvent.object">
<code class="descname">object</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.PerfMonEvent.object" title="Permalink to this definition"></a></dt>
<dd><p>Return the object that the event applies to. Return None if the
event is not associated with an object.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PerfMonEvent.startTime">
<code class="descname">startTime</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#hou.PerfMonEvent.startTime" title="Permalink to this definition"></a></dt>
<dd><p>Return the start time of the event in milliseconds since the epoch
date.</p>
<p>Raises hou.OperationFailed if the event does not contain any time
data. This can happen if the event was started when the Performance
Monitor was not recording any time statistics.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PerfMonEvent.stop">
<code class="descname">stop</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.PerfMonEvent.stop" title="Permalink to this definition"></a></dt>
<dd><p>Stop the event timer and return a 2-tuple, (&lt;time&gt;, &lt;memory&gt;),
containing the events elapsed time and memory growth.</p>
<p>The elapsed time is the number of milliseconds that the event was
timing for. The memory growth is the increase in memory usage by
Houdini (in bytes) from when the event started and when it stopped.</p>
<p>If the event was not recording memory, then the returned memory
value is 0.0. Likewise, if the event was not recording time, then
the returned time value is 0.0.</p>
<p>Raises hou.OperationFailed if the event is already stopped.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.PerfMonEvent.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.PerfMonEvent.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.PerfMonProfile">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">PerfMonProfile</code><a class="headerlink" href="#hou.PerfMonProfile" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Represents a performance monitor profile.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.perfMon</li>
<li>hou.PerfMonEvent</li>
<li>hou.PerfMonRecordOptions</li>
<li>Performance monitor pane</li>
</ul>
</div></blockquote>
<dl class="method">
<dt id="hou.PerfMonProfile.cancel">
<code class="descname">cancel</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.PerfMonProfile.cancel" title="Permalink to this definition"></a></dt>
<dd><p>Stop the profile from recording timed events and remove it from the
performance monitor.</p>
<p>Raises hou.OperationFailed if the profile is not active, that is,
the profile is neither recording nor paused.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PerfMonProfile.exportAsCSV">
<code class="descname">exportAsCSV</code><span class="sig-paren">(</span><em>self</em>, <em>file_path</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.PerfMonProfile.exportAsCSV" title="Permalink to this definition"></a></dt>
<dd><p>Export the profile statistics to disk using a comma-separated (CSV)
format. The exported .csv file can be loaded into a spreadsheet
application such as Microsoft Excel and used to generate graphs.</p>
<p>Raises hou.OperationFailed if the profile is still active or if the
.csv file could not be written to disk (i.e. permission problems).</p>
</dd></dl>

<dl class="method">
<dt id="hou.PerfMonProfile.id">
<code class="descname">id</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.PerfMonProfile.id" title="Permalink to this definition"></a></dt>
<dd><p>Return the profiles unique identifier which is used internally by
the performance monitor.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PerfMonProfile.isActive">
<code class="descname">isActive</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.PerfMonProfile.isActive" title="Permalink to this definition"></a></dt>
<dd><p>Return True if the profile is either recording events or is paused.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PerfMonProfile.isPaused">
<code class="descname">isPaused</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.PerfMonProfile.isPaused" title="Permalink to this definition"></a></dt>
<dd><p>Return True if the profile is paused from recording.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PerfMonProfile.isRecordingCookStats">
<code class="descname">isRecordingCookStats</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.PerfMonProfile.isRecordingCookStats" title="Permalink to this definition"></a></dt>
<dd><p>Return True if the profile is recording cook events and statistics.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PerfMonProfile.isRecordingDrawStats">
<code class="descname">isRecordingDrawStats</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.PerfMonProfile.isRecordingDrawStats" title="Permalink to this definition"></a></dt>
<dd><p>Return True if the profile is recording draw events and statistics.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PerfMonProfile.isRecordingErrors">
<code class="descname">isRecordingErrors</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.PerfMonProfile.isRecordingErrors" title="Permalink to this definition"></a></dt>
<dd><p>Return True if the profile is recording errors.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PerfMonProfile.isRecordingFrameStats">
<code class="descname">isRecordingFrameStats</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.PerfMonProfile.isRecordingFrameStats" title="Permalink to this definition"></a></dt>
<dd><p>Return True if the profile is recording frame events and statistics.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PerfMonProfile.isRecordingGPUDrawStats">
<code class="descname">isRecordingGPUDrawStats</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.PerfMonProfile.isRecordingGPUDrawStats" title="Permalink to this definition"></a></dt>
<dd><p>Return True if the profile is recording GPU draw events and
statistics.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PerfMonProfile.isRecordingMemoryStats">
<code class="descname">isRecordingMemoryStats</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.PerfMonProfile.isRecordingMemoryStats" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.PerfMonProfile.isRecordingRenderStats">
<code class="descname">isRecordingRenderStats</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.PerfMonProfile.isRecordingRenderStats" title="Permalink to this definition"></a></dt>
<dd><p>Return True if the profile is recording statistics related to
rendering.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PerfMonProfile.isRecordingScriptStats">
<code class="descname">isRecordingScriptStats</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.PerfMonProfile.isRecordingScriptStats" title="Permalink to this definition"></a></dt>
<dd><p>Return True if the profile is recording script events and
statistics.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PerfMonProfile.isRecordingSolveStats">
<code class="descname">isRecordingSolveStats</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.PerfMonProfile.isRecordingSolveStats" title="Permalink to this definition"></a></dt>
<dd><p>Return True if the profile is recording simulation solver events and
statistics.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PerfMonProfile.isRecordingThreadStats">
<code class="descname">isRecordingThreadStats</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.PerfMonProfile.isRecordingThreadStats" title="Permalink to this definition"></a></dt>
<dd><p>Return True if the profile is recording thread statistics.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PerfMonProfile.isRecordingViewportStats">
<code class="descname">isRecordingViewportStats</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.PerfMonProfile.isRecordingViewportStats" title="Permalink to this definition"></a></dt>
<dd><p>Return True if the profile is recording viewport events and
statistics.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PerfMonProfile.pause">
<code class="descname">pause</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.PerfMonProfile.pause" title="Permalink to this definition"></a></dt>
<dd><p>Pause the profile from recording events and statistics.</p>
<p>Raises hou.OperationFailed if the profile is stopped or already
paused.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PerfMonProfile.resume">
<code class="descname">resume</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.PerfMonProfile.resume" title="Permalink to this definition"></a></dt>
<dd><p>Unpause the profile so that it can record events and statistics.</p>
<p>Raises hou.OperationFailed if the profile is stopped or is already
recording (i.e. not paused).</p>
</dd></dl>

<dl class="method">
<dt id="hou.PerfMonProfile.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>self</em>, <em>file_path</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.PerfMonProfile.save" title="Permalink to this definition"></a></dt>
<dd><p>Save the profile to disk.</p>
<p>Raises hou.OperationFailed if the profile is still active or if the
file could not be written to disk (i.e. permission problems).</p>
</dd></dl>

<dl class="method">
<dt id="hou.PerfMonProfile.stats">
<code class="descname">stats</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.PerfMonProfile.stats" title="Permalink to this definition"></a></dt>
<dd><p>Return the profile statistics in JSON format.</p>
<p>Raises hou.OperationFailed if the profile is still active and has
not generated any statistics.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PerfMonProfile.stop">
<code class="descname">stop</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.PerfMonProfile.stop" title="Permalink to this definition"></a></dt>
<dd><p>Stop the profile from recording and generate statistics for the
events that it has already recorded.</p>
<p>Raises hou.OperatioNFailed if the profile is not active.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.PerfMonProfile.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.PerfMonProfile.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

<dl class="method">
<dt id="hou.PerfMonProfile.title">
<code class="descname">title</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.PerfMonProfile.title" title="Permalink to this definition"></a></dt>
<dd><p>Return the profile title.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.PerfMonRecordOptions">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">PerfMonRecordOptions</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.PerfMonRecordOptions" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Represents the set of options used by the Performance Monitor and
specifies the type of statistics to be recorded in a profile.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.perfMon</li>
<li>hou.PerfMonProfile</li>
<li>Performance monitor pane</li>
</ul>
</div></blockquote>
<dl class="method">
<dt id="hou.PerfMonRecordOptions.recordCookStats">
<code class="descname">recordCookStats</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.PerfMonRecordOptions.recordCookStats" title="Permalink to this definition"></a></dt>
<dd><p>Return True if cook statistics should be recorded.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PerfMonRecordOptions.recordDrawStats">
<code class="descname">recordDrawStats</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.PerfMonRecordOptions.recordDrawStats" title="Permalink to this definition"></a></dt>
<dd><p>Return True if node draw statistics should be recorded.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PerfMonRecordOptions.recordErrors">
<code class="descname">recordErrors</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.PerfMonRecordOptions.recordErrors" title="Permalink to this definition"></a></dt>
<dd><p>Return True if warnings and errors should be recorded.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PerfMonRecordOptions.recordFrameStats">
<code class="descname">recordFrameStats</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.PerfMonRecordOptions.recordFrameStats" title="Permalink to this definition"></a></dt>
<dd><p>Return True if frame statistics should be recorded.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PerfMonRecordOptions.recordGPUDrawStats">
<code class="descname">recordGPUDrawStats</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.PerfMonRecordOptions.recordGPUDrawStats" title="Permalink to this definition"></a></dt>
<dd><p>Return True if node GPU draw statistics should be recorded.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PerfMonRecordOptions.recordMemoryStats">
<code class="descname">recordMemoryStats</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.PerfMonRecordOptions.recordMemoryStats" title="Permalink to this definition"></a></dt>
<dd><p>Return True if memory statistics should be recorded.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PerfMonRecordOptions.recordRenderStats">
<code class="descname">recordRenderStats</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.PerfMonRecordOptions.recordRenderStats" title="Permalink to this definition"></a></dt>
<dd><p>Return True if Mantra render statistics should be recorded.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PerfMonRecordOptions.recordScriptStats">
<code class="descname">recordScriptStats</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.PerfMonRecordOptions.recordScriptStats" title="Permalink to this definition"></a></dt>
<dd><p>Return True if hscript and Python script statistics should be
recorded.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PerfMonRecordOptions.recordSolveStats">
<code class="descname">recordSolveStats</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.PerfMonRecordOptions.recordSolveStats" title="Permalink to this definition"></a></dt>
<dd><p>Return True if DOP solver statistics should be recorded.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PerfMonRecordOptions.recordThreadStats">
<code class="descname">recordThreadStats</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.PerfMonRecordOptions.recordThreadStats" title="Permalink to this definition"></a></dt>
<dd><p>Return True if thread statistics should be recorded.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PerfMonRecordOptions.recordViewportStats">
<code class="descname">recordViewportStats</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.PerfMonRecordOptions.recordViewportStats" title="Permalink to this definition"></a></dt>
<dd><p>Return True if viewport statistics should be recorded.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PerfMonRecordOptions.setRecordCookStats">
<code class="descname">setRecordCookStats</code><span class="sig-paren">(</span><em>self</em>, <em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.PerfMonRecordOptions.setRecordCookStats" title="Permalink to this definition"></a></dt>
<dd><p>Turn the recording of cook statistics on or off.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PerfMonRecordOptions.setRecordDrawStats">
<code class="descname">setRecordDrawStats</code><span class="sig-paren">(</span><em>self</em>, <em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.PerfMonRecordOptions.setRecordDrawStats" title="Permalink to this definition"></a></dt>
<dd><p>Turn the recording of node draw statistics on or off.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PerfMonRecordOptions.setRecordErrors">
<code class="descname">setRecordErrors</code><span class="sig-paren">(</span><em>self</em>, <em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.PerfMonRecordOptions.setRecordErrors" title="Permalink to this definition"></a></dt>
<dd><p>Turn the recording of warnings and errors on or off.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PerfMonRecordOptions.setRecordFrameStats">
<code class="descname">setRecordFrameStats</code><span class="sig-paren">(</span><em>self</em>, <em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.PerfMonRecordOptions.setRecordFrameStats" title="Permalink to this definition"></a></dt>
<dd><p>Turn the recording of frame statistics on or off.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PerfMonRecordOptions.setRecordGPUDrawStats">
<code class="descname">setRecordGPUDrawStats</code><span class="sig-paren">(</span><em>self</em>, <em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.PerfMonRecordOptions.setRecordGPUDrawStats" title="Permalink to this definition"></a></dt>
<dd><p>Turn the recording of node GPU draw statistics on or off.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PerfMonRecordOptions.setRecordMemoryStats">
<code class="descname">setRecordMemoryStats</code><span class="sig-paren">(</span><em>self</em>, <em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.PerfMonRecordOptions.setRecordMemoryStats" title="Permalink to this definition"></a></dt>
<dd><p>Turn the recording of memory statistics on or off.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PerfMonRecordOptions.setRecordRenderStats">
<code class="descname">setRecordRenderStats</code><span class="sig-paren">(</span><em>self</em>, <em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.PerfMonRecordOptions.setRecordRenderStats" title="Permalink to this definition"></a></dt>
<dd><p>Turn the recording of Mantra render statistics on or off.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PerfMonRecordOptions.setRecordScriptStats">
<code class="descname">setRecordScriptStats</code><span class="sig-paren">(</span><em>self</em>, <em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.PerfMonRecordOptions.setRecordScriptStats" title="Permalink to this definition"></a></dt>
<dd><p>Turn the recording of hscript and Python statistics on or off.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PerfMonRecordOptions.setRecordSolveStats">
<code class="descname">setRecordSolveStats</code><span class="sig-paren">(</span><em>self</em>, <em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.PerfMonRecordOptions.setRecordSolveStats" title="Permalink to this definition"></a></dt>
<dd><p>Turn the recording of DOP solver statistics on or off.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PerfMonRecordOptions.setRecordThreadStats">
<code class="descname">setRecordThreadStats</code><span class="sig-paren">(</span><em>self</em>, <em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.PerfMonRecordOptions.setRecordThreadStats" title="Permalink to this definition"></a></dt>
<dd><p>Turn the recording of thread statistics on or off.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PerfMonRecordOptions.setRecordViewportStats">
<code class="descname">setRecordViewportStats</code><span class="sig-paren">(</span><em>self</em>, <em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.PerfMonRecordOptions.setRecordViewportStats" title="Permalink to this definition"></a></dt>
<dd><p>Turn the recording of viewport statistics on or off.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.PerfMonRecordOptions.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.PerfMonRecordOptions.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.PerformanceMonitor">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">PerformanceMonitor</code><a class="headerlink" href="#hou.PerformanceMonitor" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.PaneTab" title="hou.PaneTab"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.PaneTab</span></code></a></p>
<p>Represents a Performance Monitor panetab.</p>
<p>REPLACES</p>
<blockquote>
<div><ul class="simple">
<li>performance</li>
</ul>
</div></blockquote>
<dl class="method">
<dt id="hou.PerformanceMonitor.enableLiveUpdates">
<code class="descname">enableLiveUpdates</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.PerformanceMonitor.enableLiveUpdates" title="Permalink to this definition"></a></dt>
<dd><p>Enable or disable live updates for recordings. If live updates is
enabled, then statistics are displayed in the statistics viewer and
are periodically updated while the performance monitor is recording.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PerformanceMonitor.isLiveUpdatesEnabled">
<code class="descname">isLiveUpdatesEnabled</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.PerformanceMonitor.isLiveUpdatesEnabled" title="Permalink to this definition"></a></dt>
<dd><p>Return whether live updates is enabled.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PerformanceMonitor.isRecording">
<code class="descname">isRecording</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.PerformanceMonitor.isRecording" title="Permalink to this definition"></a></dt>
<dd><p>Return whether the performance monitor is recording.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PerformanceMonitor.isSamplingCookStats">
<code class="descname">isSamplingCookStats</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.PerformanceMonitor.isSamplingCookStats" title="Permalink to this definition"></a></dt>
<dd><p>Return whether the sampling of cook statistics is turned on.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PerformanceMonitor.isSamplingErrors">
<code class="descname">isSamplingErrors</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.PerformanceMonitor.isSamplingErrors" title="Permalink to this definition"></a></dt>
<dd><p>Return whether the sampling of warnings and errors is turned on.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PerformanceMonitor.isSamplingFrameStats">
<code class="descname">isSamplingFrameStats</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.PerformanceMonitor.isSamplingFrameStats" title="Permalink to this definition"></a></dt>
<dd><p>Return whether the sampling of frame statistics is turned on.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PerformanceMonitor.isSamplingMemoryStats">
<code class="descname">isSamplingMemoryStats</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.PerformanceMonitor.isSamplingMemoryStats" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.PerformanceMonitor.isSamplingObjectDrawStats">
<code class="descname">isSamplingObjectDrawStats</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.PerformanceMonitor.isSamplingObjectDrawStats" title="Permalink to this definition"></a></dt>
<dd><p>Return whether the sampling of object drawing statistics is turned
on.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PerformanceMonitor.isSamplingObjectGPUDrawStats">
<code class="descname">isSamplingObjectGPUDrawStats</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.PerformanceMonitor.isSamplingObjectGPUDrawStats" title="Permalink to this definition"></a></dt>
<dd><p>Return whether the sampling of object GPU drawing statistics is
turned on.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PerformanceMonitor.isSamplingScriptStats">
<code class="descname">isSamplingScriptStats</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.PerformanceMonitor.isSamplingScriptStats" title="Permalink to this definition"></a></dt>
<dd><p>Return whether the sampling of script statistics is turned on.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PerformanceMonitor.isSamplingSolveStats">
<code class="descname">isSamplingSolveStats</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.PerformanceMonitor.isSamplingSolveStats" title="Permalink to this definition"></a></dt>
<dd><p>Return whether the sampling of DOP solve statistics is turned on.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PerformanceMonitor.isSamplingThreadStats">
<code class="descname">isSamplingThreadStats</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.PerformanceMonitor.isSamplingThreadStats" title="Permalink to this definition"></a></dt>
<dd><p>Return whether the sampling of thread statistics is turned on.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PerformanceMonitor.isSamplingViewportStats">
<code class="descname">isSamplingViewportStats</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.PerformanceMonitor.isSamplingViewportStats" title="Permalink to this definition"></a></dt>
<dd><p>Return whether the sampling of viewport statistics is turned on.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PerformanceMonitor.objectView">
<code class="descname">objectView</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.perfMonObjectView enum value<a class="headerlink" href="#hou.PerformanceMonitor.objectView" title="Permalink to this definition"></a></dt>
<dd><p>Return the structure type that is used to view objects in the
statistics viewer.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PerformanceMonitor.sampleCookStats">
<code class="descname">sampleCookStats</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.PerformanceMonitor.sampleCookStats" title="Permalink to this definition"></a></dt>
<dd><p>Turn sampling of cook statistics on or off.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PerformanceMonitor.sampleErrors">
<code class="descname">sampleErrors</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.PerformanceMonitor.sampleErrors" title="Permalink to this definition"></a></dt>
<dd><p>Turn sampling of warnings and errors on or off.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PerformanceMonitor.sampleFrameStats">
<code class="descname">sampleFrameStats</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.PerformanceMonitor.sampleFrameStats" title="Permalink to this definition"></a></dt>
<dd><p>Turn sampling of frame statistics on or off.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PerformanceMonitor.sampleMemoryStats">
<code class="descname">sampleMemoryStats</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.PerformanceMonitor.sampleMemoryStats" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.PerformanceMonitor.sampleObjectDrawStats">
<code class="descname">sampleObjectDrawStats</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.PerformanceMonitor.sampleObjectDrawStats" title="Permalink to this definition"></a></dt>
<dd><p>Turn sampling of object drawing statistics on or off.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PerformanceMonitor.sampleObjectGPUDrawStats">
<code class="descname">sampleObjectGPUDrawStats</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.PerformanceMonitor.sampleObjectGPUDrawStats" title="Permalink to this definition"></a></dt>
<dd><p>Turn sampling of object GPU drawing statistics on or off.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PerformanceMonitor.sampleScriptStats">
<code class="descname">sampleScriptStats</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.PerformanceMonitor.sampleScriptStats" title="Permalink to this definition"></a></dt>
<dd><p>Turn sampling of script statistics on or off.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PerformanceMonitor.sampleSolveStats">
<code class="descname">sampleSolveStats</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.PerformanceMonitor.sampleSolveStats" title="Permalink to this definition"></a></dt>
<dd><p>Turn sampling of DOP solve statistics on or off.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PerformanceMonitor.sampleThreadStats">
<code class="descname">sampleThreadStats</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.PerformanceMonitor.sampleThreadStats" title="Permalink to this definition"></a></dt>
<dd><p>Turn sampling of thread statistics on or off. Note that turning on
thread sampling can add overhead to the processing times (i.e. cook
times, solve times, etc.) in the scene.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PerformanceMonitor.sampleViewportStats">
<code class="descname">sampleViewportStats</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.PerformanceMonitor.sampleViewportStats" title="Permalink to this definition"></a></dt>
<dd><p>Turn sampling of object-drawing statistics on or off.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PerformanceMonitor.setObjectView">
<code class="descname">setObjectView</code><span class="sig-paren">(</span><em>self</em>, <em>view</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.PerformanceMonitor.setObjectView" title="Permalink to this definition"></a></dt>
<dd><p>Set the structure type to use when viewing objects in the statistics
viewer.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PerformanceMonitor.setTimeFormat">
<code class="descname">setTimeFormat</code><span class="sig-paren">(</span><em>self</em>, <em>format</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.PerformanceMonitor.setTimeFormat" title="Permalink to this definition"></a></dt>
<dd><p>Set the format to use when viewing times in the statistics viewer.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PerformanceMonitor.startRecording">
<code class="descname">startRecording</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.PerformanceMonitor.startRecording" title="Permalink to this definition"></a></dt>
<dd><p>Start recording in the performance monitor.</p>
<p>Raises hou.OperationFailed if the performance monitor is already
recording.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PerformanceMonitor.stopRecording">
<code class="descname">stopRecording</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.PerformanceMonitor.stopRecording" title="Permalink to this definition"></a></dt>
<dd><p>Stop recording in the performance monitor.</p>
<p>Raises hou.OperationFailed if the performance monitor is already
stopped.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.PerformanceMonitor.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.PerformanceMonitor.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

<dl class="method">
<dt id="hou.PerformanceMonitor.timeFormat">
<code class="descname">timeFormat</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.perfMonTimeFormat enum value<a class="headerlink" href="#hou.PerformanceMonitor.timeFormat" title="Permalink to this definition"></a></dt>
<dd><p>Return the format that is used to view times in the statistics
viewer.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.PermissionError">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">PermissionError</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.PermissionError" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.Error" title="hou.Error"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.Error</span></code></a></p>
<dl class="method">
<dt id="hou.PermissionError.description">
<code class="descname">description</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.PermissionError.description" title="Permalink to this definition"></a></dt>
<dd><p>Return a description of the class of exception. The description is
not related to the exception instance.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PermissionError.exceptionTypeName">
<code class="descname">exceptionTypeName</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.PermissionError.exceptionTypeName" title="Permalink to this definition"></a></dt>
<dd><p>Return the name of the exception type. Instances of different
subclasses of hou.Error will return different names. Instances of
the base class will return Error.</p>
<p>You can also use str(e.__class__) to get the name of the subclass.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PermissionError.instanceMessage">
<code class="descname">instanceMessage</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.PermissionError.instanceMessage" title="Permalink to this definition"></a></dt>
<dd><p>Return a message specific to the exception instance.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.PermissionError.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.PermissionError.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.Point">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">Point</code><a class="headerlink" href="#hou.Point" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Each Point object resides inside a Geometry object and stores a 3D
position. Points may be shared between primitives (such as polygons),
and the set of points and primitives describes a 3D shape.</p>
<p>The set of points may also store arbitrary data in the form of
attributes, and each point instance stores a unique attribute value.</p>
<dl class="method">
<dt id="hou.Point.attribType">
<code class="descname">attribType</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.attribType enum value<a class="headerlink" href="#hou.Point.attribType" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Return the enumerated value hou.attribType.Point. Points,
primitives, vertices, and geometry support the same set of methods
for querying their attributes, and this method is one of them.</p>
<p>See also:</p>
</div></blockquote>
<ul class="simple">
<li>hou.Prim.attribType</li>
<li>hou.Vertex.attribType</li>
<li>hou.Geometry.attribType</li>
<li>hou.attribType</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="hou.Point.attribValue">
<code class="descname">attribValue</code><span class="sig-paren">(</span><em>self</em>, <em>name_or_attrib</em><span class="sig-paren">)</span> &#x2192; int, float, str or tuple<a class="headerlink" href="#hou.Point.attribValue" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Return value stored in this point for a particular attribute. The
attribute may be specified by name or by hou.Attrib object.</p>
<p>Looking up an attribute value using a hou.Attrib object is slightly
faster than looking it up by name. When looking up attribute values
inside a loop, look up the hou.Attrib object outside the loop, and
pass it into this method.</p>
<p>Note that the point position attribute is named P and is 4 floats in
size. This attribute always exists.</p>
<p>When looking up the attribute values of all points, it is faster to
call hou.Geometry.pointFloatAttribValues or
hou.Geometry.pointFloatAttribValuesAsString than to call this method
for each point in the geometry.</p>
<p>Raises hou.OperationFailed if no attribute exists with this name.</p>
</div></blockquote>
<p>&gt; # Create an object containing two SOPs: a box SOP wired into a color SOP.
&gt; geo_node = hou.node(/obj).createNode(geo)
&gt; box = geo_node.createNode(box)
&gt; color = geo_node.createNode(color)
&gt; color.setFirstInput(box)
&gt; 
&gt; # Grab the color SOPs geometry, get its first point, and print out the
&gt; # value of the Cd attribute.
&gt; geo = color.geometry()
&gt; point = geo.iterPoints()[0]
&gt; print point.attribValue(Cd)
&gt; 
&gt; # Look up the Cd attribute and illustrate how to access the attribute
&gt; # value using the attribute object.
&gt; cd_attribute = geo.findPointAttrib(Cd)
&gt; print point.attribValue(cd_attribute)</p>
</dd></dl>

<dl class="method">
<dt id="hou.Point.floatAttribValue">
<code class="descname">floatAttribValue</code><span class="sig-paren">(</span><em>self</em>, <em>name_or_attrib</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#hou.Point.floatAttribValue" title="Permalink to this definition"></a></dt>
<dd><p>Return the point attribute value for a particular floating point
attribute. The attribute may be specified by name or by hou.Attrib
object.</p>
<p>Raises hou.OperationFailed if no attribute exists with this name or
the attribute is not float of size 1.</p>
<p>In most cases, youll just use hou.Point.attribValue to access
attribute values. Houdini uses this method internally to implement
attribValue.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Point.floatListAttribValue">
<code class="descname">floatListAttribValue</code><span class="sig-paren">(</span><em>self</em>, <em>name_or_attrib</em><span class="sig-paren">)</span> &#x2192; tuple of float<a class="headerlink" href="#hou.Point.floatListAttribValue" title="Permalink to this definition"></a></dt>
<dd><p>Return the point attribute value for a particular floating point
attribute. The attribute may be specified by name or by hou.Attrib
object. The return value is a tuple of floats.</p>
<p>It is valid to call this method when the attributes size is 1. In
this case, a tuple with one element is returned.</p>
<p>See also hou.Point.attribValue.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Point.geometry">
<code class="descname">geometry</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Geometry<a class="headerlink" href="#hou.Point.geometry" title="Permalink to this definition"></a></dt>
<dd><p>Return the hou.Geometry object containing this point.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Point.intAttribValue">
<code class="descname">intAttribValue</code><span class="sig-paren">(</span><em>self</em>, <em>name_or_attrib</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.Point.intAttribValue" title="Permalink to this definition"></a></dt>
<dd><p>Return the point attribute value for a particular integer attribute
of size 1. The attribute may be specified by name or by hou.Attrib
object. See hou.Point.floatAttribValue for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Point.intListAttribValue">
<code class="descname">intListAttribValue</code><span class="sig-paren">(</span><em>self</em>, <em>name_or_attrib</em><span class="sig-paren">)</span> &#x2192; tuple of int<a class="headerlink" href="#hou.Point.intListAttribValue" title="Permalink to this definition"></a></dt>
<dd><p>Return the point attribute value for a particular integer attribute.
The attribute may be specified by name or by hou.Attrib object. The
return value is a tuple of ints. See hou.Point.floatListAttribValue
for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Point.number">
<code class="descname">number</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.Point.number" title="Permalink to this definition"></a></dt>
<dd><p>Return the number of this point. Points are numbered sequentially
starting from 0, and the points returned by hou.Geometry.points are
in order by their number.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Point.position">
<code class="descname">position</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Vector3<a class="headerlink" href="#hou.Point.position" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Return the position of this point as a Vector3 containing the (X, Y,
Z) position values.</p>
<p>This method is a shortcut for accessing the P attribute of the
point.</p>
</div></blockquote>
<p>&gt; point.position()
&gt; # is equivalent to
&gt; hou.Vector3(point.attribValue(P))</p>
<blockquote>
<div><p>Because the position is returned as a Vector3, it can be accessed as
a sequence. However, you can also easily use hou.Matrix4 to
transform the position.</p>
<p>See also:</p>
</div></blockquote>
<ul class="simple">
<li>hou.Point.weight</li>
<li>hou.Vector3</li>
<li>hou.Matrix4</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="hou.Point.prims">
<code class="descname">prims</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.Prim<a class="headerlink" href="#hou.Point.prims" title="Permalink to this definition"></a></dt>
<dd><p>Returns a tuple of the primitives that reference this point.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Point.setAttribValue">
<code class="descname">setAttribValue</code><span class="sig-paren">(</span><em>self</em>, <em>name_or_attrib</em>, <em>attrib_value</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Point.setAttribValue" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Store an attribute value in this point. The attribute may be
specified by name or by hou.Attrib object, and must be an existing
point attribute in the geometry. You would typically call this
method from the code of a Python-defined SOP.</p>
<p>Raises hou.OperationFailed if no attribute exists with this name or
if the attributes data type does not match the value passed in. If
the attributes size is more than 1, the attribute value must be a
sequence of integers/floats, and the size of the sequence must match
the attributes size.</p>
<p>Raises hou.GeometryPermissionError if this geometry is not
modifiable.</p>
<p>See hou.Geometry.addAttrib for an example.</p>
<p>See also:</p>
</div></blockquote>
<ul class="simple">
<li>hou.Prim.setAttribValue</li>
<li>hou.Vertex.setAttribValue</li>
<li>hou.Geometry.setGlobalAttribValue</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="hou.Point.setPosition">
<code class="descname">setPosition</code><span class="sig-paren">(</span><em>self</em>, <em>position</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Point.setPosition" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Changes the points location. You would typically call this method
from the code of a Python-defined SOP.</p>
<dl class="docutils">
<dt>position</dt>
<dd>Any sequence of floats, such has a hou.Vector3 or a tuple of
floats, of length either 3 or 4. The fourth coordinate
corresponds to the weight, and is usually 1. The weight is
typically used by NURBS curves and sequences. If the sequence is
of size 3, the weight will be unchanged.</dd>
</dl>
<p>This method is a shortcut for calling hou.Point.setAttribValue on
the P attribute.</p>
</div></blockquote>
<p>&gt; point.setPosition((x, y, z))
&gt; # is the same as
&gt; point.setAttribValue(P, (x, y, z))</p>
<blockquote>
<div><p>Raises hou.GeometryPermissionError if the geometry is not
modifiable. Raises hou.InvalidSize if the length of position is not
3.</p>
<p>See also hou.Point.setWeight.</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.Point.setWeight">
<code class="descname">setWeight</code><span class="sig-paren">(</span><em>self</em>, <em>weight</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Point.setWeight" title="Permalink to this definition"></a></dt>
<dd><p>Change the points weight. You would typically call this method from
the code of a Python-defined SOP.</p>
<p>This method is a shortcut for calling hou.Point.setAttribValue on
the Pw attribute.</p>
<p>See hou.Point.weight for more information about a points weight.
See also hou.Point.setPosition.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Point.stringAttribValue">
<code class="descname">stringAttribValue</code><span class="sig-paren">(</span><em>self</em>, <em>name_or_attrib</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.Point.stringAttribValue" title="Permalink to this definition"></a></dt>
<dd><p>Return the point attribute value for a particular string attribute.
The attribute may be specified by name or by hou.Attrib object. See
hou.Point.floatAttribValue for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Point.stringListAttribValue">
<code class="descname">stringListAttribValue</code><span class="sig-paren">(</span><em>self</em>, <em>name_or_attrib</em><span class="sig-paren">)</span> &#x2192; tuple of str<a class="headerlink" href="#hou.Point.stringListAttribValue" title="Permalink to this definition"></a></dt>
<dd><p>Return the point attribute value for a particular string attribute.
The attribute may be specified by name or by hou.Attrib object. The
return value is a tuple of strings.</p>
<p>It is valid to call this method when the attributes size is 1. In
this case, a tuple with one element is returned.</p>
<p>See also hou.Point.attribValue.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.Point.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.Point.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

<dl class="method">
<dt id="hou.Point.vertices">
<code class="descname">vertices</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.Vertex<a class="headerlink" href="#hou.Point.vertices" title="Permalink to this definition"></a></dt>
<dd><p>Returns a tuple of the vertices that reference this point. Note that
this requires a search through a primitives vertices, so the cost
is linear in the total number of vertices in these primitives.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Point.weight">
<code class="descname">weight</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#hou.Point.weight" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Return the weight of this point. Point weights are displayed in
Houdinis geometry spreadsheet as the fourth component of the
position, and are used in NURBS curves and surfaces.</p>
<p>Most of the time, the weight is 1.0.</p>
<p>This method is a shortcut for accessing the Pw attribute of the
point.</p>
</div></blockquote>
<p>&gt; point.weight()
&gt; # is equivalent to
&gt; point.attribValue(Pw)</p>
<blockquote>
<div>You can build a hou.Vector4 containing both the position and weight
as follows:</div></blockquote>
<p>&gt; hou.Vector4(tuple(point.position()) + (point.weight(),))</p>
<blockquote>
<div>See also hou.Point.position.</div></blockquote>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.PointGroup">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">PointGroup</code><a class="headerlink" href="#hou.PointGroup" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A named group of points inside a Geometry object.</p>
<p>Point groups reside inside the geometry, and each point group has a
unique name.</p>
<p>Groups are either ordered or unordered. When asking for the contents of
an ordered group, the results will be returned in the order they were
added to to the group. For an unordered group, the results will be
returned in an arbitrary order (though it is normally arranged by
increasing point number). When creating a group using the group SOP, use
the &lt;Create Ordered&gt; checkbox to create an ordered group. When creating
one from Python, Use the is_ordered parameter of
hou.Geometry.createPointGroup to control whether a group is ordered.</p>
<p>See hou.Point for more information about points. See also hou.PrimGroup.</p>
<p>REPLACES</p>
<blockquote>
<div><ul class="simple">
<li>haspoint()</li>
<li>pointlist()</li>
</ul>
</div></blockquote>
<dl class="method">
<dt id="hou.PointGroup.add">
<code class="descname">add</code><span class="sig-paren">(</span><em>self</em>, <em>point_or_list_or_point_group</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.PointGroup.add" title="Permalink to this definition"></a></dt>
<dd><p>If given a hou.Point or a list of hou.Points, add the point(s) to
the group. If given a hou.PointGroup, merge the contents of the
other point group with this group (the other group is unaffected).
You would typically call this method from the code of a Python-
defined SOP.</p>
<p>It is ok to add points to the group that were already in the group.</p>
<p>Raises hou.GeometryPermissionError if this geometry is not
modifiable.</p>
<p>Raises hou.OperationFailed if the point or point group belong to a
different geometry object than this group.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PointGroup.clear">
<code class="descname">clear</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.PointGroup.clear" title="Permalink to this definition"></a></dt>
<dd><p>Remove all points from this group. You would typically call this
method from the code of a Python-defined SOP.</p>
<p>The points remain in the geometry; only the group is affected.</p>
<p>Raises hou.GeometryPermissionError if this geometry is not
modifiable.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PointGroup.contains">
<code class="descname">contains</code><span class="sig-paren">(</span><em>self</em>, <em>point</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.PointGroup.contains" title="Permalink to this definition"></a></dt>
<dd><p>Return whether or not a point is in this group.</p>
<p>Raises hou.OperationFailed if the point belongs to a different
geometry object than this group.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PointGroup.destroy">
<code class="descname">destroy</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.PointGroup.destroy" title="Permalink to this definition"></a></dt>
<dd><p>Remove this group from the geometry. You would typically call this
method from the code of a Python-defined SOP.</p>
<p>Raises hou.GeometryPermissionError if this geometry is not
modifiable.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PointGroup.geometry">
<code class="descname">geometry</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Geometry<a class="headerlink" href="#hou.PointGroup.geometry" title="Permalink to this definition"></a></dt>
<dd><p>Return the geometry object containing this group.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PointGroup.isOrdered">
<code class="descname">isOrdered</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.PointGroup.isOrdered" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.PointGroup.name">
<code class="descname">name</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.PointGroup.name" title="Permalink to this definition"></a></dt>
<dd><p>Return the name of the group. Each point group has a unique name.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PointGroup.option">
<code class="descname">option</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.PointGroup.option" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.PointGroup.optionType">
<code class="descname">optionType</code><span class="sig-paren">(</span><em>self</em>, <em>name</em><span class="sig-paren">)</span> &#x2192; hou.fieldType enum value<a class="headerlink" href="#hou.PointGroup.optionType" title="Permalink to this definition"></a></dt>
<dd><p>Return a hou.fieldType enumerated value that describes the type of
data stored in an option. Returns hou.fieldType.NoSuchField if no
field exists with that name.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PointGroup.options">
<code class="descname">options</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.PointGroup.options" title="Permalink to this definition"></a></dt>
<dd><p>option(self, name) -&gt; bool, int, float, str, hou.Vector2, , hou.Vector4,
hou.Quaternion, hou.Matrix3, hou.Matrix4, tuple of int, or tuple of
float</p>
<blockquote>
<div><p>Return the value of an individual option, on None if no such option
exists.</p>
<p>See also hou.PointGroup.options, hou.PointGroup.setOption and
hou.PointGroup.removeOption.</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.PointGroup.points">
<code class="descname">points</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.Point<a class="headerlink" href="#hou.PointGroup.points" title="Permalink to this definition"></a></dt>
<dd><p>Return the contents of this group.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PointGroup.remove">
<code class="descname">remove</code><span class="sig-paren">(</span><em>self</em>, <em>point_or_list_or_point_group</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.PointGroup.remove" title="Permalink to this definition"></a></dt>
<dd><p>If given a hou.Point or a list of hou.Points, remove the point from
the group. If given a hou.PointGroup, remove all points in the other
group from this group (the other group is unaffected). You would
typically call this method from the code of a Python-defined SOP.</p>
<p>It is not an error to try to remove a point from the group that
wasnt already in the group.</p>
<p>Raises hou.GeometryPermissionError if this geometry is not
modifiable.</p>
<p>Raises hou.OperationFailed if the point belongs to a different
geometry object than this group.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PointGroup.removeOption">
<code class="descname">removeOption</code><span class="sig-paren">(</span><em>self</em>, <em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.PointGroup.removeOption" title="Permalink to this definition"></a></dt>
<dd><p>Remove an entry in the dictionary of options. See
hou.PointGroup.options for more information.</p>
<p>Raises hou.OperationFailed if there is no entry in the dictionary
with this name.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PointGroup.setOption">
<code class="descname">setOption</code><span class="sig-paren">(</span><em>self</em>, <em>name</em>, <em>value</em>, <em>type_hint = hou.fieldType::NoSuchField</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.PointGroup.setOption" title="Permalink to this definition"></a></dt>
<dd><p>Set an entry in the dictionary of options. See
hou.PointGroup.options for more information.</p>
<dl class="docutils">
<dt>name</dt>
<dd>The name of the option to set.</dd>
<dt>value</dt>
<dd>An integer, float, string, hou.Vector2, hou.Vector3,
hou.Vector4, hou.Quaternion, hou.Matrix3, hou.matrix4, or
sequence of numbers.</dd>
<dt>type_hint</dt>
<dd>Used to determine the exact hou.fieldType desired when the
specified value type is not enough to unambiguously determine
it.</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="hou.PointGroup.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.PointGroup.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.Polygon">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">Polygon</code><a class="headerlink" href="#hou.Polygon" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.Face" title="hou.Face"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.Face</span></code></a></p>
<p>A Polygon is a kind of Face whose vertices are connected via straight
lines.</p>
<p>Currently, hou.Face, and its base class hou.Prim contain all the
necessary methods for polygon inspection and manipulation.</p>
<dl class="attribute">
<dt id="hou.Polygon.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.Polygon.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.PopNetNode">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">PopNetNode</code><a class="headerlink" href="#hou.PopNetNode" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.Node" title="hou.Node"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.Node</span></code></a></p>
<dl class="method">
<dt id="hou.PopNetNode.displayNode">
<code class="descname">displayNode</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; Node<a class="headerlink" href="#hou.PopNetNode.displayNode" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.PopNetNode.renderNode">
<code class="descname">renderNode</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; Node<a class="headerlink" href="#hou.PopNetNode.renderNode" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.PopNetNode.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.PopNetNode.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.PopNode">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">PopNode</code><a class="headerlink" href="#hou.PopNode" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.Node" title="hou.Node"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.Node</span></code></a></p>
<p>Represents a particle node.</p>
<p>REPLACES</p>
<blockquote>
<div><ul class="simple">
<li>opget</li>
<li>opset</li>
<li>opflag()</li>
<li>popevent()</li>
<li>popeventtime()</li>
<li>poppoint()</li>
<li>poppointid()</li>
<li>poppointnum()</li>
</ul>
</div></blockquote>
<dl class="method">
<dt id="hou.PopNode.bypass">
<code class="descname">bypass</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.PopNode.bypass" title="Permalink to this definition"></a></dt>
<dd><p>Turns this nodes bypass flag on or off, making this node have no
effect.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PopNode.curPoint">
<code class="descname">curPoint</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Point<a class="headerlink" href="#hou.PopNode.curPoint" title="Permalink to this definition"></a></dt>
<dd><p>Returns the current point, equivalent to the $PT local variable.
This function only works on a node that has a $PT local variable,
and only when the node is being cooked.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PopNode.displayNode">
<code class="descname">displayNode</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; Node<a class="headerlink" href="#hou.PopNode.displayNode" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.PopNode.isBypassed">
<code class="descname">isBypassed</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.PopNode.isBypassed" title="Permalink to this definition"></a></dt>
<dd><p>Returns whether this nodes bypass flag is on.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PopNode.isDisplayFlagSet">
<code class="descname">isDisplayFlagSet</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.PopNode.isDisplayFlagSet" title="Permalink to this definition"></a></dt>
<dd><p>Returns whether this nodes display flag is on.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PopNode.isRenderFlagSet">
<code class="descname">isRenderFlagSet</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.PopNode.isRenderFlagSet" title="Permalink to this definition"></a></dt>
<dd><p>Returns whether this nodes render flag is on.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PopNode.isTemplateFlagSet">
<code class="descname">isTemplateFlagSet</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.PopNode.isTemplateFlagSet" title="Permalink to this definition"></a></dt>
<dd><p>Returns whether the template flag on this node is on.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PopNode.renderNode">
<code class="descname">renderNode</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; Node<a class="headerlink" href="#hou.PopNode.renderNode" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.PopNode.setDisplayFlag">
<code class="descname">setDisplayFlag</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.PopNode.setDisplayFlag" title="Permalink to this definition"></a></dt>
<dd><p>Turn this nodes display flag on or off.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PopNode.setRenderFlag">
<code class="descname">setRenderFlag</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.PopNode.setRenderFlag" title="Permalink to this definition"></a></dt>
<dd><p>Turns this nodes render flag on or off.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PopNode.setTemplateFlag">
<code class="descname">setTemplateFlag</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.PopNode.setTemplateFlag" title="Permalink to this definition"></a></dt>
<dd><p>Sets this nodes template flag on or off.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.PopNode.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.PopNode.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.Prim">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">Prim</code><a class="headerlink" href="#hou.Prim" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Each Prim resides inside a Geometry object and stores some sort of 3D
geometric primitive, like a polygon, a NURBS curve, or a volume. Each
primitive usually contains a set of Vertex objects, each of which
references a Point object.</p>
<p>This class has a number of subclasses for the different primitive types,
such as hou.Polygon and hou.Volume.</p>
<dl class="method">
<dt id="hou.Prim.attribType">
<code class="descname">attribType</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.attribType enum value<a class="headerlink" href="#hou.Prim.attribType" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Return the enumerated value hou.attribType.Prim. Points, primitives,
vertices, and geometry support the same set of methods for querying
their attributes, and this method is one of them.</p>
<p>See also:</p>
</div></blockquote>
<ul class="simple">
<li>hou.Point.attribType</li>
<li>hou.Vertex.attribType</li>
<li>hou.Geometry.attribType</li>
<li>hou.attribType</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="hou.Prim.attribValue">
<code class="descname">attribValue</code><span class="sig-paren">(</span><em>self</em>, <em>name_or_attrib</em><span class="sig-paren">)</span> &#x2192; int, float, str or tuple<a class="headerlink" href="#hou.Prim.attribValue" title="Permalink to this definition"></a></dt>
<dd><p>Return the value stored in this primitive for a particular
attribute. The attribute may be specified by name or by hou.Attrib
object.</p>
<p>Looking an attribute value using a hou.Attrib object is slightly
faster than looking it up by name. When looking up attribute values
inside a loop, look up the hou.Attrib object outside the loop, and
pass it into this method.</p>
<p>When looking up the attribute values of all primitives, it is faster
to call hou.Geometry.primFloatAttribValues or
hou.Geometry.primFloatAttribValuesAsString than to call this method
for each primitive in the geometry.</p>
<p>Raises hou.OperationFailed if no attribute exists with this name.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Prim.attribValueAtInterior">
<code class="descname">attribValueAtInterior</code><span class="sig-paren">(</span><em>self</em>, <em>attrib_or_name</em>, <em>u</em>, <em>v</em>, <em>w=0.0</em><span class="sig-paren">)</span> &#x2192; int, float,<a class="headerlink" href="#hou.Prim.attribValueAtInterior" title="Permalink to this definition"></a></dt>
<dd><p>str or tuple</p>
<p>Return an attribute value at the normalized u, v, w parametric
position in the interior of the primitive.</p>
<p>Raises hou.OperationFailed if the attribute is not a point or vertex
attribute. If you want a primitive attribute value, it doesnt vary
across the surface, so use hou.Prim.attribValue.</p>
<p>Use hou.Face.attribValueAt for querying attributes along the
perimeter.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Prim.boundingBox">
<code class="descname">boundingBox</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.BoundingBox<a class="headerlink" href="#hou.Prim.boundingBox" title="Permalink to this definition"></a></dt>
<dd><p>Return an axis-aligned 3D bounding box that is sized and positioned
to be large enough to hold this primitive.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Prim.edges">
<code class="descname">edges</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.Prim.edges" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.Prim.floatAttribValue">
<code class="descname">floatAttribValue</code><span class="sig-paren">(</span><em>self</em>, <em>attrib</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#hou.Prim.floatAttribValue" title="Permalink to this definition"></a></dt>
<dd><p>Return the primitive attribute value for a particular floating point
attribute. The attribute may be specified by name or by hou.Attrib
object.</p>
<p>Raises hou.OperationFailed if no attribute exists with this name or
the attribute is not float of size 1.</p>
<p>In most cases, youll just use hou.Prim.attribValue to access
attribute values. Houdini uses this method internally to implement
attribValue.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Prim.floatListAttribValue">
<code class="descname">floatListAttribValue</code><span class="sig-paren">(</span><em>self</em>, <em>name_or_attrib</em><span class="sig-paren">)</span> &#x2192; tuple of float<a class="headerlink" href="#hou.Prim.floatListAttribValue" title="Permalink to this definition"></a></dt>
<dd><p>Return the primitive attribute value for a particular floating point
attribute. The attribute may be specified by name or by hou.Attrib
object. The return value is a tuple of floats.</p>
<p>It is valid to call this method when the attributes size is 1. In
this case, a tuple with one element is returned.</p>
<p>See also hou.Prim.attribValue.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Prim.geometry">
<code class="descname">geometry</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Geometry<a class="headerlink" href="#hou.Prim.geometry" title="Permalink to this definition"></a></dt>
<dd><p>Return the hou.Geometry object containing this primitive.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Prim.groups">
<code class="descname">groups</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.PrimGroup<a class="headerlink" href="#hou.Prim.groups" title="Permalink to this definition"></a></dt>
<dd><p>Return a tuple of the primitive groups that contain this primitive.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Prim.intAttribValue">
<code class="descname">intAttribValue</code><span class="sig-paren">(</span><em>self</em>, <em>name_or_attrib</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.Prim.intAttribValue" title="Permalink to this definition"></a></dt>
<dd><p>Return the primitive attribute value for a particular integer
attribute of size 1. The attribute may be specified by name or by
hou.Attrib object. See hou.Point.floatAttribValue for more
information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Prim.intListAttribValue">
<code class="descname">intListAttribValue</code><span class="sig-paren">(</span><em>self</em>, <em>name_or_attrib</em><span class="sig-paren">)</span> &#x2192; tuple of int<a class="headerlink" href="#hou.Prim.intListAttribValue" title="Permalink to this definition"></a></dt>
<dd><p>Return the primitive attribute value for a particular integer
attribute. The attribute may be specified by name or by hou.Attrib
object. The return value is a tuple of ints. See
hou.Prim.floatListAttribValue for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Prim.intrinsicNames">
<code class="descname">intrinsicNames</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of str<a class="headerlink" href="#hou.Prim.intrinsicNames" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.Prim.intrinsicReadOnly">
<code class="descname">intrinsicReadOnly</code><span class="sig-paren">(</span><em>self</em>, <em>intrinsic_name</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.Prim.intrinsicReadOnly" title="Permalink to this definition"></a></dt>
<dd><p>Returns whether the intrinsic is read-only or can be modified with
setIntrinsicValue()</p>
</dd></dl>

<dl class="method">
<dt id="hou.Prim.intrinsicSize">
<code class="descname">intrinsicSize</code><span class="sig-paren">(</span><em>self</em>, <em>intrinsic_name</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.Prim.intrinsicSize" title="Permalink to this definition"></a></dt>
<dd><p>Returns the intrinsic value tuple size.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Prim.intrinsicValue">
<code class="descname">intrinsicValue</code><span class="sig-paren">(</span><em>self</em>, <em>intrinsic_name</em><span class="sig-paren">)</span> &#x2192; int, float, str, or tuple<a class="headerlink" href="#hou.Prim.intrinsicValue" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.Prim.intrinsicValueDict">
<code class="descname">intrinsicValueDict</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; dict of str to value<a class="headerlink" href="#hou.Prim.intrinsicValueDict" title="Permalink to this definition"></a></dt>
<dd><p>Returns a dictionary mapping intrinsic names to their values.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Prim.nearestToPosition">
<code class="descname">nearestToPosition</code><span class="sig-paren">(</span><em>self</em>, <em>pos3</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Prim.nearestToPosition" title="Permalink to this definition"></a></dt>
<dd><p>Given a sequence of three floats containing a position, find the
location on this primitive that is closest to that position. Returns
a tuple containing the u value on this primitive, the v value on
this primitive, and the distance to this primitive.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Prim.numEdges">
<code class="descname">numEdges</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.Prim.numEdges" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.Prim.numVertices">
<code class="descname">numVertices</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.Prim.numVertices" title="Permalink to this definition"></a></dt>
<dd><p>A shortcut for len(self.vertices()). You probably dont need to call
this method.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Prim.number">
<code class="descname">number</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.Prim.number" title="Permalink to this definition"></a></dt>
<dd><p>Return the number of this primitive. Primitives are numbered
sequentially starting from 0, and the primitives returned by
hou.Geometry.prims are in order by their number.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Prim.points">
<code class="descname">points</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; list of hou.Point<a class="headerlink" href="#hou.Prim.points" title="Permalink to this definition"></a></dt>
<dd><p>Shortcut for getting all the points of a primitive without iterating
through each vertex.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Prim.positionAtInterior">
<code class="descname">positionAtInterior</code><span class="sig-paren">(</span><em>self</em>, <em>u</em>, <em>v</em>, <em>w=0.0</em><span class="sig-paren">)</span> &#x2192; hou.Vector3<a class="headerlink" href="#hou.Prim.positionAtInterior" title="Permalink to this definition"></a></dt>
<dd><p>Given normalized (i.e. from 0 to 1) u, v, w values, return the
interior position of the primitive at that parametric location.</p>
<p>Use hou.Face.positionAt for querying positions along the perimeter.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Prim.setAttribValue">
<code class="descname">setAttribValue</code><span class="sig-paren">(</span><em>self</em>, <em>name_or_attrib</em>, <em>attrib_value</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Prim.setAttribValue" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Store an attribute value in this primitive. The attribute may be
specified by name or by hou.Attrib object, and must be an existing
primitive attribute in the geometry. You would typically call this
method from the code of a Python-defined SOP.</p>
<p>Raises hou.OperationFailed if no attribute exists with this name or
if the attributes data type does not match the value passed in. If
the attributes size is more than 1, the attribute value must be a
sequence of integers/floats, and the size of the sequence must match
the attributes size.</p>
<p>Raises hou.GeometryPermissionError if this geometry is not
modifiable.</p>
</div></blockquote>
<p>&gt; # Create a float primitive attribute of size 3 named Cd, and assign
&gt; # each primitive a unique color.  This code will work from inside a Python
&gt; # SOP, but not from the Python shell.
&gt; geo = hou.pwd().geometry()
&gt; color_attrib = geo.addAttrib(hou.attribType.Prim, Cd, (1.0, 1.0, 1.0))
&gt; num_prims = len(geo.prims())
&gt; color = hou.Color()
&gt; for prim in geo.prims():
&gt;     fraction = float(prim.number()) / num_prims
&gt;     # Give each primitive a different hue, but full saturation and value.
&gt;     # Store the RGB value in the attribute.
&gt;     color.setHSV((fraction * 255, 1, 1))
&gt;     prim.setAttribValue(color_attrib, color.rgb())</p>
</dd></dl>

<dl class="method">
<dt id="hou.Prim.setIntrinsicValue">
<code class="descname">setIntrinsicValue</code><span class="sig-paren">(</span><em>self</em>, <em>intrinsic_name</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Prim.setIntrinsicValue" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.Prim.stringAttribValue">
<code class="descname">stringAttribValue</code><span class="sig-paren">(</span><em>self</em>, <em>name_or_attrib</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.Prim.stringAttribValue" title="Permalink to this definition"></a></dt>
<dd><p>Return the primitive attribute value for a particular string
attribute. The attribute may be specified by name or by hou.Attrib
object. See hou.Prim.floatAttribValue for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Prim.stringListAttribValue">
<code class="descname">stringListAttribValue</code><span class="sig-paren">(</span><em>self</em>, <em>name_or_attrib</em><span class="sig-paren">)</span> &#x2192; tuple of str<a class="headerlink" href="#hou.Prim.stringListAttribValue" title="Permalink to this definition"></a></dt>
<dd><p>Return the primitive attribute value for a particular string
attribute. The attribute may be specified by name or by hou.Attrib
object. The return value is a tuple of strings.</p>
<p>It is valid to call this method when the attributes size is 1. In
this case, a tuple with one element is returned.</p>
<p>See also hou.Prim.attribValue.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.Prim.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.Prim.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

<dl class="method">
<dt id="hou.Prim.type">
<code class="descname">type</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.primType enum value<a class="headerlink" href="#hou.Prim.type" title="Permalink to this definition"></a></dt>
<dd><p>Return a hou.primType value containing the type of this primitive
(e.g. polygon, NURBS curve, metaball, etc).</p>
</dd></dl>

<dl class="method">
<dt id="hou.Prim.vertices">
<code class="descname">vertices</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; generator of hou.Vertex<a class="headerlink" href="#hou.Prim.vertices" title="Permalink to this definition"></a></dt>
<dd><p>Return a sequence of the vertices contained in this primitive.</p>
<p>If the primitive is a face (e.g. a polygon or NURBS curve), the
result corresponds to the order of the vertices in that face. If it
is a surface (e.g. a NURBS mesh), however, the primitive has a 2D
array of vertices, and this method returns all vertices in the 2D
array, ordered by the rows.</p>
<p>See hou.Surface.vertex for more information about the relationship
between the 2D vertex array and the sequential vertex index, and for
more ways to access the vertices in a surface.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.PrimGroup">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">PrimGroup</code><a class="headerlink" href="#hou.PrimGroup" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A named group of primitives inside a Geometry object.</p>
<p>Primitive groups reside inside the geometry, and each primitive group
has a unique name.</p>
<p>Groups are either ordered or unordered. When asking for the contents of
an ordered group, the results will be returned in the order they were
added to to the group. For an unordered group, the results will be
returned in an arbitrary order (though it is normally arranged by
increasing primitive number). When creating a group using the group SOP,
use the &lt;Create Ordered&gt; checkbox to create an ordered group. When
creating one from Python, Use the is_ordered parameter of
hou.Geometry.createPrimGroup to control whether a group is ordered.</p>
<p>See hou.Prim for more information about primitives. See also
hou.PrimGroup.</p>
<p>REPLACES</p>
<blockquote>
<div><ul class="simple">
<li>hasprim()</li>
<li>primlist()</li>
</ul>
</div></blockquote>
<dl class="method">
<dt id="hou.PrimGroup.add">
<code class="descname">add</code><span class="sig-paren">(</span><em>self</em>, <em>prim_or_list_or_prim_group</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.PrimGroup.add" title="Permalink to this definition"></a></dt>
<dd><p>If given a hou.Prim or a list of hou.Prims, add the primitive(s) to
the group. If given a hou.PrimGroup, merge the contents of the other
primitive group with this group (the other group is unaffected). You
would typically call this method from the code of a Python-defined
SOP.</p>
<p>It is okay to add primitives to the group that were already in the
group.</p>
<p>Raises hou.GeometryPermissionError if this geometry is not
modifiable.</p>
<p>Raises hou.OperationFailed if the primitive or primitive group
belong to a different geometry object than this group.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PrimGroup.clear">
<code class="descname">clear</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.PrimGroup.clear" title="Permalink to this definition"></a></dt>
<dd><p>Remove all primitives from this group. You would typically call this
method from the code of a Python-defined SOP.</p>
<p>The primitives remain in the geometry; only the group is affected.</p>
<p>Raises hou.GeometryPermissionError if this geometry is not
modifiable.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PrimGroup.contains">
<code class="descname">contains</code><span class="sig-paren">(</span><em>self</em>, <em>prim</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.PrimGroup.contains" title="Permalink to this definition"></a></dt>
<dd><p>Return whether or not a primitive is in this group.</p>
<p>Raises hou.OperationFailed if the primitive belongs to a different
geometry object than this group.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PrimGroup.destroy">
<code class="descname">destroy</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.PrimGroup.destroy" title="Permalink to this definition"></a></dt>
<dd><p>Remove this group from the geometry. You would typically call this
method from the code of a Python-defined SOP.</p>
<p>Raises hou.GeometryPermissionError if this geometry is not
modifiable.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PrimGroup.geometry">
<code class="descname">geometry</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Geometry<a class="headerlink" href="#hou.PrimGroup.geometry" title="Permalink to this definition"></a></dt>
<dd><p>Return the geometry object containing this group.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PrimGroup.isOrdered">
<code class="descname">isOrdered</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.PrimGroup.isOrdered" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.PrimGroup.name">
<code class="descname">name</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.PrimGroup.name" title="Permalink to this definition"></a></dt>
<dd><p>Return the name of the group. Each primitive group has a unique
name.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PrimGroup.option">
<code class="descname">option</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.PrimGroup.option" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.PrimGroup.optionType">
<code class="descname">optionType</code><span class="sig-paren">(</span><em>self</em>, <em>name</em><span class="sig-paren">)</span> &#x2192; hou.fieldType enum value<a class="headerlink" href="#hou.PrimGroup.optionType" title="Permalink to this definition"></a></dt>
<dd><p>Return a hou.fieldType enumerated value that describes the type of
data stored in an option. Returns hou.fieldType.NoSuchField if no
field exists with that name.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PrimGroup.options">
<code class="descname">options</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.PrimGroup.options" title="Permalink to this definition"></a></dt>
<dd><p>option(self, name) -&gt; bool, int, float, str, hou.Vector2, hou.Vector3,
hou.Vector4, hou.Quaternion, hou.Matrix3, hou.Matrix4, tuple of int, or
tuple of float</p>
<blockquote>
<div><p>Return the value of an individual option, on None if no such option
exists.</p>
<p>See also hou.PrimGroup.options, hou.PrimGroup.setOption and
hou.PrimGroup.removeOption.</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.PrimGroup.prims">
<code class="descname">prims</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.Prim<a class="headerlink" href="#hou.PrimGroup.prims" title="Permalink to this definition"></a></dt>
<dd><p>Return the contents of this group.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PrimGroup.remove">
<code class="descname">remove</code><span class="sig-paren">(</span><em>self</em>, <em>prim_or_list_or_prim_group</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.PrimGroup.remove" title="Permalink to this definition"></a></dt>
<dd><p>If given a hou.Prim or a list of hou.Prims, remove the primitive(s)
from the group. If given a hou.PrimGroup, remove all primitives in
the other group from this group (the other group is unaffected). You
would typically call this method from the code of a Python-defined
SOP.</p>
<p>It is not an error to try to remove a primitive from the group that
wasnt already in the group.</p>
<p>Raises hou.GeometryPermissionError if this geometry is not
modifiable.</p>
<p>Raises hou.OperationFailed if the primitive belongs to a different
geometry object than this group.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PrimGroup.removeOption">
<code class="descname">removeOption</code><span class="sig-paren">(</span><em>self</em>, <em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.PrimGroup.removeOption" title="Permalink to this definition"></a></dt>
<dd><p>Remove an entry in the dictionary of options. See
hou.PrimGroup.options for more information.</p>
<p>Raises hou.OperationFailed if there is no entry in the dictionary
with this name.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PrimGroup.setOption">
<code class="descname">setOption</code><span class="sig-paren">(</span><em>self</em>, <em>name</em>, <em>value</em>, <em>type_hint = hou.fieldType::NoSuchField</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.PrimGroup.setOption" title="Permalink to this definition"></a></dt>
<dd><p>Set an entry in the dictionary of options. See hou.PrimGroup.options
for more information.</p>
<dl class="docutils">
<dt>name</dt>
<dd>The name of the option to set.</dd>
<dt>value</dt>
<dd>An integer, float, string, hou.Vector2, hou.Vector3,
hou.Vector4, hou.Quaternion, hou.Matrix3, hou.Matrix4, or
sequence of numbers.</dd>
<dt>type_hint</dt>
<dd>Used to determine the exact hou.fieldType desired when the
specified value type is not enough to unambiguously determine
it.</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="hou.PrimGroup.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.PrimGroup.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.PySwigIterator">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">PySwigIterator</code><a class="headerlink" href="#hou.PySwigIterator" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="method">
<dt id="hou.PySwigIterator.advance">
<code class="descname">advance</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.PySwigIterator.advance" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.PySwigIterator.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.PySwigIterator.copy" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.PySwigIterator.decr">
<code class="descname">decr</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.PySwigIterator.decr" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.PySwigIterator.distance">
<code class="descname">distance</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.PySwigIterator.distance" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.PySwigIterator.equal">
<code class="descname">equal</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.PySwigIterator.equal" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.PySwigIterator.incr">
<code class="descname">incr</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.PySwigIterator.incr" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.PySwigIterator.next">
<code class="descname">next</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.PySwigIterator.next" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.PySwigIterator.previous">
<code class="descname">previous</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.PySwigIterator.previous" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.PySwigIterator.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.PySwigIterator.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

<dl class="method">
<dt id="hou.PySwigIterator.value">
<code class="descname">value</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.PySwigIterator.value" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.PythonPanel">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">PythonPanel</code><a class="headerlink" href="#hou.PythonPanel" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.PathBasedPaneTab" title="hou.PathBasedPaneTab"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.PathBasedPaneTab</span></code></a></p>
<p>Class representing a pane tab that can display an embedded PySide or
PyQt interface.</p>
<p>See also hou.pypanel and hou.PythonPanelInterface.</p>
<dl class="docutils">
<dt>NOTE</dt>
<dd>PySide and PyQt interfaces can only be created from the main Houdini
application thread. You cannot call any method in this class from a
separate thread (i.e. do not call from a Python Shell).</dd>
</dl>
<dl class="method">
<dt id="hou.PythonPanel.activeInterface">
<code class="descname">activeInterface</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.PythonPanelInterface<a class="headerlink" href="#hou.PythonPanel.activeInterface" title="Permalink to this definition"></a></dt>
<dd><p>Returns the interface currently assigned to the Python Panel, or
None if no interface has been assigned.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PythonPanel.activeInterfaceRootWidget">
<code class="descname">activeInterfaceRootWidget</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; Qt.QtWidgets.QWidget subclass<a class="headerlink" href="#hou.PythonPanel.activeInterfaceRootWidget" title="Permalink to this definition"></a></dt>
<dd><p>Returns a reference to the user-defined root widget created by the
active interface in the Python Panel. Returns None if there is no
active interface or widget.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PythonPanel.expandToolbar">
<code class="descname">expandToolbar</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.PythonPanel.expandToolbar" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.PythonPanel.isToolbarExpanded">
<code class="descname">isToolbarExpanded</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.PythonPanel.isToolbarExpanded" title="Permalink to this definition"></a></dt>
<dd><p>Return True if the toolbar is expanded and False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PythonPanel.isToolbarShown">
<code class="descname">isToolbarShown</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.PythonPanel.isToolbarShown" title="Permalink to this definition"></a></dt>
<dd><p>Return True if the toolbar is shown and False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PythonPanel.setActiveInterface">
<code class="descname">setActiveInterface</code><span class="sig-paren">(</span><em>self</em>, <em>interface</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.PythonPanel.setActiveInterface" title="Permalink to this definition"></a></dt>
<dd><p>Show the specified interface in the Python Panel. interface is a
hou.PythonPanelInterface object.</p>
<p>Raises hou.OperationFailed if interface is not an installed Python
Panel interface.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PythonPanel.setLabel">
<code class="descname">setLabel</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.PythonPanel.setLabel" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.PythonPanel.showToolbar">
<code class="descname">showToolbar</code><span class="sig-paren">(</span><em>self</em>, <em>show</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.PythonPanel.showToolbar" title="Permalink to this definition"></a></dt>
<dd><p>Show or hide the toolbar. show must be either True or False.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.PythonPanel.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.PythonPanel.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.PythonPanelInterface">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">PythonPanelInterface</code><a class="headerlink" href="#hou.PythonPanelInterface" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Represents the definition of a Python panel interface.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.pypanel</li>
<li>hou.PythonPanel</li>
</ul>
</div></blockquote>
<dl class="method">
<dt id="hou.PythonPanelInterface.filePath">
<code class="descname">filePath</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.PythonPanelInterface.filePath" title="Permalink to this definition"></a></dt>
<dd><p>Returns the file path for this interface.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PythonPanelInterface.help">
<code class="descname">help</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.PythonPanelInterface.help" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.PythonPanelInterface.helpURL">
<code class="descname">helpURL</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.PythonPanelInterface.helpURL" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.PythonPanelInterface.icon">
<code class="descname">icon</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.PythonPanelInterface.icon" title="Permalink to this definition"></a></dt>
<dd><p>Returns the icon for this interface.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PythonPanelInterface.id">
<code class="descname">id</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.PythonPanelInterface.id" title="Permalink to this definition"></a></dt>
<dd><p>Returns the id for this interface.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PythonPanelInterface.label">
<code class="descname">label</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.PythonPanelInterface.label" title="Permalink to this definition"></a></dt>
<dd><p>Returns the label for this interface.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PythonPanelInterface.name">
<code class="descname">name</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.PythonPanelInterface.name" title="Permalink to this definition"></a></dt>
<dd><p>Returns the name for this interface.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PythonPanelInterface.script">
<code class="descname">script</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.PythonPanelInterface.script" title="Permalink to this definition"></a></dt>
<dd><p>Returns the script for this interface.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PythonPanelInterface.setFilePath">
<code class="descname">setFilePath</code><span class="sig-paren">(</span><em>self</em>, <em>script</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.PythonPanelInterface.setFilePath" title="Permalink to this definition"></a></dt>
<dd><p>Sets the file path for this interface.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PythonPanelInterface.setHelp">
<code class="descname">setHelp</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.PythonPanelInterface.setHelp" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.PythonPanelInterface.setHelpURL">
<code class="descname">setHelpURL</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.PythonPanelInterface.setHelpURL" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.PythonPanelInterface.setIcon">
<code class="descname">setIcon</code><span class="sig-paren">(</span><em>self</em>, <em>icon</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.PythonPanelInterface.setIcon" title="Permalink to this definition"></a></dt>
<dd><p>Sets the icon for this interface.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PythonPanelInterface.setId">
<code class="descname">setId</code><span class="sig-paren">(</span><em>self</em>, <em>id</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.PythonPanelInterface.setId" title="Permalink to this definition"></a></dt>
<dd><p>Sets the id for this interface.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PythonPanelInterface.setLabel">
<code class="descname">setLabel</code><span class="sig-paren">(</span><em>self</em>, <em>label</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.PythonPanelInterface.setLabel" title="Permalink to this definition"></a></dt>
<dd><p>Sets the label for this interface.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PythonPanelInterface.setName">
<code class="descname">setName</code><span class="sig-paren">(</span><em>self</em>, <em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.PythonPanelInterface.setName" title="Permalink to this definition"></a></dt>
<dd><p>Sets the name for this interface.</p>
</dd></dl>

<dl class="method">
<dt id="hou.PythonPanelInterface.setScript">
<code class="descname">setScript</code><span class="sig-paren">(</span><em>self</em>, <em>script</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.PythonPanelInterface.setScript" title="Permalink to this definition"></a></dt>
<dd><p>Sets the script for this interface.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.PythonPanelInterface.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.PythonPanelInterface.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.Quadric">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">Quadric</code><a class="headerlink" href="#hou.Quadric" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.Prim" title="hou.Prim"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.Prim</span></code></a></p>
<p>A Quadric is a kind of geometry primitive (Prim object) that represents
a 3-dimensional surface defined by a quadratic polynomial equation (e.g.
a sphere or tube).</p>
<dl class="method">
<dt id="hou.Quadric.getTransform">
<code class="descname">getTransform</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Quadric.getTransform" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.Quadric.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.Quadric.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

<dl class="method">
<dt id="hou.Quadric.transform">
<code class="descname">transform</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Matrix3<a class="headerlink" href="#hou.Quadric.transform" title="Permalink to this definition"></a></dt>
<dd><p>Return the 3x3 matrix associated with this quadric. This matrix
determines what type of quadric it is.</p>
<p>See Wikipedias Quadric page for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Quadric.vertex">
<code class="descname">vertex</code><span class="sig-paren">(</span><em>self</em>, <em>index</em><span class="sig-paren">)</span> &#x2192; hou.Vertex<a class="headerlink" href="#hou.Quadric.vertex" title="Permalink to this definition"></a></dt>
<dd><p>A shortcut for self.vertices()[index]. You probably dont need to
call this method.</p>
<p>This method supports negative indices to index from the end, just
like self.vertices()[index] would. Also, like Pythons indexing
operator, it will raise IndexError when the index is out of range.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.Quaternion">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">Quaternion</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Quaternion" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A representation of a 3D rotation (or orientation). You can smoothly
interpolate between two rotation values by interpolating between two
quaternions.</p>
<p>Quaternions provide an easy way to nicely interpolate between two
rotation values, and avoid the gimbal lock and direction changes caused
by interpolating Euler angles. They can easily be converted to and from
rotation matrices, Euler angles, and angle-axis rotations.</p>
<p>A quaternion is represented by a vector of 4 floats (x, y, z, and w).
Any rotation in three dimensions is a rotation by some angle about some
axis, and you can think of the (x, y, z) portion of the quaternion as
storing the axis and the w portion as storing a (representation of) the
angle.</p>
<p>See Wikipedias Quaternion page and its Quaternions and space rotation
page for more information.</p>
<dl class="method">
<dt id="hou.Quaternion.almostEqual">
<code class="descname">almostEqual</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Quaternion.almostEqual" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.Quaternion.conjugate">
<code class="descname">conjugate</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Quaternion<a class="headerlink" href="#hou.Quaternion.conjugate" title="Permalink to this definition"></a></dt>
<dd><p>Return a quaternion containing the opposite rotation of that stored
in this quaternion. Intuitively, for unit length quaternions, the
quaternion returned contains a rotation by the same angle about an
axis pointing in the opposite direction.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Quaternion.dot">
<code class="descname">dot</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#hou.Quaternion.dot" title="Permalink to this definition"></a></dt>
<dd><p>Return the dot product of this quaternion with another one.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Quaternion.extractAngleAxis">
<code class="descname">extractAngleAxis</code><span class="sig-paren">(</span><em>self) -&gt; (float</em>, <em>hou.Vector3</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Quaternion.extractAngleAxis" title="Permalink to this definition"></a></dt>
<dd><p>Return an axis and a rotation about that axis corresponding to the
rotation in the quaternion. The return value is a 2-tuple containing
a float and a hou.Vector3. The returned axis vector is normalized.</p>
<p>If this quaternion is the zero quaternion, the angle returned is
zero and the vector is the zero vector. Otherwise, if it is not
normalized, the return values will correspond to the rotation
represented by the normalized quaternion.</p>
<p>See also hou.Quaternion.setToAngleAxis.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Quaternion.extractEulerRotates">
<code class="descname">extractEulerRotates</code><span class="sig-paren">(</span><em>self</em>, <em>rotate_order=&quot;xyz&quot;</em><span class="sig-paren">)</span> &#x2192; hou.Vector3<a class="headerlink" href="#hou.Quaternion.extractEulerRotates" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Return the Euler rotations (the x, y, and z rotation values, in
degrees, about the coordinate axes) corresponding to the rotation in
the quaternion.</p>
<p>This method can also be implemented as follows:</p>
</div></blockquote>
<p>&gt; def extractEulerRotates(self, rotate_order=xyz):
&gt;     return hou.Matrix4(self.extractRotationMatrix3()).explode(rotate_order=rotate_order)[rotate]</p>
<blockquote>
<div>See also hou.Quaternion.setToEulerRotates.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.Quaternion.extractRotationMatrix3">
<code class="descname">extractRotationMatrix3</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Matrix3<a class="headerlink" href="#hou.Quaternion.extractRotationMatrix3" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Return a 3x3 rotation matrix corresponding to the rotation in the
quaternion.</p>
<p>To create a hou.Matrix4 instead of a hou.Matrix3, you can easily
create a Matrix4 from the Matrix3:</p>
</div></blockquote>
<p>&gt; hou.Matrix4(quaternion.extractRotationMatrix3())</p>
<blockquote>
<div><p>If the quaternion is the zero quaternion, this method does not raise
an exception. Instead, it returns the identity matrix.</p>
<p>See also hou.Quaternion.setToRotationMatrix.</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.Quaternion.inverse">
<code class="descname">inverse</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Quaternion<a class="headerlink" href="#hou.Quaternion.inverse" title="Permalink to this definition"></a></dt>
<dd><p>Return a quaternion containing the multiplicative inverse of this
quaternion. For unit quaternions, the inverse is the same as the
conjugate.</p>
<p>See also hou.Quaternion.conjugate.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Quaternion.isAlmostEqual">
<code class="descname">isAlmostEqual</code><span class="sig-paren">(</span><em>self</em>, <em>quaternion</em>, <em>tolerance=0.00001</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.Quaternion.isAlmostEqual" title="Permalink to this definition"></a></dt>
<dd><p>Returns whether this quaternion is equal to another, within a
numerical tolerance.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Quaternion.length">
<code class="descname">length</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#hou.Quaternion.length" title="Permalink to this definition"></a></dt>
<dd><p>Return the length of the quaternion. When quaternions represent
rotations, their length is one.</p>
<p>A quaternions length is compute the same as a Vector4s:
hou.Vector4(self).length()</p>
</dd></dl>

<dl class="method">
<dt id="hou.Quaternion.normalized">
<code class="descname">normalized</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Quaternion<a class="headerlink" href="#hou.Quaternion.normalized" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Return a normalized version of this quaternion (i.e. a version of
this quaternion whose length is one). Quaternions that represent
rotations are always normalized.</p>
<p>Normalizing a quaternion whose length is zero or near zero will
return a new quaternion with the same values.</p>
<p>This method can be implemented as follows (for non-zero length
quaternions):</p>
</div></blockquote>
<p>&gt; def normalized(self):
&gt;     return self * (1.0 / self.length())</p>
</dd></dl>

<dl class="method">
<dt id="hou.Quaternion.rotate">
<code class="descname">rotate</code><span class="sig-paren">(</span><em>self</em>, <em>vec</em><span class="sig-paren">)</span> &#x2192; hou.Vector3<a class="headerlink" href="#hou.Quaternion.rotate" title="Permalink to this definition"></a></dt>
<dd><p>Rotates the given hou.Vector3 by this quaternion and returns the
result.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Quaternion.setTo">
<code class="descname">setTo</code><span class="sig-paren">(</span><em>self</em>, <em>tuple</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Quaternion.setTo" title="Permalink to this definition"></a></dt>
<dd><p>Set the quaternions 4 float values (x, y, z, and w). tuple must be
a sequence of 4 floats.</p>
<p>This method will modify an existing quaternion object. Use
hou.Quaternion.__init__ to construct a new quaternion from these
four values.</p>
<p>See also hou.Quaternion.__setitem__.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Quaternion.setToAngleAxis">
<code class="descname">setToAngleAxis</code><span class="sig-paren">(</span><em>self</em>, <em>angle_in_deg</em>, <em>axis</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Quaternion.setToAngleAxis" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Set this quaternion to contain the rotation about an axis by the
given angle. angle_in_deg is in degrees and axis is a sequence of 3
floats.</p>
<p>This method can also be implemented as follows:</p>
</div></blockquote>
<p>&gt; def setToAngleAxis(self, angle_in_deg, axis):
&gt;     self.setToRotationMatrix(
&gt;         hou.hmath.buildRotateAboutAxis(axis, angle_in_deg))</p>
<blockquote>
<div>See also hou.Quaternion.extractAngleAxis.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.Quaternion.setToEulerRotates">
<code class="descname">setToEulerRotates</code><span class="sig-paren">(</span><em>self</em>, <em>angles_in_deg</em>, <em>rotate_order=&quot;xyz&quot;</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Quaternion.setToEulerRotates" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Set this quaternion to contain the rotation specified by Euler
rotations about the x, y, and z coordinate axes.</p>
<p>This method can also be implemented as follows:</p>
</div></blockquote>
<p>&gt; def setToEulerRotates(self, angles_in_deg, rotate_order=xyz):
&gt;     self.setToRotationMatrix(
&gt;         hou.hmath.buildRotate(angles_in_deg, rotate_order))</p>
<blockquote>
<div>See also hou.Quaternion.extractEulerRotates and
hou.hmath.buildRotate.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.Quaternion.setToRotationMatrix">
<code class="descname">setToRotationMatrix</code><span class="sig-paren">(</span><em>self</em>, <em>matrix3_or_matrix4</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Quaternion.setToRotationMatrix" title="Permalink to this definition"></a></dt>
<dd><p>Set this quaternion to contain the rotation component of the
transformation in a hou.Matrix3 or hou.Matrix4.</p>
<p>See also hou.Quaternion.extractRotationMatrix3.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Quaternion.setToVectors">
<code class="descname">setToVectors</code><span class="sig-paren">(</span><em>self</em>, <em>a</em>, <em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Quaternion.setToVectors" title="Permalink to this definition"></a></dt>
<dd><p>Sets this quaternion to the quaternion which rotates the hou.Vector3
a onto the vector b.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Quaternion.slerp">
<code class="descname">slerp</code><span class="sig-paren">(</span><em>self</em>, <em>other</em>, <em>fraction</em><span class="sig-paren">)</span> &#x2192; hou.Quaternion<a class="headerlink" href="#hou.Quaternion.slerp" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Perform spherical linear interpolation between this quaternion and
another, returning a new quaternion. fraction is a float from 0.0 to
1.0, where 0.0 gives this quaternion and 1.0 gives the other
quaternion. This method is very useful to smoothly interpolate
between two different rotations.</p>
<p>See Wikipedias Slerp page for more information.</p>
<p>The following example will nicely interpolate between two sets of
Euler rotations.</p>
</div></blockquote>
<p>&gt; def interpolateEulerRotations(rotation1, rotation2, fraction, rotate_order=xyz):
&gt;     quaternion1 = hou.Quaternion()
&gt;     quaternion1.setToEulerRotates(rotation1, rotate_order)
&gt;     quaternion2 = hou.Quaternion()
&gt;     quaternion2.setToEulerRotates(rotation2, rotate_order)
&gt; 
&gt;     return quaternion1.slerp(quaternion2, fraction).extractEulerRotates(rotate_order)</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.Quaternion.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.Quaternion.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.RadialItem">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">RadialItem</code><a class="headerlink" href="#hou.RadialItem" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.ui.RadialScriptItem</li>
<li>hou.ui.RadialSubmenu</li>
</ul>
</div></blockquote>
<dl class="method">
<dt id="hou.RadialItem.destroy">
<code class="descname">destroy</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.RadialItem.destroy" title="Permalink to this definition"></a></dt>
<dd><p>Deletes this radial menu item.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.RadialItem.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.RadialItem.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

<dl class="method">
<dt id="hou.RadialItem.type">
<code class="descname">type</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.radialItemType<a class="headerlink" href="#hou.RadialItem.type" title="Permalink to this definition"></a></dt>
<dd><p>Return this radial menu items type.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.RadialMenu">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">RadialMenu</code><a class="headerlink" href="#hou.RadialMenu" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.RadialSubmenu" title="hou.RadialSubmenu"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.RadialSubmenu</span></code></a></p>
<ul>
<li><dl class="first docutils">
<dt>Use hou.ui.radialMenus or hou.ui.radialMenu to get a reference to an</dt>
<dd><p class="first last">existing menu.</p>
</dd>
</dl>
<ul class="simple">
<li>Use hou.ui.createRadialMenu to create a new menu.</li>
</ul>
</li>
</ul>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.ui.radialMenu</li>
<li>hou.ui.radialMenus</li>
<li>hou.ui.createRadialMenu</li>
<li>hou.RadialItem</li>
</ul>
</div></blockquote>
<dl class="method">
<dt id="hou.RadialMenu.categories">
<code class="descname">categories</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.RadialMenu.categories" title="Permalink to this definition"></a></dt>
<dd><p>Return a comma separated list of this radial menus categories.</p>
</dd></dl>

<dl class="method">
<dt id="hou.RadialMenu.name">
<code class="descname">name</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.RadialMenu.name" title="Permalink to this definition"></a></dt>
<dd><p>Return this radial menus name.</p>
</dd></dl>

<dl class="method">
<dt id="hou.RadialMenu.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>self</em>, <em>filename</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.RadialMenu.save" title="Permalink to this definition"></a></dt>
<dd><p>Saves this radial menu to the specified file.</p>
</dd></dl>

<dl class="method">
<dt id="hou.RadialMenu.setCategories">
<code class="descname">setCategories</code><span class="sig-paren">(</span><em>self</em>, <em>categories</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.RadialMenu.setCategories" title="Permalink to this definition"></a></dt>
<dd><p>Sets this radial menus categories (specified as a comma separated
list).</p>
</dd></dl>

<dl class="method">
<dt id="hou.RadialMenu.sourceFile">
<code class="descname">sourceFile</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.RadialMenu.sourceFile" title="Permalink to this definition"></a></dt>
<dd><p>Return the name of the file from which this radial menu was loaded
or saved.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.RadialMenu.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.RadialMenu.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.RadialScriptItem">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">RadialScriptItem</code><a class="headerlink" href="#hou.RadialScriptItem" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.RadialItem" title="hou.RadialItem"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.RadialItem</span></code></a></p>
<dl class="method">
<dt id="hou.RadialScriptItem.check">
<code class="descname">check</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.RadialScriptItem.check" title="Permalink to this definition"></a></dt>
<dd><p>Return a Python expression used to determine the radial menu items
checked state.</p>
</dd></dl>

<dl class="method">
<dt id="hou.RadialScriptItem.icon">
<code class="descname">icon</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.RadialScriptItem.icon" title="Permalink to this definition"></a></dt>
<dd><p>Return this radial menu items icon.</p>
</dd></dl>

<dl class="method">
<dt id="hou.RadialScriptItem.label">
<code class="descname">label</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.RadialScriptItem.label" title="Permalink to this definition"></a></dt>
<dd><p>Return this radial menu items label.</p>
</dd></dl>

<dl class="method">
<dt id="hou.RadialScriptItem.script">
<code class="descname">script</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.RadialScriptItem.script" title="Permalink to this definition"></a></dt>
<dd><p>Return Python code that will be run when the radial menu item is
activated.</p>
</dd></dl>

<dl class="method">
<dt id="hou.RadialScriptItem.setCheck">
<code class="descname">setCheck</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.RadialScriptItem.setCheck" title="Permalink to this definition"></a></dt>
<dd><p>Sets the Python expression used to determine the radial menu items
checked state.</p>
</dd></dl>

<dl class="method">
<dt id="hou.RadialScriptItem.setIcon">
<code class="descname">setIcon</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.RadialScriptItem.setIcon" title="Permalink to this definition"></a></dt>
<dd><p>Sets this radial menu items icon.</p>
</dd></dl>

<dl class="method">
<dt id="hou.RadialScriptItem.setLabel">
<code class="descname">setLabel</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.RadialScriptItem.setLabel" title="Permalink to this definition"></a></dt>
<dd><p>Sets this radial menu items label.</p>
</dd></dl>

<dl class="method">
<dt id="hou.RadialScriptItem.setScript">
<code class="descname">setScript</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.RadialScriptItem.setScript" title="Permalink to this definition"></a></dt>
<dd><p>Sets the Python code that will be run when the radial menu item is
activated.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.RadialScriptItem.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.RadialScriptItem.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.RadialSubmenu">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">RadialSubmenu</code><a class="headerlink" href="#hou.RadialSubmenu" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.RadialItem" title="hou.RadialItem"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.RadialItem</span></code></a></p>
<dl class="method">
<dt id="hou.RadialSubmenu.createScriptItem">
<code class="descname">createScriptItem</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.RadialSubmenu.createScriptItem" title="Permalink to this definition"></a></dt>
<dd><p>createScriptItem(self, [Hom:hou.radialItemLocation], label=None,
icon=None, check=None, script=None) -&gt; hou.RadialScriptItem</p>
<blockquote>
<div>Creates a script item at the specified location (replacing any
existing radial menu item) and initializing the script items label,
icon, expression specifying the checked state, and script executed
when the item is activated. The new script item is returned.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.RadialSubmenu.createSubmenu">
<code class="descname">createSubmenu</code><span class="sig-paren">(</span><em>self</em>, <span class="optional">[</span><em>Hom:hou.radialItemLocation</em>, <span class="optional">]</span><em>label=None</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.RadialSubmenu.createSubmenu" title="Permalink to this definition"></a></dt>
<dd><p>hou.RadialSubmenu</p>
<p>Creates a submenu at the specified location (replacing any existing
radial menu item) and initializing the submenus label. The new
submenu is returned.</p>
</dd></dl>

<dl class="method">
<dt id="hou.RadialSubmenu.item">
<code class="descname">item</code><span class="sig-paren">(</span><em>self</em><span class="optional">[</span>, <em>Hom:hou.radialItemLocation</em><span class="optional">]</span><span class="sig-paren">)</span> &#x2192; hou.RadialItem<a class="headerlink" href="#hou.RadialSubmenu.item" title="Permalink to this definition"></a></dt>
<dd><p>Return the radial menu item at the specified location. Return None
if no radial menu item exists at the specified location.</p>
</dd></dl>

<dl class="method">
<dt id="hou.RadialSubmenu.items">
<code class="descname">items</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; dict of hou.radialItemLocation to hou.RadialItem<a class="headerlink" href="#hou.RadialSubmenu.items" title="Permalink to this definition"></a></dt>
<dd><p>Return a dict mapping radial item locations to radial menu items.</p>
</dd></dl>

<dl class="method">
<dt id="hou.RadialSubmenu.label">
<code class="descname">label</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.RadialSubmenu.label" title="Permalink to this definition"></a></dt>
<dd><p>Return this submenus label.</p>
</dd></dl>

<dl class="method">
<dt id="hou.RadialSubmenu.setLabel">
<code class="descname">setLabel</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.RadialSubmenu.setLabel" title="Permalink to this definition"></a></dt>
<dd><p>Sets this submenus label.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.RadialSubmenu.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.RadialSubmenu.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.Ramp">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">Ramp</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Ramp" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A Ramp represents a function that yields either floating point values or
colors. You can evaluate this function between 0.0 and 1.0, and the
functions shape is determined by a sequence of values at key positions
between 0.0 and 1.0.</p>
<p>If you evaluate a ramp parameter on a node, Houdini will return a Ramp
object.</p>
<p>You can check the curve basis of a ramp you get from a parameter by
calling the hou.Ramp.basis method,which returns a hou.rampBasis value.</p>
<p>In the Hermite basis, the curve passes through the _odd_ control points,
and the _even_ control points control the tangent at the previous point.
See the Wikipedia article on Hermite spline curves for more information.</p>
<p>To get a smooth curve, you should evenly space the control points.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>spline()</li>
</ul>
</div></blockquote>
<dl class="method">
<dt id="hou.Ramp.basis">
<code class="descname">basis</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.rampBasis enum values<a class="headerlink" href="#hou.Ramp.basis" title="Permalink to this definition"></a></dt>
<dd><p>Return a tuple of hou.rampBasis enumeration values that determine
how Houdini interpolates between the keys in the ramp. See
hou.Ramp.__init__ for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Ramp.colorType">
<code class="descname">colorType</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; colorType<a class="headerlink" href="#hou.Ramp.colorType" title="Permalink to this definition"></a></dt>
<dd><p>If this is a color ramp, return the color space that is used during
interpolation. The default is hou.colorType.RGB.</p>
<p>Raises hou.OperationFailed if this ramp is not a color ramp.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Ramp.isColor">
<code class="descname">isColor</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.Ramp.isColor" title="Permalink to this definition"></a></dt>
<dd><p>Return True if this is a color ramp, and False if it is a single
float ramp.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Ramp.keys">
<code class="descname">keys</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of float<a class="headerlink" href="#hou.Ramp.keys" title="Permalink to this definition"></a></dt>
<dd><p>Return a tuple of floats between 0.0 and 1.0 containing the ramp key
positions. See hou.Ramp.__init__ for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Ramp.lookup">
<code class="descname">lookup</code><span class="sig-paren">(</span><em>self</em>, <em>interpolant</em><span class="sig-paren">)</span> &#x2192; float or tuple<a class="headerlink" href="#hou.Ramp.lookup" title="Permalink to this definition"></a></dt>
<dd><p>Return the value of the ramp at a specified position from 0.0 to
1.0, inclusive.</p>
<p>Returns a float (for floating-point value ramps) or a tuple of 3
floats (for color ramps).</p>
</dd></dl>

<dl class="method">
<dt id="hou.Ramp.setColorType">
<code class="descname">setColorType</code><span class="sig-paren">(</span><em>self</em>, <em>hou.colorType</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Ramp.setColorType" title="Permalink to this definition"></a></dt>
<dd><p>If this is a color ramp, set the color space that is used during
interpolation. The default is hou.colorType.RGB.</p>
<p>To obtain a more perceptually uniform interpolation, use
hou.colorType.LAB. To obtain a ramp that matches the rainbow, use
hou.colorType.HSV.</p>
<p>Raises hou.OperationFailed if this ramp is not a color ramp.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.Ramp.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.Ramp.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

<dl class="method">
<dt id="hou.Ramp.values">
<code class="descname">values</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of float or tuple of tuple of float<a class="headerlink" href="#hou.Ramp.values" title="Permalink to this definition"></a></dt>
<dd><p>Return a tuple of floats (for a float ramp) or a tuple of tuples of
3 floats (for a color ramp) corresponding to the values in the ramp
stored at each key. See hou.Ramp.__init__ for more information.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.RampParmTemplate">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">RampParmTemplate</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.RampParmTemplate" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.ParmTemplate" title="hou.ParmTemplate"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.ParmTemplate</span></code></a></p>
<p>Parameter template for a ramp parameter.</p>
<dl class="method">
<dt id="hou.RampParmTemplate.colorType">
<code class="descname">colorType</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.colorType enum value<a class="headerlink" href="#hou.RampParmTemplate.colorType" title="Permalink to this definition"></a></dt>
<dd><p>The color space in which to interpolate color ramp keys.</p>
<p>See hou.colorType for more information on color spaces.</p>
</dd></dl>

<dl class="method">
<dt id="hou.RampParmTemplate.defaultBasis">
<code class="descname">defaultBasis</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.rampBasis enum value<a class="headerlink" href="#hou.RampParmTemplate.defaultBasis" title="Permalink to this definition"></a></dt>
<dd><p>The basis function used to control how values are interpolated
between ramp keys.</p>
<p>See hou.rampBasis for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.RampParmTemplate.defaultExpression">
<code class="descname">defaultExpression</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; string<a class="headerlink" href="#hou.RampParmTemplate.defaultExpression" title="Permalink to this definition"></a></dt>
<dd><p>Return the expression, which when evaluated, returns the number of
ramp keys to be used in new ramp parameter instances.</p>
<p>The default expression takes precendence over the default value. If
the default expression is not set (i.e. an empty string), then the
default value is used instead.</p>
<p>Note that the default expression language is needed to interpret the
meaning of the default expression.</p>
</dd></dl>

<dl class="method">
<dt id="hou.RampParmTemplate.defaultExpressionLanguage">
<code class="descname">defaultExpressionLanguage</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.scriptLanguage<a class="headerlink" href="#hou.RampParmTemplate.defaultExpressionLanguage" title="Permalink to this definition"></a></dt>
<dd><p>Return the default expression language.</p>
<p>The default expression language only applies if the default
expression is set. If the default expression is not set, then the
expression language is set to hou.scriptLanguage.Hscript.</p>
</dd></dl>

<dl class="method">
<dt id="hou.RampParmTemplate.defaultValue">
<code class="descname">defaultValue</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.RampParmTemplate.defaultValue" title="Permalink to this definition"></a></dt>
<dd><p>Return this is the default number of ramp keys in new ramp parameter
instances.</p>
</dd></dl>

<dl class="method">
<dt id="hou.RampParmTemplate.parmType">
<code class="descname">parmType</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.RampParmTemplate.parmType" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.RampParmTemplate.setColorType">
<code class="descname">setColorType</code><span class="sig-paren">(</span><em>self</em>, <em>color_type</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.RampParmTemplate.setColorType" title="Permalink to this definition"></a></dt>
<dd><p>Set the color space in which to interpolate color ramp keys to a
hou.colorType enum value.</p>
</dd></dl>

<dl class="method">
<dt id="hou.RampParmTemplate.setDefaultBasis">
<code class="descname">setDefaultBasis</code><span class="sig-paren">(</span><em>self</em>, <em>ramp_basis</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.RampParmTemplate.setDefaultBasis" title="Permalink to this definition"></a></dt>
<dd><p>Set the basis function used to control how values are interpolated
between ramp keys. ramp_basis is a hou.rampBasis enum value.</p>
</dd></dl>

<dl class="method">
<dt id="hou.RampParmTemplate.setDefaultExpression">
<code class="descname">setDefaultExpression</code><span class="sig-paren">(</span><em>self</em>, <em>default_expression</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.RampParmTemplate.setDefaultExpression" title="Permalink to this definition"></a></dt>
<dd><p>Set the default expression, which when evaluated, returns the number
of ramp keys to be used in new ramp parameter instances.</p>
<p>If default_expression is the empty string, then the default
expression is unset.</p>
</dd></dl>

<dl class="method">
<dt id="hou.RampParmTemplate.setDefaultExpressionLanguage">
<code class="descname">setDefaultExpressionLanguage</code><span class="sig-paren">(</span><em>self</em>, <em>default_expression_language</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.RampParmTemplate.setDefaultExpressionLanguage" title="Permalink to this definition"></a></dt>
<dd><p>Set the default expression language.</p>
<p>See the defaultExpressionLanguage method for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.RampParmTemplate.setDefaultValue">
<code class="descname">setDefaultValue</code><span class="sig-paren">(</span><em>self</em>, <em>default_value</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.RampParmTemplate.setDefaultValue" title="Permalink to this definition"></a></dt>
<dd><p>Set the default number of ramp keys to be used in new ramp parameter
instances.</p>
</dd></dl>

<dl class="method">
<dt id="hou.RampParmTemplate.setParmType">
<code class="descname">setParmType</code><span class="sig-paren">(</span><em>self</em>, <em>ramp_parm_type</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.RampParmTemplate.setParmType" title="Permalink to this definition"></a></dt>
<dd><p>Set the type of this ramp to a hou.rampParmType enum value.</p>
</dd></dl>

<dl class="method">
<dt id="hou.RampParmTemplate.setShowsControls">
<code class="descname">setShowsControls</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.RampParmTemplate.setShowsControls" title="Permalink to this definition"></a></dt>
<dd><p>Set whether new instances of this ramp parameter have the controls
expanded by default.</p>
</dd></dl>

<dl class="method">
<dt id="hou.RampParmTemplate.showsControls">
<code class="descname">showsControls</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.RampParmTemplate.showsControls" title="Permalink to this definition"></a></dt>
<dd><p>Return whether new instances of this ramp parameter have the
controls expanded by default. The user may later expand or collapse
the ramp controls on the parameter.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.RampParmTemplate.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.RampParmTemplate.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.RedrawBlock">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">RedrawBlock</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.RedrawBlock" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Use this class to collect mulitple redraws for any Python code block and
only redraw once.</p>
<dl class="attribute">
<dt id="hou.RedrawBlock.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.RedrawBlock.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.ReferencePlane">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">ReferencePlane</code><a class="headerlink" href="#hou.ReferencePlane" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>The reference grid (a.k.a. reference plane) in the scene viewer pane
tab.</p>
<dl class="method">
<dt id="hou.ReferencePlane.cellSize">
<code class="descname">cellSize</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of float<a class="headerlink" href="#hou.ReferencePlane.cellSize" title="Permalink to this definition"></a></dt>
<dd><p>Return the x and y sizes (width and height) of one cell in the grid
of cells. The return value is a tuple of two floats.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ReferencePlane.isVisible">
<code class="descname">isVisible</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.ReferencePlane.isVisible" title="Permalink to this definition"></a></dt>
<dd><p>Return whether the grid is visible in the viewer.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ReferencePlane.numberOfCellsPerRulerLine">
<code class="descname">numberOfCellsPerRulerLine</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of int<a class="headerlink" href="#hou.ReferencePlane.numberOfCellsPerRulerLine" title="Permalink to this definition"></a></dt>
<dd><p>Return the number of cells in the x and y directions between ruler
lines. Ruler lines are darker than the normal lines drawn between
grid cells.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ReferencePlane.sceneViewer">
<code class="descname">sceneViewer</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.SceneViewer<a class="headerlink" href="#hou.ReferencePlane.sceneViewer" title="Permalink to this definition"></a></dt>
<dd><p>Return the scene viewer containing this plane.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ReferencePlane.setCellSize">
<code class="descname">setCellSize</code><span class="sig-paren">(</span><em>self</em>, <em>size</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ReferencePlane.setCellSize" title="Permalink to this definition"></a></dt>
<dd><p>Change the x and y sizes (width and height) of each cell in the grid
of cells. size is a sequence of two floats.</p>
<p>Changing the size of each cell will change the total size of the
grid.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ReferencePlane.setIsVisible">
<code class="descname">setIsVisible</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ReferencePlane.setIsVisible" title="Permalink to this definition"></a></dt>
<dd><p>Make this grid visible or invisible in the viewer.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ReferencePlane.setNumberOfCellsPerRulerLine">
<code class="descname">setNumberOfCellsPerRulerLine</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.ReferencePlane.setNumberOfCellsPerRulerLine" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.ReferencePlane.setTransform">
<code class="descname">setTransform</code><span class="sig-paren">(</span><em>self</em>, <em>matrix</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ReferencePlane.setTransform" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Set the transformation matrix for this plane to a hou.Matrix4.</p>
<p>This matrix is used to translate and rotate the plane. See the
transform method for more information.</p>
<p>Note that scale information inside the transformation matrix is
ignored.</p>
<p>The following function will change the position of the origin of the
plane:</p>
</div></blockquote>
<p>&gt; def set_origin(reference_plane, new_origin):
&gt;     translation = hou.hmath.buildTranslate(hou.Vector3(new_origin) - origin(reference_plane))
&gt;     reference_plane.setTransform(reference_plane.transform() * translation)
&gt; 
&gt; def origin(reference_plane):
&gt;     return hou.Vector3(0, 0, 0) * reference_plane.transform()</p>
<blockquote>
<div>The following function will change the normal of the plane:</div></blockquote>
<p>&gt; def set_normal(reference_plane, normal_vector):
&gt;     existing_rotation = hou.Matrix4(reference_plane.transform().extractRotationMatrix3())
&gt;     rotation = existing_rotation * normal(reference_plane).matrixToRotateTo(normal_vector)
&gt;     translation = hou.hmath.buildTranslate(origin(reference_plane))
&gt;     reference_plane.setTransform(rotation * translation)
&gt; 
&gt; def normal(reference_plane):
&gt;     return hou.Vector3(0, 0, 1) * reference_plane.transform().inverted().transposed()
&gt; 
&gt; def origin(reference_plane):
&gt;     return hou.Vector3(0, 0, 0) * reference_plane.transform()</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.ReferencePlane.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.ReferencePlane.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

<dl class="method">
<dt id="hou.ReferencePlane.transform">
<code class="descname">transform</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Matrix4<a class="headerlink" href="#hou.ReferencePlane.transform" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Return the transformation matrix for this plane.</p>
<p>When the transformation matrix is the identity matrix, the planes
bottom-left corner is at the origin and it sits in the XY plane. In
this orientation, increasing the number of cells in x or the size of
a cell in x grows the plane outward from the origin along the
x-axis. Similarly, increasing the number of cells or size of a cell
in y grows the plane along the y-axis.</p>
<p>Note that the transformation matrix does not contain any scale
information. The reference plane extends to infinity.</p>
<p>The following function will return the normal of the plane:</p>
</div></blockquote>
<p>&gt; def normal(reference_plane):
&gt;     return hou.Vector3(0, 0, 1) * reference_plane.transform().inverted().transposed()</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.RopNode">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">RopNode</code><a class="headerlink" href="#hou.RopNode" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.Node" title="hou.Node"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.Node</span></code></a></p>
<p>Represents a render output node.</p>
<p>REPLACES</p>
<blockquote>
<div><ul class="simple">
<li>opset</li>
<li>render</li>
<li>opflag()</li>
<li>opget</li>
</ul>
</div></blockquote>
<dl class="method">
<dt id="hou.RopNode.bypass">
<code class="descname">bypass</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.RopNode.bypass" title="Permalink to this definition"></a></dt>
<dd><p>Turns the nodes bypass flag on or off, making this node have no
effect.</p>
</dd></dl>

<dl class="method">
<dt id="hou.RopNode.inputDependencies">
<code class="descname">inputDependencies</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; (tuple of hou.RopNode, tuple of tuples of<a class="headerlink" href="#hou.RopNode.inputDependencies" title="Permalink to this definition"></a></dt>
<dd><p>float)</p>
<blockquote>
<div><p>Returns the input dependencies of the ROP node, consisting of ROPs,
and the frames that need to be be rendered prior to rendering the
ROP.</p>
<p>This method returns a tuple of two elements:</p>
</div></blockquote>
<ul class="simple">
<li>The first element is a sequence of the hou.RopNode objects
representing the input dependencies.</li>
<li>The second element is a sequence, where each element corresponds to
the RopNode object at the same position in the first sequence, and
is a sequence of floats representing the frames that must be
rendered for the corresponding RopNode.</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="hou.RopNode.isBypassed">
<code class="descname">isBypassed</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.RopNode.isBypassed" title="Permalink to this definition"></a></dt>
<dd><p>Returns whether this nodes bypass flag is on.</p>
</dd></dl>

<dl class="method">
<dt id="hou.RopNode.isLocked">
<code class="descname">isLocked</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.RopNode.isLocked" title="Permalink to this definition"></a></dt>
<dd><p>Returns whether this nodes lock flag is on.</p>
</dd></dl>

<dl class="method">
<dt id="hou.RopNode.render">
<code class="descname">render</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.RopNode.render" title="Permalink to this definition"></a></dt>
<dd><p>render(self, frame_range=(), res=(), output_file=None,
output_format=None, to_flipbook=False, quality=2, ignore_inputs=False,
method=RopByRop, ignore_bypass_flags=False, ignore_lock_flags=False,
verbose=False, output_progress=False)</p>
<blockquote>
<div><p>Renders this node and optionally any of its inputs. Inputs are
recursively processed (unless ignore_inputs is True), so that all
descendents are rendered in the proper order before this node is
rendered.</p>
<dl class="docutils">
<dt>frame_range</dt>
<dd>Sequence of 2 or 3 values, overrides the frame range and frame
increment to render. The first two values specify the start and
end frames, and the third value (if given) specifies the frame
increment. If no frame increment is given and the ROP node
doesnt specify a frame increment, then a value of 1 will be
used. If no frame range is given, and the ROP node doesnt
specify a frame range, then the current frame will be rendered.</dd>
<dt>res</dt>
<dd>Sequence of two scaling factors that will be used to scale the
resolution of the image, along the x- and y-axes. The scaling
factors will be applied to the node and all dependencies that
are also rendered.</dd>
<dt>output_file</dt>
<dd>Overrides the location to which the image is written.</dd>
<dt>output_format</dt>
<dd>Overrides the format of the image.</dd>
<dt>to_flipbook</dt>
<dd>If True, renders this node to a flipbook.</dd>
<dt>quality</dt>
<dd>Overrides the render quality.</dd>
<dt>ignore_inputs</dt>
<dd>If True, renders only this node (does not render any of its
dependencies).</dd>
<dt>method</dt>
<dd><p class="first">Either hou.renderMethod.RopByRop or
hou.renderMethod.FrameByFrame. The default is ROP by ROP: each
ROP will render its entire sequence before proceeding to the
next ROP. If you specify FrameByFrame, all ROPs will render the
first frame, then the second, etc.</p>
<p class="last">This parameter is only relevant when rendering ROPs in a
dependency network.</p>
</dd>
<dt>ignore_bypass_flags</dt>
<dd>If True, renders this node even if its bypass flag is on.</dd>
<dt>ignore_lock_flags</dt>
<dd>If True, ignores any lock flags on this node and its
dependencies.</dd>
<dt>verbose</dt>
<dd>If True, then the method will print messages during the render.
For example, a message is printed when each frame starts
rendering.</dd>
<dt>output_progress</dt>
<dd>If True, then the method will print Alfred-style progress
messages. This argument does not apply if the verbose argument
is set to False.</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.RopNode.setLocked">
<code class="descname">setLocked</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.RopNode.setLocked" title="Permalink to this definition"></a></dt>
<dd><p>Sets this nodes lock flag on or off. The lock flag caches the
nodes data and the data from its inputs and prevents them from
being recalculated during cooking.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.RopNode.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.RopNode.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.SceneGraphTree">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">SceneGraphTree</code><a class="headerlink" href="#hou.SceneGraphTree" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.PathBasedPaneTab" title="hou.PathBasedPaneTab"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.PathBasedPaneTab</span></code></a></p>
<dl class="attribute">
<dt id="hou.SceneGraphTree.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.SceneGraphTree.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.SceneViewer">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">SceneViewer</code><a class="headerlink" href="#hou.SceneViewer" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.PathBasedPaneTab" title="hou.PathBasedPaneTab"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.PathBasedPaneTab</span></code></a></p>
<p>REPLACES</p>
<blockquote>
<div><ul class="simple">
<li>vieweroption</li>
<li>viewlayout</li>
<li>viewls</li>
<li>viewsnapshot</li>
<li>viewsnapshotoption</li>
</ul>
</div></blockquote>
<dl class="method">
<dt id="hou.SceneViewer.beginStateUndo">
<code class="descname">beginStateUndo</code><span class="sig-paren">(</span><em>self</em>, <em>label</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SceneViewer.beginStateUndo" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Opens an undo block to perform undoable operations with the current
viewer state. All operations performed after the opening will appear
as one single operation on the undo stack. Use
hou.SceneViewer.endStateUndo to close an open block.</p>
<p>beginStateUndo and endStateUndo can be used for managing an undo
block that begins in one function but ends in another one. Only one
undo block is supported for a sequence of undoable operations.
Exceptions will be raised if a call to a second beginStateUndo is
detected before the undo block is closed by endStateUndo.</p>
<p>Python state example of a valid undo block:</p>
</div></blockquote>
<p>&gt; def onMouseEvent(self, kwargs):
&gt;     ui_event = kwargs[ui_event]
&gt;     node = kwargs[node]
&gt;     if ui_event.reason() == hou.uiEventReason.Start:
&gt;         # left mouse button pressed
&gt;         self.scale = node.parent().parm(scale).evalAsFloat()
&gt;         self.scene_viewer.beginStateUndo(scale)
&gt; 
&gt;     if ui_event.reason() == hou.uiEventReason.Active:
&gt;         # left mouse button down while the mouse is moving
&gt;         self.scale <a href="#id23"><span class="problematic" id="id24">*</span></a>= 1.01
&gt;         node.parent().parm(scale).set(self.scale)
&gt; 
&gt;     if ui_event.reason() == hou.uiEventReason.Changed:
&gt;         # left mouse button released
&gt;         self.scene_viewer.endStateUndo()</p>
<blockquote>
<div>Example of a non-valid undo block that raises an exception:</div></blockquote>
<p>&gt; def onMouseEvent(self, kwargs):
&gt;     ui_event = kwargs[ui_event]
&gt;     node = kwargs[node]
&gt;     if ui_event.reason() == hou.uiEventReason.Start:
&gt;         # left mouse button pressed
&gt;         self.tx = node.parent().parm(tx).evalAsFloat()
&gt;         self.scale = node.parent().parm(scale).evalAsFloat()
&gt;         self.scene_viewer.beginStateUndo(scale)
&gt; 
&gt;     if ui_event.reason() == hou.uiEventReason.Active:
&gt;         # left mouse button down while the mouse is moving
&gt;         self.scale <a href="#id25"><span class="problematic" id="id26">*</span></a>= 1.01
&gt;         node.parent().parm(scale).set(self.scale)
&gt; 
&gt;         self.scene_viewer.beginStateUndo(move x)
&gt;         self.tx += 0.2
&gt;         node.parent().parm(tx).set(self.tx)
&gt;         self.scene_viewer.endStateUndo()
&gt; 
&gt;     if ui_event.reason() == hou.uiEventReason.Changed:
&gt;         # left mouse button released
&gt;         self.scene_viewer.endStateUndo()</p>
<blockquote>
<div><dl class="docutils">
<dt>label</dt>
<dd>The label of the undo block used for displaying the undo
operation in the Edit menu. An exception is raised if the label
is empty.</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.clearPromptMessage">
<code class="descname">clearPromptMessage</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SceneViewer.clearPromptMessage" title="Permalink to this definition"></a></dt>
<dd><p>Clear the prompt message previously set with
hou.SceneViewer.setPromptMessage.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.constructionPlane">
<code class="descname">constructionPlane</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.ConstructionPlane<a class="headerlink" href="#hou.SceneViewer.constructionPlane" title="Permalink to this definition"></a></dt>
<dd><p>Return the construction plane (or grid) in the perspective viewport
of this viewer.</p>
<p>See hou.ConstructionPlane for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.curViewport">
<code class="descname">curViewport</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.GeometryViewport<a class="headerlink" href="#hou.SceneViewer.curViewport" title="Permalink to this definition"></a></dt>
<dd><p>Returns this viewers current viewport. The current viewport is the
one containing the mouse cursor. If the cursor is not in a viewport,
then the selected, or active, viewport is returned.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.currentGeometrySelection">
<code class="descname">currentGeometrySelection</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.GeometrySelection<a class="headerlink" href="#hou.SceneViewer.currentGeometrySelection" title="Permalink to this definition"></a></dt>
<dd><p>Returns the current geometry selection if the viewer is in a
geometry select mode and otherwise returns None.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.currentHydraRenderer">
<code class="descname">currentHydraRenderer</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.SceneViewer.currentHydraRenderer" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.currentSceneGraphSelection">
<code class="descname">currentSceneGraphSelection</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; tuple of string<a class="headerlink" href="#hou.SceneViewer.currentSceneGraphSelection" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.currentState">
<code class="descname">currentState</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; string<a class="headerlink" href="#hou.SceneViewer.currentState" title="Permalink to this definition"></a></dt>
<dd><p>Returns the name of the viewers current tool state.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.defaultPickModifier">
<code class="descname">defaultPickModifier</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SceneViewer.defaultPickModifier" title="Permalink to this definition"></a></dt>
<dd><p>Returns the default pick modifier to which Houdini will revert after
a select state terminates.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.denoise">
<code class="descname">denoise</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.SceneViewer.denoise" title="Permalink to this definition"></a></dt>
<dd><p>Denoising setting for non-GL renders (on/off).</p>
</dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.displayRadialMenu">
<code class="descname">displayRadialMenu</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.SceneViewer.displayRadialMenu" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.endStateUndo">
<code class="descname">endStateUndo</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SceneViewer.endStateUndo" title="Permalink to this definition"></a></dt>
<dd><p>Closes an undo block previously opened with
hou.SceneViewer.beginStateUndo.</p>
<p>endStateUndo will raise an exception if called before
beginStateUndo.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.enterCurrentNodeState">
<code class="descname">enterCurrentNodeState</code><span class="sig-paren">(</span><em>self</em>, <em>wait_for_exit=False</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SceneViewer.enterCurrentNodeState" title="Permalink to this definition"></a></dt>
<dd><p>Enters the viewer into the node-specific tool state of the last
selected node. If wait_for_exit is True, then the function will not
return until the viewer exits the tool.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.enterRotateToolState">
<code class="descname">enterRotateToolState</code><span class="sig-paren">(</span><em>self</em>, <em>wait_for_exit=False</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SceneViewer.enterRotateToolState" title="Permalink to this definition"></a></dt>
<dd><p>Enters the viewer into rotate tool state. This is available only for
the node contexts that support the move tools. If wait_for_exit is
True, then the function will not return until the viewer exits the
tool.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.enterScaleToolState">
<code class="descname">enterScaleToolState</code><span class="sig-paren">(</span><em>self</em>, <em>wait_for_exit=False</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SceneViewer.enterScaleToolState" title="Permalink to this definition"></a></dt>
<dd><p>Enters the viewer into scale tool state. This is available only for
the node contexts that support the move tools. If wait_for_exit is
True, then the function will not return until the viewer exits the
tool.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.enterTranslateToolState">
<code class="descname">enterTranslateToolState</code><span class="sig-paren">(</span><em>self</em>, <em>wait_for_exit=False</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SceneViewer.enterTranslateToolState" title="Permalink to this definition"></a></dt>
<dd><p>Enters the viewer into translate tool state. This is available only
for the node contexts that support the move tools. If wait_for_exit
is True, then the function will not return until the viewer exits
the tool.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.enterViewState">
<code class="descname">enterViewState</code><span class="sig-paren">(</span><em>self</em>, <em>wait_for_exit=False</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SceneViewer.enterViewState" title="Permalink to this definition"></a></dt>
<dd><p>Enters the viewer into view tool state. If wait_for_exit is True,
then the function will not return until the viewer exits the tool.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.findViewport">
<code class="descname">findViewport</code><span class="sig-paren">(</span><em>self</em>, <em>name</em><span class="sig-paren">)</span> &#x2192; hou.GeometryViewport<a class="headerlink" href="#hou.SceneViewer.findViewport" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.flipbook">
<code class="descname">flipbook</code><span class="sig-paren">(</span><em>self</em>, <em>viewport=None</em>, <em>settings=None</em>, <em>open_dialog=False</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SceneViewer.flipbook" title="Permalink to this definition"></a></dt>
<dd><p>Capture a flipbook. A flipbook creates a quick preview animation by
taking consecutive screenshots of a viewport at each frame.</p>
<dl class="docutils">
<dt>viewport</dt>
<dd>A</dd>
</dl>
<p>Launch a flipbook for viewport if specified or the current viewport
if viewport is not. Optionally a hou.FlipbookSettings object can be
passed to settings which will override the current settings. This
override will only affect the current flipbook and not change the
dialog settings. If open_dialog is True, the flipbook dialog is
presented to the user, otherwise a flipbook is launched immediately.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.flipbookSettings">
<code class="descname">flipbookSettings</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.FlipbookSettings<a class="headerlink" href="#hou.SceneViewer.flipbookSettings" title="Permalink to this definition"></a></dt>
<dd><p>Access to the flipbook dialog settings, which can be queried, set,
or copied.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.groupListMask">
<code class="descname">groupListMask</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SceneViewer.groupListMask" title="Permalink to this definition"></a></dt>
<dd><p>Returns true if the group list gadget has been turned on for this
viewer.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.groupListSize">
<code class="descname">groupListSize</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SceneViewer.groupListSize" title="Permalink to this definition"></a></dt>
<dd><p>Returns the width and height in inches of the group list gadget.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.groupListType">
<code class="descname">groupListType</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SceneViewer.groupListType" title="Permalink to this definition"></a></dt>
<dd><p>Returns the type of component listed in the group list gadget.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.hydraRenderers">
<code class="descname">hydraRenderers</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of str<a class="headerlink" href="#hou.SceneViewer.hydraRenderers" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.isCreateInContext">
<code class="descname">isCreateInContext</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.SceneViewer.isCreateInContext" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.isDepthSnapping">
<code class="descname">isDepthSnapping</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SceneViewer.isDepthSnapping" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.isGroupListColoringGeometry">
<code class="descname">isGroupListColoringGeometry</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SceneViewer.isGroupListColoringGeometry" title="Permalink to this definition"></a></dt>
<dd><p>Returns true if the group list gadget is configured to color
geometry in the viewer based on group membership or attribute value.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.isGroupListCondensingPathHierarchies">
<code class="descname">isGroupListCondensingPathHierarchies</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SceneViewer.isGroupListCondensingPathHierarchies" title="Permalink to this definition"></a></dt>
<dd><p>Returns true if the group list will condense the hierarchy of groups
defined by a string attribute representing a path.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.isGroupListShowingEmptyGroups">
<code class="descname">isGroupListShowingEmptyGroups</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SceneViewer.isGroupListShowingEmptyGroups" title="Permalink to this definition"></a></dt>
<dd><p>Returns true if the group list gadget is including empty groups in
its list.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.isGroupListShowingOnlyPreSelectedGroups">
<code class="descname">isGroupListShowingOnlyPreSelectedGroups</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SceneViewer.isGroupListShowingOnlyPreSelectedGroups" title="Permalink to this definition"></a></dt>
<dd><p>Returns true if the group list is showing only groups that contain
one or more selected or pre-selected components.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.isGroupListVisible">
<code class="descname">isGroupListVisible</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SceneViewer.isGroupListVisible" title="Permalink to this definition"></a></dt>
<dd><p>Returns true if the group list gadget has been turned on for this
viewer. This function only refers to the option to show the group
list when not selecting groups in the viewer. In that case the group
list will be visible, but this function may still return False.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.isGroupPicking">
<code class="descname">isGroupPicking</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SceneViewer.isGroupPicking" title="Permalink to this definition"></a></dt>
<dd><p>Returns true if group, attribute, or connectivity information will
be used to automatically expand selections made in this viewer. This
option corresponds to the matching check box in the component
selection buttons context menu.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.isOrientingOnSnap">
<code class="descname">isOrientingOnSnap</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SceneViewer.isOrientingOnSnap" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.isPickingContainedGeometry">
<code class="descname">isPickingContainedGeometry</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SceneViewer.isPickingContainedGeometry" title="Permalink to this definition"></a></dt>
<dd><p>Returns true if the viewer is configured to only pick fully
contained components when performing an area-based selection. This
option corresponds to the matching check box in the component
selection buttons context menu.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.isPickingCurrentNode">
<code class="descname">isPickingCurrentNode</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SceneViewer.isPickingCurrentNode" title="Permalink to this definition"></a></dt>
<dd><p>Returns true if selections made in this viewer will pick from the
Current SOP. If not, the pick occurs on the Display SOP. This option
corresponds to the current/display option in the component selection
buttons context menu.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.isPickingVisibleGeometry">
<code class="descname">isPickingVisibleGeometry</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SceneViewer.isPickingVisibleGeometry" title="Permalink to this definition"></a></dt>
<dd><p>Returns true if the viewer is configured to only pick visible
components when performing an area-based selection. This option
corresponds to the matching check box in the component selection
buttons context menu.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.isSecureSelection">
<code class="descname">isSecureSelection</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SceneViewer.isSecureSelection" title="Permalink to this definition"></a></dt>
<dd><p>Returns true if secure selection is turned on in this viewer. This
option corresponds to the secure selection option in the select
tools context menu.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.isSnappingToOtherObjects">
<code class="descname">isSnappingToOtherObjects</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SceneViewer.isSnappingToOtherObjects" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.isSnappingToTemplates">
<code class="descname">isSnappingToTemplates</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SceneViewer.isSnappingToTemplates" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.isWholeGeometryPicking">
<code class="descname">isWholeGeometryPicking</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SceneViewer.isWholeGeometryPicking" title="Permalink to this definition"></a></dt>
<dd><p>Returns true if selections made in this viewer will automatically
expand to include the whole geometry. This option corresponds to the
matching check box in the component selection buttons context menu.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.pickFacing">
<code class="descname">pickFacing</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SceneViewer.pickFacing" title="Permalink to this definition"></a></dt>
<dd><p>Returns a value indicating whether the user is able to pick front
facing components, back facing components, or both. This option
corresponds to the frant and back facing options in the component
selection buttons context menu.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.pickGeometryType">
<code class="descname">pickGeometryType</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SceneViewer.pickGeometryType" title="Permalink to this definition"></a></dt>
<dd><p>Returns the type of geometry that will be picked in this viewer.
This option corresponds to the component types selectable in the
component selection buttons context menu.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.pickModifier">
<code class="descname">pickModifier</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SceneViewer.pickModifier" title="Permalink to this definition"></a></dt>
<dd><p>Returns the manner in which additional selection are combined with
the existing selection. This option corresponds to the picking
modifier in the select tool context menu.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.pickStyle">
<code class="descname">pickStyle</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SceneViewer.pickStyle" title="Permalink to this definition"></a></dt>
<dd><p>Returns the style of area picking currently being used by this
viewer. This option corresponds to the picking style specified in
the select tools context menu.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.referencePlane">
<code class="descname">referencePlane</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.ReferencePlane<a class="headerlink" href="#hou.SceneViewer.referencePlane" title="Permalink to this definition"></a></dt>
<dd><p>Return the reference plane (or grid) in the perspective viewport of
this viewer.</p>
<p>See hou.ReferencePlane for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.runShelfTool">
<code class="descname">runShelfTool</code><span class="sig-paren">(</span><em>self</em>, <em>tool_name</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SceneViewer.runShelfTool" title="Permalink to this definition"></a></dt>
<dd><p>Run the named shelf tool in the current viewport.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.selectDynamics">
<code class="descname">selectDynamics</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SceneViewer.selectDynamics" title="Permalink to this definition"></a></dt>
<dd><p>selectDynamics(self, prompt=Select dynamics objects, sel_index=0,
allow_objects=True, allow_modifiers=False, quick_select=False,
use_existing_selection=True, allow_multisel=True, icon=None, label=None,
prior_selection_paths=[], prior_selection_ids=[], prior_selections=[])
-&gt; tuple of hou.DopData</p>
</dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.selectDynamicsPoints">
<code class="descname">selectDynamicsPoints</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SceneViewer.selectDynamicsPoints" title="Permalink to this definition"></a></dt>
<dd><p>selectDynamicsPoints(self, prompt=Select dynamics points, sel_index=0,
quick_select=False, use_existing_selection=True, allow_multisel=True,
only_select_points=True, object_based_point_selection=False,
use_last_selected_object=False, icon=None, label=None,
prior_selection_paths=[], prior_selection_ids=[], prior_selections=[])
-&gt; tuple of (hou.DopData, hou.GeometrySelection)</p>
</dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.selectDynamicsPolygons">
<code class="descname">selectDynamicsPolygons</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SceneViewer.selectDynamicsPolygons" title="Permalink to this definition"></a></dt>
<dd><p>selectDynamicsPolygons(self, prompt=Select dynamics polygons,
sel_index=0, quick_select=False, use_existing_selection=True,
object_based_point_selection=False, use_last_selected_object=False,
icon=None, label=None, prior_selection_paths=[], prior_selection_ids=[],
prior_selections=[]) -&gt; tuple of (hou.DopData, hou.GeometrySelection)</p>
</dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.selectGeometry">
<code class="descname">selectGeometry</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SceneViewer.selectGeometry" title="Permalink to this definition"></a></dt>
<dd><p>selectGeometry(self, prompt=Select geometry, sel_index=0,
allow_drag=False, quick_select=False, use_existing_selection=True,
initial_selection = None, initial_selection_type = None, ordered=False,
geometry_types=(), primitive_types=(), allow_obj_sel=True, icon=None,
label=None, prior_selection_paths=[], prior_selection_ids=[],
prior_selections=[], allow_other_sops=True, consume_selections=True) -&gt;
GeometrySelection</p>
</dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.selectObjects">
<code class="descname">selectObjects</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SceneViewer.selectObjects" title="Permalink to this definition"></a></dt>
<dd><p>selectObjects(self, prompt=Select objects, sel_index=0,
allow_drag=False, quick_select=False, use_existing_selection=True,
allow_multisel=True, allowed_types=(*,), icon=None, label=None,
prior_selection_paths=[], prior_selection_ids=[], prior_selections=[])
-&gt; tuple of Nodes</p>
</dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.selectOrientedPositions">
<code class="descname">selectOrientedPositions</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SceneViewer.selectOrientedPositions" title="Permalink to this definition"></a></dt>
<dd><p>selectOrientedPositions(self, prompt=Click to specify a position,
number_of_positions=1, connect_positions=True, show_coordinates=True,
bbox=BoundingBox(),icon=None, label=None) -&gt; tuple of (Vector3, Matrix3)
tuples</p>
<blockquote>
<div>This method is very similar to hou.SceneViewer.selectPositions,
except the position type is always world space, and instead of a
tuple of positions this returns a tuple of (position, orientation)
pairs, with the position a hou.Vector3 and the orientation a
hou.Matrix3. This allows you to prompt the user for oriented
position, respecting possible orientation aids such as the
construction plane and alignment.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.selectPositions">
<code class="descname">selectPositions</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SceneViewer.selectPositions" title="Permalink to this definition"></a></dt>
<dd><p>selectPositions(self, prompt=Click to specify a position,
number_of_positions=1, connect_positions=True, show_coordinates=True,
bbox=BoundingBox(), position_type=positionType.WorldSpace, icon=None,
label=None) -&gt; tuple of Vector3s</p>
</dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.selectSceneGraph">
<code class="descname">selectSceneGraph</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SceneViewer.selectSceneGraph" title="Permalink to this definition"></a></dt>
<dd><p>selectSceneGraph(self, prompt, preselection, prim_mask, quick_select,
use_existing_selection, confirm_existing, allow_multisel, allow_drag,
path_prefix_mask, prim_kind) -&gt; tuple of string</p>
</dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.selectionMode">
<code class="descname">selectionMode</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SceneViewer.selectionMode" title="Permalink to this definition"></a></dt>
<dd><p>Returns the selection mode of the viewer of type hou.selectionMode.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.setCurrentGeometrySelection">
<code class="descname">setCurrentGeometrySelection</code><span class="sig-paren">(</span><em>self</em>, <em>geometry_type</em>, <em>nodes</em>, <em>selections</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SceneViewer.setCurrentGeometrySelection" title="Permalink to this definition"></a></dt>
<dd><p>Replaces a current geometry selection if the viewer is in a geometry
select mode and otherwise raises hou.NotAvailable. Any of the
specified selections not matching geometry_type will be
automatically converted to that type where possible.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.setCurrentSceneGraphSelection">
<code class="descname">setCurrentSceneGraphSelection</code><span class="sig-paren">(</span><em>selection</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SceneViewer.setCurrentSceneGraphSelection" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.setCurrentState">
<code class="descname">setCurrentState</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SceneViewer.setCurrentState" title="Permalink to this definition"></a></dt>
<dd><p>setCurrentState(self, state, wait_for_exit=False,
generate=hou.stateGenerateMode.Insert, request_new_on_generate=True)</p>
<blockquote>
<div><p>Sets the current tool state of the viewer. If wait_for_exit is True,
then the function will not return until the viewer exits the tool.</p>
<dl class="docutils">
<dt>generate</dt>
<dd>A hou.stateGenerateMode enumeration value to specify how a new
node should be generated, inserted inline or into a new branch.</dd>
<dt>request_new_on_generate</dt>
<dd>Some states reuse the current node whenever possible. Setting
this argument to True requests that such states generate a new
node.</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.setDefaultPickModifier">
<code class="descname">setDefaultPickModifier</code><span class="sig-paren">(</span><em>self</em>, <em>modifier</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SceneViewer.setDefaultPickModifier" title="Permalink to this definition"></a></dt>
<dd><p>Sets the default pick modifier to which Houdini will revert after a
select state terminates.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.setDenoise">
<code class="descname">setDenoise</code><span class="sig-paren">(</span><em>self</em>, <em>enable</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SceneViewer.setDenoise" title="Permalink to this definition"></a></dt>
<dd><p>Enables denoising for non-GL renders.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.setDepthSnapping">
<code class="descname">setDepthSnapping</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SceneViewer.setDepthSnapping" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.setGroupListColoringGeometry">
<code class="descname">setGroupListColoringGeometry</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SceneViewer.setGroupListColoringGeometry" title="Permalink to this definition"></a></dt>
<dd><p>Turns on or off the group list gadget to coloring of geometry in the
viewer based on group membership or attribute value.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.setGroupListCondensingPathHierarchies">
<code class="descname">setGroupListCondensingPathHierarchies</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SceneViewer.setGroupListCondensingPathHierarchies" title="Permalink to this definition"></a></dt>
<dd><p>Turns on or off the condensing of the hierarchy in the group list.
This applies to components grouped by string attributes representing
a path. Turning this option on can fit more information into the
list, but can make it harder to distinguish levels in the hierarchy.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.setGroupListMask">
<code class="descname">setGroupListMask</code><span class="sig-paren">(</span><em>self</em>, <em>mask</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SceneViewer.setGroupListMask" title="Permalink to this definition"></a></dt>
<dd><p>Sets the mask value in the group list gadget for this viewer. This
can be a filter applied to the comonent groups, or an attribute name
(starting with an &#64; charater), or a connectivity type.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.setGroupListShowingEmptyGroups">
<code class="descname">setGroupListShowingEmptyGroups</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SceneViewer.setGroupListShowingEmptyGroups" title="Permalink to this definition"></a></dt>
<dd><p>Turns on or off the display of empty groups in the group list
gadget.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.setGroupListShowingOnlyPreSelectedGroups">
<code class="descname">setGroupListShowingOnlyPreSelectedGroups</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SceneViewer.setGroupListShowingOnlyPreSelectedGroups" title="Permalink to this definition"></a></dt>
<dd><p>Turns on or off the trimming of the group list to show only groups
that contain one or more selected or pre-selected components.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.setGroupListSize">
<code class="descname">setGroupListSize</code><span class="sig-paren">(</span><em>self</em>, <em>width</em>, <em>height</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SceneViewer.setGroupListSize" title="Permalink to this definition"></a></dt>
<dd><p>Sets the size in inches of the group list gadget.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.setGroupListType">
<code class="descname">setGroupListType</code><span class="sig-paren">(</span><em>self</em>, <em>group_list_type</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SceneViewer.setGroupListType" title="Permalink to this definition"></a></dt>
<dd><p>Sets the type of component listed in the group list gadget. This can
be set to a specific component type or to follow the current
component selection type.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.setGroupListVisible">
<code class="descname">setGroupListVisible</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SceneViewer.setGroupListVisible" title="Permalink to this definition"></a></dt>
<dd><p>Turns on or off the group list gadget for this viewer.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.setGroupPicking">
<code class="descname">setGroupPicking</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SceneViewer.setGroupPicking" title="Permalink to this definition"></a></dt>
<dd><p>Turns on or off the group, attribute, or connectivity based picking.
When turned on, the group list gadget is automatically made visible.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.setHydraRenderer">
<code class="descname">setHydraRenderer</code><span class="sig-paren">(</span><em>self</em>, <em>ren_name</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SceneViewer.setHydraRenderer" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.setOrientOnSnap">
<code class="descname">setOrientOnSnap</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SceneViewer.setOrientOnSnap" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.setPickFacing">
<code class="descname">setPickFacing</code><span class="sig-paren">(</span><em>self</em>, <em>facing</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SceneViewer.setPickFacing" title="Permalink to this definition"></a></dt>
<dd><p>Sets the option of whether to restrict selection to front facing,
back facing, or either type of components.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.setPickGeometryType">
<code class="descname">setPickGeometryType</code><span class="sig-paren">(</span><em>self</em>, <em>geometry_type</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SceneViewer.setPickGeometryType" title="Permalink to this definition"></a></dt>
<dd><p>Sets the type of geometry that will be picked in this viewer. This
value can be changed at any time by the user, or when a selector is
invoked.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.setPickModifier">
<code class="descname">setPickModifier</code><span class="sig-paren">(</span><em>self</em>, <em>modifier</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SceneViewer.setPickModifier" title="Permalink to this definition"></a></dt>
<dd><p>Sets the method used to modify the existing selection when a new
selection is made. Modifier keys can still be used to alter this
behavior. Only the default operation (with no modifier keys) is
affected by this setting. Note that the select state will revert to
the default pick modifier upon termination, so to make your change
persist beyond this you will also need to change this default using
setDefaultPickModifier().</p>
</dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.setPickStyle">
<code class="descname">setPickStyle</code><span class="sig-paren">(</span><em>self</em>, <em>style</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SceneViewer.setPickStyle" title="Permalink to this definition"></a></dt>
<dd><p>Sets the style of area picking to be used by this viewer.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.setPickingContainedGeometry">
<code class="descname">setPickingContainedGeometry</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SceneViewer.setPickingContainedGeometry" title="Permalink to this definition"></a></dt>
<dd><p>Turns on or off the option to select only fully contained components
when performing area-based selections such as box or brush picking.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.setPickingCurrentNode">
<code class="descname">setPickingCurrentNode</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SceneViewer.setPickingCurrentNode" title="Permalink to this definition"></a></dt>
<dd><p>Tells this viewer whether picks should be made on the Current SOP or
on the Display SOP.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.setPickingVisibleGeometry">
<code class="descname">setPickingVisibleGeometry</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SceneViewer.setPickingVisibleGeometry" title="Permalink to this definition"></a></dt>
<dd><p>Turns on or off the option to select only visible components when
performing area-based selections such as box or brush picking.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.setPromptMessage">
<code class="descname">setPromptMessage</code><span class="sig-paren">(</span><em>self</em>, <em>message</em>, <em>message_type=promptMessageType.Prompt</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SceneViewer.setPromptMessage" title="Permalink to this definition"></a></dt>
<dd><p>Sets the viewport to display a message at the bottom of the screen.</p>
<dl class="docutils">
<dt>message</dt>
<dd>Text message to display.</dd>
<dt>message_type</dt>
<dd>A hou.promptMessageType value representing the type of message
to display. Defaults to hou.promptMessageType.Prompt.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.setSecureSelection">
<code class="descname">setSecureSelection</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SceneViewer.setSecureSelection" title="Permalink to this definition"></a></dt>
<dd><p>Turns on or off the secure selection option in this viewer.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.setSelectionMode">
<code class="descname">setSelectionMode</code><span class="sig-paren">(</span><em>self</em>, <em>selection_mode</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SceneViewer.setSelectionMode" title="Permalink to this definition"></a></dt>
<dd><p>Sets the selection mode of this view. The value for selection_mode
must be from hou.selectionMode.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.setShowCameras">
<code class="descname">setShowCameras</code><span class="sig-paren">(</span><em>self</em>, <em>show</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SceneViewer.setShowCameras" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.setShowGeometry">
<code class="descname">setShowGeometry</code><span class="sig-paren">(</span><em>self</em>, <em>show</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SceneViewer.setShowGeometry" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.setShowLights">
<code class="descname">setShowLights</code><span class="sig-paren">(</span><em>self</em>, <em>show</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SceneViewer.setShowLights" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.setShowSelection">
<code class="descname">setShowSelection</code><span class="sig-paren">(</span><em>self</em>, <em>show</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SceneViewer.setShowSelection" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.setSnapToOtherObjects">
<code class="descname">setSnapToOtherObjects</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SceneViewer.setSnapToOtherObjects" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.setSnapToTemplates">
<code class="descname">setSnapToTemplates</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SceneViewer.setSnapToTemplates" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.setSnappingMode">
<code class="descname">setSnappingMode</code><span class="sig-paren">(</span><em>self</em>, <em>snapping_mode</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SceneViewer.setSnappingMode" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.setViewportLayout">
<code class="descname">setViewportLayout</code><span class="sig-paren">(</span><em>self</em>, <em>layout</em>, <em>single=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SceneViewer.setViewportLayout" title="Permalink to this definition"></a></dt>
<dd><p>Sets the viewers viewport layout.</p>
<dl class="docutils">
<dt>layout</dt>
<dd><blockquote class="first">
<div>A hou.geometryViewportLayout value. For example, to set the
viewer to show four viewports at the corners:</div></blockquote>
<p class="last">&gt; viewer_pane.setViewportLayout(hou.geometryViewportLayout.Quad)</p>
</dd>
<dt>single</dt>
<dd><p class="first">If you specify the layout, this argument lets you specify which
of the four viewports from the quad view to show as the single</p>
<p>-1</p>
<p>Use the current viewport (the viewport the mouse is/was over).</p>
<p>0</p>
<p>Use the top-left viewport from the quad layout (usually the Top
view).</p>
<p>1</p>
<p>Use the top-right viewport from the quad layout (usually the
Perspective view).</p>
<p>2</p>
<p>Use the bottom-left viewport from the quad layout (usually the
Front view).</p>
<p>3</p>
<p class="last">Use the bottom-right viewport from the quad layout (usually the
Right view).</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.setWholeGeometryPicking">
<code class="descname">setWholeGeometryPicking</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SceneViewer.setWholeGeometryPicking" title="Permalink to this definition"></a></dt>
<dd><p>Turns on or off the option to expand selections made in this viewer
to include the entire geometry.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.showCameras">
<code class="descname">showCameras</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.SceneViewer.showCameras" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.showGeometry">
<code class="descname">showGeometry</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.SceneViewer.showGeometry" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.showHandle">
<code class="descname">showHandle</code><span class="sig-paren">(</span><em>self</em>, <em>name</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SceneViewer.showHandle" title="Permalink to this definition"></a></dt>
<dd><p>Shows or hides a display handle linked to the current tool state.
This API is typically used with Python states and can be called from
any python state callbacks  with one small caveat. Avoid calling
showHandle from the python state constructor, doing so will lead to
a runtime error.</p>
<dl class="docutils">
<dt>name</dt>
<dd>The name of the handle as specified with
hou.ViewerStateTemplate.bindHandle</dd>
<dt>value</dt>
<dd>Bool value, True to show the handle, False to hide it.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.showLights">
<code class="descname">showLights</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.SceneViewer.showLights" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.showSelection">
<code class="descname">showSelection</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.SceneViewer.showSelection" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.snappingMode">
<code class="descname">snappingMode</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SceneViewer.snappingMode" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.stage">
<code class="descname">stage</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SceneViewer.stage" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.stageSerial">
<code class="descname">stageSerial</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.SceneViewer.stageSerial" title="Permalink to this definition"></a></dt>
<dd><p>Integer that is increased every time the Scene Graph View data is
modified. Only count on this number to be bigger when changes occur,
and not necessarily incremented by 1.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.SceneViewer.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.SceneViewer.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.viewerType">
<code class="descname">viewerType</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.stateViewerType enum value<a class="headerlink" href="#hou.SceneViewer.viewerType" title="Permalink to this definition"></a></dt>
<dd><p>Returns the type of the viewer, either Scene for a viewer looking at
Objects, SOPs, or DOPs; or SceneGraph for a viewer looking at LOPs.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.viewportLayout">
<code class="descname">viewportLayout</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.geometryViewportLayout<a class="headerlink" href="#hou.SceneViewer.viewportLayout" title="Permalink to this definition"></a></dt>
<dd><p>Returns the current viewport layout as a hou.geometryViewportLayout
value.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SceneViewer.viewports">
<code class="descname">viewports</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.GeometryViewports<a class="headerlink" href="#hou.SceneViewer.viewports" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.ScriptEvalContext">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">ScriptEvalContext</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ScriptEvalContext" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Use this to temporarily change the scripting evaluation context within a
Python code block.</p>
<dl class="method">
<dt id="hou.ScriptEvalContext.node">
<code class="descname">node</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ScriptEvalContext.node" title="Permalink to this definition"></a></dt>
<dd><p>Return the hou.Node for this context.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ScriptEvalContext.parm">
<code class="descname">parm</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ScriptEvalContext.parm" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Return the hou.Parm for this context. Returns None if this context
was created from a hou.Node.</p>
<p>&#64;related</p>
</div></blockquote>
<ul class="simple">
<li>hou.evaluatingParm</li>
</ul>
</dd></dl>

<dl class="attribute">
<dt id="hou.ScriptEvalContext.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.ScriptEvalContext.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.Selection">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">Selection</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Selection" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A class that represents a geometry component selection.</p>
<p>Component selections are not tied to any specific hou.Geometry.
Therefore most method on this class must be passed a Geometry object to
look up information about individual components. This explicit
separation allows the selection class to be used as a utility class for
processing geometry topology (growing the set of components, shrinking
it, finding the boundary, etc.). This separation also avoids any
expectations that changing the contents of a selection object might be
expected to update the selection visible on some goemetry in the
viewport. Setting the visible viewport selection must always be an
explicit operation on a hou.SopNode in order for Houdini to be able to
track changes properly.</p>
<p>If a selection object is returned from a call to hou.Geometry.selection,
hou.GeometrySelection.selections, or a hou.SopNode.selection, the
selection cannot be modified. A copy of the selection must be made first
with the freeze() method. This new selection can be modified, and passed
back into a hou.SopNode.setSelection if desired. Because each SOP has a
selection for each component type, when you set a new selection it will
replace the existing selection of that component type. Note that this
may not result in the visible selection in the viewport changing if the
viewport is not currently configured to select that component type. The
viewport selection type can be controlled with the hou.SceneViewer
class. A selection created by calling any of the hou.Selection()
initializer methods are created in a modifiable state, so a call to
freeze() is not required.</p>
<p>A selection returned from a hou.Geometry or a hou.SopNode is a reference
to the source selection, and so will change if the selection on the
source geometry is changed. This seems like a departure from the
separation of selection objects from any particular geometry, however it
matches the behavior of the hou.Geometry class returned from a SOP node.
This is because the underlying selection data is shared with the SOP
rather than copied. The freeze() method can be used to force a copy of
the selection data that is disconnected from any particular SOP (as well
as allowing the selection contents to be modified).</p>
<dl class="method">
<dt id="hou.Selection.boundary">
<code class="descname">boundary</code><span class="sig-paren">(</span><em>self</em>, <em>geo</em>, <em>uv_connectivity = False</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Selection.boundary" title="Permalink to this definition"></a></dt>
<dd><p>Using the supplied hou.Geometry object for reference, changes the
selection to contain those components on the boundary of the current
selection. The uv_connectivity parameter controls whether to use
topology or uv attribute values to determine whether components are
connected.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Selection.clear">
<code class="descname">clear</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Selection.clear" title="Permalink to this definition"></a></dt>
<dd><p>Removes all components from the current selection.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Selection.combine">
<code class="descname">combine</code><span class="sig-paren">(</span><em>self</em>, <em>geo</em>, <em>selection</em>, <em>modifier</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Selection.combine" title="Permalink to this definition"></a></dt>
<dd><p>Using the supplied hou.Geometry object for reference, combines this
selection with another.</p>
<dl class="docutils">
<dt>geo</dt>
<dd>A hou.Geometry object that is used when doing any selection
conversions.</dd>
<dt>selection</dt>
<dd>A hou.Selection object that will be combined with the current
selection. If this selection does not have the same component
type as the current selection, an implicit conversion to the
current component type is performed before combining the
selections.</dd>
<dt>modifier</dt>
<dd>A hou.pickModifier value that controls how the selections will
be combined. This lets you perform a union, intersection, or
other operation on a pairs of selections.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hou.Selection.convert">
<code class="descname">convert</code><span class="sig-paren">(</span><em>self</em>, <em>geo</em>, <em>selection_type</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Selection.convert" title="Permalink to this definition"></a></dt>
<dd><p>Using the supplied hou.Geometry object for reference, converts the
current selection to the new hou.geometryType.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Selection.edges">
<code class="descname">edges</code><span class="sig-paren">(</span><em>self</em>, <em>geo</em><span class="sig-paren">)</span> &#x2192; tuple of hou.Edge<a class="headerlink" href="#hou.Selection.edges" title="Permalink to this definition"></a></dt>
<dd><p>Returns a tuple of all edges in the selection. If the selection does
not contain edges, an implicit conversion to edges is performed to
generate the return value.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Selection.freeze">
<code class="descname">freeze</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Selection<a class="headerlink" href="#hou.Selection.freeze" title="Permalink to this definition"></a></dt>
<dd><p>Returns a copy of the Selection object. This copy can be modified
with any of the functions that alter the selection.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Selection.grow">
<code class="descname">grow</code><span class="sig-paren">(</span><em>self</em>, <em>geo</em>, <em>uv_connectivity = False</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Selection.grow" title="Permalink to this definition"></a></dt>
<dd><p>Using the supplied hou.Geometry object for reference, adds to the
selection any components connected to the current selection. The
uv_connectivity parameter controls whether to use topology or uv
attribute values to determine whether components are connected.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Selection.invert">
<code class="descname">invert</code><span class="sig-paren">(</span><em>self</em>, <em>geo</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Selection.invert" title="Permalink to this definition"></a></dt>
<dd><p>Using the supplied hou.Geometry object for reference, inverts the
current selection. The selection will contain only those components
that were not in the selection before this method call.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Selection.numSelected">
<code class="descname">numSelected</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Selection.numSelected" title="Permalink to this definition"></a></dt>
<dd><p>Returns the number of components in the selection.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Selection.points">
<code class="descname">points</code><span class="sig-paren">(</span><em>self</em>, <em>geo</em><span class="sig-paren">)</span> &#x2192; tuple of hou.Point<a class="headerlink" href="#hou.Selection.points" title="Permalink to this definition"></a></dt>
<dd><p>Returns a tuple of all points in the selection. If the selection
does not contain points, an implicit conversion to points is
performed to generate the return value.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Selection.prims">
<code class="descname">prims</code><span class="sig-paren">(</span><em>self</em>, <em>goe</em><span class="sig-paren">)</span> &#x2192; tuple of hou.Prim<a class="headerlink" href="#hou.Selection.prims" title="Permalink to this definition"></a></dt>
<dd><p>Returns a tuple of all primitives in the selection. If the selection
does not contain primitives, an implicit conversion to primitives is
performed to generate the return value.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Selection.selectionString">
<code class="descname">selectionString</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Selection.selectionString" title="Permalink to this definition"></a></dt>
<dd><p>selectionString(self, geo, force_numeric = False,
collapse_where_possible = True, asterisk_to_select_all = False) -&gt; str</p>
<blockquote>
<div><p>Returns a string that specifies the selected components. The format
of this string is appropriate for use in SOP Group parameter fields.</p>
<dl class="docutils">
<dt>geo</dt>
<dd>A hou.Geometry object that is used when generating the selection
string (such as determining if all components are selected).</dd>
<dt>force_numeric</dt>
<dd>Set this to True to force the generated string to contain only
numeric ranges, even if the selection was constructed with group
or attribute based selection.</dd>
<dt>collapse_where_possible</dt>
<dd>Set this to True to cause numeric ranges to be collapsed as much
as possible, regardless of the selection order. So for example
if the user selected primitive 3, then 2, then 1, the generated
selection string would either be 3 2 1 or 1-3 depending on
this parameter.</dd>
<dt>asterisk_to_select_all</dt>
<dd>When this parameter is set to False, if a selection contains all
components in the supplied geometry, the resulting value is an
empty string. This is appropriate when using the resulting
string in a SOP node Group parameter. If this parameter is set
to True, a full selection will return a value of * instead.</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.Selection.selectionType">
<code class="descname">selectionType</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Selection.selectionType" title="Permalink to this definition"></a></dt>
<dd><p>Returns a hou.geometryType value indicating the type of component
referenced by this selection.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Selection.shrink">
<code class="descname">shrink</code><span class="sig-paren">(</span><em>self</em>, <em>geo</em>, <em>uv_connectivity = False</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Selection.shrink" title="Permalink to this definition"></a></dt>
<dd><p>Using the supplied hou.Geometry object for reference, removes from
the selection any components on the boundary of the current
selection. The uv_connectivity parameter controls whether to use
topology or uv attribute values to determine whether components are
connected.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.Selection.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.Selection.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

<dl class="method">
<dt id="hou.Selection.vertices">
<code class="descname">vertices</code><span class="sig-paren">(</span><em>self</em>, <em>geo</em><span class="sig-paren">)</span> &#x2192; tuple of hou.Vertex<a class="headerlink" href="#hou.Selection.vertices" title="Permalink to this definition"></a></dt>
<dd><p>Returns a tuple of all vertices in the selection. If the selection
does not contain vertices, an implicit conversion to vertices is
performed to generate the return value.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.Selector">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">Selector</code><a class="headerlink" href="#hou.Selector" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Describes how Houdini should prompt the user to choose geometry in the
viewport when creating a new SOP node instance.</p>
<p>Use hou.SopNodeType.addSelector to create a selector and add it to a SOP
node type. When the user creates a new instance of a node type in the
viewer, Houdini will invoke all of its selectors sequentially. Each
selector prompts the user to select geometry. When all selectors have
been invoked, Houdini creates the new node and each selector connects
its input nodes and fills in any group parameters on the node to match
what was selected.</p>
<dl class="method">
<dt id="hou.Selector.allowDragging">
<code class="descname">allowDragging</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.Selector.allowDragging" title="Permalink to this definition"></a></dt>
<dd><p>Return whether the user is allowed to select the geometry and begin
manipulating the handles with a single mouse click. A transform SOP,
for example, lets you select the geometry and drag it right away.
Dragging the geometry forces the selector to finish immediately, the
selector connects the input and sets the group parameter, and
subsequent mouse movements are passed to the handle which translates
the geometry by changing parameter values.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Selector.destroy">
<code class="descname">destroy</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Selector.destroy" title="Permalink to this definition"></a></dt>
<dd><p>Remove this selector from its node type.</p>
<p>See also hou.SopNodeType.addSelector.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Selector.emptyStringSelectsAll">
<code class="descname">emptyStringSelectsAll</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.Selector.emptyStringSelectsAll" title="Permalink to this definition"></a></dt>
<dd><p>Return whether or not use an empty string in the group parameter if
the user selects all the geometry. If False, Houdini will place an
asterisk (*) in the group parameter when the user selects all the
geometry. Most SOPs use an empty string.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Selector.extraInfo">
<code class="descname">extraInfo</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.Selector.extraInfo" title="Permalink to this definition"></a></dt>
<dd><p>Returns an optional extra info string that contains additional
settings.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Selector.geometryTypes">
<code class="descname">geometryTypes</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.geometryType enum values<a class="headerlink" href="#hou.Selector.geometryTypes" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Return a tuple of hou.geometryType enumeration values. This tuple
describes which geometry entities (e.g. points, primitives, edges,
etc.) the selector allows. Note that this list is a property of the
selector type and you cannot specify it when creating a new
selector. Instead, you must choose a selector type with the desired
geometry types.</p>
<p>See hou.SopNodeType.selectors for a function that returns a list of
all the selector types. The following function will return the
geometry types for a particular selector type.</p>
</div></blockquote>
<p>&gt; def geometryTypesForSelectorType(selector_type):
&gt;     Given a selector type name, return the tuple of geometry types it
&gt;        will select.
&gt;     # First find a node type that uses this selector.
&gt;     for node_type in hou.sopNodeTypeCategory().nodeTypes().values():
&gt;         # Skip manager nodes, like shopnets, ropnets, etc.
&gt;         if not isinstance(node_type, hou.SopNodeType):
&gt;             continue
&gt; 
&gt;         for selector in node_type.selectors():
&gt;             if selector_type == selector.selectorType():
&gt;                 return selector.geometryTypes()
&gt; 
&gt;     # The selector type name is invalid.
&gt;     raise hou.OperationFailed(Invalid selector type)</p>
</dd></dl>

<dl class="method">
<dt id="hou.Selector.groupParmName">
<code class="descname">groupParmName</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.Selector.groupParmName" title="Permalink to this definition"></a></dt>
<dd><p>Return the name of the SOP node parameter containing the group
field. The selector will set this parameter to the string
representing the points, primitives, edges, etc. chosen by the user
in the viewer. It is typically named group.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Selector.groupTypeParmName">
<code class="descname">groupTypeParmName</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.Selector.groupTypeParmName" title="Permalink to this definition"></a></dt>
<dd><p>Return the name of the SOP node parameter containing the menu of
geometry types. If the selector can select multiple geometry types
(e.g. points or primitives), it will set this parameter to match the
type of geometry the user chose. The transform SOP, for example, has
a Group Type parameter that tells it how to interpret the string in
the Group parameter. For such selectors, the parameter is typically
named grouptype. For selectors that do not allow multiple geometry
types, this parameter is usually .</p>
</dd></dl>

<dl class="method">
<dt id="hou.Selector.groupTypeParmValues">
<code class="descname">groupTypeParmValues</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of int<a class="headerlink" href="#hou.Selector.groupTypeParmValues" title="Permalink to this definition"></a></dt>
<dd><p>Return a tuple of indices mapping geometry types to indices on the
geometry type parameter menu.</p>
<p>Whether or not a selector is ordered is a property of the selector
type, and you cannot specify it when creating a new selector.
Instead, you must choose the appropriate selector type. For example,
the everything selector can select primitives, primitive groups,
points, point groups, edges, and breakpoints. It sets a group type
menu parameter to match the type of selection, and this menu must
have the entries Guess from Group, Breakpoints, Edges,
Points, and Primitives. For an everything selector, this
method returns (4, 4, 3, 3, 2, 1), mapping the geometry element
types to 0-based entries in the menu. For example, if the user
selects edges, the selector will look up the fifth element (2) and
set the menu parameter to the item at index 2 (Edges).</p>
<p>The length of the tuple of ints is the same as
len(self.geometryTypes). If this selector is not intended to work
with a menu parameter, each value in the tuple will be -1.</p>
<p>See also hou.Selector.geometryTypes.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Selector.inputIndex">
<code class="descname">inputIndex</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.Selector.inputIndex" title="Permalink to this definition"></a></dt>
<dd><p>Return the index of the input connector on the SOP node where the
selector should wire input SOPs. A cookie SOP, for example, has two
input connectors and one selector for each input connector.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Selector.inputRequired">
<code class="descname">inputRequired</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.Selector.inputRequired" title="Permalink to this definition"></a></dt>
<dd><p>Return whether or not this input is required or optional. If the
user does not select any geometry and the input is not required, the
selector will not connect anything to its input connector.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Selector.name">
<code class="descname">name</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.Selector.name" title="Permalink to this definition"></a></dt>
<dd><p>Return the name of this selector. The name is unique within the node
type it is attached to.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Selector.nodeType">
<code class="descname">nodeType</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.NodeType<a class="headerlink" href="#hou.Selector.nodeType" title="Permalink to this definition"></a></dt>
<dd><p>Return the node type that this selector is attached to.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Selector.ordered">
<code class="descname">ordered</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.Selector.ordered" title="Permalink to this definition"></a></dt>
<dd><p>Return whether or not this selector preserves the order in which the
user selected the geometry.</p>
<p>For example, the selector is for points and the user clicks on
points 1, 0, and 2, in that order, an ordered selector will set the
SOPs group parameter to 1 0 2, while an unordered selector will
set it to 0-2. For SOPs where the order of the group selector
matters, use ordered selectors.</p>
<p>Whether or not a selector is ordered is a property of the selector
type, and you cannot specify it when creating a new selector.
Instead, you must choose the appropriate selector type. For example,
prims is an unordered selector type, but ordered_prims is
ordered. See hou.Selector.geometryTypes for a function that can be
adapted to determine if a selector is ordered, and see
hou.SopNodeType.selectors for a function to list all the selector
types.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Selector.primitiveTypes">
<code class="descname">primitiveTypes</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.primType enum values<a class="headerlink" href="#hou.Selector.primitiveTypes" title="Permalink to this definition"></a></dt>
<dd><p>Return a sequence of hou.primType enumeration values to specify what
primitive types are allowed.</p>
<p>Note that if you pass an empty sequence for the primitive_types
parameter in hou.SopNodeType.addSelector and then call this method
on the newly-created selector, this method will return a tuple of
all primitive types.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Selector.prompt">
<code class="descname">prompt</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.Selector.prompt" title="Permalink to this definition"></a></dt>
<dd><p>A string to display at the bottom of the viewer to instruct the user
what to select.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Selector.selectorType">
<code class="descname">selectorType</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.Selector.selectorType" title="Permalink to this definition"></a></dt>
<dd><p>Return the name of the type of selector to use. Different selectors
have different behaviors. For example prims will select only
primitives and is used, for example, by the cookie SOP. points
will select only points, and is used by SOPs like the point SOP.
everything will select any geometry, and is used for SOPs like
xform and blast.</p>
<p>See hou.SopNodeType.selectors for example code that returns all the
available selector types.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.Selector.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.Selector.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.SeparatorParmTemplate">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">SeparatorParmTemplate</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SeparatorParmTemplate" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.ParmTemplate" title="hou.ParmTemplate"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.ParmTemplate</span></code></a></p>
<p>Template for a separator parameter. Separators are just lines between
parameters and do not store any parameter values.</p>
<dl class="attribute">
<dt id="hou.SeparatorParmTemplate.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.SeparatorParmTemplate.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.Shelf">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">Shelf</code><a class="headerlink" href="#hou.Shelf" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.ShelfElement" title="hou.ShelfElement"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.ShelfElement</span></code></a></p>
<p>Represents a tab of shelf tools.</p>
<p>You cant instantiate this object directly, call hou.shelves.newShelf
instead.</p>
<dl class="method">
<dt id="hou.Shelf.destroy">
<code class="descname">destroy</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Shelf.destroy" title="Permalink to this definition"></a></dt>
<dd><p>Removes this shelf tab from Houdini and deletes it from the shelf
defintion file.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Shelf.setTools">
<code class="descname">setTools</code><span class="sig-paren">(</span><em>self</em>, <em>tools</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Shelf.setTools" title="Permalink to this definition"></a></dt>
<dd><p>Replaces the current contents of the shelf with the given list of
hou.Tool objects.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.Shelf.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.Shelf.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

<dl class="method">
<dt id="hou.Shelf.tools">
<code class="descname">tools</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.Tool<a class="headerlink" href="#hou.Shelf.tools" title="Permalink to this definition"></a></dt>
<dd><p>Returns the tools on this shelf tab.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.ShelfDock">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">ShelfDock</code><a class="headerlink" href="#hou.ShelfDock" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Represents the shelf area at the top of the screen, within which shelf
sets and shelf tabs exist.</p>
<p>The shelf docking area on any given desktop has space for any number of
shelf sets, each of which may contain shelf tabs.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.Desktop</li>
</ul>
</div></blockquote>
<dl class="method">
<dt id="hou.ShelfDock.iconsize">
<code class="descname">iconsize</code><span class="sig-paren">(</span><em>self) -&gt; (int</em>, <em>int</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ShelfDock.iconsize" title="Permalink to this definition"></a></dt>
<dd><p>Returns the height and width, in pixels, of the icons in the shelf
at the current Display Tools As setting.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ShelfDock.shelfSets">
<code class="descname">shelfSets</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.ShelfSet<a class="headerlink" href="#hou.ShelfDock.shelfSets" title="Permalink to this definition"></a></dt>
<dd><p>Returns a list of the shelf sets in the current shelf dock.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ShelfDock.show">
<code class="descname">show</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ShelfDock.show" title="Permalink to this definition"></a></dt>
<dd><p>Show or hide the shelf dock by uncollapsing or collapsing its stow
bar.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.ShelfDock.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.ShelfDock.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.ShelfElement">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">ShelfElement</code><a class="headerlink" href="#hou.ShelfElement" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Superclass of shelf tools, shelf tabs, and shelf sets.</p>
<dl class="method">
<dt id="hou.ShelfElement.filePath">
<code class="descname">filePath</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.ShelfElement.filePath" title="Permalink to this definition"></a></dt>
<dd><p>Returns the file that contains the definition of this object.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ShelfElement.isReadOnly">
<code class="descname">isReadOnly</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.ShelfElement.isReadOnly" title="Permalink to this definition"></a></dt>
<dd><p>Returns True if the element is read-only (cant be edited).</p>
</dd></dl>

<dl class="method">
<dt id="hou.ShelfElement.label">
<code class="descname">label</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.ShelfElement.label" title="Permalink to this definition"></a></dt>
<dd><p>Returns the objects human-readable label.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ShelfElement.name">
<code class="descname">name</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.ShelfElement.name" title="Permalink to this definition"></a></dt>
<dd><p>Returns the internal name of this object.</p>
<p>Multiple objects may have the same name (for example, two different
assets might both provide a hammer tool), but only one will be
active at a time in a Houdini session.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ShelfElement.setFilePath">
<code class="descname">setFilePath</code><span class="sig-paren">(</span><em>self</em>, <em>file_path</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ShelfElement.setFilePath" title="Permalink to this definition"></a></dt>
<dd><p>Sets the path string for where this objects definition is stored.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ShelfElement.setLabel">
<code class="descname">setLabel</code><span class="sig-paren">(</span><em>self</em>, <em>label</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ShelfElement.setLabel" title="Permalink to this definition"></a></dt>
<dd><p>Sets the objects human-readable label. This is whats displayed in
the UI.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ShelfElement.setName">
<code class="descname">setName</code><span class="sig-paren">(</span><em>self</em>, <em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ShelfElement.setName" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Sets this objects internal name. This is how you refer to the
object in scripts.</p>
<p>The name has similar rules to naming Houdini nodes: it must not
start with a number, and can only contain letters, numbers, an
underscores.</p>
<p>For example, if a Tool objects name is foo, you can get a reference
to it using:</p>
</div></blockquote>
<p>&gt; footool = shelves.tool(foo)</p>
</dd></dl>

<dl class="method">
<dt id="hou.ShelfElement.setReadOnly">
<code class="descname">setReadOnly</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ShelfElement.setReadOnly" title="Permalink to this definition"></a></dt>
<dd><p>&gt; # Get a reference to a tool
&gt; t = hou.shelves.tool(geometry_sphere)
&gt; # Prevent the tool from being modified
&gt; t.setReadOnly(True)
&gt; # Allow the tool to be modified
&gt; t.setReadOnly(False)</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.ShelfElement.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.ShelfElement.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.ShelfSet">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">ShelfSet</code><a class="headerlink" href="#hou.ShelfSet" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.ShelfElement" title="hou.ShelfElement"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.ShelfElement</span></code></a></p>
<p>Represents a collection of shelf tabs.</p>
<p>You cant instantiate this object directly, call hou.shelves.newShelfSet
instead.</p>
<dl class="method">
<dt id="hou.ShelfSet.destroy">
<code class="descname">destroy</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ShelfSet.destroy" title="Permalink to this definition"></a></dt>
<dd><p>Removes this shelf set from Houdini and deletes it from the shelf
definition file.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ShelfSet.setShelves">
<code class="descname">setShelves</code><span class="sig-paren">(</span><em>self</em>, <em>shelves</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ShelfSet.setShelves" title="Permalink to this definition"></a></dt>
<dd><p>Replaces the current contents of the shelf with the given list of
hou.Shelf objects.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ShelfSet.shelves">
<code class="descname">shelves</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.Shelf<a class="headerlink" href="#hou.ShelfSet.shelves" title="Permalink to this definition"></a></dt>
<dd><p>Returns the shelf tabs in this shelf set.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.ShelfSet.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.ShelfSet.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.ShellIO">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">ShellIO</code><a class="headerlink" href="#hou.ShellIO" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A proxy object that replaces Pythons stdin, stdout, and stderr streams
within Houdini.</p>
<p>This class is mostly an implementation detail of how Houdini replaces
Pythons standard streams with versions that allow Python input and
output in Houdini windows and pane tabs.</p>
<p>The methods that might be useful outside of internal SideFX scripts are
addCloseCallback(), removeCloseCallback(), and callbacks(). These let
you register functions that Houdini calls when the Python shell window
or pane tab is closed (the equivalent of atexit() scripts in regular
Python).</p>
<p>The other methods should be considered internal implementation details,
and you should not use them.</p>
<dl class="method">
<dt id="hou.ShellIO.CloseCallbacks">
<code class="descname">CloseCallbacks</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.ShellIO.CloseCallbacks" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.ShellIO.addCloseCallback">
<code class="descname">addCloseCallback</code><span class="sig-paren">(</span><em>callback</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ShellIO.addCloseCallback" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Register a Python callback to be called whenever the last Houdini
Python Shell is closed.</p>
<p>The argument is a callable object that expects no parameters.</p>
</div></blockquote>
<p>&gt; def cleanup():
&gt;     # Here is where you would run your cleanup code when
&gt;     # the Python shell has closed.
&gt;     pass
&gt; 
&gt; hou.ui.shellIO().addCloseCallback(cleanup)</p>
<blockquote>
<div>You might use this function to cleanly terminate any mechanisms that
are dependent on the Python shell. For example, you can register a
callback which disables an object from logging output messages to
the shell.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.ShellIO.addDataForReading">
<code class="descname">addDataForReading</code><span class="sig-paren">(</span><em>self</em>, <em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ShellIO.addDataForReading" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.ShellIO.addEOFForReading">
<code class="descname">addEOFForReading</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ShellIO.addEOFForReading" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.ShellIO.addExitCallback">
<code class="descname">addExitCallback</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ShellIO.addExitCallback" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.ShellIO.exitCallbacks">
<code class="descname">exitCallbacks</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ShellIO.exitCallbacks" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.ShellIO.flush">
<code class="descname">flush</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.ShellIO.flush" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.ShellIO.getAndClearWrittenData">
<code class="descname">getAndClearWrittenData</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; string<a class="headerlink" href="#hou.ShellIO.getAndClearWrittenData" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.ShellIO.interruptShellThread">
<code class="descname">interruptShellThread</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ShellIO.interruptShellThread" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.ShellIO.isWaitingForCommand">
<code class="descname">isWaitingForCommand</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.ShellIO.isWaitingForCommand" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.ShellIO.isatty">
<code class="descname">isatty</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.ShellIO.isatty" title="Permalink to this definition"></a></dt>
<dd><p>Implemented as part of the file-like object interface.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ShellIO.readline">
<code class="descname">readline</code><span class="sig-paren">(</span><em>self</em>, <em>size=-1</em><span class="sig-paren">)</span> &#x2192; string<a class="headerlink" href="#hou.ShellIO.readline" title="Permalink to this definition"></a></dt>
<dd><p>Implemented as part of the file-like object interface.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ShellIO.removeCloseCallback">
<code class="descname">removeCloseCallback</code><span class="sig-paren">(</span><em>callback</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ShellIO.removeCloseCallback" title="Permalink to this definition"></a></dt>
<dd><p>Remove a Python callback that was previously registered with
hou.ShellIO.addCloseCallback. See hou.ShellIO.addCloseCallback for
more information.</p>
<p>Raises hou.OperationFailed if the callback was not previously
registered.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ShellIO.removeExitCallback">
<code class="descname">removeExitCallback</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ShellIO.removeExitCallback" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.ShellIO.setIsWaitingForCommand">
<code class="descname">setIsWaitingForCommand</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ShellIO.setIsWaitingForCommand" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.ShellIO.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.ShellIO.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

<dl class="method">
<dt id="hou.ShellIO.write">
<code class="descname">write</code><span class="sig-paren">(</span><em>self</em>, <em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ShellIO.write" title="Permalink to this definition"></a></dt>
<dd><p>Implemented as part of the file-like object interface.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.ShopNode">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">ShopNode</code><a class="headerlink" href="#hou.ShopNode" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.Node" title="hou.Node"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.Node</span></code></a></p>
<p>The base class for all SHOP nodes in Houdini. An instance of this class
corresponds to exactly one instance of a node in Houdini.</p>
<p>See hou.Node for more information.</p>
<dl class="method">
<dt id="hou.ShopNode.coshaderNodes">
<code class="descname">coshaderNodes</code><span class="sig-paren">(</span><em>self</em>, <em>parm_name</em><span class="sig-paren">)</span> &#x2192; tuple of hou.ShopNode<a class="headerlink" href="#hou.ShopNode.coshaderNodes" title="Permalink to this definition"></a></dt>
<dd><p>If this SHOP has a co-shader parameter given by parm_name it may
also have an input corresponding to that parameter. This function
will return the tuple of hou.ShopNode assigned as co-shaders to this
SHOP node either via connected input or the operator node path
specified in that parameter.</p>
<p>If the parameter represents a single co-shader, the array will
contain at most one element, however if the parameter refers to a
co-shader array then the tuple may contain more than one element.</p>
<dl class="docutils">
<dt>parm_name</dt>
<dd>Co-shader parameter name specifying the co-shader shop to
return.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hou.ShopNode.definingVopNetNode">
<code class="descname">definingVopNetNode</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.VopNetNode or None<a class="headerlink" href="#hou.ShopNode.definingVopNetNode" title="Permalink to this definition"></a></dt>
<dd><p>If this SHOP is defined by a VOP network, return the hou.VopNetNode
that defines it. Otherwise, return None.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ShopNode.shaderCode">
<code class="descname">shaderCode</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.ShopNode.shaderCode" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.ShopNode.shaderName">
<code class="descname">shaderName</code><span class="sig-paren">(</span><em>self</em>, <em>as_otl_path=True</em>, <em>shader_type_name=None</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.ShopNode.shaderName" title="Permalink to this definition"></a></dt>
<dd><p>Return the name of the shader inside this SHOP. If as_otl_path is
True, returns an opdef: path to the SHOP type. The shader_type_name
is a string indicating the shader context type to use; some nodes
may provide several shader types, and each may have a different
name. This is applicable only to multi-context shader nodes, such as
a vopnet material shop.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ShopNode.shaderString">
<code class="descname">shaderString</code><span class="sig-paren">(</span><em>self</em>, <em>render_type=None</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.ShopNode.shaderString" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Return the shader string generated by this shader for the given
render type. This string is written to the file that is read in by
the renderer.</p>
<dl class="docutils">
<dt>render_type</dt>
<dd><p class="first">A string representing the renderer. If this string is empty or
is *, Houdini uses the default render type for this shader.
Possible render types include VMantra (Mantra), RIB
(RenderMan), OGL (OpenGL), OGL2 (OpenGL 2), and I3D (Image
3D).</p>
<p class="last">You can use hou.ShopNodeType.renderMask to determine the render
types supported by this SHOPs type. You can also use
hou.ShopNodeTypeCategory.renderers to get all the possible
render types. Note that some SHOP types, like the properties
SHOP or the switch SHOP, have a render mask of * to indicate
that they will work with any shader type.</p>
</dd>
</dl>
<p>If you pass in an unknown or unsupported render type, this method
returns an empty string.</p>
</div></blockquote>
<p>&gt; &gt;&gt;&gt; for node_type_name in (v_plastic, ri_matte):
&gt;      hou.node(/shop).createNode(node_type_name)
&gt; 
&gt; &lt;hou.ShopNode of type v_plastic at /shop/v_plastic1&gt;
&gt; &lt;hou.ShopNode of type ri_matte at /shop/ri_matte1&gt;
&gt; 
&gt; &gt;&gt;&gt; for shop in hou.node(/shop).children():
&gt;      for render_type in shop.type().renderMask().split():
&gt;          print shop.name(), supports, render_type
&gt;          print     shader_string:, shop.shaderString(render_type)
&gt;          print
&gt; v_plastic1 supports VMantra
&gt;     shader_string: opdef:/Shop/v_plastic
&gt; 
&gt; v_plastic1 supports OGL
&gt;     shader_string: /shop/v_plastic1
&gt; 
&gt; ri_matte1 supports RIB
&gt;     shader_string: matte
&gt; 
&gt; ri_matte1 supports OGL
&gt;     shader_string: /shop/ri_matte1</p>
</dd></dl>

<dl class="method">
<dt id="hou.ShopNode.shaderType">
<code class="descname">shaderType</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.shaderType enum value<a class="headerlink" href="#hou.ShopNode.shaderType" title="Permalink to this definition"></a></dt>
<dd><p>Returns a hou.shaderType indicating the type of this shader.</p>
<p>Note that this method is a shortcut for self.type().shaderType(),
which calls hou.ShopNodeType.shaderType.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ShopNode.supportedRenderers">
<code class="descname">supportedRenderers</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of str<a class="headerlink" href="#hou.ShopNode.supportedRenderers" title="Permalink to this definition"></a></dt>
<dd><p>Returns a list of strings describing the renderers this shader
supports.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.ShopNode.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.ShopNode.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.ShopNodeType">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">ShopNodeType</code><a class="headerlink" href="#hou.ShopNodeType" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.NodeType" title="hou.NodeType"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.NodeType</span></code></a></p>
<p>This kind of NodeType contains extra attributes specific to SHOP nodes.</p>
<dl class="method">
<dt id="hou.ShopNodeType.renderMask">
<code class="descname">renderMask</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; string<a class="headerlink" href="#hou.ShopNodeType.renderMask" title="Permalink to this definition"></a></dt>
<dd><p>Return a string with space-separated names of the renderers that
this SHOP type supports. Note that some SHOP types, like the switch
SHOP, return * to indicate that they support all renderers.</p>
<p>See hou.ShopNode.shaderString for an example.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ShopNodeType.shaderType">
<code class="descname">shaderType</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; [Hom:hou.shaderType] enum value<a class="headerlink" href="#hou.ShopNodeType.shaderType" title="Permalink to this definition"></a></dt>
<dd><p>Return the type of shader for this SHOP type. For example, this shop
type might be a surface shader or a displacement shader. See
hou.shaderType for the possible shader types.</p>
<p>See also hou.ShopNode.shaderType.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.ShopNodeType.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.ShopNodeType.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.SopNode">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">SopNode</code><a class="headerlink" href="#hou.SopNode" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.Node" title="hou.Node"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.Node</span></code></a></p>
<p>Represents a surface node.</p>
<dl class="method">
<dt id="hou.SopNode.bypass">
<code class="descname">bypass</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SopNode.bypass" title="Permalink to this definition"></a></dt>
<dd><p>Turn this nodes bypass flag on or off, making this node have no
effect.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SopNode.copyNodeSelectionToUserSelection">
<code class="descname">copyNodeSelectionToUserSelection</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SopNode.copyNodeSelectionToUserSelection" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.SopNode.curPoint">
<code class="descname">curPoint</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; Point<a class="headerlink" href="#hou.SopNode.curPoint" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Return this nodes current point. You would typically call this
method from an expression on a node that iterates over a set of
points and re-evaluates the parameter for each point.</p>
<p>This method lets you implement the Python equivalent of Hscripts
local variables. Many of Houdinis SOPs iterate over a set of
points, and for each point they store the current point and then
evaluate a parameter. If the parameter contains a local variable,
Houdini looks up the SOPs current point when evaluating that
variable. For example, the point SOP evaluates the t parameter for
each point, and sets that points position according to the value of
the parameter. If that parameter contains, say, the local variable
$TX, it will evaluate to the x position of the current point.</p>
<p>This method gives you access to the hou.Point representation of
Houdinis current point. Using this point you could evaluate the
position, an attribute value, or do more complex operations like
compute the distance from the point to the origin.</p>
<p>Raises hou.OperationFailed if you call this method from outside a
SOP parameter expression, or if the SOP does not support local
variables.</p>
<p>The following lists Python equivalents for some point-related
Hscript expression local variables. Note that you can also access
local variables from Python using hou.lvar.</p>
</div></blockquote>
<p>&gt; # $PT (Hscript expression) or lvar(PT) (Python):
&gt; pwd().curPoint().number()
&gt; 
&gt; # $NPT (Hscript expression) or lvar(NPT) (Python):
&gt; len(pwd().geometry().iterPoints())
&gt; 
&gt; # $TX (Hscript expression) or lvar(TX) (Python):
&gt; pwd().curPoint().position()[0]
&gt; 
&gt; # $WEIGHT (Hscript expression) or lvar(WEIGHT`) (Python):
&gt; pwd().curPoint().position()[3]
&gt; 
&gt; # $CR (Hscript expression) or lvar(CR) (Python):
&gt; pwd().curPoint().attribValue(Cd)[0]
&gt; 
&gt; # $ID (Hscript expression) or lvar(ID) (Python):
&gt; pwd().curPoint().attribValue(id)
&gt; 
&gt; # $LIFE (Hscript expression) or lvar(LIFE) (Python):
&gt; pwd().curPoint().attribValue(life)
&gt; 
&gt; # $VX (Hscript expression) or lvar(VX) (Python):
&gt; pwd().curPoint().attribValue(v)[0]</p>
</dd></dl>

<dl class="method">
<dt id="hou.SopNode.curPrim">
<code class="descname">curPrim</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; Prim<a class="headerlink" href="#hou.SopNode.curPrim" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Return this nodes current primitive. You would typically call this
method from an expression on a node that iterates over a set of
primitives and re-evaluates the parameter for each primitive.</p>
<p>See hou.SopNode.curPoint for more information.</p>
<p>The following lists Python equivalents for some primitive-related
Hscript expression local variables. Note that you can also access
local variables from Python using hou.lvar.</p>
</div></blockquote>
<p>&gt; # $PR (Hscript expression) or lvar(PR) (Python):
&gt; pwd().curPrim().number()
&gt; 
&gt; # $NPR (Hscript expression) or lvar(NPR) (Python):
&gt; len(pwd().geometry().iterPrims())
&gt; 
&gt; # $NX (Hscript expression) or lvar(NX) (Python):
&gt; pwd().curPrim().attribValue(N)[0]
&gt; pwd().curPrim().normal()[0]
&gt; 
&gt; # $CR (Hscript expression) or lvar(CR) (Python):
&gt; pwd().curPrim().attribValue(Cd)[0]</p>
</dd></dl>

<dl class="method">
<dt id="hou.SopNode.curVertex">
<code class="descname">curVertex</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; Vertex<a class="headerlink" href="#hou.SopNode.curVertex" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Return this nodes current vertex. You would typically call this
method from an expression on a node that iterates over a set of
primitive vertices and re-evaluates the parameter for each vertex.</p>
<p>See hou.SopNode.curPoint for more information.</p>
<p>Note that hou.SopNode.curPrim returns the primitive containing this
vertex returned by this method.</p>
<p>The following lists Python equivalents for some vertex-related
Hscript expression local variables. Note that you can also access
local variables from Python using hou.lvar.</p>
</div></blockquote>
<p>&gt; # $VTX (Hscript expression) or lvar(VTX) (Python):
&gt; pwd().curVertex().number()
&gt; 
&gt; # $NVTX (Hscript expression) or lvar(NVTX) (Python):
&gt; pwd().curPrim().numVertices()</p>
</dd></dl>

<dl class="method">
<dt id="hou.SopNode.displayNode">
<code class="descname">displayNode</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; Node<a class="headerlink" href="#hou.SopNode.displayNode" title="Permalink to this definition"></a></dt>
<dd><p>If this is a subnet SOP, return the SOP inside the subnet with its
display flag on. Otherwise, return None.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SopNode.geometry">
<code class="descname">geometry</code><span class="sig-paren">(</span><em>self</em>, <em>output_index=0</em><span class="sig-paren">)</span> &#x2192; hou.Geometry<a class="headerlink" href="#hou.SopNode.geometry" title="Permalink to this definition"></a></dt>
<dd><p>Return the geometry computed by this SOP node. If the SOP has not
already cooked, this method will cook the SOP.</p>
<p>The returned Geometry object is not frozen. See hou.Geometry.freeze
for more information on frozen Geometry objects.</p>
<p>You can optionally specify the output_index argument to request the
geometry attached to another output on the node. This only applies
to SOP nodes with multiple outputs. If there is no geometry for the
specified output index then None is returned.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SopNode.geometryAtFrame">
<code class="descname">geometryAtFrame</code><span class="sig-paren">(</span><em>self</em>, <em>frame</em>, <em>output_index=0</em><span class="sig-paren">)</span> &#x2192; hou.Geometry<a class="headerlink" href="#hou.SopNode.geometryAtFrame" title="Permalink to this definition"></a></dt>
<dd><p>Return the geometry computed by this SOP node cooked at the
specified frame. If the SOP has not already cooked, this method will
cook the SOP.</p>
<p>The returned Geometry object is frozen. See hou.Geometry.freeze for
more information on frozen Geometry objects.</p>
<p>You can optionally specify the output_index argument to request the
geometry attached to another output on the node. This only applies
to SOP nodes with multiple outputs. If there is no geometry for the
specified output index then None is returned.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SopNode.geometryDelta">
<code class="descname">geometryDelta</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.GeometryDelta<a class="headerlink" href="#hou.SopNode.geometryDelta" title="Permalink to this definition"></a></dt>
<dd><p>Return the geometry delta stored in this SOP node. If the SOP has no
deltas then None is returned.</p>
<p>If the SOP recooks, the geometry delta objects will update to the
SOPs new geometry delta object. If the SOP is deleted, accessing
the geometry delta object will raise a hou.ObjectWasDeleted
exception.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SopNode.hasVerb">
<code class="descname">hasVerb</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; Boolean<a class="headerlink" href="#hou.SopNode.hasVerb" title="Permalink to this definition"></a></dt>
<dd><p>Returns if the node has a verb represenation.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SopNode.inputGeometry">
<code class="descname">inputGeometry</code><span class="sig-paren">(</span><em>self</em>, <em>index</em><span class="sig-paren">)</span> &#x2192; hou.Geometry<a class="headerlink" href="#hou.SopNode.inputGeometry" title="Permalink to this definition"></a></dt>
<dd><p>Return the geometry that is connected to the node input specified by
index.</p>
<p>The returned Geometry object is not frozen. See hou.Geometry.freeze
for more information on frozen Geometry objects.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SopNode.inputGeometryAtFrame">
<code class="descname">inputGeometryAtFrame</code><span class="sig-paren">(</span><em>self</em>, <em>frame</em>, <em>index</em><span class="sig-paren">)</span> &#x2192; hou.Geometry<a class="headerlink" href="#hou.SopNode.inputGeometryAtFrame" title="Permalink to this definition"></a></dt>
<dd><p>Return the geometry that is connected to the node input specified by
index and at the specified frame.</p>
<p>The returned Geometry object is not frozen. See hou.Geometry.freeze
for more information on frozen Geometry objects.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SopNode.isBypassed">
<code class="descname">isBypassed</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.SopNode.isBypassed" title="Permalink to this definition"></a></dt>
<dd><p>Return whether this nodes bypass flag is on.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SopNode.isDisplayFlagSet">
<code class="descname">isDisplayFlagSet</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.SopNode.isDisplayFlagSet" title="Permalink to this definition"></a></dt>
<dd><p>Return whether this nodes display flag is on.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SopNode.isHardLocked">
<code class="descname">isHardLocked</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.SopNode.isHardLocked" title="Permalink to this definition"></a></dt>
<dd><p>Return whether this node is hard-locked. A hard-locked node stores
its data inside the node, and no longer responds to parameter or
input node changes.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SopNode.isHighlightFlagSet">
<code class="descname">isHighlightFlagSet</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.SopNode.isHighlightFlagSet" title="Permalink to this definition"></a></dt>
<dd><p>Return whether this nodes highlight flag is on. When this flag is
turned on, Houdini displays portions of the geometry in yellow in
the viewport, to indicate the operations performed by this SOP.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SopNode.isRenderFlagSet">
<code class="descname">isRenderFlagSet</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.SopNode.isRenderFlagSet" title="Permalink to this definition"></a></dt>
<dd><p>Return whether this nodes render flag is on.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SopNode.isSelectableTemplateFlagSet">
<code class="descname">isSelectableTemplateFlagSet</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.SopNode.isSelectableTemplateFlagSet" title="Permalink to this definition"></a></dt>
<dd><p>Return whether this nodes selectable template flag is on. A
selectable template displays like the display SOP in the viewport,
and you can select it when choosing points, primitives, etc. Note
that only the display SOP will be included in the containing
geometry object or SOP subnet, however, so selectable templates are
only visible while working inside their SOP network.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SopNode.isSoftLocked">
<code class="descname">isSoftLocked</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.SopNode.isSoftLocked" title="Permalink to this definition"></a></dt>
<dd><p>Return whether this node is soft-locked. A soft-locked node stores
position delta information , preventing all but a small set of
manual modeling changes from being made.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SopNode.isTemplateFlagSet">
<code class="descname">isTemplateFlagSet</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.SopNode.isTemplateFlagSet" title="Permalink to this definition"></a></dt>
<dd><p>Returns whether this nodes template flag is on. Templated SOPs are
display as wireframe in the viewport, and you cannot select geometry
from them.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SopNode.isUnloadFlagSet">
<code class="descname">isUnloadFlagSet</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.SopNode.isUnloadFlagSet" title="Permalink to this definition"></a></dt>
<dd><p>Returns whether this nodes unload flag is on.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SopNode.renderNode">
<code class="descname">renderNode</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Node<a class="headerlink" href="#hou.SopNode.renderNode" title="Permalink to this definition"></a></dt>
<dd><p>If this is a subnet SOP, return the SOP inside the subnet with its
render flag on. Otherwise, return None.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SopNode.selection">
<code class="descname">selection</code><span class="sig-paren">(</span><em>self</em>, <em>selection_type</em><span class="sig-paren">)</span> &#x2192; hou.Selection<a class="headerlink" href="#hou.SopNode.selection" title="Permalink to this definition"></a></dt>
<dd><p>Return the current component selection of the specified component
type.</p>
<p>This method is deprecated now that component selections are once
again managed at the viewer level. See
hou.SceneViewer.currentGeometrySelection.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SopNode.setCurPoint">
<code class="descname">setCurPoint</code><span class="sig-paren">(</span><em>self</em>, <em>point_or_none</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SopNode.setCurPoint" title="Permalink to this definition"></a></dt>
<dd><p>Set this nodes current point. You can only call this method from a
Python-defined SOP.</p>
<p>See hou.SopNode.curPoint for an explanation of a SOPs current
point. You would use this method to set the current point from
inside a SOP written in Python, before you evaluate a parameter
containing a local variable referring to the current point. See
hou.Geometry.globPoints for an example.</p>
<p>Note that you can set the current point to None. In this case,
subsequent calls to hou.SopNode.curPoint will raise
hou.OperationFailed. After a Python SOP is done cooking, Houdini
will automatically set the current point back to None.</p>
<p>Raises hou.OperationFailed if called from outside a Python-defined
SOP.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SopNode.setCurPrim">
<code class="descname">setCurPrim</code><span class="sig-paren">(</span><em>self</em>, <em>prim_or_none</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SopNode.setCurPrim" title="Permalink to this definition"></a></dt>
<dd><p>Set this nodes current primitive. You can only call this method
from a Python-defined SOP. See hou.SopNode.setCurPoint for more
information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SopNode.setCurVertex">
<code class="descname">setCurVertex</code><span class="sig-paren">(</span><em>self</em>, <em>vertex_or_none</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SopNode.setCurVertex" title="Permalink to this definition"></a></dt>
<dd><p>Set this nodes current primitive. You can only call this method
from a Python-defined SOP. See hou.SopNode.setCurPoint for more
information.</p>
<p>Note that setting the current vertex will also set the current
primitive to the primitive containing the vertex.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SopNode.setDisplayFlag">
<code class="descname">setDisplayFlag</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SopNode.setDisplayFlag" title="Permalink to this definition"></a></dt>
<dd><p>Turn this nodes display flag on or off.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SopNode.setHardLocked">
<code class="descname">setHardLocked</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SopNode.setHardLocked" title="Permalink to this definition"></a></dt>
<dd><p>Turn this nodes hard-lock flag on or off. Locking a node saves its
current cooked geometry into the node. If you unlock a hard-locked
node, it will discard its locked geometry data and recook, computing
its geometry from its inputs and parameters.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SopNode.setHighlightFlag">
<code class="descname">setHighlightFlag</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SopNode.setHighlightFlag" title="Permalink to this definition"></a></dt>
<dd><p>Turn this nodes highlight flag on or off.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SopNode.setRenderFlag">
<code class="descname">setRenderFlag</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SopNode.setRenderFlag" title="Permalink to this definition"></a></dt>
<dd><p>Turns this nodes render flag on or off.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SopNode.setSelectableTemplateFlag">
<code class="descname">setSelectableTemplateFlag</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SopNode.setSelectableTemplateFlag" title="Permalink to this definition"></a></dt>
<dd><p>Turn this nodes selectable template flag on or off.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SopNode.setSelection">
<code class="descname">setSelection</code><span class="sig-paren">(</span><em>self</em>, <em>selection</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SopNode.setSelection" title="Permalink to this definition"></a></dt>
<dd><p>Sets the current component selection to the supplied value. A
separate selection object is stored for each component type, so
changing the selection this way may not update the viewport if it is
not currently set to show this type of selection.</p>
<p>This method is deprecated now that component selections are once
again managed at the viewer level. See
hou.SceneViewer.setCurrentGeometrySelection.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SopNode.setSoftLocked">
<code class="descname">setSoftLocked</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SopNode.setSoftLocked" title="Permalink to this definition"></a></dt>
<dd><p>Turns this nodes soft-lock flag on or off, allowing a subset of
manual modeling changes to be made to the locked node.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SopNode.setTemplateFlag">
<code class="descname">setTemplateFlag</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SopNode.setTemplateFlag" title="Permalink to this definition"></a></dt>
<dd><p>Turns this nodes template flag on or off.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SopNode.setUnloadFlag">
<code class="descname">setUnloadFlag</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SopNode.setUnloadFlag" title="Permalink to this definition"></a></dt>
<dd><p>Turns this nodes unload flag on or off.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.SopNode.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.SopNode.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

<dl class="method">
<dt id="hou.SopNode.verb">
<code class="descname">verb</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.SopVerb<a class="headerlink" href="#hou.SopNode.verb" title="Permalink to this definition"></a></dt>
<dd><p>Returns the verb associated with a specific node. This allows you to
run the nodes operation on geometry independently of the node
itself.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.SopNodeType">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">SopNodeType</code><a class="headerlink" href="#hou.SopNodeType" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.NodeType" title="hou.NodeType"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.NodeType</span></code></a></p>
<p>This kind of NodeType contains extra attributes specific to SOP nodes.</p>
<dl class="method">
<dt id="hou.SopNodeType.addSelector">
<code class="descname">addSelector</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SopNodeType.addSelector" title="Permalink to this definition"></a></dt>
<dd><p>addSelector(self, name, selector_type, prompt=Select components,
primitive_types=(), group_parm_name=None, group_type_parm_name=None,
input_index=0, input_required=True, allow_dragging=False,
empty_string_selects_all=True) -&gt; hou.Selector</p>
<blockquote>
<div><blockquote>
<div><p>Add a selector to this SOP node type. When the user creates a new
instance of this SOP in the viewer, Houdini will invoke all the
selectors, wait for the user to select geometry, and then connect
input SOPs and fill in group parameters to match what was selected.</p>
<dl class="docutils">
<dt>name</dt>
<dd>A name to give this selector. The name must be unique within
this node type.</dd>
<dt>selector_type</dt>
<dd>The name of the type of selector to use. Different selectors
have different behaviors. For example prims will select only
primitives and is used, for example, by the cookie SOP. points
will select only points, and is used by SOPs like the point SOP.
everything will select any geometry, and is used for SOPs like
xform and blast.</dd>
<dt>prompt</dt>
<dd>A string to display at the bottom of the viewer to instruct the
user what to select.</dd>
<dt>primitive_types</dt>
<dd>A sequence of hou.primType enumeration values to specify what
primitive types are allowed. This parameter has no effect if the
selector does not select primitives. If this sequence is empty,
all primitive types will be allowed.</dd>
<dt>group_parm_name</dt>
<dd>The name of the SOP node parameter containing the group field.
The selector will set this parameter to the string representing
the points, primitives, edges, etc. chosen by the user in the
viewer. If None, the selector will look for a parameter named
group.</dd>
<dt>group_type_parm_name</dt>
<dd>The name of the SOP node parameter containing the menu of
geometry types. If the selector can select multiple geometry
types (e.g. points or primitives), it will set this parameter to
match the type of geometry the user chose. The transform SOP,
for example, has a Group Type parameter that tells it how to
interpret the string in the Group parameter. If None, the
selector will look for a parameter named grouptype.</dd>
<dt>input_index</dt>
<dd>The index of the input connector on the SOP node where the
selector should wire input SOPs. A cookie SOP, for example, has
two input connectors. It has two selectors, one for each input
connector.</dd>
<dt>input_required</dt>
<dd>Whether or not this input is required or optional. If the user
does not select any geometry and the input is not required, the
selector will not wire anything to its input connector.</dd>
<dt>allow_dragging</dt>
<dd>Whether the user is allowed to select the geometry and begin
manipulating the handles with a single mouse drag. A transform
SOP, for example, lets you select the geometry and drag it right
away to transform it. Dragging the geometry forces the selector
to finish immediately, the selector connects the input and sets
the group parameter, and subsequent mouse movements are passed
to the handle which translates the geometry by changing
parameter values.</dd>
<dt>empty_string_selects_all</dt>
<dd>Whether or not to use an empty string in the group parameter if
the user selects all the geometry. If False, Houdini will place
an asterisk (*) in the group parameter when the user selects all
the geometry. Most SOPs use an empty string.</dd>
</dl>
<p>You would typically call this method from the shelf tool script of a
digital asset. For example, you might put the following in the Tools
script section of a Python sop that transforms points (having a
parameter named group):</p>
</div></blockquote>
<p>&gt; hou.sopNodeTypeCategory().nodeTypes()[$HDA_NAME].addSelector(
&gt;     Points to Transform,
&gt;     points,
&gt;     prompt=Select the points to transform and press Enter to complete,
&gt;     group_parm_name=group)</p>
<blockquote>
<div><p>See also hou.Geometry.globPoints and hou.Geometry.globPrims for
information on how to parse the strings the selector puts in the
group field.</p>
<p>See also hou.Selector.</p>
</div></blockquote>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.SopNodeType.selectors">
<code class="descname">selectors</code><span class="sig-paren">(</span><em>self</em>, <em>selector_indices=()</em><span class="sig-paren">)</span> &#x2192; tuple of hou.Selector<a class="headerlink" href="#hou.SopNodeType.selectors" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Return all the selectors for this node type. See
hou.SopNodeType.addSelector and hou.Selector for more information.</div></blockquote>
<p>&gt; def sopSelectorTypes():
&gt;     Return a list of all the SOP selector type names.
&gt;     selector_types = []
&gt;     for node_type in hou.sopNodeTypeCategory().nodeTypes().values():
&gt;         # Skip manager nodes, like shopnets, ropnets, etc.
&gt;         if not isinstance(node_type, hou.SopNodeType):
&gt;             continue
&gt; 
&gt;         for selector in node_type.selectors():
&gt;             selector_type = selector.selectorType()
&gt;             if selector_type not in selector_types:
&gt;                 selector_types.append(selector_type)
&gt;     selector_types.sort()
&gt;     return selector_types
&gt; def sopTypeNamesUsingSelector(selector_type):
&gt;     Given the name of a selector type, return a list of all the SOP
&gt;        node types using that selector.
&gt;     node_types = []
&gt;     for node_type in hou.sopNodeTypeCategory().nodeTypes().values():
&gt;         # Skip manager nodes, like shopnets, ropnets, etc.
&gt;         if not isinstance(node_type, hou.SopNodeType):
&gt;             continue
&gt; 
&gt;         for selector in node_type.selectors():
&gt;             if selector.selectorType() == selector_type:
&gt;                 node_types.append(node_type)
&gt; 
&gt;     result = [node_type.name() for node_type in node_types]
&gt;     result.sort()
&gt;     return result</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.SopNodeType.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.SopNodeType.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.SopVerb">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">SopVerb</code><a class="headerlink" href="#hou.SopVerb" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Represents the code of a surface node.</p>
<dl class="method">
<dt id="hou.SopVerb.execute">
<code class="descname">execute</code><span class="sig-paren">(</span><em>self</em>, <em>destgeo</em>, <em>inputgeolist</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SopVerb.execute" title="Permalink to this definition"></a></dt>
<dd><p>Applies the verb to the giving destination hou.Geometry. The input
list is a list of hou.Geometry corresponding to the source nodes
inputs. The parameters used in execution are whatever was set with
the setParms or loadParmsFromNode functions. The parameters are
initialized with the node defaults.</p>
<p>NOTE: Node defaults may change between versions.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SopVerb.loadParmsFromNode">
<code class="descname">loadParmsFromNode</code><span class="sig-paren">(</span><em>self</em>, <em>sopnode</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SopVerb.loadParmsFromNode" title="Permalink to this definition"></a></dt>
<dd><p>Initializes all the parameters of this verb from the parameters of a
specific hou.SopNode. Useful for cloning an existing node instances
behaviour.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SopVerb.minNumInputs">
<code class="descname">minNumInputs</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; integer<a class="headerlink" href="#hou.SopVerb.minNumInputs" title="Permalink to this definition"></a></dt>
<dd><p>Returns the minimum number of geometry inputs required for this verb
to compute succesfully.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SopVerb.parms">
<code class="descname">parms</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; dictionary<a class="headerlink" href="#hou.SopVerb.parms" title="Permalink to this definition"></a></dt>
<dd><p>Returns a dictionary of parameter name / value pairs currently set
on this verb. This will be the complete list understood, including
defaults. Multiparms are represented as a sub list of dictionaries.</p>
<p>This uses ParmTuple names, not channel names.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SopVerb.setParms">
<code class="descname">setParms</code><span class="sig-paren">(</span><em>self</em>, <em>parmdictionary</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SopVerb.setParms" title="Permalink to this definition"></a></dt>
<dd><p>Updates a subset of parmeters on this verb with those specified in
the dictionary. Exceptions are raised if attempts are made to set
non-existent parameters or with incorrect types.</p>
<p>This uses ParmTuple names, not channel names. So for a transform you
would use xform.setParms({t:(2,0,0)}) rather than tx.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.SopVerb.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.SopVerb.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.StickyNote">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">StickyNote</code><a class="headerlink" href="#hou.StickyNote" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.NetworkMovableItem" title="hou.NetworkMovableItem"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.NetworkMovableItem</span></code></a></p>
<p>Represents a sticky note.</p>
<p>To create a sticky note, use the hou.Node.createStickyNote method on the
node inside which you want to create the note. To get an existing sticky
note, use the hou.Node.findStickyNote method on the node containing the
sticky note. To get a list of all notes in a network, use the
hou.Node.stickyNotes method on the containing node.</p>
<dl class="method">
<dt id="hou.StickyNote.asCode">
<code class="descname">asCode</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.StickyNote.asCode" title="Permalink to this definition"></a></dt>
<dd><p>asCode(self, brief=False, recurse=False, save_box_contents=False,
save_channels_only=False, save_creation_commands=False,
save_keys_in_frames=False, save_parm_values_only=False,
save_spare_parms=False, function_name=None) -&gt; str</p>
<blockquote>
<div><p>Prints the Python code necessary to recreate a sticky note.</p>
<p>See hou.Node.asCode for information on the keyword arguments.</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.StickyNote.destroy">
<code class="descname">destroy</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.StickyNote.destroy" title="Permalink to this definition"></a></dt>
<dd><p>Remove and delete the sticky note.</p>
</dd></dl>

<dl class="method">
<dt id="hou.StickyNote.drawBackground">
<code class="descname">drawBackground</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.StickyNote.drawBackground" title="Permalink to this definition"></a></dt>
<dd><p>Returns whether the sticky note will draw a colored background and
title bar.</p>
</dd></dl>

<dl class="method">
<dt id="hou.StickyNote.isMinimized">
<code class="descname">isMinimized</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.StickyNote.isMinimized" title="Permalink to this definition"></a></dt>
<dd><p>Returns whether the sticky note is minimized.</p>
</dd></dl>

<dl class="method">
<dt id="hou.StickyNote.minimizedSize">
<code class="descname">minimizedSize</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Vector2<a class="headerlink" href="#hou.StickyNote.minimizedSize" title="Permalink to this definition"></a></dt>
<dd><p>Return the size of this items tile in the network editor graph if
it is minimized. Returned as a Vector2.</p>
</dd></dl>

<dl class="method">
<dt id="hou.StickyNote.resize">
<code class="descname">resize</code><span class="sig-paren">(</span><em>self</em>, <em>vector2</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.StickyNote.resize" title="Permalink to this definition"></a></dt>
<dd><p>Resizes a sticky note by the increments in the given hou.Vector2.
Use setSize() to set the notes absolute size.</p>
</dd></dl>

<dl class="method">
<dt id="hou.StickyNote.restoredSize">
<code class="descname">restoredSize</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Vector2<a class="headerlink" href="#hou.StickyNote.restoredSize" title="Permalink to this definition"></a></dt>
<dd><p>Return the size of this items tile in the network editor graph if
it is not minimized. Returned as a Vector2.</p>
</dd></dl>

<dl class="method">
<dt id="hou.StickyNote.setBounds">
<code class="descname">setBounds</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.StickyNote.setBounds" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.StickyNote.setDrawBackground">
<code class="descname">setDrawBackground</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.StickyNote.setDrawBackground" title="Permalink to this definition"></a></dt>
<dd><p>Turns on or off the drawing of the colored background for the text
and the title bar in the network editor. Turning this on makes the
sticky note easier to see. Turning it off allows the text to be less
obtrusive.</p>
</dd></dl>

<dl class="method">
<dt id="hou.StickyNote.setMinimized">
<code class="descname">setMinimized</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.StickyNote.setMinimized" title="Permalink to this definition"></a></dt>
<dd><p>Minimizes or restores the sticky note.</p>
</dd></dl>

<dl class="method">
<dt id="hou.StickyNote.setSize">
<code class="descname">setSize</code><span class="sig-paren">(</span><em>self</em>, <em>size</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.StickyNote.setSize" title="Permalink to this definition"></a></dt>
<dd><p>Sets the size of this sticky note to the given hou.Vector2 size
parameter. Use resize() to set the notes size relative to its
current size.</p>
</dd></dl>

<dl class="method">
<dt id="hou.StickyNote.setText">
<code class="descname">setText</code><span class="sig-paren">(</span><em>self</em>, <em>str</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.StickyNote.setText" title="Permalink to this definition"></a></dt>
<dd><p>Sets the text of the sticky note.</p>
</dd></dl>

<dl class="method">
<dt id="hou.StickyNote.setTextColor">
<code class="descname">setTextColor</code><span class="sig-paren">(</span><em>self</em>, <em>color</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.StickyNote.setTextColor" title="Permalink to this definition"></a></dt>
<dd><p>Sets the color of the text of the sticky note. The color parameter
should be a hou.Color object.</p>
</dd></dl>

<dl class="method">
<dt id="hou.StickyNote.setTextSize">
<code class="descname">setTextSize</code><span class="sig-paren">(</span><em>self</em>, <em>size</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.StickyNote.setTextSize" title="Permalink to this definition"></a></dt>
<dd><p>Sets the size of the text of the sticky note. The size value
specifies the height (in network units) of the font.</p>
</dd></dl>

<dl class="method">
<dt id="hou.StickyNote.text">
<code class="descname">text</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.StickyNote.text" title="Permalink to this definition"></a></dt>
<dd><p>Return the text displayed in the sticky note.</p>
</dd></dl>

<dl class="method">
<dt id="hou.StickyNote.textColor">
<code class="descname">textColor</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Color<a class="headerlink" href="#hou.StickyNote.textColor" title="Permalink to this definition"></a></dt>
<dd><p>Return the color of the text displayed in the sticky note.</p>
</dd></dl>

<dl class="method">
<dt id="hou.StickyNote.textSize">
<code class="descname">textSize</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#hou.StickyNote.textSize" title="Permalink to this definition"></a></dt>
<dd><p>Return the size of the text displayed in the sticky note, expressed
as the height of the font in network units.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.StickyNote.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.StickyNote.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.StringKeyframe">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">StringKeyframe</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.StringKeyframe" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.BaseKeyframe" title="hou.BaseKeyframe"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.BaseKeyframe</span></code></a></p>
<dl class="method">
<dt id="hou.StringKeyframe.asJSON">
<code class="descname">asJSON</code><span class="sig-paren">(</span><em>self</em>, <em>brief=False</em>, <em>save_keys_in_frames=False</em><span class="sig-paren">)</span> &#x2192; dict<a class="headerlink" href="#hou.StringKeyframe.asJSON" title="Permalink to this definition"></a></dt>
<dd><p>Returns a JSON dictionary that describes the keyframe. The
dictionary includes the keyframe time and the expression if it has
been set. If the save_keys_in_frames parameter is set to True, a
frame number is used instead of a time.</p>
<p>See also the fromJSON method.</p>
</dd></dl>

<dl class="method">
<dt id="hou.StringKeyframe.evaluatedType">
<code class="descname">evaluatedType</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.parmData enum value<a class="headerlink" href="#hou.StringKeyframe.evaluatedType" title="Permalink to this definition"></a></dt>
<dd><p>Return the data type of the keyframes evaluated value. For string
keyframes this method returns hou.parmData.String.</p>
</dd></dl>

<dl class="method">
<dt id="hou.StringKeyframe.fromJSON">
<code class="descname">fromJSON</code><span class="sig-paren">(</span><em>self</em>, <em>keyframe_dict</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.StringKeyframe.fromJSON" title="Permalink to this definition"></a></dt>
<dd><p>Sets the keyframe time and expression using the key/value pairs from
a JSON dictionary.</p>
<p>See also the asJSON method.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.StringKeyframe.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.StringKeyframe.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.StringParmTemplate">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">StringParmTemplate</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.StringParmTemplate" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.ParmTemplate" title="hou.ParmTemplate"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.ParmTemplate</span></code></a></p>
<p>Describes a parameter tuple containing string values. These values can
be arbitrary strings or references to files or nodes</p>
<p>Note that string parameters may also be menu parameters. String
parameters with menus are different from hou.MenuParmTemplate objects
because menu parm templates evaluate to integers.</p>
<dl class="method">
<dt id="hou.StringParmTemplate.defaultExpression">
<code class="descname">defaultExpression</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of strings<a class="headerlink" href="#hou.StringParmTemplate.defaultExpression" title="Permalink to this definition"></a></dt>
<dd><p>Return the default expression for new parameter instances.</p>
<p>The default expression takes precendence over the default value. If
a component has no default expression (i.e. an empty string), then
the default value is used for new parameter instances.</p>
<p>Note that the default expression language is needed to interpret the
meaning of the default expression.</p>
</dd></dl>

<dl class="method">
<dt id="hou.StringParmTemplate.defaultExpressionLanguage">
<code class="descname">defaultExpressionLanguage</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.scriptLanguage<a class="headerlink" href="#hou.StringParmTemplate.defaultExpressionLanguage" title="Permalink to this definition"></a></dt>
<dd><p>Return the default expression language for new parameter instances.</p>
<p>The default expression language only applies if the default
expression is set. If the default expression of a component is not
set, then the expression language is set to
hou.scriptLanguage.Hscript.</p>
</dd></dl>

<dl class="method">
<dt id="hou.StringParmTemplate.defaultValue">
<code class="descname">defaultValue</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of str<a class="headerlink" href="#hou.StringParmTemplate.defaultValue" title="Permalink to this definition"></a></dt>
<dd><p>Return the default value for new parameter instances.</p>
<p>The number of strings in the return value is the same as the number
of components in the parm template.</p>
</dd></dl>

<dl class="method">
<dt id="hou.StringParmTemplate.fileType">
<code class="descname">fileType</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.fileType enum value<a class="headerlink" href="#hou.StringParmTemplate.fileType" title="Permalink to this definition"></a></dt>
<dd><p>Return the file type of this string parameter. The file type applies
only when stringType() == hou.stringParmType.FileReference. Only
hou.fileType.Any, hou.fileType.Image, and hou.fileType.Geometry are
supported by dialog scripts.</p>
<p>See hou.fileType for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.StringParmTemplate.iconNames">
<code class="descname">iconNames</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of str<a class="headerlink" href="#hou.StringParmTemplate.iconNames" title="Permalink to this definition"></a></dt>
<dd><p>Return the tuple of icons corresponding to the menu items. If there
are no icons, returns a tuple of empty strings.</p>
<p>These icons are used when this parm template uses a menu.</p>
</dd></dl>

<dl class="method">
<dt id="hou.StringParmTemplate.itemGeneratorScript">
<code class="descname">itemGeneratorScript</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.StringParmTemplate.itemGeneratorScript" title="Permalink to this definition"></a></dt>
<dd><p>itemGeneratorScriptLanguage(self) -&gt; hou.scriptLanguage enum value</p>
<blockquote>
<div>Return the script used to generate menu items, or an empty string if
there is no such script.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.StringParmTemplate.itemGeneratorScriptLanguage">
<code class="descname">itemGeneratorScriptLanguage</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.StringParmTemplate.itemGeneratorScriptLanguage" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.StringParmTemplate.menuItems">
<code class="descname">menuItems</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of str<a class="headerlink" href="#hou.StringParmTemplate.menuItems" title="Permalink to this definition"></a></dt>
<dd><p>Return the tuple of internal menu names. If this string does not use
a menu, returns an empty tuple.</p>
<p>These internal menu names are not displayed in the UI, but they can
be passed to hou.Parm.set and will be returned by
hou.Parm.evalAsString for menu parameters.</p>
</dd></dl>

<dl class="method">
<dt id="hou.StringParmTemplate.menuLabels">
<code class="descname">menuLabels</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of str<a class="headerlink" href="#hou.StringParmTemplate.menuLabels" title="Permalink to this definition"></a></dt>
<dd><p>Return the tuple of menu labels displayed in the UI.</p>
</dd></dl>

<dl class="method">
<dt id="hou.StringParmTemplate.menuType">
<code class="descname">menuType</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.menuType enum value<a class="headerlink" href="#hou.StringParmTemplate.menuType" title="Permalink to this definition"></a></dt>
<dd><p>Return the type of menu. See hou.menuType for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.StringParmTemplate.setDefaultExpression">
<code class="descname">setDefaultExpression</code><span class="sig-paren">(</span><em>self</em>, <em>default_expression</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.StringParmTemplate.setDefaultExpression" title="Permalink to this definition"></a></dt>
<dd><p>Set the default expression for new parameter instances to a sequence
of strings.</p>
<p>See the hou.StringParmTemplate.defaultExpression method for more
information. Note that if the number of strings in the sequence is
different from the number of components in the parm template, any
extra values will be discarded and any missing expressions will
become the empty string.</p>
</dd></dl>

<dl class="method">
<dt id="hou.StringParmTemplate.setDefaultExpressionLanguage">
<code class="descname">setDefaultExpressionLanguage</code><span class="sig-paren">(</span><em>self</em>, <em>default_expression_language</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.StringParmTemplate.setDefaultExpressionLanguage" title="Permalink to this definition"></a></dt>
<dd><p>Set the default expression language for new parameter instances to a
sequence of hou.scriptLanguage values.</p>
<p>See the defaultExpressionLanguage method for more information. Note
that if the number of hou.scriptLanguage values in the sequence is
different from the number of components in the parm template, any
extra values will be discarded and any missing expression languages
will become hou.scriptLanguage.Hscript.</p>
</dd></dl>

<dl class="method">
<dt id="hou.StringParmTemplate.setDefaultValue">
<code class="descname">setDefaultValue</code><span class="sig-paren">(</span><em>self</em>, <em>default_value</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.StringParmTemplate.setDefaultValue" title="Permalink to this definition"></a></dt>
<dd><p>Set the default value for new parameter instances to a sequence of
strings.</p>
<p>See the defaultValue method for more information. Note that if the
number of strings in the sequence is different from the number of
components in the parm template, any extra values will be discarded
and any missing values will become the last value in the sequence or
an empty string if the sequence is empty.</p>
</dd></dl>

<dl class="method">
<dt id="hou.StringParmTemplate.setFileType">
<code class="descname">setFileType</code><span class="sig-paren">(</span><em>self</em>, <em>file_type</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.StringParmTemplate.setFileType" title="Permalink to this definition"></a></dt>
<dd><p>Set the type of this string parameter to a hou.fileType enum value.</p>
<p>See the fileType method for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.StringParmTemplate.setIconNames">
<code class="descname">setIconNames</code><span class="sig-paren">(</span><em>self</em>, <em>icon_names</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.StringParmTemplate.setIconNames" title="Permalink to this definition"></a></dt>
<dd><p>Set the icon names to the given sequence of strings.</p>
</dd></dl>

<dl class="method">
<dt id="hou.StringParmTemplate.setItemGeneratorScript">
<code class="descname">setItemGeneratorScript</code><span class="sig-paren">(</span><em>self</em>, <em>item_generator_script</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.StringParmTemplate.setItemGeneratorScript" title="Permalink to this definition"></a></dt>
<dd><p>Set the script used to generate menu items.</p>
<p>See the itemGeneratorScript method for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.StringParmTemplate.setItemGeneratorScriptLanguage">
<code class="descname">setItemGeneratorScriptLanguage</code><span class="sig-paren">(</span><em>self</em>, <em>language</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.StringParmTemplate.setItemGeneratorScriptLanguage" title="Permalink to this definition"></a></dt>
<dd><p>Set the script language used to generate menu items to a
hou.scriptLanguage enum value.</p>
<p>See the itemGeneratorScriptLanguage method for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.StringParmTemplate.setMenuItems">
<code class="descname">setMenuItems</code><span class="sig-paren">(</span><em>self</em>, <em>menu_items</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.StringParmTemplate.setMenuItems" title="Permalink to this definition"></a></dt>
<dd><p>Set the internal menu names to the given sequence of strings.</p>
<p>See the menuItems method for more information.</p>
<p>If the new number of menu items is less than the old number, the
menu labels will be shortened and the default value will be modified
if it is out of range.</p>
</dd></dl>

<dl class="method">
<dt id="hou.StringParmTemplate.setMenuLabels">
<code class="descname">setMenuLabels</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.StringParmTemplate.setMenuLabels" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.StringParmTemplate.setMenuType">
<code class="descname">setMenuType</code><span class="sig-paren">(</span><em>self</em>, <em>menu_type</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.StringParmTemplate.setMenuType" title="Permalink to this definition"></a></dt>
<dd><p>Set the type of menu to a hou.menuType enum value.</p>
<p>See the menuType method for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.StringParmTemplate.setStringType">
<code class="descname">setStringType</code><span class="sig-paren">(</span><em>self</em>, <em>string_type</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.StringParmTemplate.setStringType" title="Permalink to this definition"></a></dt>
<dd><p>Set the type of this string parameter to a hou.stringParmType enum
value.</p>
<p>See the stringType method for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.StringParmTemplate.stringType">
<code class="descname">stringType</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.stringParmType enum value<a class="headerlink" href="#hou.StringParmTemplate.stringType" title="Permalink to this definition"></a></dt>
<dd><p>Return the type of this string parameter. This type determines
whether the parameter has special selection controls to choose a
file path or the paths to one or more nodes.</p>
<p>See hou.stringParmType for more information.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.StringParmTemplate.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.StringParmTemplate.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.StyleSheet">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">StyleSheet</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.StyleSheet" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A class that represents a Houdini style sheet. It can be used to
evaluate, test, and debug style sheet output.</p>
<p>Unlike the hou.styles module, the style sheets represented by this class
are not saved anywhere. They are parsed style sheets that can be
evaluated for particular objects and geometry. This allows you to debug
the operation of your style sheets outside of mantra. It also allows
building SOPs which evaluate style information to apply it to a more
specific target.</p>
<dl class="method">
<dt id="hou.StyleSheet.asJSON">
<code class="descname">asJSON</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.StyleSheet.asJSON" title="Permalink to this definition"></a></dt>
<dd><p>Returns a string containing the JSON that represents the style
sheet. If the style sheet was constructed from a string argument,
the original string will be returned even if there were parsing
errors. If this style sheet was cloned with a specific target, the
JSON string is generated from the style information that applies to
that target.</p>
</dd></dl>

<dl class="method">
<dt id="hou.StyleSheet.clone">
<code class="descname">clone</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.StyleSheet<a class="headerlink" href="#hou.StyleSheet.clone" title="Permalink to this definition"></a></dt>
<dd><p>Makes an identical copy of an existing style sheet object.</p>
</dd></dl>

<dl class="method">
<dt id="hou.StyleSheet.cloneWithAddedStyleSheet">
<code class="descname">cloneWithAddedStyleSheet</code><span class="sig-paren">(</span><em>self</em>, <em>stylesheet</em>, <em>target</em><span class="sig-paren">)</span> &#x2192; hou.StyleSheet<a class="headerlink" href="#hou.StyleSheet.cloneWithAddedStyleSheet" title="Permalink to this definition"></a></dt>
<dd><p>Makes a copy of an existing style sheet object combined with another
style sheet object. The added styles are given a lower priority than
the styles already in the style sheet. In addition, a target
argument can be provided which is a JSON formatted string describing
a target condition which must be satisfied in order for the added
styles to be applied. This function can therefore be used to build
an object level style sheet by combining per-primitive style sheets
from the objects geometry.</p>
</dd></dl>

<dl class="method">
<dt id="hou.StyleSheet.cloneWithObject">
<code class="descname">cloneWithObject</code><span class="sig-paren">(</span><em>self</em>, <em>object</em><span class="sig-paren">)</span> &#x2192; hou.StyleSheet<a class="headerlink" href="#hou.StyleSheet.cloneWithObject" title="Permalink to this definition"></a></dt>
<dd><p>Makes a copy of an existing style sheet object which contains only
the styling information that applies to the provided hou.ObjNode.</p>
</dd></dl>

<dl class="method">
<dt id="hou.StyleSheet.cloneWithPrim">
<code class="descname">cloneWithPrim</code><span class="sig-paren">(</span><em>self</em>, <em>prim</em><span class="sig-paren">)</span> &#x2192; hou.StyleSheet<a class="headerlink" href="#hou.StyleSheet.cloneWithPrim" title="Permalink to this definition"></a></dt>
<dd><p>Makes a copy of an existing style sheet object which contains only
the styling information that applies to the provided hou.Prim.</p>
</dd></dl>

<dl class="method">
<dt id="hou.StyleSheet.cloneWithShape">
<code class="descname">cloneWithShape</code><span class="sig-paren">(</span><em>self</em>, <em>shape_name</em>, <em>prim</em><span class="sig-paren">)</span> &#x2192; hou.StyleSheet<a class="headerlink" href="#hou.StyleSheet.cloneWithShape" title="Permalink to this definition"></a></dt>
<dd><p>Makes a copy of an existing style sheet object which contains only
the styling information that applies to the named shape in the
provided crowd agent hou.PackedPrim.</p>
</dd></dl>

<dl class="method">
<dt id="hou.StyleSheet.errors">
<code class="descname">errors</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.StyleSheet.errors" title="Permalink to this definition"></a></dt>
<dd><p>Returns any errors generated while parsing the style sheet. If there
are no errors, an empty string is returned. For style sheet objects
returned from any of the cloneWith methods, the returned string will
always be empty.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.StyleSheet.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.StyleSheet.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.SubnetIndirectInput">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">SubnetIndirectInput</code><a class="headerlink" href="#hou.SubnetIndirectInput" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.IndirectInput" title="hou.IndirectInput"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.IndirectInput</span></code></a></p>
<p>A node-like item that appears inside subnets and corresponds to the node
wired into the subnet.</p>
<p>For example, suppose you have a font SOP, polyextrude SOP, and facet SOP
connected together in a chain. If you collapse the polyextrude and facet
SOPs into a subnet, youre left with a font SOP connected to a subnet
SOP. Inside the subnet SOP is subnet indirect input #1 connected to a
polyextrude SOP, which is connected to the facet SOP.</p>
<p>Each subnet indirect input is numbered starting from 1 and corresponds
to an input connector on the subnet. (See hou.NodeConnection for more
information on input connectors.)</p>
<p>The names of the subnet indirect inputs in the network pane correspond
to the contents of the Input #n Label parameters on the subnet node,
where n is the number.</p>
<dl class="method">
<dt id="hou.SubnetIndirectInput.inputConnections">
<code class="descname">inputConnections</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.NodeConnection<a class="headerlink" href="#hou.SubnetIndirectInput.inputConnections" title="Permalink to this definition"></a></dt>
<dd><p>Returns an empty tuple. This method exists to mirror similar methods
on hou.Node and hou.NetworkDot. This allows these network items to
be treated in a more uniform way in Python code.</p>
</dd></dl>

<dl class="method">
<dt id="hou.SubnetIndirectInput.number">
<code class="descname">number</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.SubnetIndirectInput.number" title="Permalink to this definition"></a></dt>
<dd><p>Return the number of the corresponding input connector on the
subnet. Note that the first input corresponds to the number 1, not
0.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.SubnetIndirectInput.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.SubnetIndirectInput.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.Surface">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">Surface</code><a class="headerlink" href="#hou.Surface" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.Prim" title="hou.Prim"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.Prim</span></code></a></p>
<p>A Surface is a kind of geometry primitive (Prim object) that contains a
two dimensional grid of vertices (Vertex objects). How these vertices
are used depends on the type of surface: meshes, for example, use the
vertices to define a quadrilateral mesh, while NURBS surfaces use them
as control points.</p>
<p>A hou.Face, on the other hand, stores a sequence of vertices, and might
be a polygon or NURBS curve.</p>
<dl class="method">
<dt id="hou.Surface.addCol">
<code class="descname">addCol</code><span class="sig-paren">(</span><em>self</em>, <em>after=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Surface.addCol" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Add a column of vertices after the given u (i.e. column) index. You
would typically call this method from the code of a Python-defined
SOP.</p>
<p>This method also adds one point per vertex added. The new points are
located at the origin until you move them.</p>
<p>The u (i.e. column) index after may be negative, in which case the
indexing starts from the end. By default, after is -1, meaning that
the new column will go after the last column. Raises
hou.OperationFailed if the after index is invalid.</p>
</div></blockquote>
<p>&gt; 
&gt; # This code will work from inside a Python SOP, but not from the Python
&gt; # shell.
&gt; def vertexPos(vertex):
&gt;     return hou.Vector3(vertex.point().position())
&gt; 
&gt; # Build a NURBS surface.
&gt; geo = hou.pwd().geometry()
&gt; surf = geo.createNURBSSurface(10, 10)
&gt; 
&gt; # Add a new column, and set the new point positions to the average of
&gt; # the adjacent point positions.
&gt; surf.addCol(after=7)
&gt; for v_index in range(surf.numRows()):
&gt;     vertex_before = surf.vertex(7, v_index)
&gt;     vertex_after = surf.vertex(9, v_index)
&gt;     surf.vertex(8, v_index).point().setPosition(
&gt;         (vertexPos(vertex_before) + vertexPos(vertex_after)) * 0.5)</p>
</dd></dl>

<dl class="method">
<dt id="hou.Surface.addRow">
<code class="descname">addRow</code><span class="sig-paren">(</span><em>self</em>, <em>after=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Surface.addRow" title="Permalink to this definition"></a></dt>
<dd><p>Add a row of vertices after the given v (i.e. row) index. The new
vertices are located at the origin until you move them. You would
typically call this method from the code of a Python-defined SOP.</p>
<p>See hou.Surface.addCol for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Surface.attribValueAt">
<code class="descname">attribValueAt</code><span class="sig-paren">(</span><em>self</em>, <em>attrib_or_name</em>, <em>u</em>, <em>v</em>, <em>du=0</em>, <em>dv=0</em><span class="sig-paren">)</span> &#x2192; int, float, str<a class="headerlink" href="#hou.Surface.attribValueAt" title="Permalink to this definition"></a></dt>
<dd><p>or tuple</p>
<p>Return an attribute value at a normalized (u, v) parametric position
on the surface. If du and dv are both 0, returns the interpolated
attribute value; otherwise, returns the (partial) derivative of the
attribute value.</p>
<p>Raises hou.OperationFailed if the attribute is not a point or vertex
attribute. If you want a primitive attribute value, it doesnt vary
across the surface, so use hou.Prim.attribValue.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Surface.isClosedInU">
<code class="descname">isClosedInU</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Surface.isClosedInU" title="Permalink to this definition"></a></dt>
<dd><p>Return whether the first and last columns of vertices are connected.</p>
<p>A grid, for example, is open in both U and V. A tube is open in one
of U or V and closed in the other. A torus is closed in both U and
V.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Surface.isClosedInV">
<code class="descname">isClosedInV</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Surface.isClosedInV" title="Permalink to this definition"></a></dt>
<dd><p>Return whether the first and last rows of vertices are connected.</p>
<p>See hou.Surface.isClosedInU for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Surface.normalAt">
<code class="descname">normalAt</code><span class="sig-paren">(</span><em>self</em>, <em>u</em>, <em>v</em><span class="sig-paren">)</span> &#x2192; Vector3<a class="headerlink" href="#hou.Surface.normalAt" title="Permalink to this definition"></a></dt>
<dd><p>Given normalized (i.e. from 0 to 1) u and v values, returns the
normal of the surface at that parametric location. The normal is a
vector that is perpendicular to the surface at that location.</p>
<p>The normal vector is normalized (i.e. it is a unit vector, so its
length is 1).</p>
<p>See the surface_wires cookbook example for an example.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Surface.numCols">
<code class="descname">numCols</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Surface.numCols" title="Permalink to this definition"></a></dt>
<dd><p>Return the number of columns in the 2D array of vertices.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Surface.numRows">
<code class="descname">numRows</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Surface.numRows" title="Permalink to this definition"></a></dt>
<dd><p>Return the number of rows in the 2D array of vertices.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Surface.positionAt">
<code class="descname">positionAt</code><span class="sig-paren">(</span><em>self</em>, <em>u</em>, <em>v</em><span class="sig-paren">)</span> &#x2192; hou.Vector3<a class="headerlink" href="#hou.Surface.positionAt" title="Permalink to this definition"></a></dt>
<dd><p>Given normalized (i.e. from 0 to 1) u and v values, returns the
position of the surface at that parametric location.</p>
<p>See the surface_wires cookbook example for an example.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.Surface.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.Surface.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

<dl class="method">
<dt id="hou.Surface.vertex">
<code class="descname">vertex</code><span class="sig-paren">(</span><em>self</em>, <em>u_index</em>, <em>v_index</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Surface.vertex" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Return an element in the 2D array of vertices, given the u (column)
and v (row) indices into the array.</p>
<p>Negative indices are allowed, in which case Houdini will index
starting from the last vertex.</p>
<p>For non-negative indices, this method is roughly equivalent to
writing surf.vertices()[v_index * surf.numCols() + u_index].</p>
<p>Raises hou.OperationFailed if the u or v indices are invalid.</p>
</div></blockquote>
<p>&gt; # Use a grid SOP to create a NURBS grid with 3 rows and 2 columns.
&gt; geo = hou.node(/obj).createNode(geo).createNode(grid).geometry()
&gt; grid_node = geo.sopNode()
&gt; grid_node.setDisplayFlag(True)
&gt; for name, value in (type, nurbs), (rows, 5), (cols, 4):
&gt;     grid_node.parm(name).set(value)
&gt; 
&gt; # Print out the x positions of all the vertices in the surface.
&gt; surf = geo.iterPrims()[0]
&gt; for v_index in surf.numRows():
&gt;     for u_index in surf.numCols():
&gt;         print surf.vertex(u_index, v_index).point().position()[0],
&gt;     print</p>
<blockquote>
<div>See also:</div></blockquote>
<ul class="simple">
<li>hou.Prim.vertices</li>
<li>hou.Surface.verticesInCol</li>
<li>hou.Surface.verticesInRow</li>
<li>hou.Geometry.iterPrims</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="hou.Surface.verticesInCol">
<code class="descname">verticesInCol</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.Surface.verticesInCol" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.Surface.verticesInRow">
<code class="descname">verticesInRow</code><span class="sig-paren">(</span><em>self</em>, <em>v_index</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Surface.verticesInRow" title="Permalink to this definition"></a></dt>
<dd><p>Given a v (i.e. row) index, return a tuple containing all the
vertices in that row.</p>
<p>See also hou.Prim.vertices.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.SystemExit">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">SystemExit</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.SystemExit" title="Permalink to this definition"></a></dt>
<dd><dl class="method">
<dt id="hou.SystemExit.code">
<code class="descname">code</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.SystemExit.code" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.Take">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">Take</code><a class="headerlink" href="#hou.Take" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.takes</li>
</ul>
</div></blockquote>
<dl class="method">
<dt id="hou.Take.addChildTake">
<code class="descname">addChildTake</code><span class="sig-paren">(</span><em>self</em>, <em>name</em><span class="sig-paren">)</span> &#x2192; hou.Take<a class="headerlink" href="#hou.Take.addChildTake" title="Permalink to this definition"></a></dt>
<dd><p>Create a new take with the given name and add it as a child to this
take.</p>
<p>If no name is specified then the take will have a generated name
based on the default take name.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Take.addNodeBypassFlag">
<code class="descname">addNodeBypassFlag</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.Take.addNodeBypassFlag" title="Permalink to this definition"></a></dt>
<dd><p>removeNodeBypassFlag(self, node)</p>
<blockquote>
<div><p>Exclude the given nodes bypass flag from this take making it
uneditable in this take.</p>
<p>This method does nothing if the nodes bypass flag is not included
in the take.</p>
<p>Raise hou.OperationFailed if the node argument is None. Raise
hou.OperationFailed if this take is not the current take.</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.Take.addNodeDisplayFlag">
<code class="descname">addNodeDisplayFlag</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.Take.addNodeDisplayFlag" title="Permalink to this definition"></a></dt>
<dd><p>removeNodeDisplayFlag(self, node)</p>
<blockquote>
<div><p>Exclude the given nodes display flag from this take making it
uneditable in this take.</p>
<p>This method does nothing if the nodes display flag is not included
in the take.</p>
<p>Raise hou.OperationFailed if the node argument is None. Raise
hou.OperationFailed if this take is not the current take.</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.Take.addNodeRenderFlag">
<code class="descname">addNodeRenderFlag</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.Take.addNodeRenderFlag" title="Permalink to this definition"></a></dt>
<dd><p>removeNodeRenderFlag(self, node)</p>
<blockquote>
<div><p>Exclude the given nodes render flag from this take making it
uneditable in this take.</p>
<p>This method does nothing if the nodes render flag is not included
in the take.</p>
<p>Raise hou.OperationFailed if the node argument is None. Raise
hou.OperationFailed if this take is not the current take.</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.Take.addParmTuple">
<code class="descname">addParmTuple</code><span class="sig-paren">(</span><em>self</em>, <em>parm_tuple</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Take.addParmTuple" title="Permalink to this definition"></a></dt>
<dd><p>Include the given parameter in this take making it editable in this
take.</p>
<p>This method does nothing if the parameter is already included in
this take.</p>
<p>Raise hou.OperationFailed if the parm_tuple argument is None. Raise
hou.OperationFailed if this take is not the current take.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Take.addParmTuplesFromNode">
<code class="descname">addParmTuplesFromNode</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.Take.addParmTuplesFromNode" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.Take.addParmTuplesFromTake">
<code class="descname">addParmTuplesFromTake</code><span class="sig-paren">(</span><em>self</em>, <em>take</em>, <em>overwrite_existing=True</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Take.addParmTuplesFromTake" title="Permalink to this definition"></a></dt>
<dd><p>Include all the given takes parameters in this take making the
parameters editable in this take.</p>
<p>If overwrite_existing is True then parameters that are already
included in this take will have their values overwritten by the same
parameters found in the other take. Otherwise, parameters already
included in this take will not be affected by the same parameters
found in the other take.</p>
<p>Raise hou.OperationFailed if the take argument is None. Raise
hou.OperationFailed if this take is not the current take.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Take.children">
<code class="descname">children</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.Take<a class="headerlink" href="#hou.Take.children" title="Permalink to this definition"></a></dt>
<dd><p>Return a tuple of the child takes.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Take.destroy">
<code class="descname">destroy</code><span class="sig-paren">(</span><em>self</em>, <em>recurse=False</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Take.destroy" title="Permalink to this definition"></a></dt>
<dd><p>Deletes the take.</p>
<p>If recurse is True then all child and descendent takes will be
deleted as well.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Take.hasParmTuple">
<code class="descname">hasParmTuple</code><span class="sig-paren">(</span><em>self</em>, <em>parm_tuple</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.Take.hasParmTuple" title="Permalink to this definition"></a></dt>
<dd><p>Return True if the given parameter is included in this take and
False otherwise.</p>
<p>Raise hou.OperationFailed if the parm_tuple argument is None.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Take.insertTakeAbove">
<code class="descname">insertTakeAbove</code><span class="sig-paren">(</span><em>self</em>, <em>name</em><span class="sig-paren">)</span> &#x2192; hou.Take<a class="headerlink" href="#hou.Take.insertTakeAbove" title="Permalink to this definition"></a></dt>
<dd><p>Create a new take with the given name and add it as a child of this
takes parent. This take is reparented with the newly created take
as the parent.</p>
<p>Raise hou.OperationFailed if this take is the main (master) take.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Take.isCurrent">
<code class="descname">isCurrent</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.Take.isCurrent" title="Permalink to this definition"></a></dt>
<dd><p>Return True if the take is the current take and False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Take.loadChildTakeFromFile">
<code class="descname">loadChildTakeFromFile</code><span class="sig-paren">(</span><em>self</em>, <em>filename</em><span class="sig-paren">)</span> &#x2192; tuple of hou.Take<a class="headerlink" href="#hou.Take.loadChildTakeFromFile" title="Permalink to this definition"></a></dt>
<dd><p>Load a take from a file that is saved to disk and make it a child of
this take. This will also load any child and descendent takes that
are saved in the file.</p>
<p>Return a tuple of takes that have been loaded from the file. The
first take in the tuple is the direct child take of this take. All
takes that follow are the children and descendents of the first
take.</p>
<p>Loaded takes will be renamed if there already exists takes with the
same names.</p>
<p>Note that you can only load files that have been saved from the same
.hip file session. If Houdini is restarted or if the .hip file is
closed and re-opened after the save then the file will fail to load.</p>
<p>Raise hou.OperationFailed if the filename argument does not point to
a valid file on disk.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Take.moveUnderTake">
<code class="descname">moveUnderTake</code><span class="sig-paren">(</span><em>self</em>, <em>take</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Take.moveUnderTake" title="Permalink to this definition"></a></dt>
<dd><p>Reparent this take to the specified take.</p>
<p>Raise hou.OperationFailed if the take argument is None. Raise
hou.OperationFailed if this take is the main (master) take.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Take.name">
<code class="descname">name</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Take.name" title="Permalink to this definition"></a></dt>
<dd><p>Return the name of the take.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Take.parent">
<code class="descname">parent</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Take<a class="headerlink" href="#hou.Take.parent" title="Permalink to this definition"></a></dt>
<dd><p>Return the parent take or None if this take is the main (master)
take.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Take.parmTuples">
<code class="descname">parmTuples</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.ParmTuple<a class="headerlink" href="#hou.Take.parmTuples" title="Permalink to this definition"></a></dt>
<dd><p>Return a tuple of node parameters that are included and editable in
this take.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Take.path">
<code class="descname">path</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.Take.path" title="Permalink to this definition"></a></dt>
<dd><p>Return the path of the take. The take path consists of the name of
this take as well as the names of its ancestor takes.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Take.removeNodeBypassFlag">
<code class="descname">removeNodeBypassFlag</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.Take.removeNodeBypassFlag" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.Take.removeNodeDisplayFlag">
<code class="descname">removeNodeDisplayFlag</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.Take.removeNodeDisplayFlag" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.Take.removeNodeRenderFlag">
<code class="descname">removeNodeRenderFlag</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.Take.removeNodeRenderFlag" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.Take.removeParmTuple">
<code class="descname">removeParmTuple</code><span class="sig-paren">(</span><em>self</em>, <em>parm_tuple</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Take.removeParmTuple" title="Permalink to this definition"></a></dt>
<dd><p>Exclude the given parameter from this take making it uneditable in
this take.</p>
<p>This method does nothing if the parameter is not included in this
take.</p>
<p>Raise hou.OperationFailed if the parm_tuple argument is None. Raise
hou.OperationFailed if this take is not the current take.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Take.removeParmTuplesFromNode">
<code class="descname">removeParmTuplesFromNode</code><span class="sig-paren">(</span><em>self</em>, <em>node</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Take.removeParmTuplesFromNode" title="Permalink to this definition"></a></dt>
<dd><p>Exclude all the given nodes parameters from this take making them
uneditable in this take.</p>
<p>Raise hou.OperationFailed if the node argument is None. Raise
hou.OperationFailed if this take is not the current take.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Take.saveToFile">
<code class="descname">saveToFile</code><span class="sig-paren">(</span><em>self</em>, <em>filename</em>, <em>recurse=False</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Take.saveToFile" title="Permalink to this definition"></a></dt>
<dd><p>Save this take to a file on disk.</p>
<p>If recurse is True then any child and descendent takes will also be
saved to the file.</p>
<p>Note that the saved file can only be loaded within the same .hip
file session. If Houdini is restarted or if the .hip file is closed
and re-opened then the saved file will fail to load.</p>
<p>Raise hou.OperationFailed if the filename argument does not point to
a valid location on disk.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Take.setName">
<code class="descname">setName</code><span class="sig-paren">(</span><em>self</em>, <em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Take.setName" title="Permalink to this definition"></a></dt>
<dd><p>Rename the take.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.Take.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.Take.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.ToggleParmTemplate">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">ToggleParmTemplate</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ToggleParmTemplate" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.ParmTemplate" title="hou.ParmTemplate"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.ParmTemplate</span></code></a></p>
<p>Describes a parameter tuple containing a checkbox.</p>
<dl class="method">
<dt id="hou.ToggleParmTemplate.defaultExpression">
<code class="descname">defaultExpression</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; string<a class="headerlink" href="#hou.ToggleParmTemplate.defaultExpression" title="Permalink to this definition"></a></dt>
<dd><p>Return the expression, which when evaluated, returns the initial
value of the toggle.</p>
<p>The default expression takes precendence over the default value. If
the default expression is not set (i.e. an empty string), then the
default value is used instead.</p>
<p>Note that the default expression language is needed to interpret the
meaning of the default expression.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ToggleParmTemplate.defaultExpressionLanguage">
<code class="descname">defaultExpressionLanguage</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.scriptLanguage<a class="headerlink" href="#hou.ToggleParmTemplate.defaultExpressionLanguage" title="Permalink to this definition"></a></dt>
<dd><p>Return the default expression language.</p>
<p>The default expression language only applies if the default
expression is set. If the default expression is not set, then the
expression language is set to hou.scriptLanguage.Hscript.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ToggleParmTemplate.defaultValue">
<code class="descname">defaultValue</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.ToggleParmTemplate.defaultValue" title="Permalink to this definition"></a></dt>
<dd><p>Returns the default value for new parameter instances.</p>
<p>Note that ToggleParmTemplates have only one component. Unlike float,
integer, and string parm templates, the default value is a single
bool and not a tuple.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ToggleParmTemplate.setDefaultExpression">
<code class="descname">setDefaultExpression</code><span class="sig-paren">(</span><em>self</em>, <em>default_expression</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ToggleParmTemplate.setDefaultExpression" title="Permalink to this definition"></a></dt>
<dd><p>Set the default expression, which when evaluated, returns the
initial value of the toggle.</p>
<p>If default_expression is the empty string, then the default
expression is unset.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ToggleParmTemplate.setDefaultExpressionLanguage">
<code class="descname">setDefaultExpressionLanguage</code><span class="sig-paren">(</span><em>self</em>, <em>default_expression_language</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ToggleParmTemplate.setDefaultExpressionLanguage" title="Permalink to this definition"></a></dt>
<dd><p>Set the default expression language.</p>
<p>See the defaultExpressionLanguage method for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ToggleParmTemplate.setDefaultValue">
<code class="descname">setDefaultValue</code><span class="sig-paren">(</span><em>self</em>, <em>default_value</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ToggleParmTemplate.setDefaultValue" title="Permalink to this definition"></a></dt>
<dd><p>Set the default value for new parameter instances.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.ToggleParmTemplate.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.ToggleParmTemplate.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.Tool">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">Tool</code><a class="headerlink" href="#hou.Tool" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.ShelfElement" title="hou.ShelfElement"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.ShelfElement</span></code></a></p>
<p>Represents a tool on the shelf, encapsulating a script as well as a
label, help, and other information.</p>
<p>You cant instantiate this object directly, call hou.shelves.newTool
instead.</p>
<dl class="method">
<dt id="hou.Tool.destroy">
<code class="descname">destroy</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Tool.destroy" title="Permalink to this definition"></a></dt>
<dd><p>Deletes the tool from Houdini session and removes its definition
from the file its stored in.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Tool.help">
<code class="descname">help</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.Tool.help" title="Permalink to this definition"></a></dt>
<dd><p>Returns the tools help text.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Tool.helpURL">
<code class="descname">helpURL</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.Tool.helpURL" title="Permalink to this definition"></a></dt>
<dd><p>Returns the URL pointing to this tools help.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Tool.icon">
<code class="descname">icon</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.Tool.icon" title="Permalink to this definition"></a></dt>
<dd><p>Returns the tools icon string.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Tool.keywords">
<code class="descname">keywords</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.Tool.keywords" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.Tool.language">
<code class="descname">language</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.scriptLanguage enum value<a class="headerlink" href="#hou.Tool.language" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Returns a value representing the language in which the tool script
is written.</div></blockquote>
<p>&gt; &gt;&gt;&gt; t = shelves.tool(geometry_sphere)
&gt; &gt;&gt;&gt; t.language() == hou.scriptLanguage.Python
&gt; True</p>
</dd></dl>

<dl class="method">
<dt id="hou.Tool.script">
<code class="descname">script</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.Tool.script" title="Permalink to this definition"></a></dt>
<dd><p>Returns the text of the script that runs when the user clicks the
tool.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Tool.setData">
<code class="descname">setData</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Tool.setData" title="Permalink to this definition"></a></dt>
<dd><p>setData(self, script=, language=hou.scriptLanguage.Python, icon=,
help=, help_url=, network_categories=(), viewer_categories=(),
cop_viewer_categories=(), network_op_type=, viewer_op_type=,
locations=())</p>
<blockquote>
<div><blockquote>
<div>Convenience method for setting multiple options at once, rather than
calling multiple set methods. Sets various options on the tool based
on optional keyword arguments you pass.</div></blockquote>
<p>&gt; # Get a tool
&gt; t = shelves.tool(geometry_sphere)
&gt; # Set the tools icon and help URL
&gt; t.setData(icon=SOP_sphere, help_url=tool:sphere)</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.Tool.setHelp">
<code class="descname">setHelp</code><span class="sig-paren">(</span><em>self</em>, <em>help</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Tool.setHelp" title="Permalink to this definition"></a></dt>
<dd><p>Sets the tools help text. Houdini will parse this as wiki text and
display it in the help viewer when the user requests help for this
tool. To have the help viewer go to a URL instead, use setHelpURL.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Tool.setHelpURL">
<code class="descname">setHelpURL</code><span class="sig-paren">(</span><em>self</em>, <em>help_url</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Tool.setHelpURL" title="Permalink to this definition"></a></dt>
<dd><p>Sets a URL the help viewer should go to when the user requests help
for this tool. If this is not empty, Hoduini will open this URL in
the help viewer instead of parsing and displaying the contents of
Tool.help().</p>
</dd></dl>

<dl class="method">
<dt id="hou.Tool.setIcon">
<code class="descname">setIcon</code><span class="sig-paren">(</span><em>self</em>, <em>icon</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Tool.setIcon" title="Permalink to this definition"></a></dt>
<dd><p>Sets a new icon string for the tool. The string can contain a file
path or URL pointing to an SVG file or an image file Houdini knows
how to load. You can use an opdef: path to refer to an icon file
inside an asset.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Tool.setKeywords">
<code class="descname">setKeywords</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.Tool.setKeywords" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.Tool.setLanguage">
<code class="descname">setLanguage</code><span class="sig-paren">(</span><em>self</em>, <em>language</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Tool.setLanguage" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Sets a new language for the script, where &lt;language&gt; is a value from
the hou.scriptLanguage module (usually hou.scriptLanguage.Python).</div></blockquote>
<p>&gt; t = shelves.tool(tool_1)
&gt; t.setLanguage(hou.scriptLanguage.Hscript)
&gt; t.setScript(message hello)</p>
<blockquote>
<div><dl class="docutils">
<dt>NOTE</dt>
<dd>We <em>highly</em> recommend writing scripts in Python rather than
Hscript.</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.Tool.setScript">
<code class="descname">setScript</code><span class="sig-paren">(</span><em>self</em>, <em>script</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Tool.setScript" title="Permalink to this definition"></a></dt>
<dd><p>Sets the text of the script to run when the user clicks the tool in
the shelf. See how to write a tool script for information on the
global variables available to the script and tips for common tasks.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Tool.setToolLocations">
<code class="descname">setToolLocations</code><span class="sig-paren">(</span><em>self</em>, <em>locations</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Tool.setToolLocations" title="Permalink to this definition"></a></dt>
<dd><p>Sets the description of the places that the tool should show up in
the UI. Eg, a tool could be configured to be included in the network
panes TAB menu but not in the viewport panes TAB menu.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Tool.setToolMenuCategories">
<code class="descname">setToolMenuCategories</code><span class="sig-paren">(</span><em>self</em>, <em>pane_type</em>, <em>categories</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Tool.setToolMenuCategories" title="Permalink to this definition"></a></dt>
<dd><p>Set the tool categories. The categories are used to further control
the visibility of the tool. For example, some tools specify Mantra
or RenderMan as keywords, and they show up in the TAB menu only if
the specified renderer is configured as active in the preferences
pane.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Tool.setToolMenuOpType">
<code class="descname">setToolMenuOpType</code><span class="sig-paren">(</span><em>self</em>, <em>pane_type</em>, <em>op_type</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Tool.setToolMenuOpType" title="Permalink to this definition"></a></dt>
<dd><p>Sets the operator type to be associated with the tool. The tool will
show up in the TAB menu only if the operator can be created. For
example, some operator types are scoped only to a particular parent,
thus the tool that creates nodes of this type makes sense only
inside that paretn.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.Tool.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.Tool.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

<dl class="method">
<dt id="hou.Tool.toolMenuCategories">
<code class="descname">toolMenuCategories</code><span class="sig-paren">(</span><em>self</em>, <em>pane_type</em><span class="sig-paren">)</span> &#x2192; tuple of hou.NodeTypeCategory<a class="headerlink" href="#hou.Tool.toolMenuCategories" title="Permalink to this definition"></a></dt>
<dd><p>Returns the categories specified for the tool.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Tool.toolMenuLocations">
<code class="descname">toolMenuLocations</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of str<a class="headerlink" href="#hou.Tool.toolMenuLocations" title="Permalink to this definition"></a></dt>
<dd><p>Returns the submenus of the TAB menu in which the tool is included.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Tool.toolMenuOpType">
<code class="descname">toolMenuOpType</code><span class="sig-paren">(</span><em>self</em>, <em>pane_type</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.Tool.toolMenuOpType" title="Permalink to this definition"></a></dt>
<dd><p>Returns the operator type associated with this tool.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.TopNode">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">TopNode</code><a class="headerlink" href="#hou.TopNode" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.Node" title="hou.Node"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.Node</span></code></a></p>
<p>Represents a task node.</p>
<dl class="method">
<dt id="hou.TopNode.addPDGFilter">
<code class="descname">addPDGFilter</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.TopNode.addPDGFilter" title="Permalink to this definition"></a></dt>
<dd><p>isPDGFilter(self, idx) -&gt; bool</p>
<blockquote>
<div>Returns true if the root work item with the given index part if the
filter.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.TopNode.bypass">
<code class="descname">bypass</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.TopNode.bypass" title="Permalink to this definition"></a></dt>
<dd><p>Turns this nodes bypass flag on or off, making this node have no
effect.</p>
</dd></dl>

<dl class="method">
<dt id="hou.TopNode.dirtyAllTasks">
<code class="descname">dirtyAllTasks</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.TopNode.dirtyAllTasks" title="Permalink to this definition"></a></dt>
<dd><p>Dirties all the tasks in a PDG graph so that when the graph cooks
again, it will cause a complete recook.</p>
</dd></dl>

<dl class="method">
<dt id="hou.TopNode.dirtyTasks">
<code class="descname">dirtyTasks</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.TopNode.dirtyTasks" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.TopNode.displayNode">
<code class="descname">displayNode</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; Node<a class="headerlink" href="#hou.TopNode.displayNode" title="Permalink to this definition"></a></dt>
<dd><p>If this is a subnet TOP, return the TOP node inside the subnet with
its display flag on. Otherwise, return None.</p>
</dd></dl>

<dl class="method">
<dt id="hou.TopNode.enablePDGFilter">
<code class="descname">enablePDGFilter</code><span class="sig-paren">(</span><em>self</em>, <em>filter_on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.TopNode.enablePDGFilter" title="Permalink to this definition"></a></dt>
<dd><p>Sets the nodes TOP network to use the current root task filter.</p>
</dd></dl>

<dl class="method">
<dt id="hou.TopNode.executeGraph">
<code class="descname">executeGraph</code><span class="sig-paren">(</span><em>self</em>, <em>filter_roots</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.TopNode.executeGraph" title="Permalink to this definition"></a></dt>
<dd><p>Executes the PDG graph owned by the parent network of this node. If
filter_roots is True, then the graph will be executed with respect
to the root work items stored by the TOP Network filter.</p>
</dd></dl>

<dl class="method">
<dt id="hou.TopNode.generateRootTasks">
<code class="descname">generateRootTasks</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.TopNode.generateRootTasks" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.TopNode.getFilterNodes">
<code class="descname">getFilterNodes</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.Node<a class="headerlink" href="#hou.TopNode.getFilterNodes" title="Permalink to this definition"></a></dt>
<dd><p>Returns a tuple of all nodes whose filters affect the node.</p>
</dd></dl>

<dl class="method">
<dt id="hou.TopNode.getPDGGraphContext">
<code class="descname">getPDGGraphContext</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.TopNode.getPDGGraphContext" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.TopNode.getPDGGraphContextName">
<code class="descname">getPDGGraphContextName</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.TopNode.getPDGGraphContextName" title="Permalink to this definition"></a></dt>
<dd><p>Returns a string containing the name of the graph context owned by
the parent network of this node.</p>
</dd></dl>

<dl class="method">
<dt id="hou.TopNode.getPDGNode">
<code class="descname">getPDGNode</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.TopNode.getPDGNode" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.TopNode.getPDGNodeName">
<code class="descname">getPDGNodeName</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.TopNode.getPDGNodeName" title="Permalink to this definition"></a></dt>
<dd><p>Returns the name of the PDG node owned by this node.</p>
</dd></dl>

<dl class="method">
<dt id="hou.TopNode.getSelectedWorkItem">
<code class="descname">getSelectedWorkItem</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.TopNode.getSelectedWorkItem" title="Permalink to this definition"></a></dt>
<dd><p>Returns the index of the current selected work item in this TOP
Network.</p>
</dd></dl>

<dl class="method">
<dt id="hou.TopNode.getWorkItemName">
<code class="descname">getWorkItemName</code><span class="sig-paren">(</span><em>self</em>, <em>idx</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.TopNode.getWorkItemName" title="Permalink to this definition"></a></dt>
<dd><p>Returns the name of the work item with the given index.</p>
</dd></dl>

<dl class="method">
<dt id="hou.TopNode.graphCommands">
<code class="descname">graphCommands</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.TopNode.graphCommands" title="Permalink to this definition"></a></dt>
<dd><p>Returns a string containing python commands require to construct the
PDG graph owned by the parent network of this node.</p>
</dd></dl>

<dl class="method">
<dt id="hou.TopNode.inputDataTypes">
<code class="descname">inputDataTypes</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of str<a class="headerlink" href="#hou.TopNode.inputDataTypes" title="Permalink to this definition"></a></dt>
<dd><p>Returns a tuple of the data types for the input ports of this node.</p>
</dd></dl>

<dl class="method">
<dt id="hou.TopNode.isBypassed">
<code class="descname">isBypassed</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.TopNode.isBypassed" title="Permalink to this definition"></a></dt>
<dd><p>Returns whether this nodes bypass flag is on.</p>
</dd></dl>

<dl class="method">
<dt id="hou.TopNode.isDisplayFlagSet">
<code class="descname">isDisplayFlagSet</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.TopNode.isDisplayFlagSet" title="Permalink to this definition"></a></dt>
<dd><p>Returns whether this nodes display flag is on.</p>
</dd></dl>

<dl class="method">
<dt id="hou.TopNode.isFilterOn">
<code class="descname">isFilterOn</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.TopNode.isFilterOn" title="Permalink to this definition"></a></dt>
<dd><p>Returns true is this node is currently affected by a work item
filter set on another node in the network.</p>
</dd></dl>

<dl class="method">
<dt id="hou.TopNode.isMapper">
<code class="descname">isMapper</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.TopNode.isMapper" title="Permalink to this definition"></a></dt>
<dd><p>isMapper(self) - &gt; bool</p>
<blockquote>
<div>Returns true if the TOP node is a mapper.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.TopNode.isPDGFilter">
<code class="descname">isPDGFilter</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.TopNode.isPDGFilter" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.TopNode.isPartitioner">
<code class="descname">isPartitioner</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.TopNode.isPartitioner" title="Permalink to this definition"></a></dt>
<dd><p>Returns true if the TOP node is a partitioner.</p>
</dd></dl>

<dl class="method">
<dt id="hou.TopNode.isProcessor">
<code class="descname">isProcessor</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.TopNode.isProcessor" title="Permalink to this definition"></a></dt>
<dd><p>Returns true if the TOP node is a processor.</p>
</dd></dl>

<dl class="method">
<dt id="hou.TopNode.isRenderFlagSet">
<code class="descname">isRenderFlagSet</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.TopNode.isRenderFlagSet" title="Permalink to this definition"></a></dt>
<dd><p>Returns whether this nodes render flag is on.</p>
</dd></dl>

<dl class="method">
<dt id="hou.TopNode.isScheduler">
<code class="descname">isScheduler</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.TopNode.isScheduler" title="Permalink to this definition"></a></dt>
<dd><p>isScheduler(self) - &gt; bool</p>
<blockquote>
<div>Returns true if the TOP node is a scheduler.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.TopNode.outputDataTypes">
<code class="descname">outputDataTypes</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of str<a class="headerlink" href="#hou.TopNode.outputDataTypes" title="Permalink to this definition"></a></dt>
<dd><p>Returns a tuple of the data types for the output ports of this node.</p>
</dd></dl>

<dl class="method">
<dt id="hou.TopNode.removePDGFilter">
<code class="descname">removePDGFilter</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.TopNode.removePDGFilter" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.TopNode.renderNode">
<code class="descname">renderNode</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; Node<a class="headerlink" href="#hou.TopNode.renderNode" title="Permalink to this definition"></a></dt>
<dd><p>If this is a subnet TOP, return the TOP node inside the subnet with
its render flag on. Otherwise, return None.</p>
</dd></dl>

<dl class="method">
<dt id="hou.TopNode.setDisplayFlag">
<code class="descname">setDisplayFlag</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.TopNode.setDisplayFlag" title="Permalink to this definition"></a></dt>
<dd><p>Turn this nodes display flag on or off.</p>
</dd></dl>

<dl class="method">
<dt id="hou.TopNode.setRenderFlag">
<code class="descname">setRenderFlag</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.TopNode.setRenderFlag" title="Permalink to this definition"></a></dt>
<dd><p>Turns this nodes render flag on or off.</p>
</dd></dl>

<dl class="method">
<dt id="hou.TopNode.setSelectedWorkItem">
<code class="descname">setSelectedWorkItem</code><span class="sig-paren">(</span><em>self</em>, <em>idx</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.TopNode.setSelectedWorkItem" title="Permalink to this definition"></a></dt>
<dd><p>Sets the selected work item in this TOP Network to be the work item
with the given index.</p>
</dd></dl>

<dl class="method">
<dt id="hou.TopNode.taskGraphCommands">
<code class="descname">taskGraphCommands</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.TopNode.taskGraphCommands" title="Permalink to this definition"></a></dt>
<dd><p>Returns a string containing python commands require to construct the
PDG task graph owned by the parent network of this node.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.TopNode.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.TopNode.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.Track">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">Track</code><a class="headerlink" href="#hou.Track" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Each hou.ChopNode contains its data in one or more tracks. A track
contains a sequence of floating point samples over time. Each track has
a unique name in its containing CHOP.</p>
<p>REPLACES</p>
<blockquote>
<div><ul class="simple">
<li>chop()</li>
<li>chopcf()</li>
<li>chopci()</li>
<li>chopct()</li>
<li>chopf()</li>
<li>chopi()</li>
<li>chopl()</li>
<li>chopstr()</li>
<li>chopt()</li>
</ul>
</div></blockquote>
<dl class="method">
<dt id="hou.Track.allSamples">
<code class="descname">allSamples</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of double<a class="headerlink" href="#hou.Track.allSamples" title="Permalink to this definition"></a></dt>
<dd><p>Returns all the sample values in this track.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Track.chopNode">
<code class="descname">chopNode</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.ChopNode<a class="headerlink" href="#hou.Track.chopNode" title="Permalink to this definition"></a></dt>
<dd><p>Returns the hou.ChopNode owner of this track.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Track.eval">
<code class="descname">eval</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; double<a class="headerlink" href="#hou.Track.eval" title="Permalink to this definition"></a></dt>
<dd><p>Returns the value of this track at the current time.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Track.evalAtFrame">
<code class="descname">evalAtFrame</code><span class="sig-paren">(</span><em>self</em>, <em>frame</em><span class="sig-paren">)</span> &#x2192; double<a class="headerlink" href="#hou.Track.evalAtFrame" title="Permalink to this definition"></a></dt>
<dd><p>Returns the value of this track at a given frame.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Track.evalAtFrameRange">
<code class="descname">evalAtFrameRange</code><span class="sig-paren">(</span><em>self</em>, <em>start</em>, <em>end</em><span class="sig-paren">)</span> &#x2192; tuple of double<a class="headerlink" href="#hou.Track.evalAtFrameRange" title="Permalink to this definition"></a></dt>
<dd><p>Returns the sample values of this track between a given start and
end frame.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Track.evalAtSample">
<code class="descname">evalAtSample</code><span class="sig-paren">(</span><em>self</em>, <em>sample</em><span class="sig-paren">)</span> &#x2192; double<a class="headerlink" href="#hou.Track.evalAtSample" title="Permalink to this definition"></a></dt>
<dd><p>Returns the value of the track at a given sample value.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Track.evalAtSampleIndex">
<code class="descname">evalAtSampleIndex</code><span class="sig-paren">(</span><em>self</em>, <em>index</em><span class="sig-paren">)</span> &#x2192; double<a class="headerlink" href="#hou.Track.evalAtSampleIndex" title="Permalink to this definition"></a></dt>
<dd><p>This method is deprecated in favor of evalAtSample.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Track.evalAtSampleRange">
<code class="descname">evalAtSampleRange</code><span class="sig-paren">(</span><em>self</em>, <em>start</em>, <em>end</em><span class="sig-paren">)</span> &#x2192; tuple of double<a class="headerlink" href="#hou.Track.evalAtSampleRange" title="Permalink to this definition"></a></dt>
<dd><p>Returns the sample values of this track between a given start and
end sample index.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Track.evalAtTime">
<code class="descname">evalAtTime</code><span class="sig-paren">(</span><em>self</em>, <em>time</em><span class="sig-paren">)</span> &#x2192; double<a class="headerlink" href="#hou.Track.evalAtTime" title="Permalink to this definition"></a></dt>
<dd><p>Returns the value of this track at a given time.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Track.evalAtTimeRange">
<code class="descname">evalAtTimeRange</code><span class="sig-paren">(</span><em>self</em>, <em>start</em>, <em>end</em><span class="sig-paren">)</span> &#x2192; tuple of double<a class="headerlink" href="#hou.Track.evalAtTimeRange" title="Permalink to this definition"></a></dt>
<dd><p>Returns the sample values of this track between a given start and
end time.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Track.name">
<code class="descname">name</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.Track.name" title="Permalink to this definition"></a></dt>
<dd><p>Returns the name of this track (each track in a CHOP has a unique
name).</p>
</dd></dl>

<dl class="method">
<dt id="hou.Track.numSamples">
<code class="descname">numSamples</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.Track.numSamples" title="Permalink to this definition"></a></dt>
<dd><p>Return the number of samples in this track.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.Track.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.Track.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.TypeError">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">TypeError</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.TypeError" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.Error" title="hou.Error"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.Error</span></code></a></p>
<dl class="method">
<dt id="hou.TypeError.description">
<code class="descname">description</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.TypeError.description" title="Permalink to this definition"></a></dt>
<dd><p>Return a description of the class of exception. The description is
not related to the exception instance.</p>
</dd></dl>

<dl class="method">
<dt id="hou.TypeError.exceptionTypeName">
<code class="descname">exceptionTypeName</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.TypeError.exceptionTypeName" title="Permalink to this definition"></a></dt>
<dd><p>Return the name of the exception type. Instances of different
subclasses of hou.Error will return different names. Instances of
the base class will return Error.</p>
<p>You can also use str(e.__class__) to get the name of the subclass.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.TypeError.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.TypeError.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.UIEvent">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">UIEvent</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.UIEvent" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Represents a user interface event, such as a mouse press. You can access
this object in an event handler to respond to user input.</p>
<p>hou.UIEvent provides information to interact with user input and is used
with Python states. You do not instantiate this type of object yourself.</p>
<p>RELATED</p>
<blockquote>
<div>hou.ViewerEvent</div></blockquote>
<dl class="method">
<dt id="hou.UIEvent.device">
<code class="descname">device</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.UIEventDevice<a class="headerlink" href="#hou.UIEvent.device" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Returns an object containing input-device-specific event data. For
example, if this is a mouse click event, you can use
event.device().mouseX() to get the X coordinate in screen space, and
event.device().isLeftButton() to check whether the left mouse button
was pressed.</div></blockquote>
<p>&gt; if ui_event.device().isLeftButton():
&gt;     </p>
</dd></dl>

<dl class="method">
<dt id="hou.UIEvent.hasQueuedEvents">
<code class="descname">hasQueuedEvents</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.UIEvent.hasQueuedEvents" title="Permalink to this definition"></a></dt>
<dd><p>Returns true if this event contains queued device events.</p>
</dd></dl>

<dl class="method">
<dt id="hou.UIEvent.queuedEvents">
<code class="descname">queuedEvents</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; list of hou.UIEventDevice<a class="headerlink" href="#hou.UIEvent.queuedEvents" title="Permalink to this definition"></a></dt>
<dd><p>If returns True, this method returns the list of queued input device
events.</p>
</dd></dl>

<dl class="method">
<dt id="hou.UIEvent.reason">
<code class="descname">reason</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.UIEvent.reason" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.UIEvent.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.UIEvent.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

<dl class="method">
<dt id="hou.UIEvent.value">
<code class="descname">value</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; obj<a class="headerlink" href="#hou.UIEvent.value" title="Permalink to this definition"></a></dt>
<dd><p>Returns the value payload of this event. You can tell the C++ type
of this value by calling .</p>
</dd></dl>

<dl class="method">
<dt id="hou.UIEvent.valueType">
<code class="descname">valueType</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.UIEvent.valueType" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.UIEventDevice">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">UIEventDevice</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.UIEventDevice" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Object containing methods for testing input-device-specific information
on a UI event, such as which mouse button was pressed.</p>
<p>Do not instantiate this object yourself. You can get a UIEventDevice
object from a hou.UIEvent using hou.UIEvent.device. For more information
see Python states.</p>
<dl class="method">
<dt id="hou.UIEventDevice.isAltKey">
<code class="descname">isAltKey</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.UIEventDevice.isAltKey" title="Permalink to this definition"></a></dt>
<dd><p>Returns True if an Alt/Option key was pressed.</p>
</dd></dl>

<dl class="method">
<dt id="hou.UIEventDevice.isArrowDown">
<code class="descname">isArrowDown</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.UIEventDevice.isArrowDown" title="Permalink to this definition"></a></dt>
<dd><p>Returns True if the Down arrow key was pressed.</p>
</dd></dl>

<dl class="method">
<dt id="hou.UIEventDevice.isArrowLeft">
<code class="descname">isArrowLeft</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.UIEventDevice.isArrowLeft" title="Permalink to this definition"></a></dt>
<dd><p>Returns True if the Left arrow key was pressed.</p>
</dd></dl>

<dl class="method">
<dt id="hou.UIEventDevice.isArrowRight">
<code class="descname">isArrowRight</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.UIEventDevice.isArrowRight" title="Permalink to this definition"></a></dt>
<dd><p>Returns True if the Right arrow key was pressed.</p>
</dd></dl>

<dl class="method">
<dt id="hou.UIEventDevice.isArrowUp">
<code class="descname">isArrowUp</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.UIEventDevice.isArrowUp" title="Permalink to this definition"></a></dt>
<dd><p>Returns True if the Up arrow key was pressed.</p>
</dd></dl>

<dl class="method">
<dt id="hou.UIEventDevice.isAutoRepeat">
<code class="descname">isAutoRepeat</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.UIEventDevice.isAutoRepeat" title="Permalink to this definition"></a></dt>
<dd><p>Returns True if the held key was auto-repeating.</p>
</dd></dl>

<dl class="method">
<dt id="hou.UIEventDevice.isCapsLock">
<code class="descname">isCapsLock</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.UIEventDevice.isCapsLock" title="Permalink to this definition"></a></dt>
<dd><p>Returns True if the Caps Lock key was pressed.</p>
</dd></dl>

<dl class="method">
<dt id="hou.UIEventDevice.isCtrlKey">
<code class="descname">isCtrlKey</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.UIEventDevice.isCtrlKey" title="Permalink to this definition"></a></dt>
<dd><p>Returns True if the Control key was pressed.</p>
</dd></dl>

<dl class="method">
<dt id="hou.UIEventDevice.isKeyPad">
<code class="descname">isKeyPad</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.UIEventDevice.isKeyPad" title="Permalink to this definition"></a></dt>
<dd><p>Returns True if the pressed key was on the number pad.</p>
</dd></dl>

<dl class="method">
<dt id="hou.UIEventDevice.isLeftButton">
<code class="descname">isLeftButton</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.UIEventDevice.isLeftButton" title="Permalink to this definition"></a></dt>
<dd><p>Returns True if the [LMB] left mouse button was pressed.</p>
</dd></dl>

<dl class="method">
<dt id="hou.UIEventDevice.isMiddleButton">
<code class="descname">isMiddleButton</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.UIEventDevice.isMiddleButton" title="Permalink to this definition"></a></dt>
<dd><p>Returns True if the [MMB] middle mouse button was pressed.</p>
</dd></dl>

<dl class="method">
<dt id="hou.UIEventDevice.isRightButton">
<code class="descname">isRightButton</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.UIEventDevice.isRightButton" title="Permalink to this definition"></a></dt>
<dd><p>Returns True if the [RMB] right mouse button was pressed.</p>
</dd></dl>

<dl class="method">
<dt id="hou.UIEventDevice.isShiftKey">
<code class="descname">isShiftKey</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.UIEventDevice.isShiftKey" title="Permalink to this definition"></a></dt>
<dd><p>Returns True if the a Shift key was pressed.</p>
</dd></dl>

<dl class="method">
<dt id="hou.UIEventDevice.isTablet">
<code class="descname">isTablet</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.UIEventDevice.isTablet" title="Permalink to this definition"></a></dt>
<dd><p>Returns True if the event was generated by a tablet stylus.</p>
</dd></dl>

<dl class="method">
<dt id="hou.UIEventDevice.mouseWheel">
<code class="descname">mouseWheel</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.UIEventDevice.mouseWheel" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>The result is negative if the wheel was rotated up and positive if
it was rotated down.</p>
<p>Different mice will produce different outputs:</p>
</div></blockquote>
<ul class="simple">
<li>Mice with clicky wheels will generally output a -1 or +1 event for
each click (at least that is the intention).</li>
<li>Mice with free spinning wheels, or touch sensitive surfaces (such
as the Apple Magic Mouse), will produce a wider range of values.
Small/slow scrolling might trigger a mouse wheel event but this
method returns 0, whereas big/fast scrolling can produce higher
numbers for each event, up to around 7, with the numbers increasing
as the user thows the wheel and decreasing as it slows.</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="hou.UIEventDevice.mouseX">
<code class="descname">mouseX</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.UIEventDevice.mouseX" title="Permalink to this definition"></a></dt>
<dd><p>Returns the horizontal mouse position in screen coordinates,
counting from the left edge of the view.</p>
</dd></dl>

<dl class="method">
<dt id="hou.UIEventDevice.mouseY">
<code class="descname">mouseY</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.UIEventDevice.mouseY" title="Permalink to this definition"></a></dt>
<dd><p>Returns the vertical mouse position in screen coordinates, counting
from the bottom edge of the view.</p>
</dd></dl>

<dl class="method">
<dt id="hou.UIEventDevice.tabletAngle">
<code class="descname">tabletAngle</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; double<a class="headerlink" href="#hou.UIEventDevice.tabletAngle" title="Permalink to this definition"></a></dt>
<dd><p>Returns tablet stylus angle value.</p>
</dd></dl>

<dl class="method">
<dt id="hou.UIEventDevice.tabletPressure">
<code class="descname">tabletPressure</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; double<a class="headerlink" href="#hou.UIEventDevice.tabletPressure" title="Permalink to this definition"></a></dt>
<dd><p>Returns the tablet pressure value.</p>
</dd></dl>

<dl class="method">
<dt id="hou.UIEventDevice.tabletRoll">
<code class="descname">tabletRoll</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; double<a class="headerlink" href="#hou.UIEventDevice.tabletRoll" title="Permalink to this definition"></a></dt>
<dd><p>Returns the tablet stylus roll value.</p>
</dd></dl>

<dl class="method">
<dt id="hou.UIEventDevice.tabletTilt">
<code class="descname">tabletTilt</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; double<a class="headerlink" href="#hou.UIEventDevice.tabletTilt" title="Permalink to this definition"></a></dt>
<dd><p>Returns the tablet stylus tilt value.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.UIEventDevice.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.UIEventDevice.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

<dl class="method">
<dt id="hou.UIEventDevice.time">
<code class="descname">time</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.UIEventDevice.time" title="Permalink to this definition"></a></dt>
<dd><p>time(self): -&gt; double</p>
<blockquote>
<div>Returns the time in seconds relative to the event.</div></blockquote>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.UndosDisabler">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">UndosDisabler</code><a class="headerlink" href="#hou.UndosDisabler" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Use this class to disable undos within a Python code block.</p>
<p>This object cannot be instantiated directly. See hou.undos.disabler.</p>
<p>This object is a context manager. You can create one using
hou.undos.disabler. Changes inside the with block will not add actions
to the undo stack.</p>
<dl class="attribute">
<dt id="hou.UndosDisabler.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.UndosDisabler.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.UndosGroup">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">UndosGroup</code><a class="headerlink" href="#hou.UndosGroup" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Used to group all undos within a Python code block into a single action.</p>
<p>This object is a context manager. You can create one using
hou.undos.group. Changes inside the with block appear as a single action
in the undo stack.</p>
<dl class="method">
<dt id="hou.UndosGroup.label">
<code class="descname">label</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.UndosGroup.label" title="Permalink to this definition"></a></dt>
<dd><p>Returns the group label.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.UndosGroup.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.UndosGroup.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.VDB">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">VDB</code><a class="headerlink" href="#hou.VDB" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.Prim" title="hou.Prim"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.Prim</span></code></a></p>
<p>A VDB is a kind geometry primitive (Prim object) that stores data in a
three dimensional grid of voxels.</p>
<dl class="method">
<dt id="hou.VDB.activeVoxelBoundingBox">
<code class="descname">activeVoxelBoundingBox</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.BoundingBox<a class="headerlink" href="#hou.VDB.activeVoxelBoundingBox" title="Permalink to this definition"></a></dt>
<dd><p>Returns the smallest exclusive bounding box within the VDB volume
that has active voxels.</p>
</dd></dl>

<dl class="method">
<dt id="hou.VDB.activeVoxelCount">
<code class="descname">activeVoxelCount</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.VDB.activeVoxelCount" title="Permalink to this definition"></a></dt>
<dd><p>Returns the number of active voxels in the volume.</p>
</dd></dl>

<dl class="method">
<dt id="hou.VDB.dataType">
<code class="descname">dataType</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.vdbData<a class="headerlink" href="#hou.VDB.dataType" title="Permalink to this definition"></a></dt>
<dd><p>Returns the voxel data type within the VDB volume.</p>
</dd></dl>

<dl class="method">
<dt id="hou.VDB.gradient">
<code class="descname">gradient</code><span class="sig-paren">(</span><em>self</em>, <em>position</em><span class="sig-paren">)</span> &#x2192; hou.Vector3<a class="headerlink" href="#hou.VDB.gradient" title="Permalink to this definition"></a></dt>
<dd><p>Given a sequence of three floats containing a 3D position, return a
vector which points in the direction of the greatest rate of
increase of the volumes value.</p>
<p>See Wikipedias gradient page for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.VDB.indexToPos">
<code class="descname">indexToPos</code><span class="sig-paren">(</span><em>self</em>, <em>index</em><span class="sig-paren">)</span> &#x2192; hou.Vector3<a class="headerlink" href="#hou.VDB.indexToPos" title="Permalink to this definition"></a></dt>
<dd><p>Given a sequence of three ints containing an index into the voxel
array, return the corresponding 3D position of the middle of that
voxel.</p>
</dd></dl>

<dl class="method">
<dt id="hou.VDB.isEmpty">
<code class="descname">isEmpty</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.VDB.isEmpty" title="Permalink to this definition"></a></dt>
<dd><p>Returns whether the VDB volume has no data.</p>
</dd></dl>

<dl class="method">
<dt id="hou.VDB.isSDF">
<code class="descname">isSDF</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.VDB.isSDF" title="Permalink to this definition"></a></dt>
<dd><p>Return whether or not the volume should be semantically treated as a
signed distance field. If true, the volume can be thought of as
representing a closed surface, where the negative voxel values are
inside, the positive voxel values are outside, and voxels on the
surace are zero.</p>
<p>For VDB volumes, there is typically only a 3 voxel radius around the
surface where there exists data.</p>
</dd></dl>

<dl class="method">
<dt id="hou.VDB.posToIndex">
<code class="descname">posToIndex</code><span class="sig-paren">(</span><em>self</em>, <em>position</em><span class="sig-paren">)</span> &#x2192; tuple of int<a class="headerlink" href="#hou.VDB.posToIndex" title="Permalink to this definition"></a></dt>
<dd><p>Given a sequence of three floats containing a 3D position, return a
tuple of three ints containing the corresponding index into the
voxel array.</p>
</dd></dl>

<dl class="method">
<dt id="hou.VDB.resolution">
<code class="descname">resolution</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Vector3<a class="headerlink" href="#hou.VDB.resolution" title="Permalink to this definition"></a></dt>
<dd><p>Return the x, y, and z dimensions of hou.VDB.activeVoxelBoundingBox.
Since VDB volumes are sparse, this represents the virtual resolution
of all the voxels which have data (or are active).</p>
</dd></dl>

<dl class="method">
<dt id="hou.VDB.sample">
<code class="descname">sample</code><span class="sig-paren">(</span><em>self</em>, <em>position</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#hou.VDB.sample" title="Permalink to this definition"></a></dt>
<dd><p>Given a sequence of three floats containing a 3D position, return
the value of the volume at that position. If the position is not in
the middle of a voxel, Houdini will interpolate using values from
surrounding voxels.</p>
<p>See also hou.VDB.voxel and hou.VDB.posToIndex.</p>
</dd></dl>

<dl class="method">
<dt id="hou.VDB.taper">
<code class="descname">taper</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.VDB.taper" title="Permalink to this definition"></a></dt>
<dd><p>Returns the taper value of the volumes transform. For untapered
transforms, this value will be 1.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.VDB.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.VDB.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

<dl class="method">
<dt id="hou.VDB.transform">
<code class="descname">transform</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Matrix3<a class="headerlink" href="#hou.VDB.transform" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Return a 3x3 matrix containing the scale and rotation
transformations for this volume.</p>
<p>Note that the position information for the volume can be obtained by
calling volume.vertex(0).point().position().</p>
<p>The following function returns a 4x4 transformation matrix for the
volume that includes the translation:</p>
</div></blockquote>
<p>&gt; def fullTransform(volume):
&gt;     return (hou.Matrix4(volume.transform()) *
&gt;         hou.hmath.buildTranslate(volume.vertex(0).point().position()))</p>
<blockquote>
<div><dl class="docutils">
<dt>NOTE</dt>
<dd>You need to get the object nodes transform to get to
worldspace.</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.VDB.vertex">
<code class="descname">vertex</code><span class="sig-paren">(</span><em>self</em>, <em>index</em><span class="sig-paren">)</span> &#x2192; hou.Vertex<a class="headerlink" href="#hou.VDB.vertex" title="Permalink to this definition"></a></dt>
<dd><p>A shortcut for self.vertices()[index]. You probably dont need to
call this method.</p>
<p>This method supports negative indices to index from the end, just
like self.vertices()[index] would. Also, like Pythons indexing
operator, it will raise IndexError when the index is out of range.</p>
</dd></dl>

<dl class="method">
<dt id="hou.VDB.voxel">
<code class="descname">voxel</code><span class="sig-paren">(</span><em>self</em>, <em>index</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#hou.VDB.voxel" title="Permalink to this definition"></a></dt>
<dd><p>Given a sequence of three integers containing a voxel index, return
the value of the corresponding voxel.</p>
</dd></dl>

<dl class="method">
<dt id="hou.VDB.voxelRange">
<code class="descname">voxelRange</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.VDB.voxelRange" title="Permalink to this definition"></a></dt>
<dd><p>voxelRangeAsVector3(self, range) -&gt; tuple of hou.Vector3</p>
<blockquote>
<div><p>Return a tuple containing the values of all voxels withing a
bounding box range. It is faster to call this method to retrieve all
the voxels than it is to loop through the voxel array in Python.</p>
<p>See help for hou.VDB.voxelRange for implementation details.</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.VDB.voxelRangeAsBool">
<code class="descname">voxelRangeAsBool</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.VDB.voxelRangeAsBool" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.VDB.voxelRangeAsFloat">
<code class="descname">voxelRangeAsFloat</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.VDB.voxelRangeAsFloat" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.VDB.voxelRangeAsInt">
<code class="descname">voxelRangeAsInt</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.VDB.voxelRangeAsInt" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.VDB.voxelRangeAsVector3">
<code class="descname">voxelRangeAsVector3</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.VDB.voxelRangeAsVector3" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.VDB.voxelSize">
<code class="descname">voxelSize</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Vector3<a class="headerlink" href="#hou.VDB.voxelSize" title="Permalink to this definition"></a></dt>
<dd><p>Returns the size of voxels within the VDB volume. All voxels will be
of this size for untapered volumes. For tapered volumes, this size
represents the size of voxel at the origin of the frustum.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.ValueError">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">ValueError</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ValueError" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.Error" title="hou.Error"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.Error</span></code></a></p>
<dl class="method">
<dt id="hou.ValueError.description">
<code class="descname">description</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.ValueError.description" title="Permalink to this definition"></a></dt>
<dd><p>Return a description of the class of exception. The description is
not related to the exception instance.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ValueError.exceptionTypeName">
<code class="descname">exceptionTypeName</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.ValueError.exceptionTypeName" title="Permalink to this definition"></a></dt>
<dd><p>Return the name of the exception type. Instances of different
subclasses of hou.Error will return different names. Instances of
the base class will return Error.</p>
<p>You can also use str(e.__class__) to get the name of the subclass.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.ValueError.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.ValueError.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.Vector2">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">Vector2</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Vector2" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A sequence of 2 floating point values, with associated mathematical
operations.</p>
<p>A Vector2 might be used to represent a position in 2D space, a 2D
direction and length, or the size of a rectangle. For example,
hou.Node.position returns a position and hou.Node.size returns the size
of a rectangle.</p>
<p>See also hou.Vector3 and hou.Vector4.</p>
<dl class="method">
<dt id="hou.Vector2.almostEqual">
<code class="descname">almostEqual</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Vector2.almostEqual" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.Vector2.distanceTo">
<code class="descname">distanceTo</code><span class="sig-paren">(</span><em>self</em>, <em>vector2</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#hou.Vector2.distanceTo" title="Permalink to this definition"></a></dt>
<dd><p>Interpret this vector and the argument as 2D positions, and return
the distance between them. The return value is equivalent to (self -
vector2).length().</p>
</dd></dl>

<dl class="method">
<dt id="hou.Vector2.dot">
<code class="descname">dot</code><span class="sig-paren">(</span><em>self</em>, <em>vector2</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#hou.Vector2.dot" title="Permalink to this definition"></a></dt>
<dd><p>Return the dot product between this vector and the one in the
parameter.</p>
<p>See Wikipedias dot product page.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Vector2.isAlmostEqual">
<code class="descname">isAlmostEqual</code><span class="sig-paren">(</span><em>self</em>, <em>vector2</em>, <em>tolerance=0.00001</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.Vector2.isAlmostEqual" title="Permalink to this definition"></a></dt>
<dd><p>Return whether this vector is equal to another, within a tolerance.
Verifies that the difference between each component of this vector
and the corresponding component of the other vector is within the
tolerance.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Vector2.length">
<code class="descname">length</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#hou.Vector2.length" title="Permalink to this definition"></a></dt>
<dd><p>Interpret this vector as a direction vector and return its length.
The result is the same as math.sqrt(self[0]**2 + self[1]**2).</p>
</dd></dl>

<dl class="method">
<dt id="hou.Vector2.lengthSquared">
<code class="descname">lengthSquared</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#hou.Vector2.lengthSquared" title="Permalink to this definition"></a></dt>
<dd><p>Interpret this vector as a direction vector and return the square of
its length. The result is the same as self[0]**2 + self[1]**2.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Vector2.normalized">
<code class="descname">normalized</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Vector2<a class="headerlink" href="#hou.Vector2.normalized" title="Permalink to this definition"></a></dt>
<dd><p>Interpreting this vector as a direction, return a vector with the
same direction but with a length of 1.</p>
<p>If the vectors length is 0 (or close to it), the result is the
original vector.</p>
<p>For vectors with non-zero lengths, this method is equivalent to
self * (1.0/self.length()).</p>
</dd></dl>

<dl class="method">
<dt id="hou.Vector2.setTo">
<code class="descname">setTo</code><span class="sig-paren">(</span><em>self</em>, <em>sequence</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Vector2.setTo" title="Permalink to this definition"></a></dt>
<dd><p>Set the contents of this vector to a sequence of floats.</p>
<p>Raises InvalidSize if values is not 2 elements long, or TypeError if
values is not a sequence of floats or ints.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.Vector2.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.Vector2.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

<dl class="method">
<dt id="hou.Vector2.x">
<code class="descname">x</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#hou.Vector2.x" title="Permalink to this definition"></a></dt>
<dd><p>Return the first component of the vector. Equivalent to v.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Vector2.y">
<code class="descname">y</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#hou.Vector2.y" title="Permalink to this definition"></a></dt>
<dd><p>Return the second component of the vector. Equivalent to v.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.Vector3">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">Vector3</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Vector3" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A sequence of 3 floating point values, with associated mathematical
operations.</p>
<p>A Vector3 might be used to represent a position in 3D space, or a 3D
direction with a length.</p>
<p>See also hou.Vector2 and hou.Vector4.</p>
<dl class="method">
<dt id="hou.Vector3.almostEqual">
<code class="descname">almostEqual</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Vector3.almostEqual" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.Vector3.angleTo">
<code class="descname">angleTo</code><span class="sig-paren">(</span><em>self</em>, <em>vector3</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#hou.Vector3.angleTo" title="Permalink to this definition"></a></dt>
<dd><p>Interprets this Vector3 and the parameter as directions and returns
the angle (in degrees) formed between the two vectors when you place
the origins at the same location.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Vector3.cross">
<code class="descname">cross</code><span class="sig-paren">(</span><em>self</em>, <em>vector3</em><span class="sig-paren">)</span> &#x2192; hou.Vector3<a class="headerlink" href="#hou.Vector3.cross" title="Permalink to this definition"></a></dt>
<dd><p>Return the cross product of this vector with another vector. The
return value is a vector that is perpendicular to both vectors,
pointing in the direction defined by the right-hand rule, with
length self.length() * vector3.length() *
math.sin(hou.hmath.degToRad(self.angleTo(vector3))).</p>
<p>See Wikipedias cross product page.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Vector3.distanceTo">
<code class="descname">distanceTo</code><span class="sig-paren">(</span><em>self</em>, <em>vector3</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#hou.Vector3.distanceTo" title="Permalink to this definition"></a></dt>
<dd><p>Interpret this vector and the argument as 3D positions, and return
the distance between them. The return value is equivalent to (self -
vector3).length().</p>
</dd></dl>

<dl class="method">
<dt id="hou.Vector3.dot">
<code class="descname">dot</code><span class="sig-paren">(</span><em>self</em>, <em>vector3</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#hou.Vector3.dot" title="Permalink to this definition"></a></dt>
<dd><p>Return the dot product between this vector and the one in the
parameter. This value is equal to self[0]*vector3[0] +
self[1]*vector3[1] + self[2]*vector3[2], which is also equal to
self.length() * vector3.length() *
math.cos(hou.hmath.degToRad(self.angleTo(vector3)))</p>
<p>See Wikipedias dot product page.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Vector3.isAlmostEqual">
<code class="descname">isAlmostEqual</code><span class="sig-paren">(</span><em>self</em>, <em>vector3</em>, <em>tolerance=0.00001</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.Vector3.isAlmostEqual" title="Permalink to this definition"></a></dt>
<dd><p>Return whether this vector is equal to another, within a tolerance.
Verifies that the difference between each component of this vector
and the corresponding component of the other vector is within the
tolerance.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Vector3.length">
<code class="descname">length</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#hou.Vector3.length" title="Permalink to this definition"></a></dt>
<dd><p>Interpret this vector as a direction vector and return its length.
The result is the same as math.sqrt(self[0]**2 + self[1]**2 +
self[2]**2).</p>
</dd></dl>

<dl class="method">
<dt id="hou.Vector3.lengthSquared">
<code class="descname">lengthSquared</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#hou.Vector3.lengthSquared" title="Permalink to this definition"></a></dt>
<dd><p>Interpret this vector as a direction vector and return the square of
its length. The result is the same as self[0]**2 + self[1]**2 +
self[2]**2.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Vector3.matrixToRotateTo">
<code class="descname">matrixToRotateTo</code><span class="sig-paren">(</span><em>self</em>, <em>vector3</em><span class="sig-paren">)</span> &#x2192; hou.Matrix4<a class="headerlink" href="#hou.Vector3.matrixToRotateTo" title="Permalink to this definition"></a></dt>
<dd><p>Return a matrix that rotates this vector onto vector3, rotating
about the axis perpendicular to the two vectors. If the two vectors
have the same direction, return the identity matrix.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Vector3.multiplyAsDir">
<code class="descname">multiplyAsDir</code><span class="sig-paren">(</span><em>self</em>, <em>matrix4</em><span class="sig-paren">)</span> &#x2192; hou.Vector3<a class="headerlink" href="#hou.Vector3.multiplyAsDir" title="Permalink to this definition"></a></dt>
<dd><p>Interpret this vector as a direction and returns a transformed
direction that has been rotated and scaled (not translated) by the
matrix4</p>
</dd></dl>

<dl class="method">
<dt id="hou.Vector3.normalized">
<code class="descname">normalized</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Vector3<a class="headerlink" href="#hou.Vector3.normalized" title="Permalink to this definition"></a></dt>
<dd><p>Interpret this vector as a direction and return a vector with the
same direction but with a length of 1.</p>
<p>If the vectors length is 0 (or close to it), the result is the
original vector.</p>
<p>For vectors with non-zero lengths, this method is equivalent to self
* (1.0/self.length()).</p>
</dd></dl>

<dl class="method">
<dt id="hou.Vector3.ocio_transform">
<code class="descname">ocio_transform</code><span class="sig-paren">(</span><em>self</em>, <em>src_space</em>, <em>dest_space</em><span class="sig-paren">)</span> &#x2192; hou.Vector3<a class="headerlink" href="#hou.Vector3.ocio_transform" title="Permalink to this definition"></a></dt>
<dd><p>Use Open Color IO to transform the color from the source space to
the destination space.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Vector3.setTo">
<code class="descname">setTo</code><span class="sig-paren">(</span><em>self</em>, <em>sequence</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Vector3.setTo" title="Permalink to this definition"></a></dt>
<dd><p>Set the contents of this vector to a sequence of floats.</p>
<p>Raises InvalidSize if values is not 3 elements long, or TypeError if
values is not a sequence of floats or ints.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Vector3.smoothRotation">
<code class="descname">smoothRotation</code><span class="sig-paren">(</span><em>self</em>, <em>reference</em>, <em>rotate_order=&quot;xyz&quot;</em><span class="sig-paren">)</span> &#x2192; hou.Vector3<a class="headerlink" href="#hou.Vector3.smoothRotation" title="Permalink to this definition"></a></dt>
<dd><p>Returns the Euler rotations (in degrees) that have the closest
values to reference while still describing the same orientation as
this vector.</p>
<dl class="docutils">
<dt>reference</dt>
<dd>A hou.Vector3 of Euler angles, in degrees. Typically, this will
be the rotations from the previous sample or frame.</dd>
<dt>rotate_order</dt>
<dd>A string containing a permutation of the letters x, y, and z
that determines the order in which rotations are performed about
the coordinate axes.</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="hou.Vector3.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.Vector3.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

<dl class="method">
<dt id="hou.Vector3.x">
<code class="descname">x</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#hou.Vector3.x" title="Permalink to this definition"></a></dt>
<dd><p>Return the first component of the vector. Equivalent to v.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Vector3.y">
<code class="descname">y</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#hou.Vector3.y" title="Permalink to this definition"></a></dt>
<dd><p>Return the second component of the vector. Equivalent to v.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Vector3.z">
<code class="descname">z</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#hou.Vector3.z" title="Permalink to this definition"></a></dt>
<dd><p>Return the third component of the vector. Equivalent to v.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.Vector4">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">Vector4</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Vector4" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A sequence of 4 floating point values, with associated mathematical
operations.</p>
<p>A Vector4 could be used to represent a position or direction in 4D
space. In 3D math, however, it is more commonly used to represent either
a position or a vector, depending on the value of the fourth component.
Positions have a fourth component of 1.0, and vectors have a fourth
component of 0.0. Subtracting a position from another yields a vector,
adding two vectors together yields a vector, and adding a point and a
vector yields a point. Operations that yield a fourth component value
other than 0 or 1, like adding two points together, are not valid.
Similarly, is makes sense to speak about a vectors length but not a
positions length. The fourth component also affects how the
position/vector is transformed; see hou.Vector3.__mul__ for more
information.</p>
<p>See also hou.Vector2 and hou.Vector3.</p>
<dl class="method">
<dt id="hou.Vector4.almostEqual">
<code class="descname">almostEqual</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Vector4.almostEqual" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.Vector4.dot">
<code class="descname">dot</code><span class="sig-paren">(</span><em>self</em>, <em>vector4</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#hou.Vector4.dot" title="Permalink to this definition"></a></dt>
<dd><p>Return the dot product between this 4D vector and the one in the
parameter. This value is equal to self[0]*vector4[0] +
self[1]*vector4[1] + self[2]*vector4[2] + self[3]*vector4[3].</p>
</dd></dl>

<dl class="method">
<dt id="hou.Vector4.isAlmostEqual">
<code class="descname">isAlmostEqual</code><span class="sig-paren">(</span><em>self</em>, <em>vector4</em>, <em>tolerance=0.00001</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.Vector4.isAlmostEqual" title="Permalink to this definition"></a></dt>
<dd><p>Return whether this vector is equal to another, within a tolerance.
Verifies that the difference between each component of this vector
and the corresponding component of the other vector is within the
tolerance.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Vector4.length">
<code class="descname">length</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#hou.Vector4.length" title="Permalink to this definition"></a></dt>
<dd><p>Interpret this vector as a 4D direction vector and return its
length. If this vector is representing a 3D direction (so the fourth
component is 0), the result is the 3D length.</p>
<p>The result is the same as math.sqrt(self[0]**2 + self[1]**2 +
self[2]**2 + self[3]**2).</p>
</dd></dl>

<dl class="method">
<dt id="hou.Vector4.lengthSquared">
<code class="descname">lengthSquared</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#hou.Vector4.lengthSquared" title="Permalink to this definition"></a></dt>
<dd><p>Return the result of self.length()**2. The result is the same as
self[0]**2 + self[1]**2 + self[2]**2 + self[3]**2.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Vector4.normalized">
<code class="descname">normalized</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; Vector4<a class="headerlink" href="#hou.Vector4.normalized" title="Permalink to this definition"></a></dt>
<dd><p>Interpret this vector as a 4D direction and return a vector with the
same direction but with a length of 1. If this vector being used to
represent a 3D direction (so the fourth component is 0), the result
is still meaningful, and represents the corresponding 3D direction.</p>
<p>If the vectors length is 0 (or close to it), the result is the
original vector.</p>
<p>For vectors with non-zero lengths, this method is equivalent to self
* (1.0/self.length()).</p>
</dd></dl>

<dl class="method">
<dt id="hou.Vector4.ocio_transform">
<code class="descname">ocio_transform</code><span class="sig-paren">(</span><em>self</em>, <em>src_space</em>, <em>dest_space</em><span class="sig-paren">)</span> &#x2192; hou.Vector4<a class="headerlink" href="#hou.Vector4.ocio_transform" title="Permalink to this definition"></a></dt>
<dd><p>Use Open Color IO to transform the color from the source space to
the destination space.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Vector4.setTo">
<code class="descname">setTo</code><span class="sig-paren">(</span><em>self</em>, <em>sequence</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Vector4.setTo" title="Permalink to this definition"></a></dt>
<dd><p>Set the contents of this vector to a sequence of floats.</p>
<p>Raises InvalidSize if values is not 4 elements long, or TypeError if
values is not a sequence of floats or ints.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.Vector4.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.Vector4.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

<dl class="method">
<dt id="hou.Vector4.w">
<code class="descname">w</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#hou.Vector4.w" title="Permalink to this definition"></a></dt>
<dd><p>Return the fourth component of the vector. Equivalent to v.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Vector4.x">
<code class="descname">x</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#hou.Vector4.x" title="Permalink to this definition"></a></dt>
<dd><p>Return the first component of the vector. Equivalent to v.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Vector4.y">
<code class="descname">y</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#hou.Vector4.y" title="Permalink to this definition"></a></dt>
<dd><p>Return the second component of the vector. Equivalent to v.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Vector4.z">
<code class="descname">z</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#hou.Vector4.z" title="Permalink to this definition"></a></dt>
<dd><p>Return the third component of the vector. Equivalent to v.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.Vertex">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">Vertex</code><a class="headerlink" href="#hou.Vertex" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Existing inside a Geometry object, a Vertex object is contained in
exactly one Prim, and references exactly one Point.</p>
<p>This setup allows points to be shared between primitives. For example, a
polygon contains its own list of vertices that are not shared with other
primitives, but vertices in different polygons may refer to the same
point. When that point moves, the corresponding vertices on all adjacent
polygons will also move, preventing polygon edges from separating.</p>
<p>Note that you can use hou.Vertex.point to retrieve a point from a
vertex, but there is no method to retrieve all the vertices referring to
a point. Houdini does not store this information internally, but you can
derive it. The best way to quickly retrieve this information is to build
a dictionary mapping all points to sets of vertices, and then reuse this
dictionary in your algorithm.</p>
<dl class="method">
<dt id="hou.Vertex.attribType">
<code class="descname">attribType</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.attribType enum value<a class="headerlink" href="#hou.Vertex.attribType" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Return the enumerated value hou.attribType.Vertex. Points,
primitives, vertices, and geometry support the same set of methods
for querying their attributes, and this method is one of them.</p>
<p>See also:</p>
</div></blockquote>
<ul class="simple">
<li>hou.Point.attribType</li>
<li>hou.Prim.attribType</li>
<li>hou.Geometry.attribType</li>
<li>hou.attribType</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="hou.Vertex.attribValue">
<code class="descname">attribValue</code><span class="sig-paren">(</span><em>self</em>, <em>name_or_attrib</em><span class="sig-paren">)</span> &#x2192; int, float, str or tuple<a class="headerlink" href="#hou.Vertex.attribValue" title="Permalink to this definition"></a></dt>
<dd><p>Return the value store in this vertex for a particular attribute.
The attribute may be specified by name or by hou.Attrib object.</p>
<p>Looking an attribute value using a hou.Attrib object is slightly
faster than looking it up by name. When looking up attribute values
inside a loop, look up the hou.Attrib object outside the loop, and
pass it into this method.</p>
<p>Raises hou.OperationFailed if no attribute exists with this name.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Vertex.floatAttribValue">
<code class="descname">floatAttribValue</code><span class="sig-paren">(</span><em>self</em>, <em>name_or_attrib</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#hou.Vertex.floatAttribValue" title="Permalink to this definition"></a></dt>
<dd><p>Return the vertex attribute value for a particular floating point
attribute. The attribute may be specified by name or by hou.Attrib
object.</p>
<p>Raises hou.OperationFailed if no attribute exists with this name or
the attribute is not float of size 1.</p>
<p>In most cases, youll just use hou.Vertex.attribValue to access
attribute values. Houdini uses this method internally to implement
attribValue.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Vertex.floatListAttribValue">
<code class="descname">floatListAttribValue</code><span class="sig-paren">(</span><em>self</em>, <em>name_or_attrib</em><span class="sig-paren">)</span> &#x2192; tuple of float<a class="headerlink" href="#hou.Vertex.floatListAttribValue" title="Permalink to this definition"></a></dt>
<dd><p>Return the vertex attribute value for a particular floating point
attribute. The attribute may be specified by name or by hou.Attrib
object. The return value is a tuple of floats.</p>
<p>It is valid to call this method when the attributes size is 1. In
this case, a tuple with one element is returned.</p>
<p>See also hou.Vertex.attribValue.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Vertex.geometry">
<code class="descname">geometry</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; Geometry<a class="headerlink" href="#hou.Vertex.geometry" title="Permalink to this definition"></a></dt>
<dd><p>Return the hou.Geometry object containing this vertex.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Vertex.intAttribValue">
<code class="descname">intAttribValue</code><span class="sig-paren">(</span><em>self</em>, <em>name_or_attrib</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.Vertex.intAttribValue" title="Permalink to this definition"></a></dt>
<dd><p>Return the vertex attribute value for a particular integer attribute
of size 1. The attribute may be specified by name or by hou.Attrib
object. See hou.Vertex.floatAttribValue for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Vertex.intListAttribValue">
<code class="descname">intListAttribValue</code><span class="sig-paren">(</span><em>self</em>, <em>name_or_attrib</em><span class="sig-paren">)</span> &#x2192; tuple of int<a class="headerlink" href="#hou.Vertex.intListAttribValue" title="Permalink to this definition"></a></dt>
<dd><p>Return the vertex attribute value for a particular integer
attribute. The attribute may be specified by name or by hou.Attrib
object. The return value is a tuple of ints. See
hou.Vertex.floatListAttribValue for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Vertex.linearNumber">
<code class="descname">linearNumber</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.Vertex.linearNumber" title="Permalink to this definition"></a></dt>
<dd><p>Return the number of this vertex within its whole detail. Vertices
in the detail are sometimes in the same order as they occur in
primitives, but this is often <em>not</em> true. Linear vertex numbers in a
detail are sequential, starting from 0, and ending with one less
than the total number of vertices in the detail. This can be useful
so that a function that can be applied to point, vertex, primitive,
or detail attributes doesnt have to take two numbers just to handle
the vertex case.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Vertex.number">
<code class="descname">number</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.Vertex.number" title="Permalink to this definition"></a></dt>
<dd><p>Return the number of this vertex within its primitive. Vertices in
the same primitive are numbered sequentially starting from 0, and
the vertices returned by hou.Prim.vertices are in order by their
number.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Vertex.point">
<code class="descname">point</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Point<a class="headerlink" href="#hou.Vertex.point" title="Permalink to this definition"></a></dt>
<dd><p>Return the hou.Point object that this vertex refers to. Each vertex
refers to exactly one point.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Vertex.prim">
<code class="descname">prim</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Prim<a class="headerlink" href="#hou.Vertex.prim" title="Permalink to this definition"></a></dt>
<dd><p>Return the hou.Prim object containing this vertex.</p>
<p>If the primitive is a face, use hou.Prim.vertices to access the
other vertices in the primitive. If it is a surface, use
hou.Surface.vertex, hou.Surface.numRows, and hou.Surface.numCols.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Vertex.setAttribValue">
<code class="descname">setAttribValue</code><span class="sig-paren">(</span><em>self</em>, <em>name_or_attrib</em>, <em>attrib_value</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Vertex.setAttribValue" title="Permalink to this definition"></a></dt>
<dd><p>Store an attribute value in this vertex. The attribute may be
specified by name or by hou.Attrib object, and must be an existing
vertex attribute in the geometry. You would typically call this
method from the code of a Python-defined SOP.</p>
<p>Raises hou.OperationFailed if no attribute exists with this name or
if the attributes data type does not match the value passed in. If
the attributes size is more than 1, the attribute value must be a
sequence of integers/floats, and the size of the sequence must match
the attributes size.</p>
<p>Raises hou.GeometryPermissionError if this geometry is not
modifiable.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Vertex.stringAttribValue">
<code class="descname">stringAttribValue</code><span class="sig-paren">(</span><em>self</em>, <em>name_or_attrib</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.Vertex.stringAttribValue" title="Permalink to this definition"></a></dt>
<dd><p>Return the vertex attribute value for a particular string attribute.
The attribute may be specified by name or by hou.Attrib object. See
hou.Vertex.floatAttribValue for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Vertex.stringListAttribValue">
<code class="descname">stringListAttribValue</code><span class="sig-paren">(</span><em>self</em>, <em>name_or_attrib</em><span class="sig-paren">)</span> &#x2192; tuple of str<a class="headerlink" href="#hou.Vertex.stringListAttribValue" title="Permalink to this definition"></a></dt>
<dd><p>Return the vertex attribute value for a particular string attribute.
The attribute may be specified by name or by hou.Attrib object. The
return value is a tuple of strings.</p>
<p>It is valid to call this method when the attributes size is 1. In
this case, a tuple with one element is returned.</p>
<p>See also hou.Vertex.attribValue.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.Vertex.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.Vertex.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.VexContext">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">VexContext</code><a class="headerlink" href="#hou.VexContext" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Represents a VEX/VOP context. Different contexts allow the use of
different functions/VOPs.</p>
<dl class="docutils">
<dt>NOTE</dt>
<dd>This class is for internal use by Houdini and isnt usually
necessary for scripting Houdini or creating tools.</dd>
</dl>
<p>This object is returned by hou.vexContextForNodeTypeCategory and
hou.vexContextForShaderType. You can get a list of all VEX context
objects using hou.vexContexts.</p>
<p>REPLACES</p>
<blockquote>
<div><ul class="simple">
<li>vexinfo</li>
</ul>
</div></blockquote>
<dl class="method">
<dt id="hou.VexContext.name">
<code class="descname">name</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.VexContext.name" title="Permalink to this definition"></a></dt>
<dd><p>Returns the name of this context as a string. For example, Sop or
surface.</p>
</dd></dl>

<dl class="method">
<dt id="hou.VexContext.nodeTypeCategory">
<code class="descname">nodeTypeCategory</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.NodeTypeCategory<a class="headerlink" href="#hou.VexContext.nodeTypeCategory" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Returns the hou.NodeTypeCategory object associated with this VEX
context.</div></blockquote>
<p>&gt; &gt;&gt;&gt; # Get a reference to a SOP node
&gt; &gt;&gt;&gt; n = hou.node(/obj/geo1/pointvop1)
&gt; &gt;&gt;&gt; # Get its type category (SOPs)
&gt; &gt;&gt;&gt; sops = n.type().category()
&gt; &gt;&gt;&gt; # Get the context associated with the SOPs category
&gt; &gt;&gt;&gt; ctx = hou.vexContextForNodeTypeCategory(sops)
&gt; &gt;&gt;&gt; # Get the node type category associated with the Sop context
&gt; &gt;&gt;&gt; ctx.nodeTypeCategory()
&gt; &lt;hou.NodeTypeCategory for Sop&gt;</p>
</dd></dl>

<dl class="method">
<dt id="hou.VexContext.pathsToLoadedVexFunctions">
<code class="descname">pathsToLoadedVexFunctions</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; dict mapping names to paths<a class="headerlink" href="#hou.VexContext.pathsToLoadedVexFunctions" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.VexContext.shaderType">
<code class="descname">shaderType</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.shaderType enum value or None<a class="headerlink" href="#hou.VexContext.shaderType" title="Permalink to this definition"></a></dt>
<dd><p>Returns a hou.shaderType value representing the shader type
associated with this VEX context.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.VexContext.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.VexContext.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.ViewerEvent">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">ViewerEvent</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ViewerEvent" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.UIEvent" title="hou.UIEvent"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.UIEvent</span></code></a></p>
<p>Represents a user interface event specific to viewers.</p>
<p>hou.ViewerEvent objects are used with Python states. Houdini will call
event handlers with a dictionary containing various useful data,
including a ui_event key containing a ViewerEvent object. You do not
instantiate this type of object yourself. See Python states for more
information.</p>
<p>hou.ViewerEvent is a specialized hou.UIEvent class that you can used for
accessing ray coordinates in a viewer.</p>
<dl class="method">
<dt id="hou.ViewerEvent.ray">
<code class="descname">ray</code><span class="sig-paren">(</span><em>self) -&gt; (origin_point</em>, <em>direction</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ViewerEvent.ray" title="Permalink to this definition"></a></dt>
<dd><p>Returns a tuple of two hou.Vector3 objects representing the origin
point and a direction vector of a pointing ray in 3D world space
corresponding to the underlying hou.UIEventDevices mouse
coordidnates in screen space.</p>
<p>The resulting ray can be used to shoot into the scene that passes
through whatever is under the mouse. The method puts the ray origin
at the mouse screen coordinates on the near plane and then maps the
camera space position to world space. For a perspective projection,
the near plane part of the frustum is usually small in world space,
so the origin point will be pretty close to the camera position.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ViewerEvent.snappingRay">
<code class="descname">snappingRay</code><span class="sig-paren">(</span><em>self) -&gt; (origin_point</em>, <em>direction</em>, <em>snapped</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ViewerEvent.snappingRay" title="Permalink to this definition"></a></dt>
<dd><p>Same as hou.ViewerEvent.ray, but the returned original point may be
snapped with respect to the snapping controls in Houdini. The tuple
returns the hou.Vector3 objects representing the origin point and a
direction vector along with a bool value (snapped) representing the
snap result.</p>
<p>If snapped is True, the origin point corresponds to a snapped
coordinate in 3D world space. If False, the origin point is a
regular pointing ray.</p>
<dl class="docutils">
<dt>Note</dt>
<dd>snapped may be False if snap is not enabled or the origin point
doesnt correspond to a snapped point.</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="hou.ViewerEvent.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.ViewerEvent.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.ViewerState">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">ViewerState</code><a class="headerlink" href="#hou.ViewerState" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Describes an interactive state for a viewer pane.</p>
<p>Viewer panes such as a Scene Viewer or Compositor Viewer can enter
specific states. A state controls the available handles, mouse
interactions, and in some cases node creation or deletion based on user
interaction with the viewer pane. This class does not represent a
running state in a viewer, but instead describes a state that can be
entered with methods such as hou.SceneViewer.setCurrentState or
hou.CompositorViewer.setCurrentState.</p>
<p>Each node type that can be displayed in a viewer pane will have an
associated viewer state (though not all viewer states need to be
associated with a node type). This node type specific viewer state is
used to create new instances or edit existing instances of the node type
in a viewer pane.</p>
<p>The list of viewer states associated with a given node type category is
returned from the hou.NodeTypeCategory.viewerStates method.</p>
<dl class="method">
<dt id="hou.ViewerState.categories">
<code class="descname">categories</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of hou.NodeTypeCategory<a class="headerlink" href="#hou.ViewerState.categories" title="Permalink to this definition"></a></dt>
<dd><p>Return the node type category for the nodes that are associated with
this state.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ViewerState.description">
<code class="descname">description</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; string<a class="headerlink" href="#hou.ViewerState.description" title="Permalink to this definition"></a></dt>
<dd><p>Return the brief name of the state that appears in the upper left
corner of the viewer pane when this state is active.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ViewerState.hotkey">
<code class="descname">hotkey</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; string<a class="headerlink" href="#hou.ViewerState.hotkey" title="Permalink to this definition"></a></dt>
<dd><p>Return the hotkey associated with this state.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ViewerState.icon">
<code class="descname">icon</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; string<a class="headerlink" href="#hou.ViewerState.icon" title="Permalink to this definition"></a></dt>
<dd><p>Return the icon for the state that appears in the upper left corner
of the viewer pane when this state is active.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ViewerState.isHidden">
<code class="descname">isHidden</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.ViewerState.isHidden" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.ViewerState.name">
<code class="descname">name</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; string<a class="headerlink" href="#hou.ViewerState.name" title="Permalink to this definition"></a></dt>
<dd><p>Return the internal name of this state, which is the string that
must be passed to the setCurrentState() method of the viewer pane to
enter this state.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ViewerState.nodeType">
<code class="descname">nodeType</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.NodeType or None<a class="headerlink" href="#hou.ViewerState.nodeType" title="Permalink to this definition"></a></dt>
<dd><p>Return the node type associated with this state. May return None if
this state is not associated with a particular node type, such as
the SOP or Object View states which are used for panning and
tumbling in a scene viewer pane.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ViewerState.parmTemplates">
<code class="descname">parmTemplates</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ViewerState.parmTemplates" title="Permalink to this definition"></a></dt>
<dd><p>Return the parameter templates associated with this state.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.ViewerState.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.ViewerState.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.ViewerStateMenu">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">ViewerStateMenu</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ViewerStateMenu" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Builds a context menu for a viewer state.</p>
<p>OVERVIEW</p>
<blockquote>
<div><blockquote>
<div><p>The ViewerStateMenu class lets you build a context menu for a viewer
state. This class is also represents sub-menus of the top-level
context menu.</p>
<p>Currently you can add the following items to the menu</p>
</div></blockquote>
<ul>
<li><p class="first">Toggle (checkbox) item: represents a setting you can turn on or off</p>
</li>
<li><p class="first">Radio strip: represents a choice of several mutually exclusive
items.</p>
</li>
<li><p class="first">Action item: represents an action to preform. You implement the
action in the states onMenuAction method.</p>
</li>
<li><p class="first">Separator item: creates a visual separation between groups of items
in the menu.</p>
<p>Hotkeys created with hou.hotkeys.addCommand can be added to toggle,
action and radio strip menu items.</p>
<p>See setting up viewer state context menus for more information.</p>
<p>The following example shows how to implement and bind a menu to a
sop viewer state.</p>
</li>
</ul>
<p>&gt; from __future__ import print_function
&gt; import hou
&gt; 
&gt; 
&gt; class ExampleState(object):
&gt;     def __init__(self, state_name, scene_viewer):
&gt;         self.state_name = state_name
&gt;         self.scene_viewer = scene_viewer
&gt; 
&gt;     # the menu callback
&gt;     def onMenuAction(self, kwargs):
&gt;         action = kwargs[menu_item]
&gt;         if action == toggle1:
&gt;             print(Set toggle 1 to, kwargs[toggle1])
&gt; 
&gt;         elif action == toggle2:
&gt;             print(Set toggle 2 to, kwargs[toggle2])
&gt; 
&gt;         elif action == action:
&gt;             print(Chose action 1)
&gt; 
&gt;         elif action == radio_strip:
&gt;             print(Set the radio strip to, kwargs[radio_strip])
&gt; 
&gt;         elif action == submenu_toggle1:
&gt;             print(Set the submenu toggle to, kwargs[submenu_toggle1])
&gt; 
&gt; 
&gt; def createViewerStateTemplate(state_type, state_label):     
&gt;     template = hou.ViewerStateTemplate(
&gt;         state_type, state_label, hou.sopNodeTypeCategory()
&gt;     )
&gt;     template.bindFactory(ExampleState)
&gt; 
&gt;     # create some hotkeys
&gt;     example_context = h.pane.gview.state.sop.example
&gt;     hou.hotkeys.addContext(example_context, Example Operation, These keys apply to the Example operations)
&gt; 
&gt;     h1 = example_context + h1
&gt;     hou.hotkeys.addCommand(h1, example 1, example 1)
&gt;     hou.hotkeys.addAssignment(h1, 1)            
&gt; 
&gt;     h2 = example_context + h2
&gt;     hou.hotkeys.addCommand(h2, example 2, example 2)
&gt;     hou.hotkeys.addAssignment(h2, 2)
&gt; 
&gt;     h3 = example_context + h3
&gt;     hou.hotkeys.addCommand(h3, example 3, example 3)
&gt;     hou.hotkeys.addAssignment(h3, 3)
&gt; 
&gt;     h4 = example_context + h3
&gt;     hou.hotkeys.addCommand(h4, example 4, example 4)
&gt;     hou.hotkeys.addAssignment(h4, 4)
&gt; 
&gt;     # define the state popupmenu
&gt;     m = hou.ViewerStateMenu(menu, Example)
&gt; 
&gt;     m.addSeparator()
&gt;     m.addToggleItem( toggle1, Toggle1, True, hotkey=h1 )
&gt;     m.addToggleItem( toggle2, Toggle2, False )
&gt;     m.addSeparator()
&gt;     m.addActionItem( action, Action1, hotkey=h2 )
&gt;     m.addSeparator()
&gt;     m.addRadioStrip( radio_strip, Radio, radio_item1 )
&gt;     m.addRadioStripItem( radio_strip, radio_item1, Radio1, hotkey=h3 )
&gt;     m.addRadioStripItem( radio_strip, radio_item2, Radio2, hotkey=h4 )
&gt;     m.addSeparator()
&gt;     subm = hou.ViewerStateMenu(submenu, More Example)
&gt;     subm.addToggleItem( submenu_toggle1, Sub toggle1, True )
&gt;     m.addMenu( subm )
&gt;     m.addSeparator()
&gt; 
&gt;     # attach popupmenu to state
&gt;     template.bindMenu(m)
&gt; 
&gt;     return t</p>
</div></blockquote>
<dl class="method">
<dt id="hou.ViewerStateMenu.addActionItem">
<code class="descname">addActionItem</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ViewerStateMenu.addActionItem" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.ViewerStateMenu.addMenu">
<code class="descname">addMenu</code><span class="sig-paren">(</span><em>self</em>, <em>submenu</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ViewerStateMenu.addMenu" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Adds a ViewerStateMenu object as a submenu.</div></blockquote>
<p>&gt; menu = hou.ViewerStateMenu(menu, State Menu)
&gt; menu.addActionItem(delete, Delete)
&gt; menu.addSeparator()
&gt; submenu = hou.ViwerStateMenu(options, Options)
&gt; submenu.addToggleItem(show_points, Show Points, True)
&gt; submenu.addToggleItem(show_point_nums, Show Point Numbers, False)
&gt; menu.addMenu(submenu)</p>
</dd></dl>

<dl class="method">
<dt id="hou.ViewerStateMenu.addRadioStrip">
<code class="descname">addRadioStrip</code><span class="sig-paren">(</span><em>self</em>, <em>id</em>, <em>label</em>, <em>default</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ViewerStateMenu.addRadioStrip" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Prepares the menu to accept a group of mutually exclusive radio
button items.</p>
<dl class="docutils">
<dt>id</dt>
<dd>A unique string ID for the strip. All menu items added to the
group with addRadioStripItem() will have this string as their
first argument.</dd>
<dt>label</dt>
<dd>A title displayed above the group in the menu.</dd>
<dt>default</dt>
<dd>A radio item id as specified with
hou.ViewerStateMenu.addRadioStripItem representing the default
choice when the menu is created.</dd>
</dl>
</div></blockquote>
<p>&gt; menu = hou.ViewerStateMenu(menu, State Menu)
&gt; menu.addRadioStrip(deform_type, Deformation, bend)
&gt; menu.addRadioStripItem(deform_type, bend, Bend)
&gt; menu.addRadioStripItem(deform_type, squash, Squash)</p>
</dd></dl>

<dl class="method">
<dt id="hou.ViewerStateMenu.addRadioStripItem">
<code class="descname">addRadioStripItem</code><span class="sig-paren">(</span><em>self</em>, <em>strip_id</em>, <em>id</em>, <em>label</em>, <em>hotkey=''</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ViewerStateMenu.addRadioStripItem" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Adds an menu item to a radio strip menu.</p>
<dl class="docutils">
<dt>strip_id</dt>
<dd>The string ID of the radio strip (created with addRadioStrip()).
All items that share the same strip_id are mutually exclusive.</dd>
<dt>id</dt>
<dd>A unique string ID for this item.</dd>
<dt>label</dt>
<dd>The menu item text as it will appear in the menu.</dd>
<dt>hotkey</dt>
<dd>An optional hotkey ID string to associate with this menu item.
You can use hou.hotkeys.addCommand to create a custom hotkey.</dd>
</dl>
</div></blockquote>
<p>&gt; menu = hou.ViewerStateMenu(menu, State Menu)
&gt; menu.addRadioStrip(deform_type, Deformation, bend)
&gt; menu.addRadioStripItem(deform_type, bend, Bend)
&gt; menu.addRadioStripItem(deform_type, squash, Squash)</p>
</dd></dl>

<dl class="method">
<dt id="hou.ViewerStateMenu.addSeparator">
<code class="descname">addSeparator</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ViewerStateMenu.addSeparator" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Adds a separator menu item.</div></blockquote>
<p>&gt; menu = hou.ViewerStateMenu(menu, State Menu)
&gt; menu.addActionItem(delete, Delete)
&gt; menu.addSeparator()
&gt; menu.addToggleItem(show_points, Show Points, True)
&gt; menu.addToggleItem(show_point_nums, Show Point Numbers, False)</p>
</dd></dl>

<dl class="method">
<dt id="hou.ViewerStateMenu.addToggleItem">
<code class="descname">addToggleItem</code><span class="sig-paren">(</span><em>self</em>, <em>id</em>, <em>label</em>, <em>default</em>, <em>hotkey=''</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ViewerStateMenu.addToggleItem" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Adds a toggle menu item to this menu.</p>
<dl class="docutils">
<dt>id</dt>
<dd>A unique string ID for this item.</dd>
<dt>label</dt>
<dd>The menu item text as it will appear in the menu.</dd>
<dt>default</dt>
<dd>Whether the item is on or off by default when the menu is
created.</dd>
<dt>hotkey</dt>
<dd>An optional hotkey ID string to associate with this menu item.
You can use hou.hotkeys.addCommand to create a custom hotkey.</dd>
</dl>
</div></blockquote>
<p>&gt; menu = hou.ViewerStateMenu(menu, State Menu)
&gt; menu.addToggleItem(show_points, Show Points, True)
&gt; menu.addToggleItem(show_point_nums, Show Point Numbers, False</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.ViewerStateMenu.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.ViewerStateMenu.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.ViewerStateTemplate">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">ViewerStateTemplate</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ViewerStateTemplate" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Contains attributes describing a certain viewer state (tool).</p>
<p>Viewer states control interaction in the viewport. For example, the
Rotate tool is a view state. The Handles tool allows access to the state
associated with the current node. Houdini lets you create and register
your own custom view states in Python.</p>
<p>This object describes a custom state, including its implementation class
and any bindings (menus, handles, hotkeys, selectors). You supply an
instance of this object when registering a custom state, and Houdini
uses it to create concrete instances of the state from the template.</p>
<p>&gt; import hou
&gt; 
&gt; # Create a class implementing the state callbacks
&gt; class MyState(object):
&gt;     def __init__(self, state_name, scene_viewer):
&gt;         self.state_name = state_name
&gt;         self.scene_viewer = scene_viewer
&gt; 
&gt; 
&gt; # Create a template to describe the state and its bindings
&gt; template = hou.ViewerStateTemplate(
&gt;     mystate, My Custom State,
&gt;     hou.sopNodeTypeCategory()
&gt; )
&gt; template.bindFactory(MyState)
&gt; template.bindHandleStatic(
&gt;     rotate, rot,
&gt;     [(rx, x), (ry, y), (rz, z)]
&gt; )
&gt; 
&gt; # Register the template with Houdini
&gt; hou.ui.registerViewerState(my_template)</p>
<p>For information on how to create your own custom view states, see Python
states.</p>
<dl class="method">
<dt id="hou.ViewerStateTemplate.bindFactory">
<code class="descname">bindFactory</code><span class="sig-paren">(</span><em>self</em>, <em>callable</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ViewerStateTemplate.bindFactory" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Takes a callable object (such as a class or function) that returns
an implementation of the state interface. Usually this will be a
class (a Python class is a callable object which returns an instance
of the class). The callable should accept two arguments: a string
containing the name of the state, and a hou.SceneViewer object
representing the current viewer.</div></blockquote>
<p>&gt; class MyState(object):
&gt;     def __init__(self, state_name, scene_viewer):
&gt;         self.state_name = state_name
&gt;         self.scene_viewer = scene_viewer
&gt; 
&gt;     def onMouseEvent(sefl, kwargs):
&gt;         ui_event = kwargs[ui_event]
&gt; 
&gt; 
&gt; def createViewerTemplate(<a href="#id27"><span class="problematic" id="id28">*</span></a>args):
&gt;     template = hou.ViewerStateTemplate(mystate, My State, hou.sopNodeTypeCategory())
&gt;     template.bindFactory(MyState)
&gt;     return template</p>
</dd></dl>

<dl class="method">
<dt id="hou.ViewerStateTemplate.bindGeometrySelector">
<code class="descname">bindGeometrySelector</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ViewerStateTemplate.bindGeometrySelector" title="Permalink to this definition"></a></dt>
<dd><p>bindGeometrySelector(self, prompt, allow_drag=False, quick_select=True,
auto_start=True, use_existing_selection=True, initial_selection=,
initial_selection_type=hou.geometryType.Primitives, ordered=False,
geometry_types=hou.geometryType.Primitives, primitive_types=None,
allow_other_sops=False, hotkey=None)</p>
<blockquote>
<div><p>Binds a geometry selector to this viewer state. This selector is
used for selecting geometry elements when the underlying viewer
state is active. This selector can only be used in a scene viewer,
exception is thrown otherwise at registration
(hou.ui.registerViewerStateTemplate).</p>
<p>Only one selector can be used with a viewer state. Multiple
selectors are not supported, exception is thrown otherwise.</p>
<p>The viewer state plug-in can implement the onSelection method to
receive new selections. onSelection gets the new selection as a
hou.GeometrySelection stored in the selection entry of the input
kwargs dictionary. The return value can be True to stop the
selection tool or False to keep it running. Pressing [Enter] also
terminates the selector.</p>
<dl class="docutils">
<dt>prompt</dt>
<dd>Prompt displayed in the viewport when the selector is active.
The prompt is mandatory.</dd>
<dt>allow_drag</dt>
<dd>Determines whether selecting a component with a single mouse
click completes the selection. This is typically used to prevent
a multiple component selection. Defaults to False.</dd>
<dt>quick_select</dt>
<dd>If this is True, the states selection event is called whenever
the selection changes. If this is False, Houdini waits for the
user to finish selection by pressing [Enter] before it notifies
the state about the new selection.</dd>
<dt>auto_start</dt>
<dd><p class="first">If True (the default), start the selector when the viewer state
is activated. If False, you must specify a hotkey argument that
activates the selector.</p>
<dl class="last docutils">
<dt>NOTE</dt>
<dd>If you specify auto_start=False but dont specify a hotkey
(or specify hotkey=None), Houdini will print a warning to
the console and then act as if auto_start=True.</dd>
</dl>
</dd>
<dt>use_existing_selection</dt>
<dd>If this is True, and a component selection exists when the user
activates the state, Houdini will call onSelection with that
selection. If this is False, Houdini will clear any existing
selection and ask for a new selection.</dd>
<dt>initial_selection</dt>
<dd>When use_existing_selection is False, this is a string of
component group syntax representing what to set the selection to
when the state is activated. The default is no selection.</dd>
<dt>initial_selection_type</dt>
<dd>A hou.geometryType value, representing the type of components
specified by the initial_selection argument. The default is
hou.geometryType.Primitives.</dd>
<dt>ordered</dt>
<dd><p class="first">If this is True, Houdini returns the components in the selection
in the order the user selected them. The default is False,
meaning the order of the components you get is unrelated to the
order they were selected.</p>
<p class="last">Only set this to True if for some reason you need to
distinguish, for example, the first primitive the user clicked,
or the last, or that kind of thing.</p>
</dd>
<dt>geometry_types</dt>
<dd>A hou.geometryType value representing the component type the
user can select. The default is hou.geometryType.Primitives.</dd>
<dt>primitive_types</dt>
<dd>If this is not None, it should be a hou.primType value
representing a type of primitive the user can select. The
default of None allows selecting all types.</dd>
<dt>allow_other_sops</dt>
<dd>Allow selecting components on geometry from other geometry nodes
visible in the viewport. Defaults to False.</dd>
<dt>hotkey</dt>
<dd>An optional hotkey which acts as a switch for starting or
stopping the selector. The default is None.</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.ViewerStateTemplate.bindHandle">
<code class="descname">bindHandle</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ViewerStateTemplate.bindHandle" title="Permalink to this definition"></a></dt>
<dd><p>bindHandleStatic(self, handle_type, name, bindings, settings=None)</p>
<blockquote>
<div><blockquote>
<div><p>Binds a handle to a node parameter, so dragging the handle
automatically updates the bound parameter.</p>
<dl class="docutils">
<dt>handle_type</dt>
<dd>A string naming the type of handle.</dd>
<dt>name</dt>
<dd>A unique string to use to identify the handle. Each bindings
name must be unique _within this <a href="#id79"><span class="problematic" id="id80">state_</span></a>. Trying to bind the same
name more than once will raise an exception.</dd>
<dt>bindings</dt>
<dd><p class="first">A list of (node_parm_name, handle_parm_name) tuples. This
binds the parts of the handle to individual parameters on the
node. For example:</p>
<p class="last">Holds the binding information for the handle to node parm
mappings. The bindings are provided as a list of node to handle
parm name tuples.</p>
</dd>
<dt>settings</dt>
<dd>A string containing specific settings of a handle. These
settings are mostly read-only and cannot be changed at runtime.</dd>
</dl>
</div></blockquote>
<p>&gt; t = hou.ViewerStateTemplate(my_state, my_state_label, hou.sopNodeTypeCategory())
&gt; 
&gt; t.bindHandleStatic( vector, Up Direction, 
&gt;     [
&gt;                     (group, input),
&gt;                     (originx, tx),
&gt;                     (originy, ty),
&gt;                     (originz, tz),
&gt;                     (upx, vx),
&gt;                     (upy, vy),
&gt;                     (upz, vz)
&gt;     ]
&gt; )</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.ViewerStateTemplate.bindHandleStatic">
<code class="descname">bindHandleStatic</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ViewerStateTemplate.bindHandleStatic" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.ViewerStateTemplate.bindMenu">
<code class="descname">bindMenu</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.ViewerStateTemplate.bindMenu" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.ViewerStateTemplate.bindObjectSelector">
<code class="descname">bindObjectSelector</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ViewerStateTemplate.bindObjectSelector" title="Permalink to this definition"></a></dt>
<dd><p>bindObjectSelector(self, prompt, quick_select=True, auto_start=True,
use_existing_selection=True, allow_multisel=True, allowed_types=(*,),
hotkey=None)</p>
<blockquote>
<div><p>Binds an object selector to a viewer state of type Object. This
selector is used for selecting objects when the underlying viewer
state is active. This selector can only be used in a scene viewer,
exception is thrown otherwise at registration
(hou.ui.registerViewerStateTemplate).</p>
<p>Only one selector can be used with a viewer state. Multiple
selectors are not supported, exception is thrown otherwise.</p>
<p>The viewer state plug-in can implement the onSelection method to
receive new selections. onSelection gets the new selection as a list
of hou.Node objects stored in the selection entry of the input
kwargs dictionary. The return value can be True to stop the
selection tool or False to keep it running. Pressing [Enter] also
terminates the selector.</p>
<dl class="docutils">
<dt>prompt</dt>
<dd>Prompt displayed in the viewport when the selector is active.
The prompt is mandatory.</dd>
<dt>quick_select</dt>
<dd>If this is True, the states selection event is called whenever
the selection changes. If this is False, Houdini waits for the
user to finish selection by pressing [Enter] before it notifies
the state about the new selection. Defaults to True.</dd>
<dt>auto_start</dt>
<dd><p class="first">If True (the default), start the selector when the viewer state
is activated. If False, you must specify a hotkey argument that
activates the selector.</p>
<dl class="last docutils">
<dt>NOTE</dt>
<dd>If you specify auto_start=False but dont specify a hotkey
(or specify hotkey=None), Houdini will print a warning to
the console and then act as if auto_start=True.</dd>
</dl>
</dd>
<dt>use_existing_selection</dt>
<dd>If this is True, and a component selection exists when the user
activates the state, Houdini will call onSelection with that
selection. If this is False, Houdini will clear any existing
selection and ask for a new selection. Defaults to True.</dd>
<dt>allowed_types</dt>
<dd>A list of strings to specify one or multiple object types the
user can select. For instance, add geo to allowed_types to
select geometry objects only. Patterns such as * can be used to
select any objects or more restritive patterns such as <em>cam</em> for
selecting any camera objects. All available object types can be
obtained with hou.objNodeTypeCategory.nodeTypes. Defaults to <a href="#id29"><span class="problematic" id="id30">*</span></a>.</dd>
<dt>hotkey</dt>
<dd>An optional hotkey which acts as a switch for starting or
stopping the selector. The default is None.</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.ViewerStateTemplate.bindSceneGraphSelector">
<code class="descname">bindSceneGraphSelector</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ViewerStateTemplate.bindSceneGraphSelector" title="Permalink to this definition"></a></dt>
<dd><p>bindSceneGraphSelector(self, prompt, allow_drag=True, quick_select=True,
auto_start=True, use_existing_selection=True, allow_multisel=True,
prior_selection_paths=None, prim_mask=None, path_prefix_mask=None,
prim_kind=None, hotkey=None)</p>
<blockquote>
<div><p>Binds a scene graph selector to this viewer state. This selector is
used for selecting scene graph elements when the underlying viewer
state is active. This selector can only be used in a scene graph
viewer, exception is thrown otherwise at registration
(hou.ui.registerViewerStateTemplate).</p>
<p>Only one selector can be used with a viewer state. Multiple
selectors are not supported, exception is thrown otherwise.</p>
<p>The viewer state plug-in can implement the onSelection method to
receive new selections. onSelection gets the new selection as a list
of element paths stored in the selection entry of the input kwargs
dictionary. The return value can be True to keep running the
selection tool or False to stop it. Pressing [Enter] also terminates
the selector.</p>
<dl class="docutils">
<dt>prompt</dt>
<dd>Prompt displayed in the viewport when the selector is active.
The prompt is mandatory.</dd>
<dt>allow_drag</dt>
<dd>Allows the selection to be completed with a single mouse click.
Defaults to True.</dd>
<dt>quick_select</dt>
<dd>Configure the selector to use quick selections. When True the
selection callback is called automatically for each selection,
if False the user must hit enter to complete the selection.
Defaults to True.</dd>
<dt>auto_start</dt>
<dd>Start the selector when the viewer state is activated. True by
default.</dd>
<dt>use_existing_selection</dt>
<dd>If True, the selector uses the existing selection. Defaults to
True.</dd>
<dt>allow_multisel</dt>
<dd>Allows the tool to select multiple elements. Defaults to True.</dd>
<dt>prior_selection_paths</dt>
<dd>Array of element paths to pre-select.</dd>
<dt>prim_mask</dt>
<dd>Filter mask for the selection (hou.scenePrimMask). Defaults to
hou.scenePrimMask.ViewerSetting</dd>
<dt>path_prefix_mask</dt>
<dd>Filter out selectable elements by a name prefix. Empty by
default.</dd>
<dt>prim_kind</dt>
<dd>Primitive kind to highlight. Empty by default.</dd>
<dt>hotkey</dt>
<dd>An optional hotkey which acts as a toggle switch for starting or
stopping the selector. No hotkey by default.</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.ViewerStateTemplate.bindSelector">
<code class="descname">bindSelector</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ViewerStateTemplate.bindSelector" title="Permalink to this definition"></a></dt>
<dd><p>bindSelector(self, name, selector_type, prompt, primitive_types=None,
group_parm_name=None, input_index=0, input_required=True,
allow_dragging=True)</p>
<blockquote>
<div><p>Binds a selector to the digital asset tied to this viewer state. You
can bind multiple selectors to the same viewer state.</p>
<p>These selectors are typically used by the shelf tool of the digital
asset to create new instances of the SOP nodes. Houdini will invoke
all bounded selectors, wait for the user to select geometries, and
then connect the input SOPs and fill in group parameters to match
what was selected.</p>
<dl class="docutils">
<dt>name</dt>
<dd>A unique selector name identifier.</dd>
<dt>selector_type</dt>
<dd><p class="first">The type of the selector to bind. The following types are
supported:</p>
<p>prims</p>
<p>Select only primitives.</p>
<p>points</p>
<p>Select only points.</p>
<p>edges</p>
<p>Select only edges.</p>
<p>everything</p>
<p class="last">Select any geometries.</p>
</dd>
<dt>prompt</dt>
<dd>Prompt displayed in the viewport to instruct the user what to
select. The prompt is mandatory.</dd>
<dt>primitive_types</dt>
<dd>Specify the type of selectable primitives (hou.primType).
Defaults to all types.</dd>
<dt>group_parm_name</dt>
<dd>The name of the SOP node parameter containing the group field.
The selector will set this parameter to the string representing
the points, primitives, edges, etc. chosen by the user in the
viewer. If None, the selector will look for a parameter named
group.</dd>
<dt>input_index</dt>
<dd>The index of the input connector on the SOP node where the
selector should wire input SOPs. A cookie SOP, for example, has
two input connectors. It has two selectors, one for each input
connector. Defaults to 0.</dd>
<dt>input_required</dt>
<dd>Specify if an input is required or not. If the user does not
select any geometry and the input is not required, the selector
will not wire anything to its input connector. Defaults to True.</dd>
<dt>allow_dragging</dt>
<dd>Determines if click-and-drag operations are allowed. Click-and-
drag operations select the geometry and begin manipulating the
handles with a single mouse drag. Dragging the geometry forces
the selector to finish immediately, the selector connects the
input and sets the group parameter, and subsequent mouse
movements are passed to the handle which translates the geometry
by changing parameter values. Defaults to True.</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.ViewerStateTemplate.categoryName">
<code class="descname">categoryName</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.ViewerStateTemplate.categoryName" title="Permalink to this definition"></a></dt>
<dd><p>Returns the name of the node type category of the state which you
can use for creating the proper category object.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.ViewerStateTemplate.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.ViewerStateTemplate.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

<dl class="method">
<dt id="hou.ViewerStateTemplate.typeName">
<code class="descname">typeName</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.ViewerStateTemplate.typeName" title="Permalink to this definition"></a></dt>
<dd><p>Returns a unique string used to identify the viewer state.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.ViewportVisualizer">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">ViewportVisualizer</code><a class="headerlink" href="#hou.ViewportVisualizer" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Represents a viewport visualizer.</p>
<p>You can create a new visualizer by calling
hou.viewportVisualizers.createVisualizer. You can get a list of
registered visualizers by calling hou.viewportVisualizers.visualizers.</p>
<dl class="method">
<dt id="hou.ViewportVisualizer.category">
<code class="descname">category</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.viewportVisualizerCategory<a class="headerlink" href="#hou.ViewportVisualizer.category" title="Permalink to this definition"></a></dt>
<dd><p>Return the category that the visualizer belongs to.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ViewportVisualizer.categoryNode">
<code class="descname">categoryNode</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Node<a class="headerlink" href="#hou.ViewportVisualizer.categoryNode" title="Permalink to this definition"></a></dt>
<dd><p>Return the node that the visualizer is installed on. This only
applies if the visualizer belongs to the Node category.</p>
<p>Return None if the visualizer belongs to either the Common or Scene
category.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ViewportVisualizer.destroy">
<code class="descname">destroy</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ViewportVisualizer.destroy" title="Permalink to this definition"></a></dt>
<dd><p>Delete this viewport visualizer.</p>
<p>If you call methods on a visualizer instance after it has been
destroyed, Houdini will raise hou.ObjectWasDeleted.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ViewportVisualizer.evalParm">
<code class="descname">evalParm</code><span class="sig-paren">(</span><em>self</em>, <em>parm_name</em><span class="sig-paren">)</span> &#x2192; int, float, or str<a class="headerlink" href="#hou.ViewportVisualizer.evalParm" title="Permalink to this definition"></a></dt>
<dd><p>Evaluate the specified parameter and return the result.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ViewportVisualizer.evalParmAsFloat">
<code class="descname">evalParmAsFloat</code><span class="sig-paren">(</span><em>self</em>, <em>parm_name</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#hou.ViewportVisualizer.evalParmAsFloat" title="Permalink to this definition"></a></dt>
<dd><p>Evaluate the specified parameter and return the result as a float.</p>
<p>Raise hou.TypeError if the value cannot be converted to a float.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ViewportVisualizer.evalParmAsInt">
<code class="descname">evalParmAsInt</code><span class="sig-paren">(</span><em>self</em>, <em>parm_name</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.ViewportVisualizer.evalParmAsInt" title="Permalink to this definition"></a></dt>
<dd><p>Evaluate the specified parameter and return the result as an
integer.</p>
<p>Raise hou.TypeError if the value cannot be converted to a integer.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ViewportVisualizer.evalParmAsRamp">
<code class="descname">evalParmAsRamp</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Ramp<a class="headerlink" href="#hou.ViewportVisualizer.evalParmAsRamp" title="Permalink to this definition"></a></dt>
<dd><p>Evalute the specified parameter and return the result as a ramp.</p>
<p>Raises hou.TypeError if the parameter is not a ramp.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ViewportVisualizer.evalParmAsString">
<code class="descname">evalParmAsString</code><span class="sig-paren">(</span><em>self</em>, <em>parm_name</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#hou.ViewportVisualizer.evalParmAsString" title="Permalink to this definition"></a></dt>
<dd><p>Evaluate the specified parameter and return the result as a string.</p>
<p>Raise hou.TypeError if the value cannot be converted to a string.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ViewportVisualizer.icon">
<code class="descname">icon</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; string<a class="headerlink" href="#hou.ViewportVisualizer.icon" title="Permalink to this definition"></a></dt>
<dd><p>Return the name of the visualizers icon.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ViewportVisualizer.isActive">
<code class="descname">isActive</code><span class="sig-paren">(</span><em>self</em>, <em>viewport=None</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.ViewportVisualizer.isActive" title="Permalink to this definition"></a></dt>
<dd><p>If this is a Common or Scene visualizer then return True if it is
active for the specified viewport or False otherwise. The viewport
argument must be a hou.GeometryViewport object.</p>
<p>If this is a Node visualizer then return True if it is active for
all viewports and False otherwise.</p>
<p>Raise hou.TypeError if this is a Node visualizer and the viewport
argument is not None. Node visualizers are either active in all
viewports or none of them. They cannot be activated for a specific
viewport.</p>
<p>Raise hou.TypeError if this is either a Common or Scene visualizer
and the viewport argument is None.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ViewportVisualizer.isActiveWhenCurrent">
<code class="descname">isActiveWhenCurrent</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.ViewportVisualizer.isActiveWhenCurrent" title="Permalink to this definition"></a></dt>
<dd><p>Return True if the visualizer is applied when the geometry is the
current geometry. Return False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ViewportVisualizer.isActiveWhenDisplayed">
<code class="descname">isActiveWhenDisplayed</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.ViewportVisualizer.isActiveWhenDisplayed" title="Permalink to this definition"></a></dt>
<dd><p>Return True if the visualizer is applied when the geometry is
displayed. Return False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ViewportVisualizer.isActiveWhenGhosted">
<code class="descname">isActiveWhenGhosted</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.ViewportVisualizer.isActiveWhenGhosted" title="Permalink to this definition"></a></dt>
<dd><p>Return True if the visualizer is applied when the geometry is
ghosted. Return False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ViewportVisualizer.isActiveWhenSelected">
<code class="descname">isActiveWhenSelected</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.ViewportVisualizer.isActiveWhenSelected" title="Permalink to this definition"></a></dt>
<dd><p>Return True if the visualizer is applied when the geometry is
selected. Return False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ViewportVisualizer.isActiveWhenTemplated">
<code class="descname">isActiveWhenTemplated</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.ViewportVisualizer.isActiveWhenTemplated" title="Permalink to this definition"></a></dt>
<dd><p>Return True if the visualizer is applied when the geometry is
templated.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ViewportVisualizer.isActiveWhenUnselected">
<code class="descname">isActiveWhenUnselected</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.ViewportVisualizer.isActiveWhenUnselected" title="Permalink to this definition"></a></dt>
<dd><p>Return True if the visualizer is applied when the geometry is
unselected. Return False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ViewportVisualizer.isShownInToolbar">
<code class="descname">isShownInToolbar</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.ViewportVisualizer.isShownInToolbar" title="Permalink to this definition"></a></dt>
<dd><p>Return True if the visualizer appears in the viewer panes toolbar.
Return False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ViewportVisualizer.label">
<code class="descname">label</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; string<a class="headerlink" href="#hou.ViewportVisualizer.label" title="Permalink to this definition"></a></dt>
<dd><p>Return the visualizers user-friendly label.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ViewportVisualizer.name">
<code class="descname">name</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; string<a class="headerlink" href="#hou.ViewportVisualizer.name" title="Permalink to this definition"></a></dt>
<dd><p>Return the visualizers unique identifier.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ViewportVisualizer.parmNames">
<code class="descname">parmNames</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of string<a class="headerlink" href="#hou.ViewportVisualizer.parmNames" title="Permalink to this definition"></a></dt>
<dd><p>Return a tuple of the visualizers customizable parameters. Note
that the parameters can change when either the visualizers type
changes or one of the parameters changes (for example changing the
Color Type parameter on a color visualizer).</p>
</dd></dl>

<dl class="method">
<dt id="hou.ViewportVisualizer.scope">
<code class="descname">scope</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.viewportVisualizerScope<a class="headerlink" href="#hou.ViewportVisualizer.scope" title="Permalink to this definition"></a></dt>
<dd><p>Return the scope of geometries that the visualizer affects.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ViewportVisualizer.setIcon">
<code class="descname">setIcon</code><span class="sig-paren">(</span><em>self</em>, <em>icon</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ViewportVisualizer.setIcon" title="Permalink to this definition"></a></dt>
<dd><p>Set the visualizers icon. icon must be the icon name.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ViewportVisualizer.setIsActive">
<code class="descname">setIsActive</code><span class="sig-paren">(</span><em>self</em>, <em>on</em>, <em>viewport=None</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ViewportVisualizer.setIsActive" title="Permalink to this definition"></a></dt>
<dd><p>If this is a Common or Scene visualizer then set whether it is
active or not for a specified viewport. The viewport argument must
be a hou.GeometryViewport object.</p>
<p>If this is a Node visualizer then set whether it is active or not
for all viewports.</p>
<p>Raise hou.TypeError if this is a Node visualizer and the viewport
argument is not None. Node visualizers are either active in all
viewports or none of them. They cannot be activated for a specific
viewport.</p>
<p>Raise hou.TypeError if this is either a Common or Scene visualizer
and the viewport argument is None.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ViewportVisualizer.setIsActiveWhenCurrent">
<code class="descname">setIsActiveWhenCurrent</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ViewportVisualizer.setIsActiveWhenCurrent" title="Permalink to this definition"></a></dt>
<dd><p>Set whether the visualizer is applied when the geometry is the
current geometry.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ViewportVisualizer.setIsActiveWhenDisplayed">
<code class="descname">setIsActiveWhenDisplayed</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ViewportVisualizer.setIsActiveWhenDisplayed" title="Permalink to this definition"></a></dt>
<dd><p>Set whether the visualizer is applied when the geometry is
displayed.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ViewportVisualizer.setIsActiveWhenGhosted">
<code class="descname">setIsActiveWhenGhosted</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ViewportVisualizer.setIsActiveWhenGhosted" title="Permalink to this definition"></a></dt>
<dd><p>Set whether the visualizer is applied when the geometry is ghosted.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ViewportVisualizer.setIsActiveWhenSelected">
<code class="descname">setIsActiveWhenSelected</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ViewportVisualizer.setIsActiveWhenSelected" title="Permalink to this definition"></a></dt>
<dd><p>Set whether the visualizer is applied when the geometry is selected.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ViewportVisualizer.setIsActiveWhenTemplated">
<code class="descname">setIsActiveWhenTemplated</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ViewportVisualizer.setIsActiveWhenTemplated" title="Permalink to this definition"></a></dt>
<dd><p>Set whether the visualizer is applied when the geometry is
templated.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ViewportVisualizer.setIsActiveWhenUnselected">
<code class="descname">setIsActiveWhenUnselected</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ViewportVisualizer.setIsActiveWhenUnselected" title="Permalink to this definition"></a></dt>
<dd><p>Set whether the visualizer is applied when the geometry is
unselected.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ViewportVisualizer.setLabel">
<code class="descname">setLabel</code><span class="sig-paren">(</span><em>self</em>, <em>label</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ViewportVisualizer.setLabel" title="Permalink to this definition"></a></dt>
<dd><p>Set the visualizers user-friendly label.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ViewportVisualizer.setName">
<code class="descname">setName</code><span class="sig-paren">(</span><em>self</em>, <em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ViewportVisualizer.setName" title="Permalink to this definition"></a></dt>
<dd><p>Set the visualizers unique identifier.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ViewportVisualizer.setParm">
<code class="descname">setParm</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.ViewportVisualizer.setParm" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.ViewportVisualizer.setScope">
<code class="descname">setScope</code><span class="sig-paren">(</span><em>self</em>, <em>scope</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ViewportVisualizer.setScope" title="Permalink to this definition"></a></dt>
<dd><p>Set the scope of geometries that the visualizer affects.</p>
<p>This method does nothing if the visualizer belongs to the Common or
Scene because the scope is always global.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ViewportVisualizer.setType">
<code class="descname">setType</code><span class="sig-paren">(</span><em>self</em>, <em>type</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ViewportVisualizer.setType" title="Permalink to this definition"></a></dt>
<dd><p>Sets the visualizers type. This essentially recreates the
visualizer and rebuilds its customizable parameters. Call
hou.ViewportVisualizer.parmNames to get a list of the parameters.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ViewportVisualizer.showInToolbar">
<code class="descname">showInToolbar</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ViewportVisualizer.showInToolbar" title="Permalink to this definition"></a></dt>
<dd><p>Set whether the visualizer appears in the viewer panes toolbar.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.ViewportVisualizer.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.ViewportVisualizer.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

<dl class="method">
<dt id="hou.ViewportVisualizer.type">
<code class="descname">type</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.ViewportVisualizerType<a class="headerlink" href="#hou.ViewportVisualizer.type" title="Permalink to this definition"></a></dt>
<dd><p>Return the visualizers type.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.ViewportVisualizerType">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">ViewportVisualizerType</code><a class="headerlink" href="#hou.ViewportVisualizerType" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Represents a viewport visualizer type.</p>
<dl class="method">
<dt id="hou.ViewportVisualizerType.description">
<code class="descname">description</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; string<a class="headerlink" href="#hou.ViewportVisualizerType.description" title="Permalink to this definition"></a></dt>
<dd><p>Return a brief description of the visualizer type.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ViewportVisualizerType.icon">
<code class="descname">icon</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; string<a class="headerlink" href="#hou.ViewportVisualizerType.icon" title="Permalink to this definition"></a></dt>
<dd><p>Return the name of the types icon.</p>
</dd></dl>

<dl class="method">
<dt id="hou.ViewportVisualizerType.name">
<code class="descname">name</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; string<a class="headerlink" href="#hou.ViewportVisualizerType.name" title="Permalink to this definition"></a></dt>
<dd><p>Return the visualizer types unique identifier.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.ViewportVisualizerType.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.ViewportVisualizerType.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.Volume">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">Volume</code><a class="headerlink" href="#hou.Volume" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.Prim" title="hou.Prim"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.Prim</span></code></a></p>
<p>A Volume is a kind geometry primitive (Prim object) storing a three
dimensional array of voxels.</p>
<dl class="method">
<dt id="hou.Volume.allVoxels">
<code class="descname">allVoxels</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of float<a class="headerlink" href="#hou.Volume.allVoxels" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Return a tuple of floats containing the values of all voxels. It is
faster to call this method to retrieve all the voxels than it is to
loop through the voxel array in Python.</p>
<p>You can, for example, use Pythons Numpy library to perform
operations on the voxel data and then store the result back into the
volume from a Python SOP using hou.Volume.setAllVoxels. Note that
Numpy allows you to reshape the flat tuple of floats to behave like
a 3D matrix of floats.</p>
<p>This method can be approximately implemented as follows (though this
Python implementation is much slower):</p>
</div></blockquote>
<p>&gt; def allVoxels(self):
&gt;     result = []
&gt;     xres, yres, zres = self.resolution()
&gt;     for z in range(zres):
&gt;         for y in range(yres):
&gt;             for x in range(xres):
&gt;                 result.append(self.voxel((x, y, z)))
&gt;     return tuple(result)</p>
<blockquote>
<div>See also hou.Volume.allVoxelsAsString,
hou.Geometry.pointFloatAttribValues, and
hou.Geometry.primFloatAttribValues.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.Volume.allVoxelsAsString">
<code class="descname">allVoxelsAsString</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.Volume.allVoxelsAsString" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Return a binary string representation of the floats containing all
the values of all voxels. This method is faster than
hou.Volume.allVoxels, and you can use the array module to convert
the string into a Python sequence.</p>
<p>This method provides a faster implementation of the following:</p>
</div></blockquote>
<p>&gt; import array
&gt; def allVoxelsAsString(self):
&gt;     return array.array(f, self.allVoxels()).tostring()</p>
<blockquote>
<div>You can convert the return value from this method to an array using
the following method:</div></blockquote>
<p>&gt; import array
&gt; def allVoxelsAsArray(volume):
&gt;     a = array.array(f)
&gt;     a.fromstring(volume.allVoxelsAsString())
&gt;     return a</p>
<blockquote>
<div>See hou.Volume.allVoxels for more information.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.Volume.gradient">
<code class="descname">gradient</code><span class="sig-paren">(</span><em>self</em>, <em>position</em><span class="sig-paren">)</span> &#x2192; hou.Vector3<a class="headerlink" href="#hou.Volume.gradient" title="Permalink to this definition"></a></dt>
<dd><p>Given a sequence of three floats containing a 3D position, return a
vector which points in the direction of the greatest rate of
increase of the volumes value.</p>
<p>See Wikipedias gradient page for more information.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Volume.indexToPos">
<code class="descname">indexToPos</code><span class="sig-paren">(</span><em>self</em>, <em>index</em><span class="sig-paren">)</span> &#x2192; hou.Vector3<a class="headerlink" href="#hou.Volume.indexToPos" title="Permalink to this definition"></a></dt>
<dd><p>Given a sequence of three ints containing an index into the voxel
array, return the corresponding 3D position of the middle of that
voxel.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Volume.isHeightField">
<code class="descname">isHeightField</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.Volume.isHeightField" title="Permalink to this definition"></a></dt>
<dd><p>Return whether or not the volume is flagged as a heightfield. Such
volumes are two dimensional and have the heightfield visualization
set.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Volume.isSDF">
<code class="descname">isSDF</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.Volume.isSDF" title="Permalink to this definition"></a></dt>
<dd><p>Return whether or not the volume is flagged as a signed distance
field. Such volumes have a special border condition where out of
bound reads will add the distance to the bounding box to the
streaked boundary condition. They are also best to be semantically
treated as signed distance fields.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Volume.isValidIndex">
<code class="descname">isValidIndex</code><span class="sig-paren">(</span><em>self</em>, <em>index</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.Volume.isValidIndex" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Return whether or not a sequence of three ints containing an index
into the voxel array is valid, ie, within the bounds of the array.</p>
<p>This method can approximately be implemented as follows:</p>
</div></blockquote>
<p>&gt; def isValidIndex(self, index):
&gt;     for i, maximum in zip(index, self.resolution()):
&gt;         if i &lt; 0 or i &gt;= maximum:
&gt;             return False
&gt;     return True</p>
</dd></dl>

<dl class="method">
<dt id="hou.Volume.posToIndex">
<code class="descname">posToIndex</code><span class="sig-paren">(</span><em>self</em>, <em>position</em><span class="sig-paren">)</span> &#x2192; tuple of int<a class="headerlink" href="#hou.Volume.posToIndex" title="Permalink to this definition"></a></dt>
<dd><p>Given a sequence of three floats containing a 3D position, return a
tuple of three ints containing the corresponding index into the
voxel array.</p>
<p>Note that the returned index will be invalid if the position is
outside the volume. Use hou.Volume.isValidIndex to determine if the
index is valid.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Volume.resolution">
<code class="descname">resolution</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Vector3<a class="headerlink" href="#hou.Volume.resolution" title="Permalink to this definition"></a></dt>
<dd><p>Return the x, y, and z dimensions of the volume. For example, a
resolution of (10, 20, 30) means the volume is 10 voxels in x by 20
voxels in y by 30 voxels in z.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Volume.sample">
<code class="descname">sample</code><span class="sig-paren">(</span><em>self</em>, <em>position</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#hou.Volume.sample" title="Permalink to this definition"></a></dt>
<dd><p>Given a sequence of three floats containing a 3D position, return
the value of the volume at that position. If the position is not in
the middle of a voxel, Houdini will interpolate using values from
surrounding voxels.</p>
<p>See also hou.Volume.voxel and hou.Volume.posToIndex.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Volume.setAllVoxels">
<code class="descname">setAllVoxels</code><span class="sig-paren">(</span><em>self</em>, <em>values</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Volume.setAllVoxels" title="Permalink to this definition"></a></dt>
<dd><p>Set the value of all voxels in this volume. You would typically call
this method from the code of a Python-defined SOP.</p>
<p>Raises hou.OperationFailed if the sequence of values is not exactly
the same as self.resolution()[0] * self.resolution()[1] *
self.resolution()[2].</p>
<p>Raises hou.GeometryPermissionError if this geometry is not
modifiable.</p>
<p>See also hou.Volume.allVoxels.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Volume.setAllVoxelsFromString">
<code class="descname">setAllVoxelsFromString</code><span class="sig-paren">(</span><em>self</em>, <em>values</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Volume.setAllVoxelsFromString" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Set the value of all voxels in this volume from a string
representation of a sequence of single precision float values. This
method is faster than hou.Volume.setAllVoxels.</p>
<p>Note that this method can accept more types that just a string: it
can receive any Python object that supports the buffer interface. In
particular, arrays from the array and numpy Python modules are
supported, so there is no need to first construct strings from those
arrays.</p>
<p>Raises hou.OperationFailed if the length of the string is not
exactly the same as self.resolution()[0] * self.resolution()[1] *
self.resolution()[2] * 4.</p>
<p>See hou.Volume.setAllVoxels and hou.Volume.allVoxelsAsString for
more information.</p>
<p>The following example function accepts an array.array(f) and sets
the voxels to its contents:</p>
</div></blockquote>
<p>&gt; def setAllVoxelsFromArray(volume, arr):
&gt;     assert(arr.typecode == f)
&gt;     volume.setAllVoxelsFromString(arr)</p>
</dd></dl>

<dl class="method">
<dt id="hou.Volume.setTransform">
<code class="descname">setTransform</code><span class="sig-paren">(</span><em>self</em>, <em>matrix4</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Volume.setTransform" title="Permalink to this definition"></a></dt>
<dd><p>Given a 4x4 matrix, set the position, rotation, and scale of this
volume.</p>
<p>Note that if you want to just set the translate portion of a volume
to a hou.Vector3, you could just call
volume.vertex(0).point().setPosition(position).</p>
</dd></dl>

<dl class="method">
<dt id="hou.Volume.setVoxel">
<code class="descname">setVoxel</code><span class="sig-paren">(</span><em>self</em>, <em>index</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.Volume.setVoxel" title="Permalink to this definition"></a></dt>
<dd><p>Set the value of a voxel. You would typically call this method from
the code of a Python-defined SOP.</p>
<dl class="docutils">
<dt>index</dt>
<dd>A sequence of three integers containing a voxel index. Raises
hou.OperationFailed if any of the values in index are out of
range.</dd>
<dt>value</dt>
<dd>A float containing the voxels new value.</dd>
</dl>
<p>Raises hou.GeometryPermissionError if this geometry is not
modifiable.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Volume.setVoxelSlice">
<code class="descname">setVoxelSlice</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.Volume.setVoxelSlice" title="Permalink to this definition"></a></dt>
<dd><p>setVoxelSliceFromString(self, values, plane, index)</p>
<blockquote>
<div><blockquote>
<div><p>Set the value of the voxels in a particular slice of this volume.
You would typically call this method from the code of a Python-
defined SOP.</p>
<dl class="docutils">
<dt>values</dt>
<dd><p class="first">A binary string representing of a sequence of floats containing
the new values for the slice.</p>
<p class="last">Note that this method can accept more types that just a string:
it can receive any Python object that supports the buffer
interface. In particular, arrays from the array and numpy Python
modules are supported, so there is no need to first construct
strings from those arrays.</p>
</dd>
<dt>plane</dt>
<dd>The plane corresponding to this slice. This value must be either
xy, xz, or yz.</dd>
<dt>index</dt>
<dd>The index of this slice in the array.</dd>
</dl>
<p>See hou.Volume.setVoxelSlice for more information.</p>
<p>The following example builds a volume from an compositing network
sequence:</p>
</div></blockquote>
<p>&gt; def buildVolumeFromCopSequence(
&gt;         cop_node, geo, voxel_depth, plane=C, component=r):
&gt;     zres = int(cop_node.sequenceFrameLength())
&gt;     volume_bbox = hou.BoundingBox(<a href="#id31"><span class="problematic" id="id32">*</span></a>(
&gt;         0, 0, 0,
&gt;         cop_node.xRes(), cop_node.yRes(), zres) * voxel_depth)
&gt;     volume = geo.createVolume(
&gt;         cop_node.xRes(), cop_node.yRes(), zres, volume_bbox)
&gt; 
&gt;     for z in range(zres):
&gt;         pixels = cop_node.allPixelsAsString(
&gt;             plane, component,
&gt;             time=hou.frameToTime(z + cop_node.sequenceStartFrame()))
&gt;         volume.setVoxelSliceFromString(pixels, xy, z)</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.Volume.setVoxelSliceFromString">
<code class="descname">setVoxelSliceFromString</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.Volume.setVoxelSliceFromString" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.Volume.taperX">
<code class="descname">taperX</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.Volume.taperX" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.Volume.taperY">
<code class="descname">taperY</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.Volume.taperY" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.Volume.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.Volume.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

<dl class="method">
<dt id="hou.Volume.transform">
<code class="descname">transform</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.Matrix3<a class="headerlink" href="#hou.Volume.transform" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Return a 3x3 matrix containing the scale and rotation
transformations for this volume.</p>
<p>Note that the position information for the volume can be obtained by
calling volume.vertex(0).point().position().</p>
<p>The following function returns a 4x4 transformation matrix for the
volume that includes the translation:</p>
</div></blockquote>
<p>&gt; def fullTransform(volume):
&gt;     return (hou.Matrix4(volume.transform()) *
&gt;         hou.hmath.buildTranslate(volume.vertex(0).point().position()))</p>
<blockquote>
<div><dl class="docutils">
<dt>NOTE</dt>
<dd>You need to get the node transform to get to worldspace.</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.Volume.vertex">
<code class="descname">vertex</code><span class="sig-paren">(</span><em>self</em>, <em>index</em><span class="sig-paren">)</span> &#x2192; hou.Vertex<a class="headerlink" href="#hou.Volume.vertex" title="Permalink to this definition"></a></dt>
<dd><p>A shortcut for self.vertices()[index]. You probably dont need to
call this method.</p>
<p>This method supports negative indices to index from the end, just
like self.vertices()[index] would. Also, like Pythons indexing
operator, it will raise IndexError when the index is out of range.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Volume.volumeAverage">
<code class="descname">volumeAverage</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#hou.Volume.volumeAverage" title="Permalink to this definition"></a></dt>
<dd><p>Return the average value of all voxels.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Volume.volumeMax">
<code class="descname">volumeMax</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#hou.Volume.volumeMax" title="Permalink to this definition"></a></dt>
<dd><p>Return the maximum value of all voxels.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Volume.volumeMin">
<code class="descname">volumeMin</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#hou.Volume.volumeMin" title="Permalink to this definition"></a></dt>
<dd><p>Return the minimum value of all voxels.</p>
</dd></dl>

<dl class="method">
<dt id="hou.Volume.voxel">
<code class="descname">voxel</code><span class="sig-paren">(</span><em>self</em>, <em>index</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#hou.Volume.voxel" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div>Given a sequence of three integers containing a voxel index, return
the value of the corresponding voxel.</div></blockquote>
<p>&gt; &gt;&gt;&gt; volume_sop = hou.node(/obj).createNode(geo).createNode(volume)
&gt; &gt;&gt;&gt; volume_sop.parm(initialval1).set(0.3)
&gt; &gt;&gt;&gt; volume = volume_sop.geometry().prims()[0]
&gt; &gt;&gt;&gt; volume.resolution()
&gt; (10, 10, 10)
&gt; &gt;&gt;&gt; volume.voxel((0, 0, 0))
&gt; 0.3</p>
</dd></dl>

<dl class="method">
<dt id="hou.Volume.voxelSlice">
<code class="descname">voxelSlice</code><span class="sig-paren">(</span><em>plane</em>, <em>index</em><span class="sig-paren">)</span> &#x2192; tuple of float<a class="headerlink" href="#hou.Volume.voxelSlice" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Return a tuple of floats containing the values of all voxels in a
particular slice. It is faster to call this method to retrieve a
slice than it is to loop through the voxel array in Python.</p>
<dl class="docutils">
<dt>plane</dt>
<dd>The plane corresponding to this slice. This value must be either
xy, xz, or yz.</dd>
<dt>index</dt>
<dd>The index of this slice in the array. For example, if the plane
is xy, this index is the z value and the result will contain
all values in the voxel with this particular z value.</dd>
</dl>
<p>This method can be approximately implemented as follows (though this
Python implementation is much slower):</p>
</div></blockquote>
<p>&gt; def voxelSlice(self, plane, index):
&gt;     result = []
&gt; 
&gt;     start = [0] * 3
&gt;     stop = list(self.resolution())
&gt; 
&gt;     slice_axis = {xy: 2, xz: 1, yz: 0}[plane]
&gt;     start[slice_axis] = index
&gt;     stop[slice_axis] = index + 1
&gt; 
&gt;     for z in range(start[2], stop[2]):
&gt;         for y in range(start[1], stop[1]):
&gt;             for x in range(start[0], stop[0]):
&gt;                 result.append(self.voxel((x, y, z)))
&gt;     return tuple(result)</p>
<blockquote>
<div>See also hou.Volume.voxelSliceAsString and hou.Volume.allVoxels.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.Volume.voxelSliceAsString">
<code class="descname">voxelSliceAsString</code><span class="sig-paren">(</span><em>plane</em>, <em>index</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.Volume.voxelSliceAsString" title="Permalink to this definition"></a></dt>
<dd><p>Return a binary string representation of the floats containing all
the values of voxels in a particular slice.</p>
<p>See hou.Volume.voxelSlice and hou.Volume.allVoxelsAsString for more
information.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.VopNetNode">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">VopNetNode</code><a class="headerlink" href="#hou.VopNetNode" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.Node" title="hou.Node"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.Node</span></code></a></p>
<dl class="method">
<dt id="hou.VopNetNode.definedType">
<code class="descname">definedType</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; NodeType<a class="headerlink" href="#hou.VopNetNode.definedType" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.VopNetNode.shaderType">
<code class="descname">shaderType</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.shaderType enum value or None<a class="headerlink" href="#hou.VopNetNode.shaderType" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.VopNetNode.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.VopNetNode.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

<dl class="method">
<dt id="hou.VopNetNode.vexContext">
<code class="descname">vexContext</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; VexContext<a class="headerlink" href="#hou.VopNetNode.vexContext" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.VopNode">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">VopNode</code><a class="headerlink" href="#hou.VopNode" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.Node" title="hou.Node"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.Node</span></code></a></p>
<p>Represents a VOP (VEX Operator) node.</p>
<dl class="method">
<dt id="hou.VopNode.bypass">
<code class="descname">bypass</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.VopNode.bypass" title="Permalink to this definition"></a></dt>
<dd><p>Turns the nodes bypass flag on or off. When the bypass flag is on,
the node will have no effect on the scene. The value of the on
argument must be True or False.</p>
<p>Raises hou.PermissionError if the node is unwritable.</p>
</dd></dl>

<dl class="method">
<dt id="hou.VopNode.code">
<code class="descname">code</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.VopNode.code" title="Permalink to this definition"></a></dt>
<dd><p>Returns the VEX or RSL code that defines this node.</p>
</dd></dl>

<dl class="method">
<dt id="hou.VopNode.coshaderNodes">
<code class="descname">coshaderNodes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.VopNode.coshaderNodes" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.VopNode.coshaderNodesOutputNames">
<code class="descname">coshaderNodesOutputNames</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.VopNode.coshaderNodesOutputNames" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.VopNode.currentSignatureName">
<code class="descname">currentSignatureName</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.VopNode.currentSignatureName" title="Permalink to this definition"></a></dt>
<dd><p>Returns the current signature name of this node. The HDA nodes may
provide several valid signatures, and this function returns the name
of the currently used signature. A signature is defined by a set of
input types and each set is assigned a name.</p>
</dd></dl>

<dl class="method">
<dt id="hou.VopNode.deleteIndependentInputNodes">
<code class="descname">deleteIndependentInputNodes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.VopNode.deleteIndependentInputNodes" title="Permalink to this definition"></a></dt>
<dd><p>deleteIndependentInputNodes(self, input_index):, make_parm_node,
reference_input_defaults) -&gt; bool</p>
<blockquote>
<div>Deletes a chain of nodes wired into a particular input if and only
if they are wired only into the specified input on this node.
Returns true if nodes were deleted, false otherwise.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.VopNode.dependsOnlyOn">
<code class="descname">dependsOnlyOn</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.VopNode.dependsOnlyOn" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.VopNode.extraBindings">
<code class="descname">extraBindings</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of str<a class="headerlink" href="#hou.VopNode.extraBindings" title="Permalink to this definition"></a></dt>
<dd><p>Returns the list of extra bindings the VOP node would add to the
generated code. Implemented specifically for Snippet VOPs, this
allows one to determine what bindings will be created by any adhoc &#64;
references.</p>
</dd></dl>

<dl class="method">
<dt id="hou.VopNode.inputDataTypes">
<code class="descname">inputDataTypes</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of str<a class="headerlink" href="#hou.VopNode.inputDataTypes" title="Permalink to this definition"></a></dt>
<dd><p>Returns a tuple of all input data types for this node. Data types
for input connectors that are hidden are also included.</p>
<p>The strings returned by this method can be used to set the Type
parameter on a Parameter or Constant VOP.</p>
</dd></dl>

<dl class="method">
<dt id="hou.VopNode.inputGroupNames">
<code class="descname">inputGroupNames</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of str<a class="headerlink" href="#hou.VopNode.inputGroupNames" title="Permalink to this definition"></a></dt>
<dd><p>Returns the names of the input groups on this VOP Node. Note that
not all groups will contain any inputs, and so not all groups will
be visible in the Network View. Use the hou.VopNode.inputsInGroup
method to determine which inputs are part of a particular group.</p>
</dd></dl>

<dl class="method">
<dt id="hou.VopNode.inputIndexOrder">
<code class="descname">inputIndexOrder</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of int<a class="headerlink" href="#hou.VopNode.inputIndexOrder" title="Permalink to this definition"></a></dt>
<dd><p>Return a tuple of integers which represent input index numbers that
can be passed to hou.Node.setInput and related functions. The order
of the index numbers represents the order in which those inputs
appear in the network view tile for this object. This ordering is
affected by the way inputs are grouped together on the parameter
pane for this node.</p>
</dd></dl>

<dl class="method">
<dt id="hou.VopNode.inputParmTypes">
<code class="descname">inputParmTypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.VopNode.inputParmTypes" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hou.VopNode.inputsInGroup">
<code class="descname">inputsInGroup</code><span class="sig-paren">(</span><em>self</em>, <em>group</em><span class="sig-paren">)</span> &#x2192; tuple of int<a class="headerlink" href="#hou.VopNode.inputsInGroup" title="Permalink to this definition"></a></dt>
<dd><p>Returns the input index values of all inputs that appear in the
group with the name specified in group. This parameter should be a
value returned by the hou.VopNode.inputGroupName method. This method
returns the same set of inputs whether the group is expanded or
collapsed. Returns an empty tuple if the group name contains no
inputs or is not a recognized group name.</p>
</dd></dl>

<dl class="method">
<dt id="hou.VopNode.insertParmGenerator">
<code class="descname">insertParmGenerator</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.VopNode.insertParmGenerator" title="Permalink to this definition"></a></dt>
<dd><p>insertParmGenerator(self, input_name, parm_gen_type,
reference_input_defaults) -&gt; hou.VopNode</p>
<blockquote>
<div><p>Creates a parameter or a constant node and wires it into an input
specified by input_name on this node. parm_gen_type must be a value
of hou.vopParmGenType. If reference_input_defaults is True, this
node will reference the defaults of the newly created node.</p>
<p>A resultant parameter or constant node is returned.</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.VopNode.insertParmGeneratorsForAllInputs">
<code class="descname">insertParmGeneratorsForAllInputs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.VopNode.insertParmGeneratorsForAllInputs" title="Permalink to this definition"></a></dt>
<dd><p>insertParmGeneratorsForAllInputs(self, parm_gen_type,
reference_input_defaults) -&gt; dict of str to hou.VopNode</p>
<blockquote>
<div><p>Creates parameter or constant nodes and wires them into unconnected
inputs on this node. parm_gen_type must be a value of
hou.vopParmGenType. If reference_input_defaults is True, then this
node will reference the defaults of the newly created nodes.</p>
<p>A dictionary is returned with input names for keys and hou.VopNode
objects for values.</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.VopNode.isBypassed">
<code class="descname">isBypassed</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.VopNode.isBypassed" title="Permalink to this definition"></a></dt>
<dd><p>Returns True if the nodes bypass flag is turned on. Returns False
otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="hou.VopNode.isCompressFlagSet">
<code class="descname">isCompressFlagSet</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.VopNode.isCompressFlagSet" title="Permalink to this definition"></a></dt>
<dd><p>Returns True if the nodes compress flag is turned on. Returns False
otherwise. The compress flag controls whether or not a preview image
is shown for this node in the Network View.</p>
</dd></dl>

<dl class="method">
<dt id="hou.VopNode.isDebugFlagSet">
<code class="descname">isDebugFlagSet</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.VopNode.isDebugFlagSet" title="Permalink to this definition"></a></dt>
<dd><p>Returns True if the nodes debug flag is turned on. Returns False
otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="hou.VopNode.isDetailHighFlagSet">
<code class="descname">isDetailHighFlagSet</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.VopNode.isDetailHighFlagSet" title="Permalink to this definition"></a></dt>
<dd><p>Returns True if the nodes high detail flag is turned on. Returns
False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="hou.VopNode.isDetailLowFlagSet">
<code class="descname">isDetailLowFlagSet</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.VopNode.isDetailLowFlagSet" title="Permalink to this definition"></a></dt>
<dd><p>Returns True if the nodes low detail flag is turned on. Returns
False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="hou.VopNode.isDetailMediumFlagSet">
<code class="descname">isDetailMediumFlagSet</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.VopNode.isDetailMediumFlagSet" title="Permalink to this definition"></a></dt>
<dd><p>Returns True if the nodes medium detail flag is turned on. Returns
False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="hou.VopNode.isInputCompatible">
<code class="descname">isInputCompatible</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.VopNode.isInputCompatible" title="Permalink to this definition"></a></dt>
<dd><p>isInputCompatible(self, idx, other, other_idx, allow_conversions =
False) -&gt; bool`</p>
<blockquote>
<div>Return True if input idx of this object can be connected to output
other_idx of node other. Two inputs can be connected if they are of
the same data type. If the allow_converions parameter is set to
True, a more permissive check is done which accepts an input
connection if the output data type can be automatically converted to
the input data type without an explicit conversion node (such as a
float output to a vector input).</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.VopNode.isInputGroupExpanded">
<code class="descname">isInputGroupExpanded</code><span class="sig-paren">(</span><em>self</em>, <em>group</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.VopNode.isInputGroupExpanded" title="Permalink to this definition"></a></dt>
<dd><p>Returns True if the group with the name specified by group is
expanded in the Network View. The group parameter should be a value
returned by the hou.VopNode.inputGroupName method. Returns the
current expanded state of the group even if the group is not
currently visible due to the setting of the input/output detail
flags. Returns True if the group name is not valid.</p>
</dd></dl>

<dl class="method">
<dt id="hou.VopNode.isInputVisible">
<code class="descname">isInputVisible</code><span class="sig-paren">(</span><em>self</em>, <em>input_name</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.VopNode.isInputVisible" title="Permalink to this definition"></a></dt>
<dd><p>Returns True if the input connector specified by input_name on this
node is visible, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="hou.VopNode.isMaterialFlagSet">
<code class="descname">isMaterialFlagSet</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#hou.VopNode.isMaterialFlagSet" title="Permalink to this definition"></a></dt>
<dd><p>Returns True if the nodes material flag is turned on. Returns False
otherwise. The material flag indicates whether this node is intended
for use as a material to be assigned to objects or geometry.</p>
</dd></dl>

<dl class="method">
<dt id="hou.VopNode.outerCode">
<code class="descname">outerCode</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.VopNode.outerCode" title="Permalink to this definition"></a></dt>
<dd><p>Returns the outer code associated with this node.</p>
</dd></dl>

<dl class="method">
<dt id="hou.VopNode.outputDataTypes">
<code class="descname">outputDataTypes</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; tuple of str<a class="headerlink" href="#hou.VopNode.outputDataTypes" title="Permalink to this definition"></a></dt>
<dd><p>Returns a tuple of all output data types for this node. Data types
for output connectors that are hidden are also included.</p>
<p>The strings returned by this method can be used to set the Type
parameter on a Parameter or Constant VOP.</p>
</dd></dl>

<dl class="method">
<dt id="hou.VopNode.parmDefinerNode">
<code class="descname">parmDefinerNode</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; hou.VopNode<a class="headerlink" href="#hou.VopNode.parmDefinerNode" title="Permalink to this definition"></a></dt>
<dd><p>Return the Parameter VOP node that defines the parameter that this
node is bound to. This method only applies to Parameter VOP nodes.</p>
<p>Return None if this node is not a Parameter VOP or if this node is
the definer node.</p>
</dd></dl>

<dl class="method">
<dt id="hou.VopNode.setCompressFlag">
<code class="descname">setCompressFlag</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.VopNode.setCompressFlag" title="Permalink to this definition"></a></dt>
<dd><p>Turns the nodes compress flag on or off. If the compress flag is
True, this node will not show a preview image in the Network View.
If the compress flag is False, a preview image will be shown in the
Network View. The value of the on argument must be True or False.</p>
<p>Raises hou.PermissionError if the node is unwritable.</p>
</dd></dl>

<dl class="method">
<dt id="hou.VopNode.setDebugFlag">
<code class="descname">setDebugFlag</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.VopNode.setDebugFlag" title="Permalink to this definition"></a></dt>
<dd><p>Turns the nodes debug flag on or off. The value of the on argument
must be True or False.</p>
<p>Raises hou.PermissionError if the node is unwritable.</p>
</dd></dl>

<dl class="method">
<dt id="hou.VopNode.setDetailHighFlag">
<code class="descname">setDetailHighFlag</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.VopNode.setDetailHighFlag" title="Permalink to this definition"></a></dt>
<dd><p>Turns on or off the high detail flag for this nodes inputs and
outputs. With this flag turned on, all inputs and outputs to this
node will appear in the network view, whether they are connected to
another node or not. This flag does not affect the operation of this
node, only its appearance in the network view. The value of the on
argument must be True or False.</p>
<p>Raises hou.PermissionError if the node is unwritable.</p>
</dd></dl>

<dl class="method">
<dt id="hou.VopNode.setDetailLowFlag">
<code class="descname">setDetailLowFlag</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.VopNode.setDetailLowFlag" title="Permalink to this definition"></a></dt>
<dd><p>Turns on or off the low detail flag for this nodes inputs and
outputs. With this flag turned on, all inputs and outputs to this
node will appear in the network view as connecting to a single
location on the node. This flag does not affect the operation of
this node, only its appearance in the network view. The value of the
on argument must be True or False.</p>
<p>Raises hou.PermissionError if the node is unwritable.</p>
</dd></dl>

<dl class="method">
<dt id="hou.VopNode.setDetailMediumFlag">
<code class="descname">setDetailMediumFlag</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.VopNode.setDetailMediumFlag" title="Permalink to this definition"></a></dt>
<dd><p>Turns on or off the medium detail flag for this nodes inputs and
outputs. With this flag turned on, only connected inputs and outputs
to this node will be visible in the network view. This flag does not
affect the operation of this node, only its appearance in the
network view. The value of the on argument must be True or False.</p>
<p>Raises hou.PermissionError if the node is unwritable.</p>
</dd></dl>

<dl class="method">
<dt id="hou.VopNode.setInputGroupExpanded">
<code class="descname">setInputGroupExpanded</code><span class="sig-paren">(</span><em>self</em>, <em>group</em>, <em>expanded</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.VopNode.setInputGroupExpanded" title="Permalink to this definition"></a></dt>
<dd><p>Sets the expanded state of the input group with the name specified
by the group parameter. This controls the appearance of this input
group in the Network View. Pass a group value of None to expand or
collapse all input groups.</p>
</dd></dl>

<dl class="method">
<dt id="hou.VopNode.setIsInputVisible">
<code class="descname">setIsInputVisible</code><span class="sig-paren">(</span><em>self</em>, <em>input_name</em>, <em>is_visible</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.VopNode.setIsInputVisible" title="Permalink to this definition"></a></dt>
<dd><p>Shows or hides an input connector of this node. The input is
specified by input_name. The connector is shown if is_visible is
True, and hidden otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="hou.VopNode.setMaterialFlag">
<code class="descname">setMaterialFlag</code><span class="sig-paren">(</span><em>self</em>, <em>on</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.VopNode.setMaterialFlag" title="Permalink to this definition"></a></dt>
<dd><p>Turns the nodes material flag on or off. If the material flag is
True, it indicates that this node is meant to be used as a material
to be assigned to objects or geometry. It will appear in material
node choosers and be saved to IFDs generated with the option to save
all materials turned on.</p>
<p>Raises hou.PermissionError if the node is unwritable.</p>
</dd></dl>

<dl class="method">
<dt id="hou.VopNode.shaderCode">
<code class="descname">shaderCode</code><span class="sig-paren">(</span><em>self</em>, <em>shader_type=hou.shaderType.Surface</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.VopNode.shaderCode" title="Permalink to this definition"></a></dt>
<dd><p>Returns the generated VEX or RSL code for this VOP, using the given
shader type to control output context. If the VOP is a subnet that
can be packaged up as an encapsulated shader, then the specific code
to define an encapsulated shader is output. Otherwise, the code
generated for the entire VOP network is output.</p>
</dd></dl>

<dl class="method">
<dt id="hou.VopNode.shaderLanguageName">
<code class="descname">shaderLanguageName</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.VopNode.shaderLanguageName" title="Permalink to this definition"></a></dt>
<dd><p>Returns the name of the language the shader is written in.</p>
</dd></dl>

<dl class="method">
<dt id="hou.VopNode.shaderName">
<code class="descname">shaderName</code><span class="sig-paren">(</span><em>self</em>, <em>as_otl_path=True</em>, <em>shader_type_name=None</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.VopNode.shaderName" title="Permalink to this definition"></a></dt>
<dd><p>Return the name of the shader defined by this VOP (if it is an
embedded shader) or the shader name defined by the shop in which
this VOP resides. If as_otl_path is True, returns an opdef: path to
the SHOP type. The shader_type_name is a string indicating the
shader context type to use; some nodes may provide several shader
types, and each may have a different name. This is applicable only
to multi-context shader nodes, such as a vopnet material shop.</p>
</dd></dl>

<dl class="method">
<dt id="hou.VopNode.shaderString">
<code class="descname">shaderString</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.VopNode.shaderString" title="Permalink to this definition"></a></dt>
<dd><p>shaderString(self, render_type=None, shader_type=hou.shaderType.Surface,
as_encapsulated=False) -&gt; str</p>
<blockquote>
<div>Returns the string that encodes the shader name and parameter values
suitable for specifying as a shader assignment in an input stream
acceptable by the renderer of a given type. If the VOP is material
that provides a few shader contexts (eg, surface and displacement),
it is necessary to provide the shader type explicitly. If
as_encapsulated is true, the returned shader string will encode the
shader as embedded in the parent shader with parameters referencing
the parent, if needed.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hou.VopNode.shaderType">
<code class="descname">shaderType</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hou.VopNode.shaderType" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.VopNode.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.VopNode.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.VopNodeType">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">VopNodeType</code><a class="headerlink" href="#hou.VopNodeType" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#hou.NodeType" title="hou.NodeType"><code class="xref py py-class docutils literal notranslate"><span class="pre">hou.NodeType</span></code></a></p>
<p>This kind of NodeType contains extra attributes specific to VOP nodes.</p>
<dl class="method">
<dt id="hou.VopNodeType.inputTags">
<code class="descname">inputTags</code><span class="sig-paren">(</span><em>self</em>, <em>input_name</em><span class="sig-paren">)</span> &#x2192; dict of string to string<a class="headerlink" href="#hou.VopNodeType.inputTags" title="Permalink to this definition"></a></dt>
<dd><p>Returns a dictionary of key-value paris associated with the given
input. This dictionary allows attaching arbitrary data to node
inputs.</p>
</dd></dl>

<dl class="method">
<dt id="hou.VopNodeType.outputTags">
<code class="descname">outputTags</code><span class="sig-paren">(</span><em>self</em>, <em>output_name</em><span class="sig-paren">)</span> &#x2192; dict of string to string<a class="headerlink" href="#hou.VopNodeType.outputTags" title="Permalink to this definition"></a></dt>
<dd><p>Returns a dictionary of key-value paris associated with the given
output. This dictionary allows attaching arbitrary data to node
outputs.</p>
</dd></dl>

<dl class="method">
<dt id="hou.VopNodeType.renderMask">
<code class="descname">renderMask</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#hou.VopNodeType.renderMask" title="Permalink to this definition"></a></dt>
<dd><p>Returns a string with space-separated names of the renderers that
this VOP type supports. Note that some VOP types, like the switch
VOP, return * to indicate that they support all renderers, while
others return an empty string to indicate they are not real shaders.</p>
<p>See hou.VopNode.shaderString for an example.</p>
</dd></dl>

<dl class="method">
<dt id="hou.VopNodeType.shaderType">
<code class="descname">shaderType</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span> &#x2192; [Hom:hou.shaderType] enum value<a class="headerlink" href="#hou.VopNodeType.shaderType" title="Permalink to this definition"></a></dt>
<dd><p>Returns the type of shader for this VOP type. For example, this vop
type might be a surface shader or a displacement shader. See
hou.shaderType for the possible shader types.</p>
<p>See also hou.VopNode.shaderType.</p>
</dd></dl>

<dl class="attribute">
<dt id="hou.VopNodeType.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.VopNodeType.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="hou.addNodeBundle">
<code class="descclassname">hou.</code><code class="descname">addNodeBundle</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.addNodeBundle" title="Permalink to this definition"></a></dt>
<dd><p>Create a new node bundle with the specified name.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>addNodeBundle(name = None) -&gt; hou.NodeBundle</dd>
</dl>
<p>See hou.NodeBundle for more information about node bundles.</p>
<p>If name is None, a unique bundle name is generated automatically.</p>
<p>Raises hou.OperationFailed if the name is not alphanumeric or a bundle
with that name already exists.</p>
<p>REPLACES</p>
<blockquote>
<div><ul class="simple">
<li>opbadd</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.allowEnvironmentToOverwriteVariable">
<code class="descclassname">hou.</code><code class="descname">allowEnvironmentToOverwriteVariable</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.allowEnvironmentToOverwriteVariable" title="Permalink to this definition"></a></dt>
<dd><p>Allow (or disallow) an environment variable to overwrite the value of a
global variable saved in a hip file.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>allowEnvironmentToOverwriteVariable(name, onoff)</dd>
</dl>
<p>Note that you need to allow the variable to be overwritten from within
Houdini/hython _before_ loading in the hip file.</p>
<p>For example, suppose you set the JOB environment variable to
/home/john/dyproject and created a hip file in
/home/john/myproject/hip/scene.hip. Your hip file could then reference
files using a $JOB prefix. If you then moved your project to
/mnt/projects/myproject you cannot simply change the JOB environment
variable because Houdini saved the old value of $JOB to the hip file.
This function lets you override the value of $JOB before you load the
hip file, as follows:</p>
<p>&gt; import os
&gt; os.environ[JOB] = /mnt/projects/myproject
&gt; hou.allowEnvironmentToOverwriteVariable(JOB, True)
&gt; hou.hipFile.load(os.path.expandvars($JOB/hip/scene.hip))</p>
</dd></dl>

<dl class="function">
<dt id="hou.almostEqual">
<code class="descclassname">hou.</code><code class="descname">almostEqual</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.almostEqual" title="Permalink to this definition"></a></dt>
<dd><p>Compares two numbers and returns True if they are almost equal in terms
of how far apart they are when represented as floating point numbers.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>almostEqual(x, y) -&gt; bool</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="hou.appearanceChangeType">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">appearanceChangeType</code><a class="headerlink" href="#hou.appearanceChangeType" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Enumeration of types of appearance change events that can happen to
nodes.</p>
<p>See hou.Node.addEventCallback.</p>
<p>VALUES</p>
<blockquote>
<div>Any
ErrorState
Pick
Color
DeleteScript
CommentLockFlag
CompressFlag
OTLMatchState
ActiveInput
Connections
ExpressionLanguage
NetworkBox
PostIt</div></blockquote>
<dl class="attribute">
<dt id="hou.appearanceChangeType.ActiveInput">
<code class="descname">ActiveInput</code><em class="property"> = appearanceChangeType.ActiveInput</em><a class="headerlink" href="#hou.appearanceChangeType.ActiveInput" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.appearanceChangeType.Any">
<code class="descname">Any</code><em class="property"> = appearanceChangeType.Any</em><a class="headerlink" href="#hou.appearanceChangeType.Any" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.appearanceChangeType.Color">
<code class="descname">Color</code><em class="property"> = appearanceChangeType.Color</em><a class="headerlink" href="#hou.appearanceChangeType.Color" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.appearanceChangeType.Comment">
<code class="descname">Comment</code><em class="property"> = appearanceChangeType.Comment</em><a class="headerlink" href="#hou.appearanceChangeType.Comment" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.appearanceChangeType.CompressFlag">
<code class="descname">CompressFlag</code><em class="property"> = appearanceChangeType.CompressFlag</em><a class="headerlink" href="#hou.appearanceChangeType.CompressFlag" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.appearanceChangeType.Connections">
<code class="descname">Connections</code><em class="property"> = appearanceChangeType.Connections</em><a class="headerlink" href="#hou.appearanceChangeType.Connections" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.appearanceChangeType.DeleteScript">
<code class="descname">DeleteScript</code><em class="property"> = appearanceChangeType.DeleteScript</em><a class="headerlink" href="#hou.appearanceChangeType.DeleteScript" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.appearanceChangeType.Dot">
<code class="descname">Dot</code><em class="property"> = appearanceChangeType.Dot</em><a class="headerlink" href="#hou.appearanceChangeType.Dot" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.appearanceChangeType.ErrorState">
<code class="descname">ErrorState</code><em class="property"> = appearanceChangeType.ErrorState</em><a class="headerlink" href="#hou.appearanceChangeType.ErrorState" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.appearanceChangeType.ExpressionLanguage">
<code class="descname">ExpressionLanguage</code><em class="property"> = appearanceChangeType.ExpressionLanguage</em><a class="headerlink" href="#hou.appearanceChangeType.ExpressionLanguage" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.appearanceChangeType.LockFlag">
<code class="descname">LockFlag</code><em class="property"> = appearanceChangeType.LockFlag</em><a class="headerlink" href="#hou.appearanceChangeType.LockFlag" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.appearanceChangeType.NetworkBox">
<code class="descname">NetworkBox</code><em class="property"> = appearanceChangeType.NetworkBox</em><a class="headerlink" href="#hou.appearanceChangeType.NetworkBox" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.appearanceChangeType.OTLMatchState">
<code class="descname">OTLMatchState</code><em class="property"> = appearanceChangeType.OTLMatchState</em><a class="headerlink" href="#hou.appearanceChangeType.OTLMatchState" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.appearanceChangeType.Pick">
<code class="descname">Pick</code><em class="property"> = appearanceChangeType.Pick</em><a class="headerlink" href="#hou.appearanceChangeType.Pick" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.appearanceChangeType.PostIt">
<code class="descname">PostIt</code><em class="property"> = appearanceChangeType.PostIt</em><a class="headerlink" href="#hou.appearanceChangeType.PostIt" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.appearanceChangeType.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.appearanceChangeType.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="hou.appendSessionModuleSource">
<code class="descclassname">hou.</code><code class="descname">appendSessionModuleSource</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.appendSessionModuleSource" title="Permalink to this definition"></a></dt>
<dd><p>Appends the given source code to the hou.session module. The appended
code is made available immediately. You do not have to re-import
hou.session.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>appendSessionModuleSource(source)</dd>
</dl>
<p>This function throws a hou.OperationFailed exception if it fails to
update the hou.session module. This can happen if the appended source
has syntax errors or if it conflicts with the existing contents of the
module.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.session</li>
<li>hou.sessionModuleSource</li>
<li>hou.setSessionModuleSource</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.applicationCompilationDate">
<code class="descclassname">hou.</code><code class="descname">applicationCompilationDate</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.applicationCompilationDate" title="Permalink to this definition"></a></dt>
<dd><p>Returns the applications compilation date.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>applicationCompilationDate() -&gt; string</dd>
</dl>
<p>If this method is executed in python, then it returns the date which the
hou module was compiled on.</p>
<p>REPLACES</p>
<blockquote>
<div><ul class="simple">
<li>version</li>
</ul>
</div></blockquote>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.applicationName</li>
<li>hou.applicationVersion</li>
<li>hou.applicationVersionString</li>
<li>hou.applicationPlatformInfo</li>
<li>hou.licenseCategory</li>
<li>hou.isApprentice</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.applicationName">
<code class="descclassname">hou.</code><code class="descname">applicationName</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.applicationName" title="Permalink to this definition"></a></dt>
<dd><p>Returns the application name.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>applicationName() -&gt; string</dd>
</dl>
<p>REPLACES</p>
<blockquote>
<div><ul class="simple">
<li>version</li>
</ul>
</div></blockquote>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.applicationCompilationDate</li>
<li>hou.applicationVersion</li>
<li>hou.applicationVersionString</li>
<li>hou.applicationPlatformInfo</li>
<li>hou.licenseCategory</li>
<li>hou.isApprentice</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.applicationPlatformInfo">
<code class="descclassname">hou.</code><code class="descname">applicationPlatformInfo</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.applicationPlatformInfo" title="Permalink to this definition"></a></dt>
<dd><p>Returns a string containing information about the system that compiled
this version of Houdini.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>applicationPlatformInfo() -&gt; string</dd>
</dl>
<p>Most of the time you can use Pythons platform module to get information
about the current operating system, processor type, etc. However, this
function can provide information not available through the platform
module, such as the version of the compiler that compiled Houdini.</p>
<p>&gt; &gt;&gt;&gt; hou.applicationPlatformInfo()
&gt; linux-x86_64-gcc4.4</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.applicationCompilationDate</li>
<li>hou.applicationVersion</li>
<li>hou.applicationVersionString</li>
<li>hou.applicationName</li>
<li>hou.licenseCategory</li>
<li>hou.isApprentice</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.applicationVersion">
<code class="descclassname">hou.</code><code class="descname">applicationVersion</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.applicationVersion" title="Permalink to this definition"></a></dt>
<dd><p>Returns the applications version number as a tuple of integers 
(major_version, minor_version, build_version).</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>applicationVersion() -&gt; tuple of 3 ints</dd>
</dl>
<p>If this method is executed in python, then it returns the hou modules
version number.</p>
<p>REPLACES</p>
<blockquote>
<div><ul class="simple">
<li>version</li>
</ul>
</div></blockquote>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.applicationCompilationDate</li>
<li>hou.applicationName</li>
<li>hou.applicationVersionString</li>
<li>hou.applicationPlatformInfo</li>
<li>hou.licenseCategory</li>
<li>hou.isApprentice</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="class">
<dt id="hou.attribData">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">attribData</code><a class="headerlink" href="#hou.attribData" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Enumeration of attribute data types.</p>
<p>VALUES</p>
<blockquote>
<div>Int
Float
String</div></blockquote>
<dl class="attribute">
<dt id="hou.attribData.Float">
<code class="descname">Float</code><em class="property"> = attribData.Float</em><a class="headerlink" href="#hou.attribData.Float" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.attribData.Int">
<code class="descname">Int</code><em class="property"> = attribData.Int</em><a class="headerlink" href="#hou.attribData.Int" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.attribData.String">
<code class="descname">String</code><em class="property"> = attribData.String</em><a class="headerlink" href="#hou.attribData.String" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.attribData.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.attribData.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.attribType">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">attribType</code><a class="headerlink" href="#hou.attribType" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Enumeration of geometry attribute types.</p>
<p>Note that global attributes are also known as detail attributes.</p>
<p>The type of data (e.g. int, float, string) is called the attribute data
type, can correspond to hou.attribData.</p>
<p>See hou.Geometry.addAttrib and hou.Attrib for more information.</p>
<p>VALUES</p>
<blockquote>
<div>Point
Prim
Vertex
Global</div></blockquote>
<dl class="attribute">
<dt id="hou.attribType.Global">
<code class="descname">Global</code><em class="property"> = attribType.Global</em><a class="headerlink" href="#hou.attribType.Global" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.attribType.Point">
<code class="descname">Point</code><em class="property"> = attribType.Point</em><a class="headerlink" href="#hou.attribType.Point" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.attribType.Prim">
<code class="descname">Prim</code><em class="property"> = attribType.Prim</em><a class="headerlink" href="#hou.attribType.Prim" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.attribType.Vertex">
<code class="descname">Vertex</code><em class="property"> = attribType.Vertex</em><a class="headerlink" href="#hou.attribType.Vertex" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.attribType.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.attribType.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="hou.bezier">
<code class="descclassname">hou.</code><code class="descname">bezier</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.bezier" title="Permalink to this definition"></a></dt>
<dd><p>Evaluate a Bezier interpolation spline for an animated parameter using
the left keyframes outgoing value, tangent, and acceleration and the
right keyframes incoming value, tangent, and acceleration.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>bezier() -&gt; float</dd>
</dl>
<p>This function is one of the special animation functions that use the
current playbar time and information in the parameters keyframes, such
as in and out values, tangents, acceleration, etc., to evaluate
themselves. Because the information needed to evaluate these functions
comes from the keyframes, these functions take few or no parameters.</p>
<p>Calling this function from outside a parameters expression will raise a
hou.NotAvailable exception.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.constant</li>
<li>hou.cubic</li>
<li>hou.cycle</li>
<li>hou.cyclet</li>
<li>hou.ease</li>
<li>hou.easein</li>
<li>hou.easeinp</li>
<li>hou.easeout</li>
<li>hou.easeoutp</li>
<li>hou.easep</li>
<li>hou.linear</li>
<li>hou.match</li>
<li>hou.matchin</li>
<li>hou.matchout</li>
<li>hou.qlinear</li>
<li>hou.quintic</li>
<li>hou.repeat</li>
<li>hou.repeatt</li>
<li>hou.spline</li>
<li>hou.vmatch</li>
<li>hou.vmatchin</li>
<li>hou.vmatchout</li>
</ul>
</div></blockquote>
<p>REPLACES</p>
<blockquote>
<div><ul class="simple">
<li>bezier()</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="class">
<dt id="hou.boundaryDisplay">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">boundaryDisplay</code><a class="headerlink" href="#hou.boundaryDisplay" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Enum for viewport boundary overlay.</p>
<p>Boundaries are used to show the edges of polygon mesh islands, for
either position or UV coordinates.</p>
<p>VALUES</p>
<blockquote>
<div><dl class="docutils">
<dt>hou.boundaryDisplay.Off</dt>
<dd>The boundary is disabled.</dd>
<dt>hou.boundaryDisplay.View3D</dt>
<dd>The boundary is shown in 3D viewports only.</dd>
<dt>hou.boundaryDisplay.ViewUV</dt>
<dd>The boundary is shown in UV viewports only.</dd>
<dt>hou.boundaryDisplay.On</dt>
<dd>The boundary is shown in all viewports.</dd>
</dl>
</div></blockquote>
<dl class="attribute">
<dt id="hou.boundaryDisplay.Off">
<code class="descname">Off</code><em class="property"> = boundaryDisplay.Off</em><a class="headerlink" href="#hou.boundaryDisplay.Off" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.boundaryDisplay.On">
<code class="descname">On</code><em class="property"> = boundaryDisplay.On</em><a class="headerlink" href="#hou.boundaryDisplay.On" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.boundaryDisplay.View3D">
<code class="descname">View3D</code><em class="property"> = boundaryDisplay.View3D</em><a class="headerlink" href="#hou.boundaryDisplay.View3D" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.boundaryDisplay.ViewUV">
<code class="descname">ViewUV</code><em class="property"> = boundaryDisplay.ViewUV</em><a class="headerlink" href="#hou.boundaryDisplay.ViewUV" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.boundaryDisplay.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.boundaryDisplay.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="hou.cd">
<code class="descclassname">hou.</code><code class="descname">cd</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.cd" title="Permalink to this definition"></a></dt>
<dd><p>Change the current node. Houdini has one current node, analogous to a
current directory in a file system. If a relative path is given, it is
relative to the node returned by hou.pwd().</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>cd(path)</dd>
</dl>
<p>If no node exists at the path, this function raises hou.OperationFailed.</p>
<p>Even though, when called from a parameters expression, hou.pwd()
returns the node containing the parameter and not Houdinis current
node, hou.cd() will always change the current node.</p>
<p>This function will raise hou.NotAvailable if you call it from MPlay.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.pwd</li>
<li>hou.setPwd</li>
</ul>
</div></blockquote>
<p>REPLACES</p>
<blockquote>
<div><ul class="simple">
<li>opcf</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.ch">
<code class="descclassname">hou.</code><code class="descname">ch</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ch" title="Permalink to this definition"></a></dt>
<dd><p>The same as evalParm(). Provided for backward compatibility.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>ch(path) -&gt; int, float, or string</dd>
</dl>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.evalParm</li>
<li>hou.evalParmTuple</li>
<li>hou.chsop</li>
<li>hou.chsoplist</li>
<li>hou.parm</li>
<li>hou.parmTuple</li>
</ul>
</div></blockquote>
<p>REPLACES</p>
<blockquote>
<div><ul class="simple">
<li>ch()</li>
<li>chs()</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="class">
<dt id="hou.channelEditorMode">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">channelEditorMode</code><a class="headerlink" href="#hou.channelEditorMode" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="attribute">
<dt id="hou.channelEditorMode.Dopesheet">
<code class="descname">Dopesheet</code><em class="property"> = channelEditorMode.Dopesheet</em><a class="headerlink" href="#hou.channelEditorMode.Dopesheet" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.channelEditorMode.Graph">
<code class="descname">Graph</code><em class="property"> = channelEditorMode.Graph</em><a class="headerlink" href="#hou.channelEditorMode.Graph" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.channelEditorMode.Table">
<code class="descname">Table</code><em class="property"> = channelEditorMode.Table</em><a class="headerlink" href="#hou.channelEditorMode.Table" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.channelEditorMode.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.channelEditorMode.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="hou.chopExportConflictResolutionPattern">
<code class="descclassname">hou.</code><code class="descname">chopExportConflictResolutionPattern</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.chopExportConflictResolutionPattern" title="Permalink to this definition"></a></dt>
<dd><p>Returns a CHOP node path pattern to take precedence when exporting to
the same channel.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>chopExportConflictResolutionPattern() -&gt; str</dd>
</dl>
<p>Returns a pattern for matching CHOP node paths that should take
precedence when there are other CHOPs that override the same channels
thus leading to conflicts.</p>
</dd></dl>

<dl class="function">
<dt id="hou.chopNetNodeTypeCategory">
<code class="descclassname">hou.</code><code class="descname">chopNetNodeTypeCategory</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.chopNetNodeTypeCategory" title="Permalink to this definition"></a></dt>
<dd><p>Return the NodeTypeCategory instance for Houdini channel container
(chopnet) nodes.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>chopNetNodeTypeCategory() -&gt; NodeTypeCategory</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="hou.chopNodeTypeCategory">
<code class="descclassname">hou.</code><code class="descname">chopNodeTypeCategory</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.chopNodeTypeCategory" title="Permalink to this definition"></a></dt>
<dd><p>Return the NodeTypeCategory instance for Houdini channel (chop) nodes.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>chopNodeTypeCategory() -&gt; NodeTypeCategory</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="hou.chsop">
<code class="descclassname">hou.</code><code class="descname">chsop</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.chsop" title="Permalink to this definition"></a></dt>
<dd><p>Evaluate a parameter that references a node, and return the absolute
path to the node.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>chsop(path) -&gt; string</dd>
</dl>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.evalParm</li>
<li>hou.chsoplist</li>
</ul>
</div></blockquote>
<p>REPLACES</p>
<blockquote>
<div><ul class="simple">
<li>chsop()</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.chsoplist">
<code class="descclassname">hou.</code><code class="descname">chsoplist</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.chsoplist" title="Permalink to this definition"></a></dt>
<dd><p>Evaluate a parameter that references a node path list, and return a
space separated list of absolute node paths.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>chsoplist(path) -&gt; string</dd>
</dl>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.evalParm</li>
<li>hou.chsop</li>
</ul>
</div></blockquote>
<p>REPLACES</p>
<blockquote>
<div><ul class="simple">
<li>chsoplist()</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.clearAllSelected">
<code class="descclassname">hou.</code><code class="descname">clearAllSelected</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.clearAllSelected" title="Permalink to this definition"></a></dt>
<dd><p>Clears the selected state for all nodes, network boxes, and other
subclasses of hou.NetworkMovableItem in the Houdini session.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>clearAllSelected()</dd>
</dl>
<p>This function is equivalent to traversing the node hierarchy and calling
setSelected(False) on every hou.NetworkMovableItem in the scene, but
operates much much faster.</p>
<p>This function will raise hou.NotAvailable if you call it from MPlay.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.NetworkBoxItem.isSelected</li>
<li>hou.NetworkBoxItem.setSelected</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="class">
<dt id="hou.colorItemType">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">colorItemType</code><a class="headerlink" href="#hou.colorItemType" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>&lt;Summary&gt;</p>
<p>&lt;Description&gt;</p>
<p>VALUES</p>
<blockquote>
<div>NetworkBox
StickyNote
StickyNoteText</div></blockquote>
<dl class="attribute">
<dt id="hou.colorItemType.NetworkBox">
<code class="descname">NetworkBox</code><em class="property"> = colorItemType.NetworkBox</em><a class="headerlink" href="#hou.colorItemType.NetworkBox" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.colorItemType.StickyNote">
<code class="descname">StickyNote</code><em class="property"> = colorItemType.StickyNote</em><a class="headerlink" href="#hou.colorItemType.StickyNote" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.colorItemType.StickyNoteText">
<code class="descname">StickyNoteText</code><em class="property"> = colorItemType.StickyNoteText</em><a class="headerlink" href="#hou.colorItemType.StickyNoteText" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.colorItemType.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.colorItemType.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.colorType">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">colorType</code><a class="headerlink" href="#hou.colorType" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Enumeration of color spaces.</p>
<p>VALUES</p>
<blockquote>
<div><dl class="docutils">
<dt>RGB</dt>
<dd>The red green blue color model.</dd>
<dt>HSV</dt>
<dd>The hue saturation value color model.</dd>
<dt>HSL</dt>
<dd>The hue saturation lightness color model.</dd>
<dt>LAB</dt>
<dd>The CIE L* a* b* color space model.</dd>
<dt>XYZ</dt>
<dd>The CIE XYZ color space model.</dd>
</dl>
</div></blockquote>
<dl class="attribute">
<dt id="hou.colorType.HSL">
<code class="descname">HSL</code><em class="property"> = colorType.HSL</em><a class="headerlink" href="#hou.colorType.HSL" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.colorType.HSV">
<code class="descname">HSV</code><em class="property"> = colorType.HSV</em><a class="headerlink" href="#hou.colorType.HSV" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.colorType.LAB">
<code class="descname">LAB</code><em class="property"> = colorType.LAB</em><a class="headerlink" href="#hou.colorType.LAB" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.colorType.RGB">
<code class="descname">RGB</code><em class="property"> = colorType.RGB</em><a class="headerlink" href="#hou.colorType.RGB" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.colorType.TMI">
<code class="descname">TMI</code><em class="property"> = colorType.TMI</em><a class="headerlink" href="#hou.colorType.TMI" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.colorType.XYZ">
<code class="descname">XYZ</code><em class="property"> = colorType.XYZ</em><a class="headerlink" href="#hou.colorType.XYZ" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.colorType.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.colorType.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.componentLoopType">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">componentLoopType</code><a class="headerlink" href="#hou.componentLoopType" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Enumeration of component loop types.</p>
<p>VALUES</p>
<blockquote>
<div><dl class="docutils">
<dt>Partial</dt>
<dd>A partial loop connects the components provided in a path with
each input component acting as a way-point on the path. The loop
will always start with the first provided component and end with
the last.</dd>
<dt>Extended</dt>
<dd>An extended loop is always created from just two components (or
possibly one edge component). It finds a path between these two
components, then extends that path at both ends. It extends each
direction until it either hits a boundary in the geometry, or
finds its way back to the existing path. Often the resulting
path will neither start with the start component or end with the
end component.</dd>
<dt>Closed</dt>
<dd>A closed loop is always created from just two components (or
possibly one edge component). It always tries to find a path the
goes from the starting component, passes through the end
component, and then continues on looking for a path back to the
starting component. The paths returned will generally both start
and end with the starting component.</dd>
</dl>
</div></blockquote>
<dl class="attribute">
<dt id="hou.componentLoopType.Closed">
<code class="descname">Closed</code><em class="property"> = componentLoopType.Closed</em><a class="headerlink" href="#hou.componentLoopType.Closed" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.componentLoopType.Extended">
<code class="descname">Extended</code><em class="property"> = componentLoopType.Extended</em><a class="headerlink" href="#hou.componentLoopType.Extended" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.componentLoopType.Partial">
<code class="descname">Partial</code><em class="property"> = componentLoopType.Partial</em><a class="headerlink" href="#hou.componentLoopType.Partial" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.componentLoopType.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.componentLoopType.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.compressionType">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">compressionType</code><a class="headerlink" href="#hou.compressionType" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Enumeration of compression types.</p>
<p>VALUES</p>
<blockquote>
<div><dl class="docutils">
<dt>Gzip</dt>
<dd>Compress using Gzip.</dd>
<dt>Blosc</dt>
<dd>Compress using Blosc.</dd>
<dt>NoCompression</dt>
<dd>Do not compress.</dd>
</dl>
</div></blockquote>
<dl class="attribute">
<dt id="hou.compressionType.Blosc">
<code class="descname">Blosc</code><em class="property"> = compressionType.Blosc</em><a class="headerlink" href="#hou.compressionType.Blosc" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.compressionType.Gzip">
<code class="descname">Gzip</code><em class="property"> = compressionType.Gzip</em><a class="headerlink" href="#hou.compressionType.Gzip" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.compressionType.NoCompression">
<code class="descname">NoCompression</code><em class="property"> = compressionType.NoCompression</em><a class="headerlink" href="#hou.compressionType.NoCompression" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.compressionType.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.compressionType.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.confirmType">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">confirmType</code><a class="headerlink" href="#hou.confirmType" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Enumeration of confirmation dialog suppression options.</p>
<p>VALUES</p>
<blockquote>
<div>OverwriteFile
UnlockNode
DeleteSpareParameters
DeleteWithoutReferences
NestedChannelGroups
SiblingChannelGroups
DeleteShelfElement
DeleteGalleryEntry
InactiveSnapMode
BackgroundSave
LockMultiNode</div></blockquote>
<dl class="attribute">
<dt id="hou.confirmType.BackgroundSave">
<code class="descname">BackgroundSave</code><em class="property"> = confirmType.BackgroundSave</em><a class="headerlink" href="#hou.confirmType.BackgroundSave" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.confirmType.DeleteGalleryEntry">
<code class="descname">DeleteGalleryEntry</code><em class="property"> = confirmType.DeleteGalleryEntry</em><a class="headerlink" href="#hou.confirmType.DeleteGalleryEntry" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.confirmType.DeleteShelfElement">
<code class="descname">DeleteShelfElement</code><em class="property"> = confirmType.DeleteShelfElement</em><a class="headerlink" href="#hou.confirmType.DeleteShelfElement" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.confirmType.DeleteSpareParameters">
<code class="descname">DeleteSpareParameters</code><em class="property"> = confirmType.DeleteSpareParameters</em><a class="headerlink" href="#hou.confirmType.DeleteSpareParameters" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.confirmType.DeleteWithoutReferences">
<code class="descname">DeleteWithoutReferences</code><em class="property"> = confirmType.DeleteWithoutReferences</em><a class="headerlink" href="#hou.confirmType.DeleteWithoutReferences" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.confirmType.InactiveSnapMode">
<code class="descname">InactiveSnapMode</code><em class="property"> = confirmType.InactiveSnapMode</em><a class="headerlink" href="#hou.confirmType.InactiveSnapMode" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.confirmType.LockMultiNode">
<code class="descname">LockMultiNode</code><em class="property"> = confirmType.LockMultiNode</em><a class="headerlink" href="#hou.confirmType.LockMultiNode" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.confirmType.NestedChannelGroups">
<code class="descname">NestedChannelGroups</code><em class="property"> = confirmType.NestedChannelGroups</em><a class="headerlink" href="#hou.confirmType.NestedChannelGroups" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.confirmType.OverwriteFile">
<code class="descname">OverwriteFile</code><em class="property"> = confirmType.OverwriteFile</em><a class="headerlink" href="#hou.confirmType.OverwriteFile" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.confirmType.SiblingChannelGroups">
<code class="descname">SiblingChannelGroups</code><em class="property"> = confirmType.SiblingChannelGroups</em><a class="headerlink" href="#hou.confirmType.SiblingChannelGroups" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.confirmType.UnlockNode">
<code class="descname">UnlockNode</code><em class="property"> = confirmType.UnlockNode</em><a class="headerlink" href="#hou.confirmType.UnlockNode" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.confirmType.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.confirmType.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.connectivityType">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">connectivityType</code><a class="headerlink" href="#hou.connectivityType" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Enumeration of connectivity types.</p>
<p>VALUES</p>
<blockquote>
<div>NoConnectivity
Texture
Position</div></blockquote>
<dl class="attribute">
<dt id="hou.connectivityType.NoConnectivity">
<code class="descname">NoConnectivity</code><em class="property"> = connectivityType.NoConnectivity</em><a class="headerlink" href="#hou.connectivityType.NoConnectivity" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.connectivityType.Position">
<code class="descname">Position</code><em class="property"> = connectivityType.Position</em><a class="headerlink" href="#hou.connectivityType.Position" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.connectivityType.Texture">
<code class="descname">Texture</code><em class="property"> = connectivityType.Texture</em><a class="headerlink" href="#hou.connectivityType.Texture" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.connectivityType.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.connectivityType.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="hou.constant">
<code class="descclassname">hou.</code><code class="descname">constant</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.constant" title="Permalink to this definition"></a></dt>
<dd><p>Evaluate an animation function for an animated parameter. The return
value is always the left keyframes outgoing value.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>constant() -&gt; float</dd>
</dl>
<p>This function is one of the special animation functions that use the
current playbar time and information in the parameters keyframes, such
as in and out values, tangents, acceleration, etc., to evaluate
themselves. Because the information needed to evaluate these functions
comes from the keyframes, these functions take few or no parameters.</p>
<p>Calling this function from outside a parameters expression will raise a
hou.NotAvailable exception.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.bezier</li>
<li>hou.cubic</li>
<li>hou.cycle</li>
<li>hou.cyclet</li>
<li>hou.ease</li>
<li>hou.easein</li>
<li>hou.easeinp</li>
<li>hou.easeout</li>
<li>hou.easeoutp</li>
<li>hou.easep</li>
<li>hou.linear</li>
<li>hou.match</li>
<li>hou.matchin</li>
<li>hou.matchout</li>
<li>hou.qlinear</li>
<li>hou.quintic</li>
<li>hou.repeat</li>
<li>hou.repeatt</li>
<li>hou.spline</li>
<li>hou.vmatch</li>
<li>hou.vmatchin</li>
<li>hou.vmatchout</li>
</ul>
</div></blockquote>
<p>REPLACES</p>
<blockquote>
<div><ul class="simple">
<li>constant()</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.contextOption">
<code class="descclassname">hou.</code><code class="descname">contextOption</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.contextOption" title="Permalink to this definition"></a></dt>
<dd><p>Returns the value of a cook context option.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>contextOption(option) -&gt; float or str</dd>
</dl>
<p>The return type will depend on the type of data used to set the option
value.</p>
<p>Retrieves the current value of a cook context option. This may have been
set by a node requesting data from another node, or from the global
default context option values stored in the hip file.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.contextOptionNames</li>
<li>hou.hasContextOption</li>
<li>hou.setDefaultContextOption</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.contextOptionNames">
<code class="descclassname">hou.</code><code class="descname">contextOptionNames</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.contextOptionNames" title="Permalink to this definition"></a></dt>
<dd><p>Returns the names of all available cook context options.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>contextOptionNames() -&gt; tuple of str</dd>
</dl>
<p>Retrieves the names of all options available in the current cook
context. If this method is invoked outside a cook context, it will
return the names of all the default cook context options stored in the
hip file.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.contextOption</li>
<li>hou.hasContextOption</li>
<li>hou.setDefaultContextOption</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.convertClipData">
<code class="descclassname">hou.</code><code class="descname">convertClipData</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.convertClipData" title="Permalink to this definition"></a></dt>
<dd><dl class="docutils">
<dt>USAGE</dt>
<dd>convertClipData(data, from_binary, from_blosc_compression, to_binary,
to_blosc_compression) -&gt; str</dd>
</dl>
<p>Converts the given clip &lt;data&gt; from the given format into the specified
format.</p>
<p>&lt;from_binary&gt; and &lt;from_blosc_compression&gt; specify the format of the
given &lt;data&gt;.</p>
<blockquote>
<div><ul class="simple">
<li>If &lt;from_binary&gt; is True, the given data is binary clip data.
Otherwise it is plain text (ASCII) clip data.</li>
<li>If &lt;from_blosc_compression&gt; is True, the given data is blosc
compressed binary clip data. This cannot be used with ASCII clip
data.</li>
</ul>
</div></blockquote>
<p>&lt;to_binary&gt; and &lt;to_blosc_compression&gt; specify the format the data
should be converted to.</p>
<blockquote>
<div><ul class="simple">
<li>If &lt;to_binary&gt; is True, convert to binary clip data. Otherwise
convert to ASCII clip data.</li>
<li>If &lt;to_blosc_compression&gt; is True, convert to blosc compressed
binary clip data. This cannot be used with ASCII clip data.</li>
</ul>
</div></blockquote>
<p>Raises a hou.InvalidInput exception if from_binary = False and
from_blosc_compression = True, or if to_binary = False and
to_blosc_compression = True.</p>
<p>Raises a hou.OperationFailed exception if the given &lt;data&gt; is invalid.</p>
</dd></dl>

<dl class="function">
<dt id="hou.convertKeyframesToClipData">
<code class="descclassname">hou.</code><code class="descname">convertKeyframesToClipData</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.convertKeyframesToClipData" title="Permalink to this definition"></a></dt>
<dd><dl class="docutils">
<dt>USAGE</dt>
<dd>convertKeyframesToClipData(keyframe_map, binary=True,
use_blosc_compression=True) -&gt; str</dd>
</dl>
<p>Converts the given keyframes into clip data.</p>
<dl class="docutils">
<dt>keyframe_map</dt>
<dd>A dictionary mapping parameter names (str) to a list of keyframes
for the parameter (hou.Keyframe).</dd>
</dl>
<p>&lt;binary&gt; and &lt;use_blosc_compression&gt; specify the format of the returned
clip data.</p>
<blockquote>
<div><ul class="simple">
<li>If &lt;binary&gt; is True, the returned data is binary clip data.
Otherwise it is plain text (ASCII) clip data.</li>
<li>If &lt;use_blosc_compression&gt; is True, the returned data is blosc
compressed binary clip data. This cannot be used with ASCII clip
data.</li>
</ul>
</div></blockquote>
<p>Raises a hou.InvalidInput exception if binary = False and
use_blosc_compression = True.</p>
<p>Raises a hou.OperationFailed exception if the given &lt;keyframe_map&gt; is
empty.</p>
</dd></dl>

<dl class="function">
<dt id="hou.cop2NetNodeTypeCategory">
<code class="descclassname">hou.</code><code class="descname">cop2NetNodeTypeCategory</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.cop2NetNodeTypeCategory" title="Permalink to this definition"></a></dt>
<dd><p>Return the NodeTypeCategory instance for Houdini composite container
(copnet) nodes.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>cop2NetNodeTypeCategory() -&gt; NodeTypeCategory</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="hou.cop2NodeTypeCategory">
<code class="descclassname">hou.</code><code class="descname">cop2NodeTypeCategory</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.cop2NodeTypeCategory" title="Permalink to this definition"></a></dt>
<dd><p>Return the NodeTypeCategory instance for Houdini composite (cop) nodes.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>cop2NodeTypeCategory() -&gt; NodeTypeCategory</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="hou.copyNodesTo">
<code class="descclassname">hou.</code><code class="descname">copyNodesTo</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.copyNodesTo" title="Permalink to this definition"></a></dt>
<dd><p>Copy all given nodes to a new place in node hierarchy.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>copyNodesTo(nodes, destination_node) -&gt; tuple of Nodes</dd>
</dl>
<p>The nodes to be copied should be a sequence of hou.Node objects. The
destination node will be the parent of new copied nodes. The type of all
source nodes should match the destination node child type.</p>
<p>This function returns a tuple of hou.Node objects corresponding to the
copied nodes.</p>
<p>Nodes will be copied to the destination in batches based on their
parent. All the nodes in a batch will be copied at the same time. This
way, any relative channel references between nodes with the same parent
will be updated to reflect the copied node location. Batches themselves
will be copied sequentially. Thus, channel references between nodes with
different parents will not be updated in copies.</p>
<p>For every copied node, if a node with the same name already exists at
the destination, the copy will be renamed. Any relative channel
references to the copy will be updated with the new copy name.</p>
<p>This function will raise a hou.OperationFailed exception if any of the
nodes to be copied are of invalid type, the destination node cannot be
copied into, or source node type does not match the destination node
child type.</p>
<p>This function will raise hou.ObjectWasDeleted if any of source nodes or
the destination node no longer exist in Houdini.</p>
<p>All of the above issues with source and destination nodes will be
reported before copying starts to avoid partial copy.</p>
<p>After the function finishes execution, all the new nodes created by it
will be selected.</p>
<p>REPLACES</p>
<blockquote>
<div><ul class="simple">
<li>opcp</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.copyNodesToClipboard">
<code class="descclassname">hou.</code><code class="descname">copyNodesToClipboard</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.copyNodesToClipboard" title="Permalink to this definition"></a></dt>
<dd><p>Copy given nodes to clipboard.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>copyNodesToClipboard(nodes)</dd>
</dl>
<p>This function copies given nodes to clipboard.</p>
<p>The nodes to be copied should be a sequence of hou.Node objects that
have the same parent. Copying nodes from different networks at the same
time is currently not supported.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.pasteNodesFromClipboard</li>
</ul>
</div></blockquote>
<p>REPLACES</p>
<blockquote>
<div><ul class="simple">
<li>opcopy</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.cubic">
<code class="descclassname">hou.</code><code class="descname">cubic</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.cubic" title="Permalink to this definition"></a></dt>
<dd><p>Smooth curve between the left keyframes outgoing slope and the rights
incoming slope.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>cubic() -&gt; float</dd>
</dl>
<p>This function is one of the special animation functions that use the
current playbar time and information in the parameters keyframes, such
as in and out values, tangents, acceleration, etc., to evaluate
themselves. Because the information needed to evaluate these functions
comes from the keyframes, these functions take few or no parameters.</p>
<p>Calling this function from outside a parameters expression will raise a
hou.NotAvailable exception.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.bezier</li>
<li>hou.constant</li>
<li>hou.cycle</li>
<li>hou.cyclet</li>
<li>hou.ease</li>
<li>hou.easein</li>
<li>hou.easeinp</li>
<li>hou.easeout</li>
<li>hou.easeoutp</li>
<li>hou.easep</li>
<li>hou.linear</li>
<li>hou.match</li>
<li>hou.matchin</li>
<li>hou.matchout</li>
<li>hou.qlinear</li>
<li>hou.quintic</li>
<li>hou.repeat</li>
<li>hou.repeatt</li>
<li>hou.spline</li>
<li>hou.vmatch</li>
<li>hou.vmatchin</li>
<li>hou.vmatchout</li>
</ul>
</div></blockquote>
<p>REPLACES</p>
<blockquote>
<div><ul class="simple">
<li>cubic()</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.currentDopNet">
<code class="descclassname">hou.</code><code class="descname">currentDopNet</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.currentDopNet" title="Permalink to this definition"></a></dt>
<dd><p>Returns the DOP Network node set as the current simulation in the UI.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>currentDopNet() -&gt; hou.Node</dd>
</dl>
<p>The current DOP network is the network the shelf tools put new nodes
into. The user can change this using the simulation menu in the bottom
right corner of the main window.</p>
<p>If youre building a shelf tool that creates simulation nodes, you
should use this function to know where to put them.</p>
<p>Call hou.setCurrentDopNet to set the current simulation network
programatically.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.setCurrentDopNet</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.cycle">
<code class="descclassname">hou.</code><code class="descname">cycle</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.cycle" title="Permalink to this definition"></a></dt>
<dd><p>Repeats the motion between two times.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>cycle(start_frame, end_frame) -&gt; float</dd>
</dl>
<p>The values within the range are repeated exactly. If you want to line up
the values with the value of the previous keyframe, use
hou.cycleoffset() instead.</p>
<p>This function is the same as hou.cyclet() except hou.cyclet() accepts
times instead of frames.</p>
<p>This function is one of the special animation functions that use the
current playbar time and information in the parameters keyframes, such
as in and out values, tangents, acceleration, etc., to evaluate
themselves. Because the information needed to evaluate these functions
comes from the keyframes, these functions take few or no parameters.</p>
<p>Calling this function from outside a parameters expression will raise a
hou.NotAvailable exception.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.bezier</li>
<li>hou.constant</li>
<li>hou.cubic</li>
<li>hou.cyclet</li>
<li>hou.cycleoffset</li>
<li>hou.cycleoffsett</li>
<li>hou.ease</li>
<li>hou.easein</li>
<li>hou.easeinp</li>
<li>hou.easeout</li>
<li>hou.easeoutp</li>
<li>hou.easep</li>
<li>hou.linear</li>
<li>hou.match</li>
<li>hou.matchin</li>
<li>hou.matchout</li>
<li>hou.qlinear</li>
<li>hou.quintic</li>
<li>hou.spline</li>
<li>hou.vmatch</li>
<li>hou.vmatchin</li>
<li>hou.vmatchout</li>
</ul>
</div></blockquote>
<p>REPLACES</p>
<blockquote>
<div><ul class="simple">
<li>cycle()</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.cycleoffset">
<code class="descclassname">hou.</code><code class="descname">cycleoffset</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.cycleoffset" title="Permalink to this definition"></a></dt>
<dd><p>Repeats the motion between two frames, lining up the first repeated
value with the left keyframes value.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>cycleoffset(start_frame, end_frame) -&gt; float</dd>
</dl>
<p>The repeated values are shifted so that each repeated portion has its
first value set to the last value of the previous cycle. If the start
frame is less than the end frame, the animation will cycle forwards.
Otherwise, it will cycle backwards.</p>
<p>This function is the same as hou.cycleoffsett() except
hou.cycleoffsett() accepts times instead of frames. If you want to
repeat motion exactly, use the hou.cycle() function instead.</p>
<p>This function is one of the special animation functions that use the
current playbar time and information in the parameters keyframes, such
as in and out values, tangents, acceleration, etc., to evaluate
themselves. Because the information needed to evaluate these functions
comes from the keyframes, these functions take few or no parameters.</p>
<p>Calling this function from outside a parameters expression will raise a
hou.NotAvailable exception.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.bezier</li>
<li>hou.constant</li>
<li>hou.cubic</li>
<li>hou.cycle</li>
<li>hou.cyclet</li>
<li>hou.cycleoffsett</li>
<li>hou.ease</li>
<li>hou.easein</li>
<li>hou.easeinp</li>
<li>hou.easeout</li>
<li>hou.easeoutp</li>
<li>hou.easep</li>
<li>hou.linear</li>
<li>hou.match</li>
<li>hou.matchin</li>
<li>hou.matchout</li>
<li>hou.qlinear</li>
<li>hou.quintic</li>
<li>hou.spline</li>
<li>hou.vmatch</li>
<li>hou.vmatchin</li>
<li>hou.vmatchout</li>
</ul>
</div></blockquote>
<p>REPLACES</p>
<blockquote>
<div><ul class="simple">
<li>cycleoffset()</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.cycleoffsett">
<code class="descclassname">hou.</code><code class="descname">cycleoffsett</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.cycleoffsett" title="Permalink to this definition"></a></dt>
<dd><p>Repeats the motion between two times, lining up the repeated values with
the left keyframes value.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>cycleoffsett(start_time, end_time) -&gt; float</dd>
</dl>
<p>The repeated values are shifted so that each repeated portion has its
first value set to the last value of the previous cycle. If the start
frame is less than the end frame, the animation will cycle forwards.
Otherwise, it will cycle backwards.</p>
<p>This function is the same as hou.cycleoffset() except hou.cycleoffset()
accepts frames instead of times. If you want to repeat motion exactly,
use the hou.cyclet() function instead.</p>
<p>This function is one of the special animation functions that use the
current playbar time and information in the parameters keyframes, such
as in and out values, tangents, acceleration, etc., to evaluate
themselves. Because the information needed to evaluate these functions
comes from the keyframes, these functions take few or no parameters.</p>
<p>Calling this function from outside a parameters expression will raise a
hou.NotAvailable exception.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.bezier</li>
<li>hou.constant</li>
<li>hou.cubic</li>
<li>hou.cycle</li>
<li>hou.cyclet</li>
<li>hou.cycleoffset</li>
<li>hou.ease</li>
<li>hou.easein</li>
<li>hou.easeinp</li>
<li>hou.easeout</li>
<li>hou.easeoutp</li>
<li>hou.easep</li>
<li>hou.linear</li>
<li>hou.match</li>
<li>hou.matchin</li>
<li>hou.matchout</li>
<li>hou.qlinear</li>
<li>hou.quintic</li>
<li>hou.spline</li>
<li>hou.vmatch</li>
<li>hou.vmatchin</li>
<li>hou.vmatchout</li>
</ul>
</div></blockquote>
<p>REPLACES</p>
<blockquote>
<div><ul class="simple">
<li>cycleoffsett()</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.cyclet">
<code class="descclassname">hou.</code><code class="descname">cyclet</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.cyclet" title="Permalink to this definition"></a></dt>
<dd><p>Repeats the motion between two times.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>cyclet(start_time, end_time) -&gt; float</dd>
</dl>
<p>The values within the range are repeated exactly. If you want to line up
the values with the value of the previous keyframe, use
hou.cycleoffsett() instead.</p>
<p>This function is the same as hou.cycle() except hou.cycle() it accepts
frames instead of times.</p>
<p>This function is one of the special animation functions that use the
current playbar time and information in the parameters keyframes, such
as in and out values, tangents, acceleration, etc., to evaluate
themselves. Because the information needed to evaluate these functions
comes from the keyframes, these functions take few or no parameters.</p>
<p>Calling this function from outside a parameters expression will raise a
hou.NotAvailable exception.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.bezier</li>
<li>hou.constant</li>
<li>hou.cubic</li>
<li>hou.cycle</li>
<li>hou.cycleoffset</li>
<li>hou.cycleoffsett</li>
<li>hou.ease</li>
<li>hou.easein</li>
<li>hou.easeinp</li>
<li>hou.easeout</li>
<li>hou.easeoutp</li>
<li>hou.easep</li>
<li>hou.linear</li>
<li>hou.match</li>
<li>hou.matchin</li>
<li>hou.matchout</li>
<li>hou.qlinear</li>
<li>hou.quintic</li>
<li>hou.spline</li>
<li>hou.vmatch</li>
<li>hou.vmatchin</li>
<li>hou.vmatchout</li>
</ul>
</div></blockquote>
<p>REPLACES</p>
<blockquote>
<div><ul class="simple">
<li>cyclet()</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="class">
<dt id="hou.dataParmType">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">dataParmType</code><a class="headerlink" href="#hou.dataParmType" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Enumeration of data parameter types.</p>
<p>A hou.DataParmTemplate is set to one of these types to specify whether a
data parameter will hold geometry data or a key-value dictionary
structure.</p>
<p>VALUES</p>
<blockquote>
<div>Geometry
KeyValueDictionary</div></blockquote>
<dl class="attribute">
<dt id="hou.dataParmType.Geometry">
<code class="descname">Geometry</code><em class="property"> = dataParmType.Geometry</em><a class="headerlink" href="#hou.dataParmType.Geometry" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.dataParmType.KeyValueDictionary">
<code class="descname">KeyValueDictionary</code><em class="property"> = dataParmType.KeyValueDictionary</em><a class="headerlink" href="#hou.dataParmType.KeyValueDictionary" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.dataParmType.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.dataParmType.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="hou.defaultColor">
<code class="descclassname">hou.</code><code class="descname">defaultColor</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.defaultColor" title="Permalink to this definition"></a></dt>
<dd><p>Return the default color for a particular network element.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>defaultColor(color_item) -&gt; hou.Color</dd>
</dl>
<p>Returns the default color that will be used for new network elements
such as network boxes and sticky notes. Node default colors are
controlled with methods on the hou.NodeType.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.colorItemType</li>
<li>hou.NodeType.defaultColor</li>
<li>hou.setDefaultColor</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="class">
<dt id="hou.displaySetType">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">displaySetType</code><a class="headerlink" href="#hou.displaySetType" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Enum of viewport geometry contexts.</p>
<p>There are several contexts for controlling shading and marker display
which allow geometries from different operators to be distinguished from
one another.</p>
<p>VALUES</p>
<blockquote>
<div><dl class="docutils">
<dt>hou.displaySetType.SceneObject</dt>
<dd>Objects which are displayed but not selected, when the scene is
viewing objects.</dd>
<dt>hou.displaySetType.SelectedObject</dt>
<dd>Objects which are displayed and selected, when the scene is
viewing objects.</dd>
<dt>hou.displaySetType.GhostObject</dt>
<dd>Objects which are not the currently edited object when Ghost
other Objects display mode is active.</dd>
<dt>hou.displaySetType.DisplayModel</dt>
<dd>The currently displayed surface operater when editing an object.</dd>
<dt>hou.displaySetType.CurrentModel</dt>
<dd>The currently selected surface operater when editing an object.</dd>
<dt>hou.displaySetType.TemplateModel</dt>
<dd>Surface operaters that have their template flag set when editing
an object.</dd>
</dl>
</div></blockquote>
<dl class="attribute">
<dt id="hou.displaySetType.CurrentModel">
<code class="descname">CurrentModel</code><em class="property"> = displaySetType.CurrentModel</em><a class="headerlink" href="#hou.displaySetType.CurrentModel" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.displaySetType.DisplayModel">
<code class="descname">DisplayModel</code><em class="property"> = displaySetType.DisplayModel</em><a class="headerlink" href="#hou.displaySetType.DisplayModel" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.displaySetType.GhostObject">
<code class="descname">GhostObject</code><em class="property"> = displaySetType.GhostObject</em><a class="headerlink" href="#hou.displaySetType.GhostObject" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.displaySetType.SceneObject">
<code class="descname">SceneObject</code><em class="property"> = displaySetType.SceneObject</em><a class="headerlink" href="#hou.displaySetType.SceneObject" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.displaySetType.SelectedObject">
<code class="descname">SelectedObject</code><em class="property"> = displaySetType.SelectedObject</em><a class="headerlink" href="#hou.displaySetType.SelectedObject" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.displaySetType.TemplateModel">
<code class="descname">TemplateModel</code><em class="property"> = displaySetType.TemplateModel</em><a class="headerlink" href="#hou.displaySetType.TemplateModel" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.displaySetType.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.displaySetType.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="hou.dopNodeTypeCategory">
<code class="descclassname">hou.</code><code class="descname">dopNodeTypeCategory</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.dopNodeTypeCategory" title="Permalink to this definition"></a></dt>
<dd><p>Return the NodeTypeCategory instance for Houdini dynamic (DOP) nodes.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>dopNodeTypeCategory() -&gt; NodeTypeCategory</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="hou.drawableDisplayMode">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">drawableDisplayMode</code><a class="headerlink" href="#hou.drawableDisplayMode" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Enumerator for the drawable display mode.</p>
<p>VALUES</p>
<blockquote>
<div><dl class="docutils">
<dt>hou.drawableDisplayMode.CurrentViewportMode</dt>
<dd>Specifies the display mode currently active in the viewport.</dd>
<dt>hou.drawableDisplayMode.WireframeMode</dt>
<dd>Specifies the display mode as wireframe.</dd>
</dl>
</div></blockquote>
<dl class="attribute">
<dt id="hou.drawableDisplayMode.CurrentViewportMode">
<code class="descname">CurrentViewportMode</code><em class="property"> = drawableDisplayMode.CurrentViewportMode</em><a class="headerlink" href="#hou.drawableDisplayMode.CurrentViewportMode" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.drawableDisplayMode.WireframeMode">
<code class="descname">WireframeMode</code><em class="property"> = drawableDisplayMode.WireframeMode</em><a class="headerlink" href="#hou.drawableDisplayMode.WireframeMode" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.drawableDisplayMode.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.drawableDisplayMode.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.drawablePrimitive">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">drawablePrimitive</code><a class="headerlink" href="#hou.drawablePrimitive" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Enumerator for the drawable primitive types.</p>
<p>VALUES</p>
<blockquote>
<div>hou.drawablePrimitive.Circle
hou.drawablePrimitive.Sphere
hou.drawablePrimitive.Tube</div></blockquote>
<dl class="attribute">
<dt id="hou.drawablePrimitive.Circle">
<code class="descname">Circle</code><em class="property"> = drawablePrimitive.Circle</em><a class="headerlink" href="#hou.drawablePrimitive.Circle" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.drawablePrimitive.Sphere">
<code class="descname">Sphere</code><em class="property"> = drawablePrimitive.Sphere</em><a class="headerlink" href="#hou.drawablePrimitive.Sphere" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.drawablePrimitive.Tube">
<code class="descname">Tube</code><em class="property"> = drawablePrimitive.Tube</em><a class="headerlink" href="#hou.drawablePrimitive.Tube" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.drawablePrimitive.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.drawablePrimitive.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="hou.ease">
<code class="descclassname">hou.</code><code class="descname">ease</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ease" title="Permalink to this definition"></a></dt>
<dd><p>Interpolates between the left keyframes outgoing value and the right
keyframes incoming value.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>ease() -&gt; float</dd>
</dl>
<p>The tangents will be flat at both ends of the function, so the curve
will slowly ease from the left value and, near the end of the function,
slowly reduce the speed until it is at rest at the right value.</p>
<p>This function is one of the special animation functions that use the
current playbar time and information in the parameters keyframes, such
as in and out values, tangents, acceleration, etc., to evaluate
themselves. Because the information needed to evaluate these functions
comes from the keyframes, these functions take few or no parameters.</p>
<p>Calling this function from outside a parameters expression will raise a
hou.NotAvailable exception.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.bezier</li>
<li>hou.constant</li>
<li>hou.cubic</li>
<li>hou.cycle</li>
<li>hou.cyclet</li>
<li>hou.easein</li>
<li>hou.easeinp</li>
<li>hou.easeout</li>
<li>hou.easeoutp</li>
<li>hou.easep</li>
<li>hou.linear</li>
<li>hou.match</li>
<li>hou.matchin</li>
<li>hou.matchout</li>
<li>hou.qlinear</li>
<li>hou.quintic</li>
<li>hou.repeat</li>
<li>hou.repeatt</li>
<li>hou.spline</li>
<li>hou.vmatch</li>
<li>hou.vmatchin</li>
<li>hou.vmatchout</li>
</ul>
</div></blockquote>
<p>REPLACES</p>
<blockquote>
<div><ul class="simple">
<li>ease()</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.easein">
<code class="descclassname">hou.</code><code class="descname">easein</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.easein" title="Permalink to this definition"></a></dt>
<dd><p>Interpolates between the left keyframes outgoing value and the right
keyframes incoming value.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>easein() -&gt; float</dd>
</dl>
<p>The tangent will be flat at the left end of the function, so it will
slowly ease from the outgoing value of the left keyframe.</p>
<p>This function is one of the special animation functions that use the
current playbar time and information in the parameters keyframes, such
as in and out values, tangents, acceleration, etc., to evaluate
themselves. Because the information needed to evaluate these functions
comes from the keyframes, these functions take few or no parameters.</p>
<p>Calling this function from outside a parameters expression will raise a
hou.NotAvailable exception.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.bezier</li>
<li>hou.constant</li>
<li>hou.cubic</li>
<li>hou.cycle</li>
<li>hou.cyclet</li>
<li>hou.ease</li>
<li>hou.easeinp</li>
<li>hou.easeout</li>
<li>hou.easeoutp</li>
<li>hou.easep</li>
<li>hou.linear</li>
<li>hou.match</li>
<li>hou.matchin</li>
<li>hou.matchout</li>
<li>hou.qlinear</li>
<li>hou.quintic</li>
<li>hou.repeat</li>
<li>hou.repeatt</li>
<li>hou.spline</li>
<li>hou.vmatch</li>
<li>hou.vmatchin</li>
<li>hou.vmatchout</li>
</ul>
</div></blockquote>
<p>REPLACES</p>
<blockquote>
<div><ul class="simple">
<li>easein()</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.easeinp">
<code class="descclassname">hou.</code><code class="descname">easeinp</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.easeinp" title="Permalink to this definition"></a></dt>
<dd><p>Interpolates between the values of two keyframes.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>easeinp(ease_speed) -&gt; float</dd>
</dl>
<p>This function is like hou.easein, except it has an additional parameter
to say how fast the curve should ease into the motion.</p>
<p>This function is one of the special animation functions that use the
current playbar time and information in the parameters keyframes, such
as in and out values, tangents, acceleration, etc., to evaluate
themselves. Because the information needed to evaluate these functions
comes from the keyframes, these functions take few or no parameters.</p>
<p>Calling this function from outside a parameters expression will raise a
hou.NotAvailable exception.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.bezier</li>
<li>hou.constant</li>
<li>hou.cubic</li>
<li>hou.cycle</li>
<li>hou.cyclet</li>
<li>hou.ease</li>
<li>hou.easein</li>
<li>hou.easeout</li>
<li>hou.easeoutp</li>
<li>hou.easep</li>
<li>hou.linear</li>
<li>hou.match</li>
<li>hou.matchin</li>
<li>hou.matchout</li>
<li>hou.qlinear</li>
<li>hou.quintic</li>
<li>hou.repeat</li>
<li>hou.repeatt</li>
<li>hou.spline</li>
<li>hou.vmatch</li>
<li>hou.vmatchin</li>
<li>hou.vmatchout</li>
</ul>
</div></blockquote>
<p>REPLACES</p>
<blockquote>
<div><ul class="simple">
<li>easeinp()</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.easeout">
<code class="descclassname">hou.</code><code class="descname">easeout</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.easeout" title="Permalink to this definition"></a></dt>
<dd><p>Interpolates between the left keyframes outgoing value and the right
keyframes incoming value.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>easeout() -&gt; float</dd>
</dl>
<p>The tangent will be flat at the right end of the function, so it will
slowly come to rest at the incoming value of the right keyframe.</p>
<p>This function is one of the special animation functions that use the
current playbar time and information in the parameters keyframes, such
as in and out values, tangents, acceleration, etc., to evaluate
themselves. Because the information needed to evaluate these functions
comes from the keyframes, these functions take few or no parameters.</p>
<p>Calling this function from outside a parameters expression will raise a
hou.NotAvailable exception.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.bezier</li>
<li>hou.constant</li>
<li>hou.cubic</li>
<li>hou.cycle</li>
<li>hou.cyclet</li>
<li>hou.ease</li>
<li>hou.easein</li>
<li>hou.easeinp</li>
<li>hou.easeoutp</li>
<li>hou.easep</li>
<li>hou.linear</li>
<li>hou.match</li>
<li>hou.matchin</li>
<li>hou.matchout</li>
<li>hou.qlinear</li>
<li>hou.quintic</li>
<li>hou.repeat</li>
<li>hou.repeatt</li>
<li>hou.spline</li>
<li>hou.vmatch</li>
<li>hou.vmatchin</li>
<li>hou.vmatchout</li>
</ul>
</div></blockquote>
<p>REPLACES</p>
<blockquote>
<div><ul class="simple">
<li>easeout()</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.easeoutp">
<code class="descclassname">hou.</code><code class="descname">easeoutp</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.easeoutp" title="Permalink to this definition"></a></dt>
<dd><p>Interpolates between the values of two keyframes.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>easeoutp(ease_speed) -&gt; float</dd>
</dl>
<p>This function is like hou.easeout, except it has an additional parameter
to say how fast the curve should ease into the motion.</p>
<p>This function is one of the special animation functions that use the
current playbar time and information in the parameters keyframes, such
as in and out values, tangents, acceleration, etc., to evaluate
themselves. Because the information needed to evaluate these functions
comes from the keyframes, these functions take few or no parameters.</p>
<p>Calling this function from outside a parameters expression will raise a
hou.NotAvailable exception.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.bezier</li>
<li>hou.constant</li>
<li>hou.cubic</li>
<li>hou.cycle</li>
<li>hou.cyclet</li>
<li>hou.ease</li>
<li>hou.easein</li>
<li>hou.easeinp</li>
<li>hou.easeout</li>
<li>hou.easep</li>
<li>hou.linear</li>
<li>hou.match</li>
<li>hou.matchin</li>
<li>hou.matchout</li>
<li>hou.qlinear</li>
<li>hou.quintic</li>
<li>hou.repeat</li>
<li>hou.repeatt</li>
<li>hou.spline</li>
<li>hou.vmatch</li>
<li>hou.vmatchin</li>
<li>hou.vmatchout</li>
</ul>
</div></blockquote>
<p>REPLACES</p>
<blockquote>
<div><ul class="simple">
<li>easeoutp()</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.easep">
<code class="descclassname">hou.</code><code class="descname">easep</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.easep" title="Permalink to this definition"></a></dt>
<dd><p>Interpolates between the values of two keyframes.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>easep(ease_bias) -&gt; float</dd>
</dl>
<p>An ease bias of less than one slow the animation near right keyframe,
while an ease bias greater than one will slow it near the left keyframe.</p>
<p>This function is one of the special animation functions that use the
current playbar time and information in the parameters keyframes, such
as in and out values, tangents, acceleration, etc., to evaluate
themselves. Because the information needed to evaluate these functions
comes from the keyframes, these functions take few or no parameters.</p>
<p>Calling this function from outside a parameters expression will raise a
hou.NotAvailable exception.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.bezier</li>
<li>hou.constant</li>
<li>hou.cubic</li>
<li>hou.cycle</li>
<li>hou.cyclet</li>
<li>hou.ease</li>
<li>hou.easein</li>
<li>hou.easeinp</li>
<li>hou.easeout</li>
<li>hou.easeoutp</li>
<li>hou.linear</li>
<li>hou.match</li>
<li>hou.matchin</li>
<li>hou.matchout</li>
<li>hou.qlinear</li>
<li>hou.quintic</li>
<li>hou.repeat</li>
<li>hou.repeatt</li>
<li>hou.spline</li>
<li>hou.vmatch</li>
<li>hou.vmatchin</li>
<li>hou.vmatchout</li>
</ul>
</div></blockquote>
<p>REPLACES</p>
<blockquote>
<div><ul class="simple">
<li>easep()</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.evalParm">
<code class="descclassname">hou.</code><code class="descname">evalParm</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.evalParm" title="Permalink to this definition"></a></dt>
<dd><p>Evaluate a parameter, given either an absolute or a relative path to it.
Relative path searches are done from the node returned by . This
function is a shortcut for hou.parm(path).eval().</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>evalParm(path) -&gt; int, float, or string</dd>
</dl>
<p>The return type will depend on the type of the parameter.</p>
<p>When a parameter is evaluating, hou.pwd returns the node containing that
parameter, so hou.evalParm() can be used inside expressions to perform
relative parameter references.</p>
<p>This function throws a hou.NotAvailable exception if you call it from
MPlay.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.evalParmTuple</li>
<li>hou.Parm</li>
<li>hou.ParmTuple</li>
</ul>
</div></blockquote>
<p>REPLACES</p>
<blockquote>
<div><ul class="simple">
<li>ch()</li>
<li>chs()</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.evalParmTuple">
<code class="descclassname">hou.</code><code class="descname">evalParmTuple</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.evalParmTuple" title="Permalink to this definition"></a></dt>
<dd><p>Evaluate a parameter, given either an absolute or a relative path to it.
Relative path searches are done from the node returned by . This
function is a shortcut for hou.parmTuple(path).eval().</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>evalParmTuple(path) -&gt; tuple of int, float, or str, or hou.Ramp</dd>
</dl>
<p>The return type will depend on the type of the parameter.</p>
<p>When a parameter is evaluating, hou.pwd returns the node containing that
parameter, so hou.evalParmTuple() can be used inside expressions to
perform relative parameter references.</p>
<p>This function throws a hou.NotAvailable exception if you call it from
MPlay.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.evalParm</li>
<li>hou.Parm</li>
<li>hou.ParmTuple</li>
</ul>
</div></blockquote>
<p>REPLACES</p>
<blockquote>
<div><ul class="simple">
<li>ch()</li>
<li>chramp()</li>
<li>chs()</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.evaluatingParm">
<code class="descclassname">hou.</code><code class="descname">evaluatingParm</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.evaluatingParm" title="Permalink to this definition"></a></dt>
<dd><p>Return the parameter that is currently evaluating.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>evaluatingParm() -&gt; hou.Parm</dd>
</dl>
<p>You can call this function from a parameter expression to determine
which parameter is currently evaluating. This function provides the
Python equivalent of Hscripts $CH variable.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.ScriptEvalContext</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.exit">
<code class="descclassname">hou.</code><code class="descname">exit</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.exit" title="Permalink to this definition"></a></dt>
<dd><p>Exits Houdini, returning the exit code to the operating system. If
suppress_save_prompt is false, this function asks the user if he/she
wants to save. If the user presses Cancel, the exit will be canceled
and the next statement will execute.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>exit(exit_code=0, suppress_save_prompt=False)</dd>
</dl>
<p>The exit confirmation prompt only appears if the session has unsaved
changes. This function will not return until after the user has made a
choice from the prompt. If this function is called from outside Houdini
(e.g. MPlay or a non-graphical Python shell), the dialog is not
displayed and suppress_save_prompt==True is implied.</p>
<p>Note that if the user chose to exit, this function will raise a Python
SystemExit exception to ensure the executing Python script terminates.
This approach ensures that the next Python statement will not be
executed, since Houdini may add events to its event queue that carry out
the actual shutdown, or hou.exit() may be called from a different thread
than the one executing the shutdown.</p>
<p>Note that if you call sys.exit() from within the interactive Houdini
Python shell, it will call hou.exit() with suppress_save_prompt=True.
The Houdini Python shell does this by intercepting the SystemExit
exception raised by sys.exit() and calling hou.exit(). Since both
sys.exit() and hou.exit() both raise SystemExit exceptions, the shell
calls hou._isExiting() to differentiate between the two.</p>
<p>Avoid calling sys.exit() from any place other than the interactive
Houdini Python shell, such as non-graphical Python shells, and instead
call hou.exit(). Using hou.exit() ensures that Houdini shuts down
cleanly.</p>
<p>REPLACES</p>
<blockquote>
<div><ul class="simple">
<li>quit</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.expandString">
<code class="descclassname">hou.</code><code class="descname">expandString</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.expandString" title="Permalink to this definition"></a></dt>
<dd><p>Expands global variables and expressions in a string at the current
frame.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>expandString(str) -&gt; str</dd>
</dl>
<p>Expands global variables in the expression. For example, when Houdini is
at frame 10:</p>
<p>&gt; &gt;&gt;&gt; hou.expandStringAtFrame($F)
&gt; 10</p>
<p>Also expands HScript expressions in backticks, such as the channel
reference in this example. This returns the value of the translate X
parameter for geo1 at the current frame as a string:</p>
<p>&gt; hou.expandStringAtFrame(<cite>ch(/obj/geo1/tx)</cite>)</p>
<p>This function evaluates the string as if it were the contents of a non-
animated text parameter. To evaluate a straight HScript expression
(without needing backticks), use hou.hscriptExpression.</p>
<p>Raises hou.OperationFailed exception if the first argument is None.</p>
<p>&gt; &gt;&gt;&gt; hou.expandString($HIP/file.geo)
&gt; /dir/containing/hip/file/file.geo
&gt; &gt;&gt;&gt; hou.expandString(file`$F+1`.pic)
&gt; file2.pic</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.expandStringAtFrame</li>
<li>hou.hscriptExpression</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.expandStringAtFrame">
<code class="descclassname">hou.</code><code class="descname">expandStringAtFrame</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.expandStringAtFrame" title="Permalink to this definition"></a></dt>
<dd><p>Expands global variables and expressions in a string at a given frame.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>expandStringAtFrame(str, frame_number) -&gt; str</dd>
</dl>
<p>Expands global variables in the expression. For example:</p>
<p>&gt; &gt;&gt;&gt; hou.expandStringAtFrame($F, 10)
&gt; 10</p>
<p>Also expands HScript expressions in back-ticks, such as the channel
reference in this example. This returns the value of the translate X
parameter for geo1 at the current frame as a string:</p>
<p>&gt; hou.expandStringAtFrame(<cite>ch(/obj/geo1/tx)</cite>, hou.frame())</p>
<p>This function evaluates the string as if it were the contents of a non-
animated text parameter. To evaluate a straight HScript expression
(without needing back-ticks), use hou.hscriptExpression.</p>
<p>Raises hou.OperationFailed exception if the first argument is None.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.expandString</li>
<li>hou.hscriptExpression</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="class">
<dt id="hou.exprLanguage">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">exprLanguage</code><a class="headerlink" href="#hou.exprLanguage" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Enumeration of available expression languages.</p>
<p>VALUES</p>
<blockquote>
<div>Python
Hscript</div></blockquote>
<dl class="attribute">
<dt id="hou.exprLanguage.Hscript">
<code class="descname">Hscript</code><em class="property"> = exprLanguage.Hscript</em><a class="headerlink" href="#hou.exprLanguage.Hscript" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.exprLanguage.Python">
<code class="descname">Python</code><em class="property"> = exprLanguage.Python</em><a class="headerlink" href="#hou.exprLanguage.Python" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.exprLanguage.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.exprLanguage.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="hou.expressionGlobals">
<code class="descclassname">hou.</code><code class="descname">expressionGlobals</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.expressionGlobals" title="Permalink to this definition"></a></dt>
<dd><p>Return the globals dictionary used by the parameter expression
evaluation namespace.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>expressionGlobals() -&gt; dict</dd>
</dl>
<p>When Houdini evaluates a Python expression inside a parameter, it uses a
separate namespace. This way, Houdini can run from hou import * and from
hou.session import * in that namespace, allowing you to drop the hou.
and hou.session. prefixes in your expressions, and the global namespace
does not get polluted.</p>
<p>In Python, namespaces are stored as dictionaries. This function returns
the dictionary for the Python parameter expression namespace. It is
analogous to the builtin globals function, which returns you the
dictionary for the current namespace.</p>
<p>You might use this function from the pythonrc.py file to set up Python
functions that can be called from any Python parameter expression. For
example, if you put your functions in a module called expr, you might
put the following in pythonrc.py:</p>
<p>&gt; import expr
&gt; hou.expressionGlobals()[expr] = expr</p>
<p>Then, from a Python expression, you could write expr.foo(), where foo is
a function defined in your expr module.</p>
<p>You can also use this dictionary with Pythons exec statement. The
following example also imports the expr module into the both the global
and expression namespaces:</p>
<p>&gt; code = compile(import expr, &lt;generated_code&gt;, exec)
&gt; exec code
&gt; exec code in hou.expressionGlobals()</p>
<p>See Python Parameter Expressions for more information on using Python
expressions in parameters. See startup scripts for more information
about pythonrc.py.</p>
</dd></dl>

<dl class="class">
<dt id="hou.fbxCompatibilityMode">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">fbxCompatibilityMode</code><a class="headerlink" href="#hou.fbxCompatibilityMode" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="attribute">
<dt id="hou.fbxCompatibilityMode.FBXStandard">
<code class="descname">FBXStandard</code><em class="property"> = fbxCompatibilityMode.FBXStandard</em><a class="headerlink" href="#hou.fbxCompatibilityMode.FBXStandard" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.fbxCompatibilityMode.Maya">
<code class="descname">Maya</code><em class="property"> = fbxCompatibilityMode.Maya</em><a class="headerlink" href="#hou.fbxCompatibilityMode.Maya" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.fbxCompatibilityMode.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.fbxCompatibilityMode.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.fbxMaterialMode">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">fbxMaterialMode</code><a class="headerlink" href="#hou.fbxMaterialMode" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="attribute">
<dt id="hou.fbxMaterialMode.FBXShaderNodes">
<code class="descname">FBXShaderNodes</code><em class="property"> = fbxMaterialMode.FBXShaderNodes</em><a class="headerlink" href="#hou.fbxMaterialMode.FBXShaderNodes" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.fbxMaterialMode.VopNetworks">
<code class="descname">VopNetworks</code><em class="property"> = fbxMaterialMode.VopNetworks</em><a class="headerlink" href="#hou.fbxMaterialMode.VopNetworks" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.fbxMaterialMode.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.fbxMaterialMode.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.fieldType">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">fieldType</code><a class="headerlink" href="#hou.fieldType" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Enumeration of field types.</p>
<p>VALUES</p>
<blockquote>
<div>NoSuchField
Integer
Boolean
Float
String
Vector2
Vector3
Vector4
Quaternion
Matrix3
Matrix4
UV
UVW
IntArray
FloatArray</div></blockquote>
<dl class="attribute">
<dt id="hou.fieldType.Boolean">
<code class="descname">Boolean</code><em class="property"> = fieldType.Boolean</em><a class="headerlink" href="#hou.fieldType.Boolean" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.fieldType.Float">
<code class="descname">Float</code><em class="property"> = fieldType.Float</em><a class="headerlink" href="#hou.fieldType.Float" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.fieldType.FloatArray">
<code class="descname">FloatArray</code><em class="property"> = fieldType.FloatArray</em><a class="headerlink" href="#hou.fieldType.FloatArray" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.fieldType.IntArray">
<code class="descname">IntArray</code><em class="property"> = fieldType.IntArray</em><a class="headerlink" href="#hou.fieldType.IntArray" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.fieldType.Integer">
<code class="descname">Integer</code><em class="property"> = fieldType.Integer</em><a class="headerlink" href="#hou.fieldType.Integer" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.fieldType.Matrix2">
<code class="descname">Matrix2</code><em class="property"> = fieldType.Matrix2</em><a class="headerlink" href="#hou.fieldType.Matrix2" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.fieldType.Matrix3">
<code class="descname">Matrix3</code><em class="property"> = fieldType.Matrix3</em><a class="headerlink" href="#hou.fieldType.Matrix3" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.fieldType.Matrix4">
<code class="descname">Matrix4</code><em class="property"> = fieldType.Matrix4</em><a class="headerlink" href="#hou.fieldType.Matrix4" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.fieldType.NoSuchField">
<code class="descname">NoSuchField</code><em class="property"> = fieldType.NoSuchField</em><a class="headerlink" href="#hou.fieldType.NoSuchField" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.fieldType.Quaternion">
<code class="descname">Quaternion</code><em class="property"> = fieldType.Quaternion</em><a class="headerlink" href="#hou.fieldType.Quaternion" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.fieldType.String">
<code class="descname">String</code><em class="property"> = fieldType.String</em><a class="headerlink" href="#hou.fieldType.String" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.fieldType.StringArray">
<code class="descname">StringArray</code><em class="property"> = fieldType.StringArray</em><a class="headerlink" href="#hou.fieldType.StringArray" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.fieldType.UV">
<code class="descname">UV</code><em class="property"> = fieldType.UV</em><a class="headerlink" href="#hou.fieldType.UV" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.fieldType.UVW">
<code class="descname">UVW</code><em class="property"> = fieldType.UVW</em><a class="headerlink" href="#hou.fieldType.UVW" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.fieldType.Vector2">
<code class="descname">Vector2</code><em class="property"> = fieldType.Vector2</em><a class="headerlink" href="#hou.fieldType.Vector2" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.fieldType.Vector3">
<code class="descname">Vector3</code><em class="property"> = fieldType.Vector3</em><a class="headerlink" href="#hou.fieldType.Vector3" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.fieldType.Vector4">
<code class="descname">Vector4</code><em class="property"> = fieldType.Vector4</em><a class="headerlink" href="#hou.fieldType.Vector4" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.fieldType.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.fieldType.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.fileChooserMode">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">fileChooserMode</code><a class="headerlink" href="#hou.fileChooserMode" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Enumeration of possible read/write modes for the file chooser.</p>
<p>See hou.ui.selectFile.</p>
<p>VALUES</p>
<blockquote>
<div>Read
Write
ReadAndWrite</div></blockquote>
<dl class="attribute">
<dt id="hou.fileChooserMode.Read">
<code class="descname">Read</code><em class="property"> = fileChooserMode.Read</em><a class="headerlink" href="#hou.fileChooserMode.Read" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.fileChooserMode.ReadAndWrite">
<code class="descname">ReadAndWrite</code><em class="property"> = fileChooserMode.ReadAndWrite</em><a class="headerlink" href="#hou.fileChooserMode.ReadAndWrite" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.fileChooserMode.Write">
<code class="descname">Write</code><em class="property"> = fileChooserMode.Write</em><a class="headerlink" href="#hou.fileChooserMode.Write" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.fileChooserMode.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.fileChooserMode.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.fileType">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">fileType</code><a class="headerlink" href="#hou.fileType" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Enumeration of file types.</p>
<p>VALUES</p>
<blockquote>
<div>Any
Image
Geometry
Ramp
Capture
Clip
Lut
Cmd
Midi
I3d
Chan
Sim
SimData
Hip
Otl
Dae
Gallery
Directory</div></blockquote>
<dl class="attribute">
<dt id="hou.fileType.Any">
<code class="descname">Any</code><em class="property"> = fileType.Any</em><a class="headerlink" href="#hou.fileType.Any" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.fileType.Capture">
<code class="descname">Capture</code><em class="property"> = fileType.Capture</em><a class="headerlink" href="#hou.fileType.Capture" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.fileType.Chan">
<code class="descname">Chan</code><em class="property"> = fileType.Chan</em><a class="headerlink" href="#hou.fileType.Chan" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.fileType.Clip">
<code class="descname">Clip</code><em class="property"> = fileType.Clip</em><a class="headerlink" href="#hou.fileType.Clip" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.fileType.Cmd">
<code class="descname">Cmd</code><em class="property"> = fileType.Cmd</em><a class="headerlink" href="#hou.fileType.Cmd" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.fileType.Dae">
<code class="descname">Dae</code><em class="property"> = fileType.Dae</em><a class="headerlink" href="#hou.fileType.Dae" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.fileType.Directory">
<code class="descname">Directory</code><em class="property"> = fileType.Directory</em><a class="headerlink" href="#hou.fileType.Directory" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.fileType.Gallery">
<code class="descname">Gallery</code><em class="property"> = fileType.Gallery</em><a class="headerlink" href="#hou.fileType.Gallery" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.fileType.Geometry">
<code class="descname">Geometry</code><em class="property"> = fileType.Geometry</em><a class="headerlink" href="#hou.fileType.Geometry" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.fileType.Hip">
<code class="descname">Hip</code><em class="property"> = fileType.Hip</em><a class="headerlink" href="#hou.fileType.Hip" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.fileType.I3d">
<code class="descname">I3d</code><em class="property"> = fileType.I3d</em><a class="headerlink" href="#hou.fileType.I3d" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.fileType.Image">
<code class="descname">Image</code><em class="property"> = fileType.Image</em><a class="headerlink" href="#hou.fileType.Image" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.fileType.Lut">
<code class="descname">Lut</code><em class="property"> = fileType.Lut</em><a class="headerlink" href="#hou.fileType.Lut" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.fileType.Midi">
<code class="descname">Midi</code><em class="property"> = fileType.Midi</em><a class="headerlink" href="#hou.fileType.Midi" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.fileType.Otl">
<code class="descname">Otl</code><em class="property"> = fileType.Otl</em><a class="headerlink" href="#hou.fileType.Otl" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.fileType.Ramp">
<code class="descname">Ramp</code><em class="property"> = fileType.Ramp</em><a class="headerlink" href="#hou.fileType.Ramp" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.fileType.Sim">
<code class="descname">Sim</code><em class="property"> = fileType.Sim</em><a class="headerlink" href="#hou.fileType.Sim" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.fileType.SimData">
<code class="descname">SimData</code><em class="property"> = fileType.SimData</em><a class="headerlink" href="#hou.fileType.SimData" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.fileType.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.fileType.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="hou.findDirectories">
<code class="descclassname">hou.</code><code class="descname">findDirectories</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.findDirectories" title="Permalink to this definition"></a></dt>
<dd><p>Search the Houdini path for the specified directory, returning a tuple
of all the matches. The directory name specified should be relative to
the Houdini directory.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>findDirectories(directory_name) -&gt; tuple of strings</dd>
</dl>
<p>If the directory cannot be found in the Houdini path, OperationFailed is
raised.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.findDirectory</li>
<li>hou.findFile</li>
<li>hou.findFiles</li>
<li>hou.houdiniPath</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.findDirectory">
<code class="descclassname">hou.</code><code class="descname">findDirectory</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.findDirectory" title="Permalink to this definition"></a></dt>
<dd><p>Search the Houdini path for a specified directory, returning the first
match found. The directory name specified should be relative to the
Houdini directory.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>findDirectory(directory_name) -&gt; string</dd>
</dl>
<p>If the directory cannot be found in the Houdini path, OperationFailed is
raised.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.findDirectories</li>
<li>hou.findFile</li>
<li>hou.findFiles</li>
<li>hou.houdiniPath</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.findFile">
<code class="descclassname">hou.</code><code class="descname">findFile</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.findFile" title="Permalink to this definition"></a></dt>
<dd><p>Search the Houdini path for a specified file, returning the first match
found. The filename specified should be relative to the Houdini
directory.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>findFile(file_name) -&gt; string</dd>
</dl>
<p>If the file cannot be found in the Houdini path, OperationFailed is
raised. Directories are not found, for directories use hou.findDirectory
instead.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.findFiles</li>
<li>hou.findDirectory</li>
<li>hou.findDirectories</li>
<li>hou.houdiniPath</li>
</ul>
</div></blockquote>
<p>REPLACES</p>
<blockquote>
<div><ul class="simple">
<li>findfile()</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.findFiles">
<code class="descclassname">hou.</code><code class="descname">findFiles</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.findFiles" title="Permalink to this definition"></a></dt>
<dd><p>Search the Houdini path for the specified file, returning a tuple of all
the matches. The filename specified should be relative to the Houdini
directory.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>findFiles(file_name) -&gt; tuple of strings</dd>
</dl>
<p>If the file cannot be found on the Houdini path, OperationFailed is
raised. Directories are not found, for directories use
hou.findDirectories instead.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.findFile</li>
<li>hou.findDirectory</li>
<li>hou.findDirectories</li>
<li>hou.houdiniPath</li>
</ul>
</div></blockquote>
<p>REPLACES</p>
<blockquote>
<div><ul class="simple">
<li>findfiles()</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.findFilesWithExtension">
<code class="descclassname">hou.</code><code class="descname">findFilesWithExtension</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.findFilesWithExtension" title="Permalink to this definition"></a></dt>
<dd><p>Search the Houdini path for files with a particular extension, returning
a tuple of all the matches. A subdirectory can also be optionally
provided which is appended to each entry in the Houdini path before
looking for files.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>findFilesWithExtension(file_extension, subdirectory = None) -&gt; tuple
of strings</dd>
</dl>
<p>Directories are not returned by this method.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.findFile</li>
<li>hou.findDirectory</li>
<li>hou.findDirectories</li>
<li>hou.houdiniPath</li>
</ul>
</div></blockquote>
<p>REPLACES</p>
<blockquote>
<div><ul class="simple">
<li>findfiles()</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="class">
<dt id="hou.flipbookAntialias">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">flipbookAntialias</code><a class="headerlink" href="#hou.flipbookAntialias" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Enum values for flipbook antialiasing settings.</p>
<p>See hou.FlipbookSettings.antialias.</p>
<p>VALUES</p>
<blockquote>
<div><dl class="docutils">
<dt>UseViewportSetting</dt>
<dd>Use the current viewports antialiasing setting.</dd>
<dt>Off</dt>
<dd>No antialiasing.</dd>
<dt>Fast</dt>
<dd>Fast 2-sample antialiasing.</dd>
<dt>Good</dt>
<dd>4-sample antialiasing.</dd>
<dt>HighQuality</dt>
<dd>High-quality 8-sample antialiasing.</dd>
</dl>
</div></blockquote>
<dl class="attribute">
<dt id="hou.flipbookAntialias.Fast">
<code class="descname">Fast</code><em class="property"> = flipbookAntialias.Fast</em><a class="headerlink" href="#hou.flipbookAntialias.Fast" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.flipbookAntialias.Good">
<code class="descname">Good</code><em class="property"> = flipbookAntialias.Good</em><a class="headerlink" href="#hou.flipbookAntialias.Good" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.flipbookAntialias.HighQuality">
<code class="descname">HighQuality</code><em class="property"> = flipbookAntialias.HighQuality</em><a class="headerlink" href="#hou.flipbookAntialias.HighQuality" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.flipbookAntialias.Off">
<code class="descname">Off</code><em class="property"> = flipbookAntialias.Off</em><a class="headerlink" href="#hou.flipbookAntialias.Off" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.flipbookAntialias.UseViewportSetting">
<code class="descname">UseViewportSetting</code><em class="property"> = flipbookAntialias.UseViewportSetting</em><a class="headerlink" href="#hou.flipbookAntialias.UseViewportSetting" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.flipbookAntialias.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.flipbookAntialias.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.flipbookMotionBlurBias">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">flipbookMotionBlurBias</code><a class="headerlink" href="#hou.flipbookMotionBlurBias" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Enum values used to specify the motion blur subframe range.</p>
<p>See hou.FlipbookSettings.motionBlurFrameRange.</p>
<p>VALUES</p>
<blockquote>
<div><dl class="docutils">
<dt>Centered</dt>
<dd>Subframe range is centered around the currently rendering frame.</dd>
<dt>Forward</dt>
<dd>Subframe range begins at the currently rendering frame.</dd>
<dt>Previous</dt>
<dd>Subframe range ends at the currently rendering frame.</dd>
</dl>
</div></blockquote>
<dl class="attribute">
<dt id="hou.flipbookMotionBlurBias.Centered">
<code class="descname">Centered</code><em class="property"> = flipbookMotionBlurBias.Centered</em><a class="headerlink" href="#hou.flipbookMotionBlurBias.Centered" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.flipbookMotionBlurBias.Forward">
<code class="descname">Forward</code><em class="property"> = flipbookMotionBlurBias.Forward</em><a class="headerlink" href="#hou.flipbookMotionBlurBias.Forward" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.flipbookMotionBlurBias.Previous">
<code class="descname">Previous</code><em class="property"> = flipbookMotionBlurBias.Previous</em><a class="headerlink" href="#hou.flipbookMotionBlurBias.Previous" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.flipbookMotionBlurBias.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.flipbookMotionBlurBias.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.flipbookObjectType">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">flipbookObjectType</code><a class="headerlink" href="#hou.flipbookObjectType" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Enum values for setting the flipbooks visible object types.</p>
<p>Used by FlipbookSettings.visibleTypes() to set the visible object types
when doing a flipbook.</p>
<p>VALUES</p>
<blockquote>
<div><dl class="docutils">
<dt>hou.flipbookObjectType.Visible</dt>
<dd>All object types that are currently visible will be rendered.</dd>
<dt>hou.flipbookObjectType.GeoOnly</dt>
<dd>Only geometry objects will be rendered, which excludes bone,
muscle, null, camera, light, and blend objects.</dd>
<dt>hou.flipbookObjectType.GeoExcluded</dt>
<dd>All object types other than Geometry that are currently visible
will be rendered.</dd>
<dt>hou.flipbookObjectType.AllObjects</dt>
<dd>All object types will be rendered, even if their type is not
currently visible.</dd>
</dl>
</div></blockquote>
<dl class="attribute">
<dt id="hou.flipbookObjectType.AllObjects">
<code class="descname">AllObjects</code><em class="property"> = flipbookObjectType.AllObjects</em><a class="headerlink" href="#hou.flipbookObjectType.AllObjects" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.flipbookObjectType.GeoExcluded">
<code class="descname">GeoExcluded</code><em class="property"> = flipbookObjectType.GeoExcluded</em><a class="headerlink" href="#hou.flipbookObjectType.GeoExcluded" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.flipbookObjectType.GeoOnly">
<code class="descname">GeoOnly</code><em class="property"> = flipbookObjectType.GeoOnly</em><a class="headerlink" href="#hou.flipbookObjectType.GeoOnly" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.flipbookObjectType.Visible">
<code class="descname">Visible</code><em class="property"> = flipbookObjectType.Visible</em><a class="headerlink" href="#hou.flipbookObjectType.Visible" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.flipbookObjectType.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.flipbookObjectType.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.folderType">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">folderType</code><a class="headerlink" href="#hou.folderType" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Enumeration of folder types for FolderParmTemplates.</p>
<p>See also hou.FolderParmTemplate.</p>
<p>VALUES</p>
<blockquote>
<div><dl class="docutils">
<dt>Collapsible</dt>
<dd>A folder that expands and collapses to show and hide its
contents respectively.</dd>
<dt>Simple</dt>
<dd>A simple folder for organizing parameters in the form of a group
box.</dd>
<dt>Tabs</dt>
<dd>A normal folder represented by a tab.</dd>
<dt>RadioButtons</dt>
<dd>A folder with a radio button. The open folder is the selected
radio button in the set of buttons.</dd>
<dt>MultiparmBlock</dt>
<dd>A block of multiparms. The user can add or remove instances of
this parameter block.</dd>
<dt>ScrollingMultiparmBlock</dt>
<dd>A multiparm block inside a smaller region with scroll bars.</dd>
<dt>TabbedMultiparmBlock</dt>
<dd>A multiparm block where each instance of the parameters in the
block appears in its own tab.</dd>
<dt>ImportBlock</dt>
<dd>A block containing parameters imported from another node.</dd>
</dl>
</div></blockquote>
<dl class="attribute">
<dt id="hou.folderType.Collapsible">
<code class="descname">Collapsible</code><em class="property"> = folderType.Collapsible</em><a class="headerlink" href="#hou.folderType.Collapsible" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.folderType.ImportBlock">
<code class="descname">ImportBlock</code><em class="property"> = folderType.ImportBlock</em><a class="headerlink" href="#hou.folderType.ImportBlock" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.folderType.MultiparmBlock">
<code class="descname">MultiparmBlock</code><em class="property"> = folderType.MultiparmBlock</em><a class="headerlink" href="#hou.folderType.MultiparmBlock" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.folderType.RadioButtons">
<code class="descname">RadioButtons</code><em class="property"> = folderType.RadioButtons</em><a class="headerlink" href="#hou.folderType.RadioButtons" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.folderType.ScrollingMultiparmBlock">
<code class="descname">ScrollingMultiparmBlock</code><em class="property"> = folderType.ScrollingMultiparmBlock</em><a class="headerlink" href="#hou.folderType.ScrollingMultiparmBlock" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.folderType.Simple">
<code class="descname">Simple</code><em class="property"> = folderType.Simple</em><a class="headerlink" href="#hou.folderType.Simple" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.folderType.TabbedMultiparmBlock">
<code class="descname">TabbedMultiparmBlock</code><em class="property"> = folderType.TabbedMultiparmBlock</em><a class="headerlink" href="#hou.folderType.TabbedMultiparmBlock" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.folderType.Tabs">
<code class="descname">Tabs</code><em class="property"> = folderType.Tabs</em><a class="headerlink" href="#hou.folderType.Tabs" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.folderType.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.folderType.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="hou.fps">
<code class="descclassname">hou.</code><code class="descname">fps</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.fps" title="Permalink to this definition"></a></dt>
<dd><p>Return the number of frames per second.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>fps() -&gt; float</dd>
</dl>
<p>This value is used when converting between frames and time.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.setFps</li>
<li>hou.frame</li>
<li>hou.time</li>
</ul>
</div></blockquote>
<p>REPLACES</p>
<blockquote>
<div><ul class="simple">
<li>fps</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.frame">
<code class="descclassname">hou.</code><code class="descname">frame</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.frame" title="Permalink to this definition"></a></dt>
<dd><p>Return the playbars current frame. Note that Houdini can be on a
fractional frame if fractional frames are enabled.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>frame() -&gt; float</dd>
</dl>
<p>Note that this function is equivalent to Hscripts $FF variable. If you
want hscripts $F variable, use hou.intFrame, which rounds the frame to
the nearest integer.</p>
<p>To enable fractional frames, turn off the Integer Frame Values in the
Global Animation Options dialog.</p>
<p>This function rounds its output to 3 decimal places, just like Hscripts
$FF variable does. Note, though, that because a Python float may not be
able to precisely represent a floating point value, and because Python
does not round numbers when it displays them, the frame number might end
with 9999999999999 or 0000000000001 when you print it to the Python
shell. When you convert the number to a string, though, Python will
round the value, so it will contain at most 3 decimal places.</p>
<p>&gt; &gt;&gt;&gt; 2.759
&gt; 2.7589999999999999
&gt; &gt;&gt;&gt; 2.757
&gt; 2.7570000000000001
&gt; &gt;&gt;&gt; str(2.759)
&gt; 2.759</p>
<p>If Houdini is on a fractional frame and you do not want the rounded
value, use hou.timeToFrame(hou.time()).</p>
<p>&gt; &gt;&gt;&gt; hou.setFrame(13.193)
&gt; &gt;&gt;&gt; hou.frame()
&gt; 13.193
&gt; &gt;&gt;&gt; hou.timeToFrame(hou.time())
&gt; 13.192999839782715
&gt; &gt;&gt;&gt; hou.setFrame(2.759)
&gt; &gt;&gt;&gt; hou.frame()
&gt; 2.7589999999999999
&gt; &gt;&gt;&gt; int(hou.frame())
&gt; 2
&gt; &gt;&gt;&gt; hou.intFrame()
&gt; 3</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.intFrame</li>
<li>hou.setFrame</li>
<li>hou.time</li>
<li>hou.fps</li>
</ul>
</div></blockquote>
<p>REPLACES</p>
<blockquote>
<div><ul class="simple">
<li>fcur</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.frameToTime">
<code class="descclassname">hou.</code><code class="descname">frameToTime</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.frameToTime" title="Permalink to this definition"></a></dt>
<dd><p>Convert from a given frame value to a time value.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>frameToTime(frame) -&gt; float</dd>
</dl>
<p>Calling this function is the same as evaluating (frame - 1.0) /
hou.fps(). Unlike hou.timeToFrame(), no rounding is performed.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.fps</li>
<li>hou.time</li>
<li>hou.frame</li>
</ul>
</div></blockquote>
<p>REPLACES</p>
<blockquote>
<div><ul class="simple">
<li>fps</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="class">
<dt id="hou.geometryType">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">geometryType</code><a class="headerlink" href="#hou.geometryType" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Enumeration of geometry component types.</p>
<p>VALUES</p>
<blockquote>
<div>Points
Vertices
Edges
Breakpoints
Primitives</div></blockquote>
<dl class="attribute">
<dt id="hou.geometryType.Breakpoints">
<code class="descname">Breakpoints</code><em class="property"> = geometryType.Breakpoints</em><a class="headerlink" href="#hou.geometryType.Breakpoints" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.geometryType.Edges">
<code class="descname">Edges</code><em class="property"> = geometryType.Edges</em><a class="headerlink" href="#hou.geometryType.Edges" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.geometryType.Points">
<code class="descname">Points</code><em class="property"> = geometryType.Points</em><a class="headerlink" href="#hou.geometryType.Points" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.geometryType.Primitives">
<code class="descname">Primitives</code><em class="property"> = geometryType.Primitives</em><a class="headerlink" href="#hou.geometryType.Primitives" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.geometryType.Vertices">
<code class="descname">Vertices</code><em class="property"> = geometryType.Vertices</em><a class="headerlink" href="#hou.geometryType.Vertices" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.geometryType.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.geometryType.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.geometryViewportEvent">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">geometryViewportEvent</code><a class="headerlink" href="#hou.geometryViewportEvent" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Enumeration of the geometry viewport events that can be handled by
callback functions.</p>
<p>See hou.GeometryViewport.addEventCallback.</p>
<p>VALUES</p>
<blockquote>
<div><dl class="docutils">
<dt>CameraSwitched</dt>
<dd>This event is triggered when the viewport camera has been
switched to a different one.</dd>
</dl>
</div></blockquote>
<dl class="attribute">
<dt id="hou.geometryViewportEvent.CameraSwitched">
<code class="descname">CameraSwitched</code><em class="property"> = geometryViewportEvent.CameraSwitched</em><a class="headerlink" href="#hou.geometryViewportEvent.CameraSwitched" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.geometryViewportEvent.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.geometryViewportEvent.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.geometryViewportLayout">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">geometryViewportLayout</code><a class="headerlink" href="#hou.geometryViewportLayout" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Enumeration of viewport layouts.</p>
<p>&gt; # Get a reference to the 3D viewer pane tab
&gt; desktop = hou.ui.curDesktop()
&gt; viewer = desktop.paneTabOfType(hou.paneTabType.SceneViewer)
&gt; 
&gt; # Get the current layout
&gt; current_layout = viewer.viewportLayout()
&gt; # Change the layout to quad view
&gt; viewer.setViewportLayout(hou.geometryViewportLayout.)</p>
<p>See the viewport methods on the SceneViewer object.</p>
<p>VALUES</p>
<blockquote>
<div><p>DoubleSide</p>
<p>DoubleStack</p>
<p>Quad</p>
<p>QuadBottomSplit</p>
<p>QuadLeftSplit</p>
<p>Single</p>
<p>TripleBottomSplit</p>
<p>TripleLeftSplit</p>
</div></blockquote>
<dl class="attribute">
<dt id="hou.geometryViewportLayout.DoubleSide">
<code class="descname">DoubleSide</code><em class="property"> = geometryViewportLayout.DoubleSide</em><a class="headerlink" href="#hou.geometryViewportLayout.DoubleSide" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.geometryViewportLayout.DoubleStack">
<code class="descname">DoubleStack</code><em class="property"> = geometryViewportLayout.DoubleStack</em><a class="headerlink" href="#hou.geometryViewportLayout.DoubleStack" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.geometryViewportLayout.Quad">
<code class="descname">Quad</code><em class="property"> = geometryViewportLayout.Quad</em><a class="headerlink" href="#hou.geometryViewportLayout.Quad" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.geometryViewportLayout.QuadBottomSplit">
<code class="descname">QuadBottomSplit</code><em class="property"> = geometryViewportLayout.QuadBottomSplit</em><a class="headerlink" href="#hou.geometryViewportLayout.QuadBottomSplit" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.geometryViewportLayout.QuadLeftSplit">
<code class="descname">QuadLeftSplit</code><em class="property"> = geometryViewportLayout.QuadLeftSplit</em><a class="headerlink" href="#hou.geometryViewportLayout.QuadLeftSplit" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.geometryViewportLayout.Single">
<code class="descname">Single</code><em class="property"> = geometryViewportLayout.Single</em><a class="headerlink" href="#hou.geometryViewportLayout.Single" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.geometryViewportLayout.TripleBottomSplit">
<code class="descname">TripleBottomSplit</code><em class="property"> = geometryViewportLayout.TripleBottomSplit</em><a class="headerlink" href="#hou.geometryViewportLayout.TripleBottomSplit" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.geometryViewportLayout.TripleLeftSplit">
<code class="descname">TripleLeftSplit</code><em class="property"> = geometryViewportLayout.TripleLeftSplit</em><a class="headerlink" href="#hou.geometryViewportLayout.TripleLeftSplit" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.geometryViewportLayout.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.geometryViewportLayout.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.geometryViewportType">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">geometryViewportType</code><a class="headerlink" href="#hou.geometryViewportType" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Enumeration of scene viewer viewport types.</p>
<p>VALUES</p>
<blockquote>
<div>Perspective
Top
Bottom
Front
Back
Right
Left
UV</div></blockquote>
<dl class="attribute">
<dt id="hou.geometryViewportType.Back">
<code class="descname">Back</code><em class="property"> = geometryViewportType.Back</em><a class="headerlink" href="#hou.geometryViewportType.Back" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.geometryViewportType.Bottom">
<code class="descname">Bottom</code><em class="property"> = geometryViewportType.Bottom</em><a class="headerlink" href="#hou.geometryViewportType.Bottom" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.geometryViewportType.Front">
<code class="descname">Front</code><em class="property"> = geometryViewportType.Front</em><a class="headerlink" href="#hou.geometryViewportType.Front" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.geometryViewportType.Left">
<code class="descname">Left</code><em class="property"> = geometryViewportType.Left</em><a class="headerlink" href="#hou.geometryViewportType.Left" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.geometryViewportType.Perspective">
<code class="descname">Perspective</code><em class="property"> = geometryViewportType.Perspective</em><a class="headerlink" href="#hou.geometryViewportType.Perspective" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.geometryViewportType.Right">
<code class="descname">Right</code><em class="property"> = geometryViewportType.Right</em><a class="headerlink" href="#hou.geometryViewportType.Right" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.geometryViewportType.Top">
<code class="descname">Top</code><em class="property"> = geometryViewportType.Top</em><a class="headerlink" href="#hou.geometryViewportType.Top" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.geometryViewportType.UV">
<code class="descname">UV</code><em class="property"> = geometryViewportType.UV</em><a class="headerlink" href="#hou.geometryViewportType.UV" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.geometryViewportType.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.geometryViewportType.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="hou.getPreference">
<code class="descclassname">hou.</code><code class="descname">getPreference</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.getPreference" title="Permalink to this definition"></a></dt>
<dd><p>Return a preference value.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>getPreference(name) -&gt; string</dd>
</dl>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.getPreferenceNames</li>
<li>hou.setPreference</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.getPreferenceNames">
<code class="descclassname">hou.</code><code class="descname">getPreferenceNames</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.getPreferenceNames" title="Permalink to this definition"></a></dt>
<dd><p>Return all the preference names.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>getPreferenceNames() -&gt; tuple of strings</dd>
</dl>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.getPreference</li>
<li>hou.setPreference</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.getenv">
<code class="descclassname">hou.</code><code class="descname">getenv</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.getenv" title="Permalink to this definition"></a></dt>
<dd><p>Return the value of the specified Houdini environment variable.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>getenv(name, default_value=None) -&gt; str</dd>
</dl>
<p>Return the value of the specified Houdini environment variable. Return
default_value if the environment variable does not exist.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.putenv</li>
<li>hou.unsetenv</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="class">
<dt id="hou.glShadingType">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">glShadingType</code><a class="headerlink" href="#hou.glShadingType" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Enum for viewport shading modes</p>
<p>VALUES</p>
<blockquote>
<div><dl class="docutils">
<dt>hou.glShadingType.WireBoundingBox</dt>
<dd>Objects displayed as wireframe bounding boxes.</dd>
<dt>hou.glShadingType.ShadedBoundingBox</dt>
<dd>Objects displayed as solid bounding boxes.</dd>
<dt>hou.glShadingType.Wire</dt>
<dd>Geometry displayed as regular wireframe.</dd>
<dt>hou.glShadingType.WireGhost</dt>
<dd>Geometry displayed as wireframe with occluded wires dimmed.</dd>
<dt>hou.glShadingType.HiddenLineGhost</dt>
<dd>Geometry displayed as wireframe with constant filled polygons.</dd>
<dt>hou.glShadingType.HiddenLineInvisible</dt>
<dd>Geometry displayed as wireframe hidden occluded wires.</dd>
<dt>hou.glShadingType.Flat</dt>
<dd>Geometry displayed as lit, but with flat shaded polygons.</dd>
<dt>hou.glShadingType.FlatWire</dt>
<dd>Geometry displayed as lit, but with flat shaded, outlined
polygons.</dd>
<dt>hou.glShadingType.Smooth</dt>
<dd>Geometry displayed as shaded and lit.</dd>
<dt>hou.glShadingType.SmoothWire</dt>
<dd>Geometry displayed as shaded and lit with outlined polygons.</dd>
</dl>
</div></blockquote>
<dl class="attribute">
<dt id="hou.glShadingType.Flat">
<code class="descname">Flat</code><em class="property"> = glShadingType.Flat</em><a class="headerlink" href="#hou.glShadingType.Flat" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.glShadingType.FlatWire">
<code class="descname">FlatWire</code><em class="property"> = glShadingType.FlatWire</em><a class="headerlink" href="#hou.glShadingType.FlatWire" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.glShadingType.HiddenLineGhost">
<code class="descname">HiddenLineGhost</code><em class="property"> = glShadingType.HiddenLineGhost</em><a class="headerlink" href="#hou.glShadingType.HiddenLineGhost" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.glShadingType.HiddenLineInvisible">
<code class="descname">HiddenLineInvisible</code><em class="property"> = glShadingType.HiddenLineInvisible</em><a class="headerlink" href="#hou.glShadingType.HiddenLineInvisible" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.glShadingType.ShadedBoundingBox">
<code class="descname">ShadedBoundingBox</code><em class="property"> = glShadingType.ShadedBoundingBox</em><a class="headerlink" href="#hou.glShadingType.ShadedBoundingBox" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.glShadingType.Smooth">
<code class="descname">Smooth</code><em class="property"> = glShadingType.Smooth</em><a class="headerlink" href="#hou.glShadingType.Smooth" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.glShadingType.SmoothWire">
<code class="descname">SmoothWire</code><em class="property"> = glShadingType.SmoothWire</em><a class="headerlink" href="#hou.glShadingType.SmoothWire" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.glShadingType.Wire">
<code class="descname">Wire</code><em class="property"> = glShadingType.Wire</em><a class="headerlink" href="#hou.glShadingType.Wire" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.glShadingType.WireBoundingBox">
<code class="descname">WireBoundingBox</code><em class="property"> = glShadingType.WireBoundingBox</em><a class="headerlink" href="#hou.glShadingType.WireBoundingBox" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.glShadingType.WireGhost">
<code class="descname">WireGhost</code><em class="property"> = glShadingType.WireGhost</em><a class="headerlink" href="#hou.glShadingType.WireGhost" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.glShadingType.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.glShadingType.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.groupListType">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">groupListType</code><a class="headerlink" href="#hou.groupListType" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Enumeration of group list types.</p>
<p>VALUES</p>
<blockquote>
<div>Points
Vertices
Edges
Breakpoints
Primitives
MatchPickType</div></blockquote>
<dl class="attribute">
<dt id="hou.groupListType.Breakpoints">
<code class="descname">Breakpoints</code><em class="property"> = groupListType.Breakpoints</em><a class="headerlink" href="#hou.groupListType.Breakpoints" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.groupListType.Edges">
<code class="descname">Edges</code><em class="property"> = groupListType.Edges</em><a class="headerlink" href="#hou.groupListType.Edges" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.groupListType.MatchPickType">
<code class="descname">MatchPickType</code><em class="property"> = groupListType.MatchPickType</em><a class="headerlink" href="#hou.groupListType.MatchPickType" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.groupListType.Points">
<code class="descname">Points</code><em class="property"> = groupListType.Points</em><a class="headerlink" href="#hou.groupListType.Points" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.groupListType.Primitives">
<code class="descname">Primitives</code><em class="property"> = groupListType.Primitives</em><a class="headerlink" href="#hou.groupListType.Primitives" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.groupListType.Vertices">
<code class="descname">Vertices</code><em class="property"> = groupListType.Vertices</em><a class="headerlink" href="#hou.groupListType.Vertices" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.groupListType.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.groupListType.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.handleOrientToNormalAxis">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">handleOrientToNormalAxis</code><a class="headerlink" href="#hou.handleOrientToNormalAxis" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Enumeration of handle axes that can be aligned to a geometry normal.</p>
<p>See hou.ui.handleOrientToNormalAxis for more information.</p>
<p>VALUES</p>
<blockquote>
<div>Y
Z</div></blockquote>
<dl class="attribute">
<dt id="hou.handleOrientToNormalAxis.Y">
<code class="descname">Y</code><em class="property"> = handleOrientToNormalAxis.Y</em><a class="headerlink" href="#hou.handleOrientToNormalAxis.Y" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.handleOrientToNormalAxis.Z">
<code class="descname">Z</code><em class="property"> = handleOrientToNormalAxis.Z</em><a class="headerlink" href="#hou.handleOrientToNormalAxis.Z" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.handleOrientToNormalAxis.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.handleOrientToNormalAxis.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="hou.hasContextOption">
<code class="descclassname">hou.</code><code class="descname">hasContextOption</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.hasContextOption" title="Permalink to this definition"></a></dt>
<dd><p>Returns True if the specified option exists in the current cook context.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>hasContextOption(option) -&gt; bool</dd>
</dl>
<p>This method tests for options that may have been set by a node
requesting data from another node, or that are set in the default cook
context options stored with the hip file.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.contextOption</li>
<li>hou.contextOptionNames</li>
<li>hou.setDefaultContextOption</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.hdaDefinition">
<code class="descclassname">hou.</code><code class="descname">hdaDefinition</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.hdaDefinition" title="Permalink to this definition"></a></dt>
<dd><p>Given a node type category, operator name and digital asset library
path, return an HDADefinition object. Return None if no such digital
asset definition matches the arguments.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>hdaDefinition(node_type_category, name, lib_path) -&gt; hou.HDADefinition
or None</dd>
</dl>
<p>Be careful not to confuse this function with the class
hou.HDADefinition.</p>
<p>Example:</p>
<p>&gt; # Return the HDA definition for a SOP digital asset named foo
&gt; # that is located in the /tmp/bar.hda library.
&gt; hou.hdaDefinition(hou.sopNodeTypeCategory(), foo, /tmp/bar.hda)</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.hda</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="class">
<dt id="hou.hdaEventType">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">hdaEventType</code><a class="headerlink" href="#hou.hdaEventType" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Enumeration of types of events that can happen for digital asset
libraries.</p>
<p>See hou.hda.addEventCallback.</p>
<dl class="docutils">
<dt>NOTE</dt>
<dd>The AssetCreated and AssetDeleted events do not fire when a library
file is installed or uninstalled.</dd>
</dl>
<p>VALUES</p>
<blockquote>
<div><dl class="docutils">
<dt>AssetCreated</dt>
<dd><p class="first">A new asset was created (using the Create Digital Asset context
menu item in the network editor or through HOM).</p>
<p>The callback function is called with this event type and the
following additional argument:</p>
<dl class="last docutils">
<dt>asset_definition</dt>
<dd>An hou.HDADefinition object representing the newly created
asset.</dd>
</dl>
</dd>
<dt>AssetDeleted</dt>
<dd><p class="first">An asset was deleted (using the Asset Manager UI or through
HOM). Note that the asset no longer exists by the time the
function is called.</p>
<p>The callback function is called with this event type and the
following additional arguments:</p>
<dl class="last docutils">
<dt>asset_name</dt>
<dd>A string containing the name of the deleted asset.</dd>
<dt>library_path</dt>
<dd>A string containing the file path of the asset library
(.hda) file that contained the asset.</dd>
<dt>node_type_category</dt>
<dd>A hou.NodeTypeCategory representing the type category (for
example, Object, SOP, DOP) of the deleted asset.</dd>
</dl>
</dd>
<dt>AssetSaved</dt>
<dd><p class="first">An asset was saved.</p>
<p>The callback function is called with this event type and the
following additional argument:</p>
<dl class="last docutils">
<dt>asset_definition</dt>
<dd>An hou.HDADefinition object representing the saved asset.</dd>
</dl>
</dd>
<dt>LibraryInstalled</dt>
<dd><p class="first">A digital asset library has been installed into the current
Houdini session.</p>
<p>The callback function is called with this event type and the
following additional argument:</p>
<dl class="last docutils">
<dt>library_path</dt>
<dd>The file path to the installed asset library (.hda) file.</dd>
</dl>
</dd>
<dt>LibraryUninstalled</dt>
<dd><p class="first">A digital asset library has been uninstalled from the current
Houdini session.</p>
<p>The callback function is called with this event type and the
following additional argument:</p>
<dl class="last docutils">
<dt>library_path</dt>
<dd>The file path to the uninstalled asset library (.hda) file.</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<dl class="attribute">
<dt id="hou.hdaEventType.AssetCreated">
<code class="descname">AssetCreated</code><em class="property"> = hdaEventType.AssetCreated</em><a class="headerlink" href="#hou.hdaEventType.AssetCreated" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.hdaEventType.AssetDeleted">
<code class="descname">AssetDeleted</code><em class="property"> = hdaEventType.AssetDeleted</em><a class="headerlink" href="#hou.hdaEventType.AssetDeleted" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.hdaEventType.AssetSaved">
<code class="descname">AssetSaved</code><em class="property"> = hdaEventType.AssetSaved</em><a class="headerlink" href="#hou.hdaEventType.AssetSaved" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.hdaEventType.LibraryInstalled">
<code class="descname">LibraryInstalled</code><em class="property"> = hdaEventType.LibraryInstalled</em><a class="headerlink" href="#hou.hdaEventType.LibraryInstalled" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.hdaEventType.LibraryUninstalled">
<code class="descname">LibraryUninstalled</code><em class="property"> = hdaEventType.LibraryUninstalled</em><a class="headerlink" href="#hou.hdaEventType.LibraryUninstalled" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.hdaEventType.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.hdaEventType.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.hdaLicenseType">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">hdaLicenseType</code><a class="headerlink" href="#hou.hdaLicenseType" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Enumeration of digital asset license permission levels.</p>
<p>VALUES</p>
<blockquote>
<div>Execute
Read
Full</div></blockquote>
<dl class="attribute">
<dt id="hou.hdaLicenseType.Execute">
<code class="descname">Execute</code><em class="property"> = hdaLicenseType.Execute</em><a class="headerlink" href="#hou.hdaLicenseType.Execute" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.hdaLicenseType.Full">
<code class="descname">Full</code><em class="property"> = hdaLicenseType.Full</em><a class="headerlink" href="#hou.hdaLicenseType.Full" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.hdaLicenseType.Read">
<code class="descname">Read</code><em class="property"> = hdaLicenseType.Read</em><a class="headerlink" href="#hou.hdaLicenseType.Read" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.hdaLicenseType.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.hdaLicenseType.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="hou.helpServerUrl">
<code class="descclassname">hou.</code><code class="descname">helpServerUrl</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.helpServerUrl" title="Permalink to this definition"></a></dt>
<dd><p>Return the base URL for all Houdini help pages.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>helpServerUrl() -&gt; string</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="hou.hipFileEventType">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">hipFileEventType</code><a class="headerlink" href="#hou.hipFileEventType" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Enumeration of the hip file event types that can be handled by callback
functions.</p>
<p>See hou.hipFile.addEventCallback.</p>
<p>VALUES</p>
<blockquote>
<div><dl class="docutils">
<dt>BeforeClear</dt>
<dd>This event is triggered immediately before the current .hip file
is cleared. For example, when selecting File -&gt; New in the main
menu bar.</dd>
<dt>AfterClear</dt>
<dd>This event is triggered immediately after the current .hip file
is cleared. For example, when selecting File -&gt; New in the main
menu bar.</dd>
<dt>BeforeLoad</dt>
<dd>This event is triggered immediately before a .hip file is loaded
into Houdini.</dd>
<dt>AfterLoad</dt>
<dd>This event is triggered immediately after a .hip file is loaded
into Houdini.</dd>
<dt>BeforeMerge</dt>
<dd>This event is triggered immediately before a .hip file is merged
into the current Houdini session.</dd>
<dt>AfterMerge</dt>
<dd>This event is triggered immediately after a .hip file is merged
into the current Houdini session.</dd>
<dt>BeforeSave</dt>
<dd>This event is triggered immediately before the current .hip file
is saved.</dd>
<dt>AfterSave</dt>
<dd>This event is triggered immediately after the current .hip file
is saved.</dd>
</dl>
</div></blockquote>
<dl class="attribute">
<dt id="hou.hipFileEventType.AfterClear">
<code class="descname">AfterClear</code><em class="property"> = hipFileEventType.AfterClear</em><a class="headerlink" href="#hou.hipFileEventType.AfterClear" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.hipFileEventType.AfterLoad">
<code class="descname">AfterLoad</code><em class="property"> = hipFileEventType.AfterLoad</em><a class="headerlink" href="#hou.hipFileEventType.AfterLoad" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.hipFileEventType.AfterMerge">
<code class="descname">AfterMerge</code><em class="property"> = hipFileEventType.AfterMerge</em><a class="headerlink" href="#hou.hipFileEventType.AfterMerge" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.hipFileEventType.AfterSave">
<code class="descname">AfterSave</code><em class="property"> = hipFileEventType.AfterSave</em><a class="headerlink" href="#hou.hipFileEventType.AfterSave" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.hipFileEventType.BeforeClear">
<code class="descname">BeforeClear</code><em class="property"> = hipFileEventType.BeforeClear</em><a class="headerlink" href="#hou.hipFileEventType.BeforeClear" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.hipFileEventType.BeforeLoad">
<code class="descname">BeforeLoad</code><em class="property"> = hipFileEventType.BeforeLoad</em><a class="headerlink" href="#hou.hipFileEventType.BeforeLoad" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.hipFileEventType.BeforeMerge">
<code class="descname">BeforeMerge</code><em class="property"> = hipFileEventType.BeforeMerge</em><a class="headerlink" href="#hou.hipFileEventType.BeforeMerge" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.hipFileEventType.BeforeSave">
<code class="descname">BeforeSave</code><em class="property"> = hipFileEventType.BeforeSave</em><a class="headerlink" href="#hou.hipFileEventType.BeforeSave" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.hipFileEventType.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.hipFileEventType.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="hou.homeHoudiniDirectory">
<code class="descclassname">hou.</code><code class="descname">homeHoudiniDirectory</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.homeHoudiniDirectory" title="Permalink to this definition"></a></dt>
<dd><p>Return the path to the Houdini directory in your $HOME directory.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>homeHoudiniDirectory() -&gt; str</dd>
</dl>
<p>Return the directory in your $HOME directory where Houdini stores user-
specific settings. On many platforms, this directory is
$HOME/houdiniX.Y, where X is the Houdini major version and Y is the
minor version. Note that on the Mac, though, this directory might be in
a different location.</p>
<p>See hou.houdiniPath for more information about how Houdini searches for
files.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.houdiniPath</li>
<li>hou.applicationVersion</li>
<li>hou.findFile</li>
<li>hou.findFiles</li>
<li>hou.findDirectory</li>
<li>hou.findDirectories</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.houdiniPath">
<code class="descclassname">hou.</code><code class="descname">houdiniPath</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.houdiniPath" title="Permalink to this definition"></a></dt>
<dd><p>Return the contents of the Houdini path as a tuple of strings.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>houdiniPath(path_variable = None) -&gt; tuple of strings</dd>
</dl>
<p>This method returns an ordered list of path components of the Houdini
Path. The Houdini Path is used when searching for various files like
otls, shelf tools, preferences, desktops, icons, etc. By adjusting the
HOUDINI_PATH environment variable, you can add entries to the path that
are specific to the current user, job, or studio.</p>
<p>By default the components of the HOUDINI_PATH variable are returned. If
the path_variable passed in refers to another well-known Houdini path,
the components of that search path are returned instead. For example
houdiniPath(HOUDINI_OTLSCAN_PATH)</p>
<p>See the output of hconfig -ap for more information on the current paths
and their values.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.findFile</li>
<li>hou.findFiles</li>
<li>hou.findDirectory</li>
<li>hou.findDirectories</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.hscript">
<code class="descclassname">hou.</code><code class="descname">hscript</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.hscript" title="Permalink to this definition"></a></dt>
<dd><p>Executes the given hscript command and returns a 2-tuple of strings
where the first string contains the regular output of the executed
command and the second string contains the error output. You can specify
multiple commands by using ; or the newline character as the
separator.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>hscript(command) -&gt; tuple of strings</dd>
</dl>
<p>REPLACES</p>
<blockquote>
<div><ul class="simple">
<li>execute()</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.hscriptCommandHelp">
<code class="descclassname">hou.</code><code class="descname">hscriptCommandHelp</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.hscriptCommandHelp" title="Permalink to this definition"></a></dt>
<dd><p>Return the text help of an hscript command. This function is used to
help re-implement hscript commands in Python.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>hscriptCommandHelp(command_name) -&gt; string</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="hou.hscriptExpandString">
<code class="descclassname">hou.</code><code class="descname">hscriptExpandString</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.hscriptExpandString" title="Permalink to this definition"></a></dt>
<dd><p>Deprecated: Use expandString.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>hscriptExpandString(str) -&gt; string</dd>
<dt>WARNING</dt>
<dd>This is deprecated. Use hou.expandString instead.</dd>
</dl>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.expandString</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.hscriptExpression">
<code class="descclassname">hou.</code><code class="descname">hscriptExpression</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.hscriptExpression" title="Permalink to this definition"></a></dt>
<dd><p>Evaluate an Hscript expression.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>hscriptExpression(expression_string) -&gt; float, str, or tuple</dd>
</dl>
<p>Given an expression string, this function evaluates it as though it was
an HScript expression on a parameter. The return type depends on the
expression.</p>
<p>Raises hou.OperationFailed if the expression is invalid or generates an
error occur during evaluation.</p>
<p>&gt; &gt;&gt;&gt; hou.hscriptExpression($HIP)
&gt; /path/to/hip/directory
&gt; &gt;&gt;&gt; hou.hscriptExpression($F)
&gt; 1.0
&gt; &gt;&gt;&gt; hou.hscriptExpression(vector([1, 2, 3]))
&gt; (1.0, 2.0, 3.0)
&gt; &gt;&gt;&gt; hou.hscriptExpression(matrix([[1, 2][3, 4]]))
&gt; ((1.0, 2.0), (3.0, 4.0))
&gt; &gt;&gt;&gt; hou.hscriptExpression(hello)
&gt; hello
&gt; &gt;&gt;&gt; hou.hscriptExpression(hello)
&gt; hello
&gt; &gt;&gt;&gt; hou.hscriptExpression(hello +  world)
&gt; hello world
&gt; &gt;&gt;&gt; hou.hscriptExpression($F)
&gt; 1
&gt; &gt;&gt;&gt; hou.hscriptExpression($F)
&gt; $F</p>
<p>This function is somewhat similar to hou.expandString, however,
expandString will replace the portions of the string containing
variables, leaving the rest of the string unchanged. If the variable is
unknown, it will not do any expansion.</p>
<p>&gt; &gt;&gt;&gt; hou.expandString($HOME)
&gt; /home/me
&gt; &gt;&gt;&gt; hou.expandString(HOME is $HOME)
&gt; HOME is /home/me
&gt; &gt;&gt;&gt; hou.hscriptExpression(HOME is $HOME)
&gt; Traceback (most recent call last):
&gt;   File &lt;console&gt;, line 1, in &lt;module&gt;
&gt;   File /opt/hfs10.5/houdini/python2.5libs/hou.py, line 19331, in hscriptExpression
&gt;     return _hou.hscriptExpression(<a href="#id33"><span class="problematic" id="id34">*</span></a>args)
&gt; OperationFailed: The attempted operation failed.
&gt; Syntax error - extra tokens detected in expression
&gt; &gt;&gt;&gt; hou.expandString($F)
&gt; 1
&gt; &gt;&gt;&gt; hou.expandString($F)
&gt; 1
&gt; &gt;&gt;&gt; hou.hscriptExpression($GARBAGE)
&gt; Traceback (most recent call last):
&gt;   File &lt;console&gt;, line 1, in &lt;module&gt;
&gt;   File /opt/hfs10.5/houdini/python2.5libs/hou.py, line 19331, in hscriptExpression
&gt;     return _hou.hscriptExpression(<a href="#id35"><span class="problematic" id="id36">*</span></a>args)
&gt; OperationFailed: The attempted operation failed.
&gt; Undefined variable
&gt; &gt;&gt;&gt; hou.expandString($GARBAGE)
&gt; $GARBAGE
&gt; &gt;&gt;&gt; hou.hscript(echo -n $GARBAGE)[0]
&gt; 
&gt; &gt;&gt;&gt; hou.expandString()
&gt; 
&gt; &gt;&gt;&gt; hou.hscriptExpression()
&gt; Traceback (most recent call last):
&gt;   File &lt;console&gt;, line 1, in &lt;module&gt;
&gt;   File /opt/hfs10.5/houdini/python2.5libs/hou.py, line 19331, in hscriptExpression
&gt;     return _hou.hscriptExpression(<a href="#id37"><span class="problematic" id="id38">*</span></a>args)
&gt; OperationFailed: The attempted operation failed.
&gt; Invalid expression</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.hscriptFloatExpression</li>
<li>hou.hscriptStringExpression</li>
<li>hou.hscriptVectorExpression</li>
<li>hou.hscriptMatrixExpression</li>
<li>hou.expandString</li>
<li>hou.expandStringAtFrame</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.hscriptFloatExpression">
<code class="descclassname">hou.</code><code class="descname">hscriptFloatExpression</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.hscriptFloatExpression" title="Permalink to this definition"></a></dt>
<dd><p>Evaluate an Hscript expression as a float.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>hscriptFloatExpression(expression) -&gt; float</dd>
</dl>
<p>This function will force the return type to be a float.</p>
<p>Most of the time, you want to use hou.hscriptExpression over this
function. See it for more examples.</p>
<p>Raises hou.OperationFailed if the expression is invalid or generates an
error occur during evaluation.</p>
<p>If the expression contains variables, Houdini will attempt to evaluate
them as floats, and use the value 0.0 if they cannot be converted to
floats. However, if the expression definitely evaluates to a string that
does not start with a number, this function raises hou.OperationFailed.</p>
<p>&gt; &gt;&gt;&gt; hou.hscriptFloatExpression(3)
&gt; 3.0
&gt; &gt;&gt;&gt; hou.hscriptFloatExpression(3)
&gt; 3.0
&gt; &gt;&gt;&gt; hou.hscriptFloatExpression(3X)
&gt; 3.0
&gt; &gt;&gt;&gt; hou.hscriptFloatExpression(X3)
&gt; Traceback (most recent call last):
&gt;   File &lt;console&gt;, line 1, in &lt;module&gt;
&gt;   File /opt/hfs10.5/houdini/python2.5libs/hou.py, line 9359, in hscriptFloatExpression
&gt;     return _hou.hscriptFloatExpression(<a href="#id39"><span class="problematic" id="id40">*</span></a>args)
&gt; OperationFailed: The attempted operation failed.
&gt; Bad data type for function or operation
&gt; &gt;&gt;&gt; hou.hscriptFloatExpression(3X)
&gt; Traceback (most recent call last):
&gt;   File &lt;console&gt;, line 1, in &lt;module&gt;
&gt;   File /opt/hfs10.5/houdini/python2.5libs/hou.py, line 9359, in hscriptFloatExpression
&gt;     return _hou.hscriptFloatExpression(<a href="#id41"><span class="problematic" id="id42">*</span></a>args)
&gt; OperationFailed: The attempted operation failed.
&gt; Syntax error - extra tokens detected in expression
&gt; &gt;&gt;&gt; hou.hscriptFloatExpression($F)
&gt; 1.0
&gt; &gt;&gt;&gt; hou.hscriptFloatExpression($F)
&gt; 1.0
&gt; &gt;&gt;&gt; hou.hscriptFloatExpression($HOME)
&gt; 0.0
&gt; &gt;&gt;&gt; hou.hscriptFloatExpression($HOME)
&gt; Traceback (most recent call last):
&gt;   File &lt;console&gt;, line 1, in &lt;module&gt;
&gt;   File /opt/hfs10.5/houdini/python2.5libs/hou.py, line 9359, in hscriptFloatExpression
&gt;     return _hou.hscriptFloatExpression(<a href="#id43"><span class="problematic" id="id44">*</span></a>args)
&gt; OperationFailed: The attempted operation failed.
&gt; Bad data type for function or operation
&gt; &gt;&gt;&gt; hou.hscriptFloatExpression($F)
&gt; Traceback (most recent call last):
&gt;   File &lt;console&gt;, line 1, in &lt;module&gt;
&gt;   File /opt/hfs10.5/houdini/python2.5libs/hou.py, line 9359, in hscriptFloatExpression
&gt;     return _hou.hscriptFloatExpression(<a href="#id45"><span class="problematic" id="id46">*</span></a>args)
&gt; OperationFailed: The attempted operation failed.
&gt; Bad data type for function or operation</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.hscriptExpression</li>
<li>hou.hscriptStringExpression</li>
<li>hou.hscriptVectorExpression</li>
<li>hou.hscriptMatrixExpression</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.hscriptMatrixExpression">
<code class="descclassname">hou.</code><code class="descname">hscriptMatrixExpression</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.hscriptMatrixExpression" title="Permalink to this definition"></a></dt>
<dd><p>Evaluate an Hscript expression as a vector.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>hscriptMatrixExpression(expression) -&gt; tuple of tuple of floats</dd>
</dl>
<p>This function will force the return type to be an Hscript matrix.
Because Hscript matrices can be be of different sizes, the value is
returned as a tuple of tuples of floats. If you know the matrix is a
particular size, you can construct a Matrix3/Matrix4 out of the return
value.</p>
<p>Most of the time, you want to use hou.hscriptExpression over this
function.</p>
<p>&gt; xform = hou.Matrix4(hou.hscriptMatrixExpression(doptransform(/obj/dopnet1, obj0, Geometry)))</p>
<p>Raises hou.OperationFailed if the expression is invalid or generates an
error during evaluation.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.hscriptExpression</li>
<li>hou.hscriptFloatExpression</li>
<li>hou.hscriptStringExpression</li>
<li>hou.hscriptVectorExpression</li>
<li>hou.Matrix3</li>
<li>hou.Matrix4</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.hscriptStringExpression">
<code class="descclassname">hou.</code><code class="descname">hscriptStringExpression</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.hscriptStringExpression" title="Permalink to this definition"></a></dt>
<dd><p>Evaluate an Hscript expression as a float.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>hscriptStringExpression(expression) -&gt; string</dd>
</dl>
<p>This function will force the return type to be a string. If the
expression does not evaluate to a string, this function returns its
string representation.</p>
<p>Most of the time, you want to use hou.hscriptExpression over this
function. See it for more examples.</p>
<p>Raises hou.OperationFailed if the expression is invalid or generates an
error occur during evaluation.</p>
<p>&gt; &gt;&gt;&gt; hou.hscriptStringExpression(3)
&gt; 3
&gt; &gt;&gt;&gt; hou.hscriptStringExpression(3)
&gt; 3
&gt; &gt;&gt;&gt; hou.hscriptStringExpression($F)
&gt; 1
&gt; &gt;&gt;&gt; hou.hscriptStringExpression(vector([1, 2, 3]))
&gt; [1,2,3]</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.hscriptExpression</li>
<li>hou.hscriptFloatExpression</li>
<li>hou.hscriptVectorExpression</li>
<li>hou.hscriptMatrixExpression</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.hscriptVectorExpression">
<code class="descclassname">hou.</code><code class="descname">hscriptVectorExpression</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.hscriptVectorExpression" title="Permalink to this definition"></a></dt>
<dd><p>Evaluate an Hscript expression as a vector.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>hscriptVectorExpression(expression) -&gt; tuple of floats</dd>
</dl>
<p>This function will force the return type to be an Hscript vector.
Because Hscript vectors can be be of different lengths, the value is
returned as a tuple of floats. If you know the vector is a particular
length, you can construct a Vector2/Vector3/Vector4 out of the return
value.</p>
<p>Most of the time, you want to use hou.hscriptExpression over this
function.</p>
<p>&gt; vector = hou.Vector3(hou.hscriptVectorExpression(vtorigin(/obj/geo1, /obj/geo2)))
&gt; print vector.length()</p>
<p>Raises hou.OperationFailed if the expression is invalid or generates an
error occur during evaluation.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.hscriptExpression</li>
<li>hou.hscriptFloatExpression</li>
<li>hou.hscriptStringExpression</li>
<li>hou.hscriptMatrixExpression</li>
<li>hou.Vector2</li>
<li>hou.Vector3</li>
<li>hou.Vector4</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="class">
<dt id="hou.imageDepth">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">imageDepth</code><a class="headerlink" href="#hou.imageDepth" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Enumeration of image depths (data formats) for representing the pixels
in an image plane.</p>
<p>See hou.CopNode.depth.</p>
<p>VALUES</p>
<blockquote>
<div>Int8
Int16
Int32
Float16
Float32</div></blockquote>
<dl class="attribute">
<dt id="hou.imageDepth.Float16">
<code class="descname">Float16</code><em class="property"> = imageDepth.Float16</em><a class="headerlink" href="#hou.imageDepth.Float16" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.imageDepth.Float32">
<code class="descname">Float32</code><em class="property"> = imageDepth.Float32</em><a class="headerlink" href="#hou.imageDepth.Float32" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.imageDepth.Int16">
<code class="descname">Int16</code><em class="property"> = imageDepth.Int16</em><a class="headerlink" href="#hou.imageDepth.Int16" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.imageDepth.Int32">
<code class="descname">Int32</code><em class="property"> = imageDepth.Int32</em><a class="headerlink" href="#hou.imageDepth.Int32" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.imageDepth.Int8">
<code class="descname">Int8</code><em class="property"> = imageDepth.Int8</em><a class="headerlink" href="#hou.imageDepth.Int8" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.imageDepth.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.imageDepth.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="hou.imageResolution">
<code class="descclassname">hou.</code><code class="descname">imageResolution</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.imageResolution" title="Permalink to this definition"></a></dt>
<dd><p>Return the resolution of an image in a file.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>imageResolution(image_file_name) -&gt; tuple of int</dd>
</dl>
<p>Returns the width and height of an image stored in a file.</p>
<p>Another way to get the resolution of an image is to load it into a file
cop and retrieve it. For example, this method could be approximately
implemented as follows:</p>
<p>&gt; def imageResolution(image_file_name):
&gt;     file_cop = hou.node(/img/comp1).createNode(file)
&gt;     file_cop.setParm(filename1, image_file_name)
&gt;     resolution = (file_cop.xRes(), file_cop.yRes())
&gt;     file_cop.destroy()
&gt;     return resolution</p>
<p>Note, however, that this method is faster than loading the image into
Houdini and retrieving the resolution because it is much less disk
intensive. It does not load the image data from disk, and instead only
loads as much as necessary to retrieve the resolution.</p>
<p>Raises hou.OperationFailed if the image file does not exist or if its
not an image file type supported by Houdini.</p>
<p>The following example retrieves the resolution of the default.pic file
that ships with Houdini.</p>
<p>&gt; &gt;&gt;&gt; hou.imageResolution(hou.findFile(pic/default.pic))
&gt; (512, 512)</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.CopNode.xRes</li>
<li>hou.CopNode.yRes</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.intFrame">
<code class="descclassname">hou.</code><code class="descname">intFrame</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.intFrame" title="Permalink to this definition"></a></dt>
<dd><p>Return the playbars current frame, rounded to the nearest integer.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>intFrame() -&gt; int</dd>
</dl>
<p>Note that this function is equivalent to Hscripts $F variable. If you
want Hscripts $FF variable, use hou.frame.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.frame</li>
<li>hou.setFrame</li>
<li>hou.time</li>
<li>hou.fps</li>
</ul>
</div></blockquote>
<p>REPLACES</p>
<blockquote>
<div><ul class="simple">
<li>fcur</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.isApprentice">
<code class="descclassname">hou.</code><code class="descname">isApprentice</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.isApprentice" title="Permalink to this definition"></a></dt>
<dd><p>Return whether the application is an apprentice (non-commercial)
version.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>isApprentice() -&gt; bool</dd>
</dl>
<p>Return whether the hou module is using an Apprentice license. Note that
this function returns True for both Apprentice and Apprentice HD.</p>
<p>REPLACES</p>
<blockquote>
<div><ul class="simple">
<li>version</li>
</ul>
</div></blockquote>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.licenseCategory</li>
<li>hou.applicationCompilationDate</li>
<li>hou.applicationName</li>
<li>hou.applicationVersion</li>
<li>hou.applicationVersionString</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.isUIAvailable">
<code class="descclassname">hou.</code><code class="descname">isUIAvailable</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.isUIAvailable" title="Permalink to this definition"></a></dt>
<dd><p>Return whether or not the hou.ui module is available.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>isUIAvailable() -&gt; bool</dd>
</dl>
<p>The hou.ui module is not available in the command-line interpreter or in
MPlay, and this function helps you to write scripts that will run in
Houdini and command-line and/or MPlay.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.ui</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.item">
<code class="descclassname">hou.</code><code class="descname">item</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.item" title="Permalink to this definition"></a></dt>
<dd><p>Given a path string, return a NetworkMovableItem object. Return None if
the path does not refer to an item.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>item(path) -&gt; hou.NetworkMovableItem or None</dd>
</dl>
<p>If the path starts with a /, Houdini will look for an item with that
exact path. Otherwise, the Houdini searches relative to the current
path. See hou.pwd for more information about Houdinis current path. For
each occurrence of .. in the path, Houdini will move up one item from
the current location.</p>
<p>This method is a more general form of the <a class="reference internal" href="#hou.node">hou.node</a> method, which will
only return hou.Node objects. But some network item types
(hou.SubnetIndirectInput and hou.NetworkDot) do not have names, and so
will never be returned by this method.</p>
<p>Raises hou.NotAvailable if you call it from MPlay.</p>
<p>&gt; &gt;&gt;&gt; hou.item(/obj)
&gt; &lt;hou.Node at /obj&gt;
&gt; &gt;&gt;&gt; hou.item(/obj).createNetworkBox()
&gt; &lt;hou.NetworkBox at /obj/__netbox1&gt;
&gt; &gt;&gt;&gt; hou.item(/obj/__netbox1)
&gt; &lt;hou.NetworkBox at /obj/__netbox1&gt;
&gt; &gt;&gt;&gt; hou.cd(/obj)
&gt; &gt;&gt;&gt; hou.item(__netbox1)
&gt; &lt;hou.NetworkBox at /obj/__netbox1&gt;
&gt; &gt;&gt;&gt; print hou.item(__netbox2)
&gt; None</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li><a class="reference internal" href="#hou.node">hou.node</a></li>
<li>hou.nodes</li>
<li>hou.items</li>
<li>hou.pwd</li>
<li>hou.parent</li>
<li>hou.root</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.itemBySessionId">
<code class="descclassname">hou.</code><code class="descname">itemBySessionId</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.itemBySessionId" title="Permalink to this definition"></a></dt>
<dd><p>Given an items session id and an item type, return a NetworkMovableItem
object. Return None if the id does not correspond to a valid item.</p>
<p>This function is equivalent to a series of if statements checking the
item_type enum value, and calling the more specific session id functions
such as hou.nodeBySessionId. It allows network items to be treated in a
uniform manner by code that is expected to handle a variety of network
item types.</p>
<p>The item_type parameter should be one of the hou.networkItemType enum
values, except hou.networkItemType.Connection, which doesnt support
lookup using a single session id value.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>itemBySessionId(item_type, session_id) -&gt; hou.NetworkMovableItem or
None</dd>
</dl>
<p>See hou.NetworkMovableItem.sessionId for more information.</p>
<p>Raises hou.NotAvailable if you call it from MPlay.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.item</li>
<li>hou.networkBoxBySessionId</li>
<li>hou.networkDotBySessionId</li>
<li>hou.nodeBySessionId</li>
<li>hou.stickyNoteBySessionId</li>
<li>hou.subnetIndirectInputBySessionId</li>
<li>hou.NetworkMovableItem.sessionId</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.items">
<code class="descclassname">hou.</code><code class="descname">items</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.items" title="Permalink to this definition"></a></dt>
<dd><p>Takes a sequence of node path strings and returns a tuple of
NetworkMovableItem objects.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>item(path_tuple) -&gt; tuple of hou.NetworkMovableItem or None</dd>
</dl>
<p>This is like hou.items but takes multiple paths and returns multiple
item objects. See hou.item for more information.</p>
<p>&gt; paths = [/obj/geo1, /obj/geo2, /obj/geo3]
&gt; items = hou.items(paths)</p>
<p>This is the equivalent of:</p>
<p>&gt; items = [hou.item(path) for path in paths]</p>
<p>Raises hou.NotAvailable if you call it from MPlay.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li><a class="reference internal" href="#hou.node">hou.node</a></li>
<li>hou.nodes</li>
<li>hou.item</li>
<li>hou.pwd</li>
<li>hou.parent</li>
<li>hou.root</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.licenseCategory">
<code class="descclassname">hou.</code><code class="descname">licenseCategory</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.licenseCategory" title="Permalink to this definition"></a></dt>
<dd><p>Return the category of license (Commercial, Apprentice, ApprenticeHD,
etc.) in use.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>licenseCategory() -&gt; hou.licenseCategoryType enum value</dd>
</dl>
<p>REPLACES</p>
<blockquote>
<div><ul class="simple">
<li>version</li>
</ul>
</div></blockquote>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.licenseCategoryType</li>
<li>hou.applicationCompilationDate</li>
<li>hou.applicationName</li>
<li>hou.applicationVersion</li>
<li>hou.applicationVersionString</li>
<li>hou.isApprentice</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="class">
<dt id="hou.licenseCategoryType">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">licenseCategoryType</code><a class="headerlink" href="#hou.licenseCategoryType" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Enumeration of license category values.</p>
<p>VALUES</p>
<blockquote>
<div>Commercial
Education
ApprenticeHD
Apprentice</div></blockquote>
<dl class="attribute">
<dt id="hou.licenseCategoryType.Apprentice">
<code class="descname">Apprentice</code><em class="property"> = licenseCategoryType.Apprentice</em><a class="headerlink" href="#hou.licenseCategoryType.Apprentice" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.licenseCategoryType.ApprenticeHD">
<code class="descname">ApprenticeHD</code><em class="property"> = licenseCategoryType.ApprenticeHD</em><a class="headerlink" href="#hou.licenseCategoryType.ApprenticeHD" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.licenseCategoryType.Commercial">
<code class="descname">Commercial</code><em class="property"> = licenseCategoryType.Commercial</em><a class="headerlink" href="#hou.licenseCategoryType.Commercial" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.licenseCategoryType.Education">
<code class="descname">Education</code><em class="property"> = licenseCategoryType.Education</em><a class="headerlink" href="#hou.licenseCategoryType.Education" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.licenseCategoryType.Indie">
<code class="descname">Indie</code><em class="property"> = licenseCategoryType.Indie</em><a class="headerlink" href="#hou.licenseCategoryType.Indie" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.licenseCategoryType.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.licenseCategoryType.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="hou.linear">
<code class="descclassname">hou.</code><code class="descname">linear</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.linear" title="Permalink to this definition"></a></dt>
<dd><p>Linearly interpolates between the left keyframes outgoing value and the
right keyframes incoming value.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>linear() -&gt; float</dd>
</dl>
<p>This function is one of the special animation functions that use the
current playbar time and information in the parameters keyframes, such
as in and out values, tangents, acceleration, etc., to evaluate
themselves. Because the information needed to evaluate these functions
comes from the keyframes, these functions take few or no parameters.</p>
<p>Calling this function from outside a parameters expression will raise a
hou.NotAvailable exception.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.bezier</li>
<li>hou.constant</li>
<li>hou.cubic</li>
<li>hou.cycle</li>
<li>hou.cyclet</li>
<li>hou.ease</li>
<li>hou.easein</li>
<li>hou.easeinp</li>
<li>hou.easeout</li>
<li>hou.easeoutp</li>
<li>hou.easep</li>
<li>hou.match</li>
<li>hou.matchin</li>
<li>hou.matchout</li>
<li>hou.qlinear</li>
<li>hou.quintic</li>
<li>hou.repeat</li>
<li>hou.repeatt</li>
<li>hou.spline</li>
<li>hou.vmatch</li>
<li>hou.vmatchin</li>
<li>hou.vmatchout &#64;replaces</li>
<li>linear()</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.loadCPIODataFromString">
<code class="descclassname">hou.</code><code class="descname">loadCPIODataFromString</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.loadCPIODataFromString" title="Permalink to this definition"></a></dt>
<dd><p>Given a string containing data in CPIO data format, decode the data and
return a sequence of (name, value) pairs representing the data.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>loadCPIODataFromString(data) -&gt; tuple of (str, str)</dd>
</dl>
<p>CPIO data format stores an ordered sequence of (name, value) pairs. The
same name may occur multiple times. Is most commonly used to store hip
files and contents sections inside assets. The other common file format
used in Houdini is index file format.</p>
<p>If the data is not in CPIO data format, this function returns an empty
tuple.</p>
<p>The inverse of this function is hou.saveCPIODataToString.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.saveCPIODataToString</li>
<li>hou.loadIndexDataFromString</li>
<li>hou.saveIndexDataToString</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.loadIndexDataFromFile">
<code class="descclassname">hou.</code><code class="descname">loadIndexDataFromFile</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.loadIndexDataFromFile" title="Permalink to this definition"></a></dt>
<dd><p>Given a file containing data in index data format, decode the data and
return a dictionary representing the data.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>loadIndexDataFromFile(file_path) -&gt; dict</dd>
</dl>
<p>This function could be implemented as follows:</p>
<p>&gt; def loadIndexDataFromFile(file_path):
&gt;     hou.loadIndexDataFromString(hou.readFile(file_path))</p>
<p>See hou.loadIndexDataFromString for more details.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.saveIndexDataToFile</li>
<li>hou.loadIndexDataFromString</li>
<li>hou.saveIndexDataToString</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.loadIndexDataFromString">
<code class="descclassname">hou.</code><code class="descname">loadIndexDataFromString</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.loadIndexDataFromString" title="Permalink to this definition"></a></dt>
<dd><p>Given a string containing data in index data format, decode the data and
return a dictionary representing the data.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>loadIndexDataFromString(data) -&gt; dict</dd>
</dl>
<p>Index data format stores an unordered mapping of (key, value) pairs. Is
used to store otl files and asset definition sections, preset files,
icon archives, and other files in Houdini. The other common file format
used in Houdini is CPIO.</p>
<p>If the data is not in index data format, this function returns an empty
dictionary.</p>
<p>The inverse of this function is hou.saveIndexDataToString.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.saveIndexDataToString</li>
<li>hou.loadIndexDataFromFile</li>
<li>hou.saveIndexDataToFile</li>
<li>hou.loadCPIODataFromString</li>
<li>hou.saveCPIODataToString</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.lopNodeTypeCategory">
<code class="descclassname">hou.</code><code class="descname">lopNodeTypeCategory</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.lopNodeTypeCategory" title="Permalink to this definition"></a></dt>
<dd><p>Return the NodeTypeCategory instance for Houdini lighting (lop) nodes.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>lopNodeTypeCategory() -&gt; NodeTypeCategory</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="hou.lvar">
<code class="descclassname">hou.</code><code class="descname">lvar</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.lvar" title="Permalink to this definition"></a></dt>
<dd><p>Return the value of a nodes local variable. Call this function from
expressions inside node parameters.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>lvar(name) -&gt; float</dd>
</dl>
<p>Many SOP and POP algorithms involve iterating over a series of points
(or primitives or vertices, but well use points for the examples).
These SOP and POP nodes evaluate their parameters for each point,
setting a variable that you can access from an expression in that
parameter to a value specific to that point. For example, the TX
variable is set to evaluate to the X value of the position of the
current point. These variables are called local variables because they
are local to the expressions inside parameters in the node.</p>
<p>In the Hscript expression language, you use $ to evaluate local
variables, just like how you evaluate global variables. In Python, you
use the lvar function. So, the Python equivalent of $TX is lvar(TX).</p>
<dl class="docutils">
<dt>TIP</dt>
<dd>Inside a parameter expression you can drop the hou. prefix from the
call to lvar, since Houdini implicitly runs from hou import * when
it evaluates expressions.</dd>
</dl>
<p>If you call this function from outside a parameter expression it will
raise hou.NotAvailable. If you call it with an invalid variable name, it
will raise hou.OperationFailed. Note that you cannot use this function
to evaluate Houdini global variables; instead use hou.expandString.</p>
<p>Note that hou.SopNode.curPoint and similar methods on the hou.SopNode
and hou.PopNode classes return the current point that the node is
iterating over. Using the point, you can evaluate attributes, etc, to
perform the equivalent of a local variable. You can also access
information that may not be accessible through local variables.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.SopNode.curPoint</li>
<li>hou.SopNode.curPoint2</li>
<li>hou.SopNode.curPrim</li>
<li>hou.SopNode.curPrim2</li>
<li>hou.SopNode.curVertex</li>
<li>hou.SopNode.curVertex2</li>
<li>hou.PopNode.curPoint</li>
<li>hou.expandString</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.managerNodeTypeCategory">
<code class="descclassname">hou.</code><code class="descname">managerNodeTypeCategory</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.managerNodeTypeCategory" title="Permalink to this definition"></a></dt>
<dd><p>Return the NodeTypeCategory instance for Houdini manager nodes. The
manager nodes are /obj, /out, /part, /ch, /shop, /img, and /vex.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>managerNodeTypeCategory() -&gt; NodeTypeCategory</dd>
</dl>
<p>Note that some container node types, like the shop network node type,
are called managers in Houdini. The node type category for an instance
of those nodes will be the same as other nodes in that same network. For
example, a shop network in objects will be in the objects node type
category, while a shop network in a sop network will be in the geometry
node type category.</p>
</dd></dl>

<dl class="class">
<dt id="hou.markerVisibility">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">markerVisibility</code><a class="headerlink" href="#hou.markerVisibility" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Enum of visibility options for marker visualizers.</p>
<p>VALUES</p>
<blockquote>
<div><dl class="docutils">
<dt>hou.markerVisibility.Always</dt>
<dd>Display the markers without restriction.</dd>
<dt>hou.markerVisibility.Selected</dt>
<dd>Only display the marker if its component is selected.</dd>
<dt>hou.markerVisibility.AroundPointer</dt>
<dd>Display markers around the mouse pointer in 3D space.</dd>
<dt>hou.markerVisibility.UnderPointer</dt>
<dd>Display markers under the mouse pointer in screen space.</dd>
</dl>
</div></blockquote>
<dl class="attribute">
<dt id="hou.markerVisibility.Always">
<code class="descname">Always</code><em class="property"> = markerVisibility.Always</em><a class="headerlink" href="#hou.markerVisibility.Always" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.markerVisibility.AroundPointer">
<code class="descname">AroundPointer</code><em class="property"> = markerVisibility.AroundPointer</em><a class="headerlink" href="#hou.markerVisibility.AroundPointer" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.markerVisibility.Selected">
<code class="descname">Selected</code><em class="property"> = markerVisibility.Selected</em><a class="headerlink" href="#hou.markerVisibility.Selected" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.markerVisibility.UnderPointer">
<code class="descname">UnderPointer</code><em class="property"> = markerVisibility.UnderPointer</em><a class="headerlink" href="#hou.markerVisibility.UnderPointer" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.markerVisibility.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.markerVisibility.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="hou.match">
<code class="descclassname">hou.</code><code class="descname">match</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.match" title="Permalink to this definition"></a></dt>
<dd><p>Creates a smooth curve between the left keyframes incoming slope and
the right keyframes outgoing slope.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>match() -&gt; float</dd>
</dl>
<p>This function is one of the special animation functions that use the
current playbar time and information in the parameters keyframes, such
as in and out values, tangents, acceleration, etc., to evaluate
themselves. Because the information needed to evaluate these functions
comes from the keyframes, these functions take few or no parameters.</p>
<p>Calling this function from outside a parameters expression will raise a
hou.NotAvailable exception.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.bezier</li>
<li>hou.constant</li>
<li>hou.cubic</li>
<li>hou.cycle</li>
<li>hou.cyclet</li>
<li>hou.ease</li>
<li>hou.easein</li>
<li>hou.easeinp</li>
<li>hou.easeout</li>
<li>hou.easeoutp</li>
<li>hou.easep</li>
<li>hou.linear</li>
<li>hou.matchin</li>
<li>hou.matchout</li>
<li>hou.qlinear</li>
<li>hou.quintic</li>
<li>hou.repeat</li>
<li>hou.repeatt</li>
<li>hou.spline</li>
<li>hou.vmatch</li>
<li>hou.vmatchin</li>
<li>hou.vmatchout &#64;replaces</li>
<li>match()</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.matchin">
<code class="descclassname">hou.</code><code class="descname">matchin</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.matchin" title="Permalink to this definition"></a></dt>
<dd><p>Creates a straight line from the left keyframes incoming value,
matching the left keyframes incoming slope.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>matchin() -&gt; float</dd>
</dl>
<p>This function is one of the special animation functions that use the
current playbar time and information in the parameters keyframes, such
as in and out values, tangents, acceleration, etc., to evaluate
themselves. Because the information needed to evaluate these functions
comes from the keyframes, these functions take few or no parameters.</p>
<p>Calling this function from outside a parameters expression will raise a
hou.NotAvailable exception.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.bezier</li>
<li>hou.constant</li>
<li>hou.cubic</li>
<li>hou.cycle</li>
<li>hou.cyclet</li>
<li>hou.ease</li>
<li>hou.easein</li>
<li>hou.easeinp</li>
<li>hou.easeout</li>
<li>hou.easeoutp</li>
<li>hou.easep</li>
<li>hou.linear</li>
<li>hou.match</li>
<li>hou.matchout</li>
<li>hou.qlinear</li>
<li>hou.quintic</li>
<li>hou.repeat</li>
<li>hou.repeatt</li>
<li>hou.spline</li>
<li>hou.vmatch</li>
<li>hou.vmatchin</li>
<li>hou.vmatchout</li>
</ul>
</div></blockquote>
<p>REPLACES</p>
<blockquote>
<div><ul class="simple">
<li>matchin()</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.matchout">
<code class="descclassname">hou.</code><code class="descname">matchout</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.matchout" title="Permalink to this definition"></a></dt>
<dd><p>Creates a straight line from the right keyframes outgoing value,
matching the right keyframes outgoing slope.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>matchout() -&gt; float</dd>
</dl>
<p>This function is one of the special animation functions that use the
current playbar time and information in the parameters keyframes, such
as in and out values, tangents, acceleration, etc., to evaluate
themselves. Because the information needed to evaluate these functions
comes from the keyframes, these functions take few or no parameters.</p>
<p>Calling this function from outside a parameters expression will raise a
hou.NotAvailable exception.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.bezier</li>
<li>hou.constant</li>
<li>hou.cubic</li>
<li>hou.cycle</li>
<li>hou.cyclet</li>
<li>hou.ease</li>
<li>hou.easein</li>
<li>hou.easeinp</li>
<li>hou.easeout</li>
<li>hou.easeoutp</li>
<li>hou.easep</li>
<li>hou.linear</li>
<li>hou.match</li>
<li>hou.matchin</li>
<li>hou.qlinear</li>
<li>hou.quintic</li>
<li>hou.repeat</li>
<li>hou.repeatt</li>
<li>hou.spline</li>
<li>hou.vmatch</li>
<li>hou.vmatchin</li>
<li>hou.vmatchout</li>
</ul>
</div></blockquote>
<p>REPLACES</p>
<blockquote>
<div><ul class="simple">
<li>matchout()</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.maxThreads">
<code class="descclassname">hou.</code><code class="descname">maxThreads</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.maxThreads" title="Permalink to this definition"></a></dt>
<dd><p>Returns the number of threads used for processing.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>maxThreads() -&gt; int</dd>
</dl>
<p>When Houdini/hython is started, it uses all available processors on the
machine for multi-threaded processing, unless overridden by the -j
command line option or the hou.setMaxThreads function.</p>
<p>This function returns that maximum number of threads that Houdini/hython
will use.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.setMaxThreads</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="class">
<dt id="hou.menuType">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">menuType</code><a class="headerlink" href="#hou.menuType" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Enumeration of parameter menu types.</p>
<p>See also hou.MenuParmTemplate and hou.StringParmTemplate.</p>
<p>VALUES</p>
<blockquote>
<div><dl class="docutils">
<dt>Normal</dt>
<dd>A standard menu that displays the currently selected menu item.</dd>
<dt>Mini</dt>
<dd>A condensed menu that only displays a dropdown arrow. Houdini
lets you choose a menu entry when you click on this arrow.</dd>
<dt>ControlNextParameter</dt>
<dd>A standard menu that displays the currently selected menu item.
This menu always joins horizontally to the next parameter and is
displayed without a label. However unlike simply turning off the
label and joining to the next parameter, the layout of the next
parameter is such that a series of parameters preceded by menus
of this type will align in a much more appealing way.</dd>
<dt>StringReplace</dt>
<dd>A menu that also displays an input field. Selecting an entry
from this menu will replace the contents of the field with the
menu item. This type of menu only has meaning for string
parameters.</dd>
<dt>StringToggle</dt>
<dd>A menu that also displays an input field. Selecting an entry
from this menu will add the menu item to the field if it was not
already there, and will remove it from the field it if was. This
type of menu only has meaning for string parameters.</dd>
</dl>
</div></blockquote>
<dl class="attribute">
<dt id="hou.menuType.ControlNextParameter">
<code class="descname">ControlNextParameter</code><em class="property"> = menuType.ControlNextParameter</em><a class="headerlink" href="#hou.menuType.ControlNextParameter" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.menuType.Mini">
<code class="descname">Mini</code><em class="property"> = menuType.Mini</em><a class="headerlink" href="#hou.menuType.Mini" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.menuType.Normal">
<code class="descname">Normal</code><em class="property"> = menuType.Normal</em><a class="headerlink" href="#hou.menuType.Normal" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.menuType.StringReplace">
<code class="descname">StringReplace</code><em class="property"> = menuType.StringReplace</em><a class="headerlink" href="#hou.menuType.StringReplace" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.menuType.StringToggle">
<code class="descname">StringToggle</code><em class="property"> = menuType.StringToggle</em><a class="headerlink" href="#hou.menuType.StringToggle" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.menuType.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.menuType.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="hou.moveNodesTo">
<code class="descclassname">hou.</code><code class="descname">moveNodesTo</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.moveNodesTo" title="Permalink to this definition"></a></dt>
<dd><p>Move all given nodes to a new place in node hierarchy.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>moveNodesTo(nodes, destination_node) -&gt; tuple of Nodes</dd>
</dl>
<p>The nodes to be moved should be a sequence of hou.Node objects. The
destination node will be the parent of new copied nodes. The type of all
source nodes should match the destination node child type.</p>
<p>This function returns a tuple of hou.Node objects corresponding to the
nodes at their new locations. If you attempt to access the original
hou.Node objects in the sequence you passed into this function, you will
receive hou.ObjectWasDeleted exceptions.</p>
<p>For every moved node, if a node with the same name already exists at the
destination, the node will be renamed to a unique name.</p>
<p>This function will raise a hou.OperationFailed exception if any of the
nodes to be moved are of invalid type, the destination node cannot be
copied into, or source node type does not match the destination nodes
child type.</p>
<p>This function will raise hou.ObjectWasDeleted if any of source nodes or
the destination node no longer exist in Houdini.</p>
<p>All of the above issues with source and destination nodes will be
reported before moving starts to avoid a partial move.</p>
<p>After the function finishes execution, all the moved nodes by it will be
selected.</p>
</dd></dl>

<dl class="function">
<dt id="hou.networkBoxBySessionId">
<code class="descclassname">hou.</code><code class="descname">networkBoxBySessionId</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.networkBoxBySessionId" title="Permalink to this definition"></a></dt>
<dd><p>Given a network boxs session id, return a NetworkBox object. Return
None if the id does not correspond to a valid network box.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>networkBoxBySessionId(session_id) -&gt; hou.NetworkBox or None</dd>
</dl>
<p>See hou.NetworkBox.sessionId for more information.</p>
<p>Raises hou.NotAvailable if you call it from MPlay.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.item</li>
<li>hou.NetworkBox.sessionId</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.networkDotBySessionId">
<code class="descclassname">hou.</code><code class="descname">networkDotBySessionId</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.networkDotBySessionId" title="Permalink to this definition"></a></dt>
<dd><p>Given a dots session id, return a NetworkDot object. Return None if the
id does not correspond to a valid dot (e.g. if the dot was deleted).</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>networkDotBySessionId(session_id) -&gt; hou.NetworkDot or None</dd>
</dl>
<p>See hou.NetworkDot.sessionId for more information.</p>
<p>Raises hou.NotAvailable if you call it from MPlay.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.item</li>
<li>hou.NetworkDot.sessionId</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="class">
<dt id="hou.networkItemType">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">networkItemType</code><a class="headerlink" href="#hou.networkItemType" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>&lt;Summary&gt;</p>
<p>&lt;Description&gt;</p>
<p>VALUES</p>
<blockquote>
<div>Connection
NetworkBox
NetworkDot
Node
StickyNote
SubnetIndirectInput</div></blockquote>
<dl class="attribute">
<dt id="hou.networkItemType.Connection">
<code class="descname">Connection</code><em class="property"> = networkItemType.Connection</em><a class="headerlink" href="#hou.networkItemType.Connection" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.networkItemType.NetworkBox">
<code class="descname">NetworkBox</code><em class="property"> = networkItemType.NetworkBox</em><a class="headerlink" href="#hou.networkItemType.NetworkBox" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.networkItemType.NetworkDot">
<code class="descname">NetworkDot</code><em class="property"> = networkItemType.NetworkDot</em><a class="headerlink" href="#hou.networkItemType.NetworkDot" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.networkItemType.Node">
<code class="descname">Node</code><em class="property"> = networkItemType.Node</em><a class="headerlink" href="#hou.networkItemType.Node" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.networkItemType.StickyNote">
<code class="descname">StickyNote</code><em class="property"> = networkItemType.StickyNote</em><a class="headerlink" href="#hou.networkItemType.StickyNote" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.networkItemType.SubnetIndirectInput">
<code class="descname">SubnetIndirectInput</code><em class="property"> = networkItemType.SubnetIndirectInput</em><a class="headerlink" href="#hou.networkItemType.SubnetIndirectInput" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.networkItemType.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.networkItemType.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="hou.node">
<code class="descclassname">hou.</code><code class="descname">node</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.node" title="Permalink to this definition"></a></dt>
<dd><p>Given a path string, return a Node object. Return None if the path does
not refer to a node.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>node(path) -&gt; hou.Node or None</dd>
</dl>
<p>If the path starts with a /, Houdini will look for a node with that
exact path. Otherwise, the Houdini searches relative to the current
path. See hou.pwd for more information about Houdinis current path. For
each occurrence of .. in the path, Houdini will move up one node from
the current location.</p>
<p>Raises hou.NotAvailable if you call it from MPlay.</p>
<p>Be careful not to confuse this function with the class hou.Node.</p>
<p>&gt; &gt;&gt;&gt; hou.node(/obj)
&gt; &lt;hou.Node at /obj&gt;
&gt; &gt;&gt;&gt; hou.node(/obj).createNode(geo)
&gt; &lt;hou.ObjNode of type geo at /obj/geo1&gt;
&gt; &gt;&gt;&gt; hou.node(/obj).createNode(geo)
&gt; &lt;hou.ObjNode of type geo at /obj/geo2&gt;
&gt; &gt;&gt;&gt; hou.node(/obj/geo1)
&gt; &lt;hou.ObjNode of type geo at /obj/geo1&gt;
&gt; &gt;&gt;&gt; hou.cd(/obj)
&gt; &gt;&gt;&gt; hou.node(geo1)
&gt; &lt;hou.ObjNode of type geo at /obj/geo1&gt;
&gt; &gt;&gt;&gt; hou.cd(/obj/geo2)
&gt; &gt;&gt;&gt; hou.node(../geo1)
&gt; &lt;hou.ObjNode of type geo at /obj/geo1&gt;
&gt; &gt;&gt;&gt; print hou.node(../geo3)
&gt; None</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.item</li>
<li>hou.items</li>
<li>hou.nodes</li>
<li>hou.pwd</li>
<li>hou.parent</li>
<li>hou.root</li>
</ul>
</div></blockquote>
<p>REPLACES</p>
<blockquote>
<div><ul class="simple">
<li>opfind</li>
<li>ch()</li>
<li>chs()</li>
<li>chsop()</li>
<li>opexist()</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.nodeBundle">
<code class="descclassname">hou.</code><code class="descname">nodeBundle</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.nodeBundle" title="Permalink to this definition"></a></dt>
<dd><p>Given a node bundle name, return the corresponding NodeBundle object, or
None if there is not one with that name.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>nodeBundle(name) -&gt; hou.NodeBundle or None</dd>
</dl>
<p>See hou.NodeBundle for more information.</p>
<p>REPLACES</p>
<blockquote>
<div><ul class="simple">
<li>opbls</li>
<li>opglob</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.nodeBundles">
<code class="descclassname">hou.</code><code class="descname">nodeBundles</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.nodeBundles" title="Permalink to this definition"></a></dt>
<dd><p>Return a tuple containing all the node bundles in the current session.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>nodeBundles() -&gt; tuple of hou.NodeBundle</dd>
</dl>
<p>See hou.NodeBundle for more information.</p>
<p>REPLACES</p>
<blockquote>
<div><ul class="simple">
<li>opbls</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.nodeBySessionId">
<code class="descclassname">hou.</code><code class="descname">nodeBySessionId</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.nodeBySessionId" title="Permalink to this definition"></a></dt>
<dd><p>Given a nodes session id, return a Node object. Return None if the id
does not correspond to a valid node (e.g. if the node was deleted).</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>nodeBySessionId(session_id) -&gt; hou.Node or None</dd>
</dl>
<p>See hou.Node.sessionId for more information.</p>
<p>Raises hou.NotAvailable if you call it from MPlay.</p>
<p>REPLACES</p>
<blockquote>
<div><ul class="simple">
<li>opfind</li>
<li>ch()</li>
<li>chs()</li>
<li>chsop()</li>
<li>chsoplist()</li>
<li>opexist()</li>
</ul>
</div></blockquote>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.item</li>
<li><a class="reference internal" href="#hou.node">hou.node</a></li>
<li>hou.Node.sessionId</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.nodeConnectionBySessionId">
<code class="descclassname">hou.</code><code class="descname">nodeConnectionBySessionId</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.nodeConnectionBySessionId" title="Permalink to this definition"></a></dt>
<dd><p>Given a nodes session id and an input index, return a NodeConnection
object. Return None if the id does not correspond to a valid node (e.g.
if the node was deleted), or the specified input index is not connected.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>nodeConnectionBySessionId(session_id, input_index) -&gt;
hou.NodeConnection or None</dd>
</dl>
<p>Raises hou.NotAvailable if you call it from MPlay.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.nodeBySessionId</li>
<li>hou.Node.sessionId</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="class">
<dt id="hou.nodeEventType">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">nodeEventType</code><a class="headerlink" href="#hou.nodeEventType" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Enumeration of types of events that can happen to nodes.</p>
<p>Node event callbacks let you run code when events occur on an individual
node instance. See hou.Node.addEventCallback.</p>
<p>For all event types, the callback is called with a node keyword argument
(containing a hou.Node reference to the node) and an event_type argument
(containing one of the values below, indicating the type of event that
occured).</p>
<p>Some event types pass additional keyword arguments to the callback
function, as noted below.</p>
<p>VALUES</p>
<blockquote>
<div><dl class="docutils">
<dt>BeingDeleted</dt>
<dd>Runs before a node is deleted. You cannot cancel the deletion.</dd>
<dt>NameChanged</dt>
<dd>Runs after a node was renamed. You can get the new name using
hou.Node.name.</dd>
<dt>FlagChanged</dt>
<dd>Runs after one of the nodes flags was turned on or off.</dd>
<dt>AppearanceChanged</dt>
<dd><blockquote class="first">
<div>Runs after the an event occurs that changes what the node looks
like in the network editor. This includes but is not limited to:</div></blockquote>
<ul class="last">
<li><p class="first">Color or shape changed</p>
</li>
<li><p class="first">Error triggered or cleared</p>
</li>
<li><p class="first">Selected or deselected</p>
</li>
<li><p class="first">Asset locked or unlocked</p>
<p><em>Extra keyword argument</em>: change_type (hou.appearanceChangeType)</p>
</li>
</ul>
</dd>
<dt>PositionChanged</dt>
<dd>Runs after the node is moved in the network editor. You can get
the nodes new position using hou.Node.position.</dd>
<dt>InputRewired</dt>
<dd><p class="first">Runs after one of the nodes inputs are connected or
disconnected.</p>
<p class="last"><em>Extra keyword argument</em>: input_index (int)  the input number
(starting at 0) that changed.</p>
</dd>
<dt>InputDataChanged</dt>
<dd>The data on changed on a node this node depends on. For example,
if this node references another node in an expression. Houdini
_does <a href="#id81"><span class="problematic" id="id82">not_</span></a> trigger this event when a parameter changes.</dd>
<dt>ParmTupleChanged</dt>
<dd><p class="first">Runs after a parameter value changes. You can get the new value
using hou.ParmTuple.eval.</p>
<p><em>Extra keyword argument</em>: parm_tuple (hou.ParmTuple).</p>
<dl class="last docutils">
<dt>NOTE</dt>
<dd>If many/all parameters on the node change at the same time,
instead of calling the handler for each one, Houdini will
call the handler once with a parm_tuple argument of None.
Your callback code should be handle this possibility.</dd>
</dl>
</dd>
<dt>ChildCreated</dt>
<dd><p class="first">For a subnet node (for example, a Geometry object), runs after a
new node is created inside.</p>
<p class="last"><em>Extra keyword argument</em>: child_node (hou.Node)</p>
</dd>
<dt>ChildDeleted</dt>
<dd><p class="first">For a subnet node (for example, a Geometry object), runs
_before_ a node is deleted inside. You cannot cancel the
deletion.</p>
<p class="last"><em>Extra keyword argument</em>: child_node (hou.Node)</p>
</dd>
<dt>ChildSwitched</dt>
<dd><p class="first">For a subnet node (for example, a Geometry object), runs after
the current node, display flag, or render flag changes inside
(meaning the 3D view will change).</p>
<p class="last"><em>Extra keyword argument</em>: child_node (hou.Node)  the newly
selected child node.</p>
</dd>
<dt>ChildSelectionChanged</dt>
<dd>For a subnet node (for example, a Geometry object), runs after
the selection changes inside. You can get the new selection with
hou.Node.selectedChildren.</dd>
<dt>SpareParmTemplatesChanged</dt>
<dd><p class="first">Runs after a spare parameter is modified on, added to, or
removed from the node.</p>
<dl class="last docutils">
<dt>NOTE</dt>
<dd>If the node has spare parameters, this event triggers when
_any_ parameter is modified, not just a spare parameter.</dd>
</dl>
</dd>
<dt>SelectionChanged</dt>
<dd>Runs after the selection associated with a node changes. This
only applies to the geometry selected on a SOP node, or the
scene graph primitives selected in a LOP Network.</dd>
</dl>
</div></blockquote>
<dl class="attribute">
<dt id="hou.nodeEventType.AppearanceChanged">
<code class="descname">AppearanceChanged</code><em class="property"> = nodeEventType.AppearanceChanged</em><a class="headerlink" href="#hou.nodeEventType.AppearanceChanged" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.nodeEventType.BeingDeleted">
<code class="descname">BeingDeleted</code><em class="property"> = nodeEventType.BeingDeleted</em><a class="headerlink" href="#hou.nodeEventType.BeingDeleted" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.nodeEventType.ChildCreated">
<code class="descname">ChildCreated</code><em class="property"> = nodeEventType.ChildCreated</em><a class="headerlink" href="#hou.nodeEventType.ChildCreated" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.nodeEventType.ChildDeleted">
<code class="descname">ChildDeleted</code><em class="property"> = nodeEventType.ChildDeleted</em><a class="headerlink" href="#hou.nodeEventType.ChildDeleted" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.nodeEventType.ChildSelectionChanged">
<code class="descname">ChildSelectionChanged</code><em class="property"> = nodeEventType.ChildSelectionChanged</em><a class="headerlink" href="#hou.nodeEventType.ChildSelectionChanged" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.nodeEventType.ChildSwitched">
<code class="descname">ChildSwitched</code><em class="property"> = nodeEventType.ChildSwitched</em><a class="headerlink" href="#hou.nodeEventType.ChildSwitched" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.nodeEventType.FlagChanged">
<code class="descname">FlagChanged</code><em class="property"> = nodeEventType.FlagChanged</em><a class="headerlink" href="#hou.nodeEventType.FlagChanged" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.nodeEventType.InputDataChanged">
<code class="descname">InputDataChanged</code><em class="property"> = nodeEventType.InputDataChanged</em><a class="headerlink" href="#hou.nodeEventType.InputDataChanged" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.nodeEventType.InputRewired">
<code class="descname">InputRewired</code><em class="property"> = nodeEventType.InputRewired</em><a class="headerlink" href="#hou.nodeEventType.InputRewired" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.nodeEventType.NameChanged">
<code class="descname">NameChanged</code><em class="property"> = nodeEventType.NameChanged</em><a class="headerlink" href="#hou.nodeEventType.NameChanged" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.nodeEventType.ParmTupleChanged">
<code class="descname">ParmTupleChanged</code><em class="property"> = nodeEventType.ParmTupleChanged</em><a class="headerlink" href="#hou.nodeEventType.ParmTupleChanged" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.nodeEventType.PositionChanged">
<code class="descname">PositionChanged</code><em class="property"> = nodeEventType.PositionChanged</em><a class="headerlink" href="#hou.nodeEventType.PositionChanged" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.nodeEventType.SelectionChanged">
<code class="descname">SelectionChanged</code><em class="property"> = nodeEventType.SelectionChanged</em><a class="headerlink" href="#hou.nodeEventType.SelectionChanged" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.nodeEventType.SpareParmTemplatesChanged">
<code class="descname">SpareParmTemplatesChanged</code><em class="property"> = nodeEventType.SpareParmTemplatesChanged</em><a class="headerlink" href="#hou.nodeEventType.SpareParmTemplatesChanged" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.nodeEventType.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.nodeEventType.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.nodeFlag">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">nodeFlag</code><a class="headerlink" href="#hou.nodeFlag" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Enumeration of the different node flags.</p>
<p>VALUES</p>
<blockquote>
<div>Audio
Bypass
ColorDefault
Compress
Current
Debug
Display
DisplayComment
DisplayDescriptiveName
Export
Expose
Footprint
Highlight
InOutDetailLow
InOutDetailMedium
InOutDetailHigh
Material
Lock
SoftLock
Origin
Pick
Render
Selectable
Template
Unload
Visible
XRay</div></blockquote>
<dl class="attribute">
<dt id="hou.nodeFlag.Audio">
<code class="descname">Audio</code><em class="property"> = nodeFlag.Audio</em><a class="headerlink" href="#hou.nodeFlag.Audio" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.nodeFlag.Bypass">
<code class="descname">Bypass</code><em class="property"> = nodeFlag.Bypass</em><a class="headerlink" href="#hou.nodeFlag.Bypass" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.nodeFlag.ColorDefault">
<code class="descname">ColorDefault</code><em class="property"> = nodeFlag.ColorDefault</em><a class="headerlink" href="#hou.nodeFlag.ColorDefault" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.nodeFlag.Compress">
<code class="descname">Compress</code><em class="property"> = nodeFlag.Compress</em><a class="headerlink" href="#hou.nodeFlag.Compress" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.nodeFlag.Current">
<code class="descname">Current</code><em class="property"> = nodeFlag.Current</em><a class="headerlink" href="#hou.nodeFlag.Current" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.nodeFlag.Debug">
<code class="descname">Debug</code><em class="property"> = nodeFlag.Debug</em><a class="headerlink" href="#hou.nodeFlag.Debug" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.nodeFlag.Display">
<code class="descname">Display</code><em class="property"> = nodeFlag.Display</em><a class="headerlink" href="#hou.nodeFlag.Display" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.nodeFlag.DisplayComment">
<code class="descname">DisplayComment</code><em class="property"> = nodeFlag.DisplayComment</em><a class="headerlink" href="#hou.nodeFlag.DisplayComment" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.nodeFlag.DisplayDescriptiveName">
<code class="descname">DisplayDescriptiveName</code><em class="property"> = nodeFlag.DisplayDescriptiveName</em><a class="headerlink" href="#hou.nodeFlag.DisplayDescriptiveName" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.nodeFlag.Export">
<code class="descname">Export</code><em class="property"> = nodeFlag.Export</em><a class="headerlink" href="#hou.nodeFlag.Export" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.nodeFlag.Expose">
<code class="descname">Expose</code><em class="property"> = nodeFlag.Expose</em><a class="headerlink" href="#hou.nodeFlag.Expose" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.nodeFlag.Footprint">
<code class="descname">Footprint</code><em class="property"> = nodeFlag.Footprint</em><a class="headerlink" href="#hou.nodeFlag.Footprint" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.nodeFlag.Highlight">
<code class="descname">Highlight</code><em class="property"> = nodeFlag.Highlight</em><a class="headerlink" href="#hou.nodeFlag.Highlight" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.nodeFlag.InOutDetailHigh">
<code class="descname">InOutDetailHigh</code><em class="property"> = nodeFlag.InOutDetailHigh</em><a class="headerlink" href="#hou.nodeFlag.InOutDetailHigh" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.nodeFlag.InOutDetailLow">
<code class="descname">InOutDetailLow</code><em class="property"> = nodeFlag.InOutDetailLow</em><a class="headerlink" href="#hou.nodeFlag.InOutDetailLow" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.nodeFlag.InOutDetailMedium">
<code class="descname">InOutDetailMedium</code><em class="property"> = nodeFlag.InOutDetailMedium</em><a class="headerlink" href="#hou.nodeFlag.InOutDetailMedium" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.nodeFlag.Lock">
<code class="descname">Lock</code><em class="property"> = nodeFlag.Lock</em><a class="headerlink" href="#hou.nodeFlag.Lock" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.nodeFlag.Material">
<code class="descname">Material</code><em class="property"> = nodeFlag.Material</em><a class="headerlink" href="#hou.nodeFlag.Material" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.nodeFlag.Origin">
<code class="descname">Origin</code><em class="property"> = nodeFlag.Origin</em><a class="headerlink" href="#hou.nodeFlag.Origin" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.nodeFlag.Pick">
<code class="descname">Pick</code><em class="property"> = nodeFlag.Pick</em><a class="headerlink" href="#hou.nodeFlag.Pick" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.nodeFlag.Render">
<code class="descname">Render</code><em class="property"> = nodeFlag.Render</em><a class="headerlink" href="#hou.nodeFlag.Render" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.nodeFlag.Selectable">
<code class="descname">Selectable</code><em class="property"> = nodeFlag.Selectable</em><a class="headerlink" href="#hou.nodeFlag.Selectable" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.nodeFlag.SoftLock">
<code class="descname">SoftLock</code><em class="property"> = nodeFlag.SoftLock</em><a class="headerlink" href="#hou.nodeFlag.SoftLock" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.nodeFlag.Template">
<code class="descname">Template</code><em class="property"> = nodeFlag.Template</em><a class="headerlink" href="#hou.nodeFlag.Template" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.nodeFlag.Unload">
<code class="descname">Unload</code><em class="property"> = nodeFlag.Unload</em><a class="headerlink" href="#hou.nodeFlag.Unload" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.nodeFlag.Visible">
<code class="descname">Visible</code><em class="property"> = nodeFlag.Visible</em><a class="headerlink" href="#hou.nodeFlag.Visible" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.nodeFlag.XRay">
<code class="descname">XRay</code><em class="property"> = nodeFlag.XRay</em><a class="headerlink" href="#hou.nodeFlag.XRay" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.nodeFlag.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.nodeFlag.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="hou.nodeType">
<code class="descclassname">hou.</code><code class="descname">nodeType</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.nodeType" title="Permalink to this definition"></a></dt>
<dd><p>Given a node type category object and a name, or possibly just a node
type name that includes the category, return the corresponding NodeType
object. The exact name is assumed so node type aliases are not
evaluated. To check aliases use hou.preferredNodeType() instead. Return
None if there is no such type with that name.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>nodeType(category, name) -&gt; NodeType or None</dd>
<dt>category</dt>
<dd><p class="first">A hou.NodeTypeCategory object (_not_ a string). You can use the
hou.nodeTypeCategories() function to get a dict of category name
strings to NodeTypeCategory objects. You can also use the helper
functions hou.sopNodeTypeCategory, hou.objNodeTypeCategory, etc.</p>
<p class="last">Note that this parameter is optional. If omitted, the name parameter
must contain the node type category.</p>
</dd>
<dt>name</dt>
<dd><p class="first">The internal name of a node type. To get the internal name of any
node type in Houdini, right-click a node of that type and choose
Type properties. The internal name is listed at the top of the type
properties window beside <em>Operator type</em>. For example, the internal
name of the Geometry object is geo.</p>
<p class="last">If the category parameter is omitted, the name must include the
category name. For example, you can pass Object/geo to get the
Geometry objects node type.</p>
</dd>
</dl>
<p>EXAMPLES</p>
<blockquote>
<div>&gt; # The following four ways of looking up the copy SOPs node type are equivalent:
&gt; &gt;&gt;&gt; hou.nodeType(Sop/copy)
&gt; &lt;hou.SopNodeType for Sop copy&gt;
&gt; 
&gt; &gt;&gt;&gt; hou.nodeType(hou.sopNodeTypeCategory(), copy)
&gt; &lt;hou.SopNodeType for Sop copy&gt;
&gt; 
&gt; &gt;&gt;&gt; hou.sopNodeTypeCategory().nodeTypes()[copy]
&gt; &lt;hou.SopNodeType for Sop copy&gt;
&gt; 
&gt; &gt;&gt;&gt; hou.nodeType(hou.nodeTypeCategories()[Sop], copy)
&gt; &lt;hou.SopNodeType for Sop copy&gt;</div></blockquote>
<p>REPLACES</p>
<blockquote>
<div><ul class="simple">
<li>optype</li>
<li>optype()</li>
<li>optypeinfo()</li>
</ul>
</div></blockquote>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.NodeType</li>
<li>hou.NodeTypeCategory</li>
<li>hou.NodeTypeCategory.nodeTypes</li>
<li>hou.nodeTypeCategories</li>
<li>hou.preferredNodeType</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.nodeTypeCategories">
<code class="descclassname">hou.</code><code class="descname">nodeTypeCategories</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.nodeTypeCategories" title="Permalink to this definition"></a></dt>
<dd><p>Return a dictionary where the keys are the category names (e.g.
Object, Sop) and the values are hou.NodeTypeCategory objects.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>nodeTypeCategories() -&gt; dict of str to hou.NodeTypeCategory</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="hou.nodeTypeFilter">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">nodeTypeFilter</code><a class="headerlink" href="#hou.nodeTypeFilter" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Enumeration of available node type filters.</p>
<p>These filters are used by node bundles to limit the nodes in the bundle
based on type.</p>
<p>VALUES</p>
<blockquote>
<div><dl class="docutils">
<dt>NoFilter</dt>
<dd>Any node</dd>
<dt>Sop</dt>
<dd>Any SOP</dd>
<dt>Dop</dt>
<dd>Any DOP</dd>
<dt>Pop</dt>
<dd>Any POP</dd>
<dt>Popnet</dt>
<dd>Any POP Network</dd>
<dt>Chop</dt>
<dd>Any CHOP</dd>
<dt>Chopnet</dt>
<dd>Any CHOP Network</dd>
<dt>Cop</dt>
<dd>Any COP</dd>
<dt>Copnet</dt>
<dd>Any COP Network</dd>
<dt>Vop</dt>
<dd>Any VOP</dd>
<dt>Vopnet</dt>
<dd>Any VOP Network</dd>
<dt>Rop</dt>
<dd>Any ROP</dd>
<dt>Lop</dt>
<dd>Any LOP</dd>
<dt>Shop</dt>
<dd>Any SHOP</dd>
<dt>Obj</dt>
<dd>Any Object</dd>
<dt>ObjBone</dt>
<dd>Object: Bone Only</dd>
<dt>ObjCamera</dt>
<dd>Object: Camera Only</dd>
<dt>ObjFog</dt>
<dd>Object: Fog Only</dd>
<dt>ObjGeometry</dt>
<dd>Object: Geometry Only</dd>
<dt>ObjGeometryOrFog</dt>
<dd>Object: Geometry and Fog Only</dd>
<dt>ObjLight</dt>
<dd>Object: Light Only</dd>
<dt>ObjMuscle</dt>
<dd>Object: Muscle Only</dd>
<dt>ObjSubnet</dt>
<dd>Object: Muscle Only</dd>
<dt>ShopAtmosphere</dt>
<dd>Shop: Atmosphere Only</dd>
<dt>ShopCVEX</dt>
<dd>Shop: CVEX Only</dd>
<dt>ShopDisplacement</dt>
<dd>Shop: Displacement Only</dd>
<dt>ShopImage3D</dt>
<dd>Shop: Image3D Only</dd>
<dt>ShopInterior</dt>
<dd>Shop: Interior Only</dd>
<dt>ShopLight</dt>
<dd>Shop: Light Only</dd>
<dt>ShopLightShadow</dt>
<dd>Shop: Light Shadow Only</dd>
<dt>ShopShopMaterial</dt>
<dd>Shop: Material Only</dd>
<dt>ShopPhoton</dt>
<dd>Shop: Photon Only</dd>
<dt>ShopProperties</dt>
<dd>Shop: Properties Only</dd>
<dt>ShopSurface</dt>
<dd>Shop: Surface Only</dd>
</dl>
</div></blockquote>
<dl class="attribute">
<dt id="hou.nodeTypeFilter.Chop">
<code class="descname">Chop</code><em class="property"> = nodeTypeFilter.Chop</em><a class="headerlink" href="#hou.nodeTypeFilter.Chop" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.nodeTypeFilter.Chopnet">
<code class="descname">Chopnet</code><em class="property"> = nodeTypeFilter.Chopnet</em><a class="headerlink" href="#hou.nodeTypeFilter.Chopnet" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.nodeTypeFilter.Cop">
<code class="descname">Cop</code><em class="property"> = nodeTypeFilter.Cop</em><a class="headerlink" href="#hou.nodeTypeFilter.Cop" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.nodeTypeFilter.Copnet">
<code class="descname">Copnet</code><em class="property"> = nodeTypeFilter.Copnet</em><a class="headerlink" href="#hou.nodeTypeFilter.Copnet" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.nodeTypeFilter.Dop">
<code class="descname">Dop</code><em class="property"> = nodeTypeFilter.Dop</em><a class="headerlink" href="#hou.nodeTypeFilter.Dop" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.nodeTypeFilter.Lop">
<code class="descname">Lop</code><em class="property"> = nodeTypeFilter.Lop</em><a class="headerlink" href="#hou.nodeTypeFilter.Lop" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.nodeTypeFilter.NoFilter">
<code class="descname">NoFilter</code><em class="property"> = nodeTypeFilter.NoFilter</em><a class="headerlink" href="#hou.nodeTypeFilter.NoFilter" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.nodeTypeFilter.Obj">
<code class="descname">Obj</code><em class="property"> = nodeTypeFilter.Obj</em><a class="headerlink" href="#hou.nodeTypeFilter.Obj" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.nodeTypeFilter.ObjBone">
<code class="descname">ObjBone</code><em class="property"> = nodeTypeFilter.ObjBone</em><a class="headerlink" href="#hou.nodeTypeFilter.ObjBone" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.nodeTypeFilter.ObjCamera">
<code class="descname">ObjCamera</code><em class="property"> = nodeTypeFilter.ObjCamera</em><a class="headerlink" href="#hou.nodeTypeFilter.ObjCamera" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.nodeTypeFilter.ObjFog">
<code class="descname">ObjFog</code><em class="property"> = nodeTypeFilter.ObjFog</em><a class="headerlink" href="#hou.nodeTypeFilter.ObjFog" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.nodeTypeFilter.ObjGeometry">
<code class="descname">ObjGeometry</code><em class="property"> = nodeTypeFilter.ObjGeometry</em><a class="headerlink" href="#hou.nodeTypeFilter.ObjGeometry" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.nodeTypeFilter.ObjGeometryOrFog">
<code class="descname">ObjGeometryOrFog</code><em class="property"> = nodeTypeFilter.ObjGeometryOrFog</em><a class="headerlink" href="#hou.nodeTypeFilter.ObjGeometryOrFog" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.nodeTypeFilter.ObjLight">
<code class="descname">ObjLight</code><em class="property"> = nodeTypeFilter.ObjLight</em><a class="headerlink" href="#hou.nodeTypeFilter.ObjLight" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.nodeTypeFilter.ObjMuscle">
<code class="descname">ObjMuscle</code><em class="property"> = nodeTypeFilter.ObjMuscle</em><a class="headerlink" href="#hou.nodeTypeFilter.ObjMuscle" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.nodeTypeFilter.ObjSubnet">
<code class="descname">ObjSubnet</code><em class="property"> = nodeTypeFilter.ObjSubnet</em><a class="headerlink" href="#hou.nodeTypeFilter.ObjSubnet" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.nodeTypeFilter.Pop">
<code class="descname">Pop</code><em class="property"> = nodeTypeFilter.Pop</em><a class="headerlink" href="#hou.nodeTypeFilter.Pop" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.nodeTypeFilter.Popnet">
<code class="descname">Popnet</code><em class="property"> = nodeTypeFilter.Popnet</em><a class="headerlink" href="#hou.nodeTypeFilter.Popnet" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.nodeTypeFilter.Rop">
<code class="descname">Rop</code><em class="property"> = nodeTypeFilter.Rop</em><a class="headerlink" href="#hou.nodeTypeFilter.Rop" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.nodeTypeFilter.Shop">
<code class="descname">Shop</code><em class="property"> = nodeTypeFilter.Shop</em><a class="headerlink" href="#hou.nodeTypeFilter.Shop" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.nodeTypeFilter.ShopAtmosphere">
<code class="descname">ShopAtmosphere</code><em class="property"> = nodeTypeFilter.ShopAtmosphere</em><a class="headerlink" href="#hou.nodeTypeFilter.ShopAtmosphere" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.nodeTypeFilter.ShopCVEX">
<code class="descname">ShopCVEX</code><em class="property"> = nodeTypeFilter.ShopCVEX</em><a class="headerlink" href="#hou.nodeTypeFilter.ShopCVEX" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.nodeTypeFilter.ShopDisplacement">
<code class="descname">ShopDisplacement</code><em class="property"> = nodeTypeFilter.ShopDisplacement</em><a class="headerlink" href="#hou.nodeTypeFilter.ShopDisplacement" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.nodeTypeFilter.ShopImage3D">
<code class="descname">ShopImage3D</code><em class="property"> = nodeTypeFilter.ShopImage3D</em><a class="headerlink" href="#hou.nodeTypeFilter.ShopImage3D" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.nodeTypeFilter.ShopInterior">
<code class="descname">ShopInterior</code><em class="property"> = nodeTypeFilter.ShopInterior</em><a class="headerlink" href="#hou.nodeTypeFilter.ShopInterior" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.nodeTypeFilter.ShopLight">
<code class="descname">ShopLight</code><em class="property"> = nodeTypeFilter.ShopLight</em><a class="headerlink" href="#hou.nodeTypeFilter.ShopLight" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.nodeTypeFilter.ShopLightShadow">
<code class="descname">ShopLightShadow</code><em class="property"> = nodeTypeFilter.ShopLightShadow</em><a class="headerlink" href="#hou.nodeTypeFilter.ShopLightShadow" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.nodeTypeFilter.ShopMaterial">
<code class="descname">ShopMaterial</code><em class="property"> = nodeTypeFilter.ShopMaterial</em><a class="headerlink" href="#hou.nodeTypeFilter.ShopMaterial" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.nodeTypeFilter.ShopPhoton">
<code class="descname">ShopPhoton</code><em class="property"> = nodeTypeFilter.ShopPhoton</em><a class="headerlink" href="#hou.nodeTypeFilter.ShopPhoton" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.nodeTypeFilter.ShopProperties">
<code class="descname">ShopProperties</code><em class="property"> = nodeTypeFilter.ShopProperties</em><a class="headerlink" href="#hou.nodeTypeFilter.ShopProperties" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.nodeTypeFilter.ShopSurface">
<code class="descname">ShopSurface</code><em class="property"> = nodeTypeFilter.ShopSurface</em><a class="headerlink" href="#hou.nodeTypeFilter.ShopSurface" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.nodeTypeFilter.Sop">
<code class="descname">Sop</code><em class="property"> = nodeTypeFilter.Sop</em><a class="headerlink" href="#hou.nodeTypeFilter.Sop" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.nodeTypeFilter.Vop">
<code class="descname">Vop</code><em class="property"> = nodeTypeFilter.Vop</em><a class="headerlink" href="#hou.nodeTypeFilter.Vop" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.nodeTypeFilter.Vopnet">
<code class="descname">Vopnet</code><em class="property"> = nodeTypeFilter.Vopnet</em><a class="headerlink" href="#hou.nodeTypeFilter.Vopnet" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.nodeTypeFilter.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.nodeTypeFilter.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.nodeTypeSource">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">nodeTypeSource</code><a class="headerlink" href="#hou.nodeTypeSource" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Enumeration of node type sources.</p>
<p>VALUES</p>
<blockquote>
<div>Internal
CompiledCode
VexCode
RslCode
Subnet</div></blockquote>
<dl class="attribute">
<dt id="hou.nodeTypeSource.CompiledCode">
<code class="descname">CompiledCode</code><em class="property"> = nodeTypeSource.CompiledCode</em><a class="headerlink" href="#hou.nodeTypeSource.CompiledCode" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.nodeTypeSource.Internal">
<code class="descname">Internal</code><em class="property"> = nodeTypeSource.Internal</em><a class="headerlink" href="#hou.nodeTypeSource.Internal" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.nodeTypeSource.RslCode">
<code class="descname">RslCode</code><em class="property"> = nodeTypeSource.RslCode</em><a class="headerlink" href="#hou.nodeTypeSource.RslCode" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.nodeTypeSource.Subnet">
<code class="descname">Subnet</code><em class="property"> = nodeTypeSource.Subnet</em><a class="headerlink" href="#hou.nodeTypeSource.Subnet" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.nodeTypeSource.VexCode">
<code class="descname">VexCode</code><em class="property"> = nodeTypeSource.VexCode</em><a class="headerlink" href="#hou.nodeTypeSource.VexCode" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.nodeTypeSource.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.nodeTypeSource.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="hou.nodes">
<code class="descclassname">hou.</code><code class="descname">nodes</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.nodes" title="Permalink to this definition"></a></dt>
<dd><p>Takes a sequence of node path strings and returns a tuple of Node
objects.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>nodes(path_tuple) -&gt; tuple of hou.Node</dd>
</dl>
<p>This is like <a class="reference internal" href="#hou.node">hou.node</a> but takes multiple paths and returns multiple
node objects. See <a class="reference internal" href="#hou.node">hou.node</a> for more information.</p>
<p>&gt; paths = [/obj/geo1, /obj/geo2, /obj/geo3]
&gt; nodes = hou.nodes(paths)</p>
<p>This is the equivalent of:</p>
<p>&gt; nodes = [hou.node(path) for path in paths]</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.item</li>
<li>hou.items</li>
<li>hou.node</li>
<li>hou.pwd</li>
<li>hou.parent</li>
<li>hou.root</li>
</ul>
</div></blockquote>
<p>REPLACES</p>
<blockquote>
<div><ul class="simple">
<li>opfind</li>
<li>ch()</li>
<li>chs()</li>
<li>chsop()</li>
<li>opexist()</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="class">
<dt id="hou.numericData">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">numericData</code><a class="headerlink" href="#hou.numericData" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="attribute">
<dt id="hou.numericData.Float16">
<code class="descname">Float16</code><em class="property"> = numericData.Float16</em><a class="headerlink" href="#hou.numericData.Float16" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.numericData.Float32">
<code class="descname">Float32</code><em class="property"> = numericData.Float32</em><a class="headerlink" href="#hou.numericData.Float32" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.numericData.Float64">
<code class="descname">Float64</code><em class="property"> = numericData.Float64</em><a class="headerlink" href="#hou.numericData.Float64" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.numericData.Int16">
<code class="descname">Int16</code><em class="property"> = numericData.Int16</em><a class="headerlink" href="#hou.numericData.Int16" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.numericData.Int32">
<code class="descname">Int32</code><em class="property"> = numericData.Int32</em><a class="headerlink" href="#hou.numericData.Int32" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.numericData.Int64">
<code class="descname">Int64</code><em class="property"> = numericData.Int64</em><a class="headerlink" href="#hou.numericData.Int64" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.numericData.Int8">
<code class="descname">Int8</code><em class="property"> = numericData.Int8</em><a class="headerlink" href="#hou.numericData.Int8" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.numericData.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.numericData.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="hou.objNodeTypeCategory">
<code class="descclassname">hou.</code><code class="descname">objNodeTypeCategory</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.objNodeTypeCategory" title="Permalink to this definition"></a></dt>
<dd><p>Return the NodeTypeCategory instance for Houdini object nodes. For
example, if /obj/model is an object then
hou.node(/obj/model).type().category() is
hou.objectNodeTypeCategory().</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>objNodeTypeCategory() -&gt; NodeTypeCategory</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="hou.orientUpAxis">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">orientUpAxis</code><a class="headerlink" href="#hou.orientUpAxis" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Enumeration of global orientation mode.</p>
<p>See hou.ui.orientationUpAxis for more information.</p>
<p>VALUES</p>
<blockquote>
<div>Y
Z</div></blockquote>
<dl class="attribute">
<dt id="hou.orientUpAxis.Y">
<code class="descname">Y</code><em class="property"> = orientUpAxis.Y</em><a class="headerlink" href="#hou.orientUpAxis.Y" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.orientUpAxis.Z">
<code class="descname">Z</code><em class="property"> = orientUpAxis.Z</em><a class="headerlink" href="#hou.orientUpAxis.Z" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.orientUpAxis.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.orientUpAxis.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.paneLinkType">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">paneLinkType</code><a class="headerlink" href="#hou.paneLinkType" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Enumeration of possible pane link values.</p>
<p>VALUES</p>
<blockquote>
<div>Pinned
Group1
Group2
Group3
Group4
Group5
Group6
Group7
Group8
FollowSelection</div></blockquote>
<dl class="attribute">
<dt id="hou.paneLinkType.FollowSelection">
<code class="descname">FollowSelection</code><em class="property"> = paneLinkType.FollowSelection</em><a class="headerlink" href="#hou.paneLinkType.FollowSelection" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.paneLinkType.Group1">
<code class="descname">Group1</code><em class="property"> = paneLinkType.Group1</em><a class="headerlink" href="#hou.paneLinkType.Group1" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.paneLinkType.Group2">
<code class="descname">Group2</code><em class="property"> = paneLinkType.Group2</em><a class="headerlink" href="#hou.paneLinkType.Group2" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.paneLinkType.Group3">
<code class="descname">Group3</code><em class="property"> = paneLinkType.Group3</em><a class="headerlink" href="#hou.paneLinkType.Group3" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.paneLinkType.Group4">
<code class="descname">Group4</code><em class="property"> = paneLinkType.Group4</em><a class="headerlink" href="#hou.paneLinkType.Group4" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.paneLinkType.Group5">
<code class="descname">Group5</code><em class="property"> = paneLinkType.Group5</em><a class="headerlink" href="#hou.paneLinkType.Group5" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.paneLinkType.Group6">
<code class="descname">Group6</code><em class="property"> = paneLinkType.Group6</em><a class="headerlink" href="#hou.paneLinkType.Group6" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.paneLinkType.Group7">
<code class="descname">Group7</code><em class="property"> = paneLinkType.Group7</em><a class="headerlink" href="#hou.paneLinkType.Group7" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.paneLinkType.Group8">
<code class="descname">Group8</code><em class="property"> = paneLinkType.Group8</em><a class="headerlink" href="#hou.paneLinkType.Group8" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.paneLinkType.Group9">
<code class="descname">Group9</code><em class="property"> = paneLinkType.Group9</em><a class="headerlink" href="#hou.paneLinkType.Group9" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.paneLinkType.Pinned">
<code class="descname">Pinned</code><em class="property"> = paneLinkType.Pinned</em><a class="headerlink" href="#hou.paneLinkType.Pinned" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.paneLinkType.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.paneLinkType.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.paneTabType">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">paneTabType</code><a class="headerlink" href="#hou.paneTabType" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Enumeration of pane tab types.</p>
<p>VALUES</p>
<blockquote>
<div>SceneViewer
ChannelViewer
CompositorViewer
OutputViewer
MaterialPalette
IPRViewer
NetworkEditor
Parm
DetailsView
ChannelEditor
ChannelList
Textport
HandleList
BundleList
TakeList
TreeView
HelpBrowser
PythonPanel
ParmSpreadsheet
LightLinker
AssetBrowser
TaskGraphTable</div></blockquote>
<dl class="attribute">
<dt id="hou.paneTabType.AssetBrowser">
<code class="descname">AssetBrowser</code><em class="property"> = paneTabType.AssetBrowser</em><a class="headerlink" href="#hou.paneTabType.AssetBrowser" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.paneTabType.BundleList">
<code class="descname">BundleList</code><em class="property"> = paneTabType.BundleList</em><a class="headerlink" href="#hou.paneTabType.BundleList" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.paneTabType.ChannelEditor">
<code class="descname">ChannelEditor</code><em class="property"> = paneTabType.ChannelEditor</em><a class="headerlink" href="#hou.paneTabType.ChannelEditor" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.paneTabType.ChannelList">
<code class="descname">ChannelList</code><em class="property"> = paneTabType.ChannelList</em><a class="headerlink" href="#hou.paneTabType.ChannelList" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.paneTabType.ChannelViewer">
<code class="descname">ChannelViewer</code><em class="property"> = paneTabType.ChannelViewer</em><a class="headerlink" href="#hou.paneTabType.ChannelViewer" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.paneTabType.CompositorViewer">
<code class="descname">CompositorViewer</code><em class="property"> = paneTabType.CompositorViewer</em><a class="headerlink" href="#hou.paneTabType.CompositorViewer" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.paneTabType.ContextViewer">
<code class="descname">ContextViewer</code><em class="property"> = paneTabType.ContextViewer</em><a class="headerlink" href="#hou.paneTabType.ContextViewer" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.paneTabType.DataTree">
<code class="descname">DataTree</code><em class="property"> = paneTabType.DataTree</em><a class="headerlink" href="#hou.paneTabType.DataTree" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.paneTabType.DetailsView">
<code class="descname">DetailsView</code><em class="property"> = paneTabType.DetailsView</em><a class="headerlink" href="#hou.paneTabType.DetailsView" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.paneTabType.HandleList">
<code class="descname">HandleList</code><em class="property"> = paneTabType.HandleList</em><a class="headerlink" href="#hou.paneTabType.HandleList" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.paneTabType.HelpBrowser">
<code class="descname">HelpBrowser</code><em class="property"> = paneTabType.HelpBrowser</em><a class="headerlink" href="#hou.paneTabType.HelpBrowser" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.paneTabType.IPRViewer">
<code class="descname">IPRViewer</code><em class="property"> = paneTabType.IPRViewer</em><a class="headerlink" href="#hou.paneTabType.IPRViewer" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.paneTabType.LightLinker">
<code class="descname">LightLinker</code><em class="property"> = paneTabType.LightLinker</em><a class="headerlink" href="#hou.paneTabType.LightLinker" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.paneTabType.MaterialPalette">
<code class="descname">MaterialPalette</code><em class="property"> = paneTabType.MaterialPalette</em><a class="headerlink" href="#hou.paneTabType.MaterialPalette" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.paneTabType.NetworkEditor">
<code class="descname">NetworkEditor</code><em class="property"> = paneTabType.NetworkEditor</em><a class="headerlink" href="#hou.paneTabType.NetworkEditor" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.paneTabType.OutputViewer">
<code class="descname">OutputViewer</code><em class="property"> = paneTabType.OutputViewer</em><a class="headerlink" href="#hou.paneTabType.OutputViewer" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.paneTabType.Parm">
<code class="descname">Parm</code><em class="property"> = paneTabType.Parm</em><a class="headerlink" href="#hou.paneTabType.Parm" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.paneTabType.ParmSpreadsheet">
<code class="descname">ParmSpreadsheet</code><em class="property"> = paneTabType.ParmSpreadsheet</em><a class="headerlink" href="#hou.paneTabType.ParmSpreadsheet" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.paneTabType.PerformanceMonitor">
<code class="descname">PerformanceMonitor</code><em class="property"> = paneTabType.PerformanceMonitor</em><a class="headerlink" href="#hou.paneTabType.PerformanceMonitor" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.paneTabType.PythonPanel">
<code class="descname">PythonPanel</code><em class="property"> = paneTabType.PythonPanel</em><a class="headerlink" href="#hou.paneTabType.PythonPanel" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.paneTabType.PythonShell">
<code class="descname">PythonShell</code><em class="property"> = paneTabType.PythonShell</em><a class="headerlink" href="#hou.paneTabType.PythonShell" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.paneTabType.SceneGraphTree">
<code class="descname">SceneGraphTree</code><em class="property"> = paneTabType.SceneGraphTree</em><a class="headerlink" href="#hou.paneTabType.SceneGraphTree" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.paneTabType.SceneViewer">
<code class="descname">SceneViewer</code><em class="property"> = paneTabType.SceneViewer</em><a class="headerlink" href="#hou.paneTabType.SceneViewer" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.paneTabType.ShaderViewer">
<code class="descname">ShaderViewer</code><em class="property"> = paneTabType.ShaderViewer</em><a class="headerlink" href="#hou.paneTabType.ShaderViewer" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.paneTabType.TakeList">
<code class="descname">TakeList</code><em class="property"> = paneTabType.TakeList</em><a class="headerlink" href="#hou.paneTabType.TakeList" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.paneTabType.TaskGraphTable">
<code class="descname">TaskGraphTable</code><em class="property"> = paneTabType.TaskGraphTable</em><a class="headerlink" href="#hou.paneTabType.TaskGraphTable" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.paneTabType.Textport">
<code class="descname">Textport</code><em class="property"> = paneTabType.Textport</em><a class="headerlink" href="#hou.paneTabType.Textport" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.paneTabType.TreeView">
<code class="descname">TreeView</code><em class="property"> = paneTabType.TreeView</em><a class="headerlink" href="#hou.paneTabType.TreeView" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.paneTabType.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.paneTabType.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="hou.parent">
<code class="descclassname">hou.</code><code class="descname">parent</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.parent" title="Permalink to this definition"></a></dt>
<dd><p>Return the parent of the current node.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>parent() -&gt; hou.Node or None</dd>
</dl>
<p>This function is a shortcut for writing hou.node(..). It returns the
parent of the current node (i.e. the node returned by hou.pwd).</p>
<p>This function will raise hou.NotAvailable if you call it from MPlay.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li><a class="reference internal" href="#hou.node">hou.node</a></li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.parm">
<code class="descclassname">hou.</code><code class="descname">parm</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.parm" title="Permalink to this definition"></a></dt>
<dd><p>Given a path string, return a Parm object. Return None if the path does
not refer to a parameter.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>parm(path) -&gt; hou.Parm or None</dd>
</dl>
<p>If the path starts with a /, Houdini will look for a parameter with that
exact path. Otherwise, the Houdini searches relative to the current node
path. For each occurrence of .. in the path, Houdini will move up one
node from the current node location.</p>
<p>&gt; &gt;&gt;&gt; node = hou.node(/obj).createNode(geo)
&gt; &gt;&gt;&gt; node.path()
&gt; /obj/geo1
&gt; &gt;&gt;&gt; hou.parmTuple(/obj/geo1/t)
&gt; &lt;hou.ParmTuple t in /obj/geo1&gt;
&gt; &gt;&gt;&gt; hou.parmTuple(/obj/geo1/t)[0]
&gt; &lt;hou.Parm tx in /obj/geo1&gt;
&gt; &gt;&gt;&gt; hou.parm(/obj/geo1/tx)
&gt; &lt;hou.Parm tx in /obj/geo1&gt;
&gt; &gt;&gt;&gt; hou.setPwd(node)
&gt; &gt;&gt;&gt; hou.parm(t)
&gt; &lt;hou.Parm tx in /obj/geo1&gt;</p>
<p>Raises hou.NotAvailable if you call it from MPlay.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.Parm</li>
<li>hou.evalParm</li>
<li><a href="#id83"><span class="problematic" id="id84">hou.parmTuple_</span></a></li>
</ul>
</div></blockquote>
<p>REPLACES</p>
<blockquote>
<div><ul class="simple">
<li>ch()</li>
<li>chs()</li>
<li>chexist()</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="class">
<dt id="hou.parmBakeChop">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">parmBakeChop</code><a class="headerlink" href="#hou.parmBakeChop" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Enumeration of Bake Chop modes.</p>
<p>See hou.Parm.keyframesRefit.</p>
<p>VALUES</p>
<blockquote>
<div>Off
KeepExportFlag
DisableExportFlag
CreateDeleteChop</div></blockquote>
<dl class="attribute">
<dt id="hou.parmBakeChop.CreateDeleteChop">
<code class="descname">CreateDeleteChop</code><em class="property"> = parmBakeChop.CreateDeleteChop</em><a class="headerlink" href="#hou.parmBakeChop.CreateDeleteChop" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.parmBakeChop.DisableExportFlag">
<code class="descname">DisableExportFlag</code><em class="property"> = parmBakeChop.DisableExportFlag</em><a class="headerlink" href="#hou.parmBakeChop.DisableExportFlag" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.parmBakeChop.KeepExportFlag">
<code class="descname">KeepExportFlag</code><em class="property"> = parmBakeChop.KeepExportFlag</em><a class="headerlink" href="#hou.parmBakeChop.KeepExportFlag" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.parmBakeChop.Off">
<code class="descname">Off</code><em class="property"> = parmBakeChop.Off</em><a class="headerlink" href="#hou.parmBakeChop.Off" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.parmBakeChop.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.parmBakeChop.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="hou.parmClipboardContents">
<code class="descclassname">hou.</code><code class="descname">parmClipboardContents</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.parmClipboardContents" title="Permalink to this definition"></a></dt>
<dd><p>Returns the contents of the parameter clipboard as a tuple of copied
parameter dictionaries.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>parmClipboardContents() -&gt; tuple of dictionaries</dd>
</dl>
<p>Returns a tuple of dictionaries, one per copied hou.Parm. Each
dictionary has the following keys.</p>
<dl class="docutils">
<dt>path</dt>
<dd>The path of hou.Parm parameter when it was copied.</dd>
<dt>value</dt>
<dd>The evaluated value of the parameter when it was copied as a string.</dd>
<dt>expression</dt>
<dd>The expression of the parameter when it was copied as a string.</dd>
<dt>expressionLanguage</dt>
<dd>The expression language of the parameter when it was copied. This is
a string. To convert to a hou.exprLanguage object, use
getattr(hou.exprLanguage, expr_language_str).</dd>
</dl>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.Parm.copyToParmClipboard</li>
<li>hou.ParmTuple.copyToParmClipboard</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="class">
<dt id="hou.parmCondType">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">parmCondType</code><a class="headerlink" href="#hou.parmCondType" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Enumeration of available parameter conditional types.</p>
<p>VALUES</p>
<blockquote>
<div>DisableWhen
HideWhen
NoCookWhen</div></blockquote>
<dl class="attribute">
<dt id="hou.parmCondType.DisableWhen">
<code class="descname">DisableWhen</code><em class="property"> = parmCondType.DisableWhen</em><a class="headerlink" href="#hou.parmCondType.DisableWhen" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.parmCondType.HideWhen">
<code class="descname">HideWhen</code><em class="property"> = parmCondType.HideWhen</em><a class="headerlink" href="#hou.parmCondType.HideWhen" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.parmCondType.NoCookWhen">
<code class="descname">NoCookWhen</code><em class="property"> = parmCondType.NoCookWhen</em><a class="headerlink" href="#hou.parmCondType.NoCookWhen" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.parmCondType.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.parmCondType.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.parmData">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">parmData</code><a class="headerlink" href="#hou.parmData" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Enumeration of parameter data types.</p>
<p>VALUES</p>
<blockquote>
<div>Int
Float
String
Ramp</div></blockquote>
<dl class="attribute">
<dt id="hou.parmData.Data">
<code class="descname">Data</code><em class="property"> = parmData.Data</em><a class="headerlink" href="#hou.parmData.Data" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.parmData.Float">
<code class="descname">Float</code><em class="property"> = parmData.Float</em><a class="headerlink" href="#hou.parmData.Float" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.parmData.Int">
<code class="descname">Int</code><em class="property"> = parmData.Int</em><a class="headerlink" href="#hou.parmData.Int" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.parmData.Ramp">
<code class="descname">Ramp</code><em class="property"> = parmData.Ramp</em><a class="headerlink" href="#hou.parmData.Ramp" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.parmData.String">
<code class="descname">String</code><em class="property"> = parmData.String</em><a class="headerlink" href="#hou.parmData.String" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.parmData.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.parmData.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.parmExtrapolate">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">parmExtrapolate</code><a class="headerlink" href="#hou.parmExtrapolate" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Enumeration of Extrapolation methods when evaluating value outside the
keyframe range.</p>
<p>VALUES</p>
<blockquote>
<div>Default
Hold
Cycle
Extend
Slope
CycleOffset
Oscillate</div></blockquote>
<dl class="attribute">
<dt id="hou.parmExtrapolate.Cycle">
<code class="descname">Cycle</code><em class="property"> = parmExtrapolate.Cycle</em><a class="headerlink" href="#hou.parmExtrapolate.Cycle" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.parmExtrapolate.CycleOffset">
<code class="descname">CycleOffset</code><em class="property"> = parmExtrapolate.CycleOffset</em><a class="headerlink" href="#hou.parmExtrapolate.CycleOffset" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.parmExtrapolate.Default">
<code class="descname">Default</code><em class="property"> = parmExtrapolate.Default</em><a class="headerlink" href="#hou.parmExtrapolate.Default" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.parmExtrapolate.Extend">
<code class="descname">Extend</code><em class="property"> = parmExtrapolate.Extend</em><a class="headerlink" href="#hou.parmExtrapolate.Extend" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.parmExtrapolate.Hold">
<code class="descname">Hold</code><em class="property"> = parmExtrapolate.Hold</em><a class="headerlink" href="#hou.parmExtrapolate.Hold" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.parmExtrapolate.Oscillate">
<code class="descname">Oscillate</code><em class="property"> = parmExtrapolate.Oscillate</em><a class="headerlink" href="#hou.parmExtrapolate.Oscillate" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.parmExtrapolate.Slope">
<code class="descname">Slope</code><em class="property"> = parmExtrapolate.Slope</em><a class="headerlink" href="#hou.parmExtrapolate.Slope" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.parmExtrapolate.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.parmExtrapolate.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.parmLook">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">parmLook</code><a class="headerlink" href="#hou.parmLook" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Enumeration of available looks for a parameter</p>
<p>These looks are used by hou.ParmTemplate objects and control the user
interface of the parameter in parameter editors.</p>
<p>VALUES</p>
<blockquote>
<div><dl class="docutils">
<dt>Regular</dt>
<dd>The default parameter look.</dd>
<dt>Logarithmic</dt>
<dd>The parameter displays a slider that changes the value on a
logarithmic scale.</dd>
<dt>Angle</dt>
<dd><p class="first">The parameter has an arc control to enter an angle.</p>
<p class="last">If you use this look, set your parameters naming scheme to
hou.parmNamingScheme.Base1.</p>
</dd>
<dt>Vector</dt>
<dd><p class="first">The parameter has a handle beside the label to edit the vector
direction.</p>
<p class="last">If you use this look, set your parameters naming scheme to
hou.parmNamingScheme.XYZW.</p>
</dd>
<dt>ColorSquare</dt>
<dd><p class="first">The parameter has a square button beside the label to display
the current color. You can click on the square to edit the
color.</p>
<p class="last">If you use this look, set your parameters naming scheme to
hou.parmNamingScheme.RGBA.</p>
</dd>
<dt>HueCircle</dt>
<dd>The parameter has a hue circle with a pie-shaped region, like
the keying nodes in COPs have.</dd>
<dt>CRGBAPlaneChooser</dt>
<dd>The parameter has an RGBA mask, with buttons to toggle the red,
green, blue, and alpha planes.</dd>
</dl>
</div></blockquote>
<dl class="attribute">
<dt id="hou.parmLook.Angle">
<code class="descname">Angle</code><em class="property"> = parmLook.Angle</em><a class="headerlink" href="#hou.parmLook.Angle" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.parmLook.CRGBAPlaneChooser">
<code class="descname">CRGBAPlaneChooser</code><em class="property"> = parmLook.CRGBAPlaneChooser</em><a class="headerlink" href="#hou.parmLook.CRGBAPlaneChooser" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.parmLook.ColorSquare">
<code class="descname">ColorSquare</code><em class="property"> = parmLook.ColorSquare</em><a class="headerlink" href="#hou.parmLook.ColorSquare" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.parmLook.HueCircle">
<code class="descname">HueCircle</code><em class="property"> = parmLook.HueCircle</em><a class="headerlink" href="#hou.parmLook.HueCircle" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.parmLook.Logarithmic">
<code class="descname">Logarithmic</code><em class="property"> = parmLook.Logarithmic</em><a class="headerlink" href="#hou.parmLook.Logarithmic" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.parmLook.Regular">
<code class="descname">Regular</code><em class="property"> = parmLook.Regular</em><a class="headerlink" href="#hou.parmLook.Regular" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.parmLook.Vector">
<code class="descname">Vector</code><em class="property"> = parmLook.Vector</em><a class="headerlink" href="#hou.parmLook.Vector" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.parmLook.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.parmLook.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.parmNamingScheme">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">parmNamingScheme</code><a class="headerlink" href="#hou.parmNamingScheme" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Enumeration of available naming schemes for a parameter.</p>
<p>These naming schemes are stored inside hou.ParmTemplate objects and
determine the names of hou.Parm objects inside hou.ParmTuple objects.</p>
<p>The number of components in the parm template determines the number of
parms inside the parm tuple. If this number is 1, the parm name is the
same as the parm tuple name. If the naming scheme is Base1, the number
of components may be more than 4. Otherwise, the component may have from
2 components up to the maximum number allowed by the naming scheme.</p>
<p>The following restrictions exist on naming schemes:</p>
<blockquote>
<div><ul class="simple">
<li>You cannot use the following naming schemes when editing the
parameter interface on a node or a digital asset: MinMax, MaxMin,
StartEnd, BeginEnd, XYWH. However, some built-in node types use
parameters with these naming schemes, so asking these node types for
their parm templates may return ones using these naming schemes.</li>
<li>String and toggle parameters only support the Base1 naming scheme.</li>
<li>Parameters with the hou.parmLook.Vector look must use the XYZW
naming scheme.</li>
<li>Parameters with the hou.parmLook.Angle look must use the Base1
naming scheme.</li>
<li>Parameters with the hou.parmLook.ColorSquare look must use an RGBA
naming scheme.</li>
</ul>
</div></blockquote>
<p>The example names below are for a parm template named foo:</p>
<p>VALUES</p>
<blockquote>
<div><dl class="docutils">
<dt>Base1</dt>
<dd>foo1, foo2, foo3, </dd>
<dt>XYZW</dt>
<dd>foox, fooy, fooz, foow</dd>
<dt>XYWH</dt>
<dd>foox, fooy, foow, fooh</dd>
<dt>UVW</dt>
<dd>foou, foov, foow</dd>
<dt>RGBA</dt>
<dd>foor, foog, foob, fooa</dd>
<dt>MinMax</dt>
<dd>foomin, foomax</dd>
<dt>MaxMin</dt>
<dd>foomax, foomin</dd>
<dt>StartEnd</dt>
<dd>foostart, fooend</dd>
<dt>BeginEnd</dt>
<dd>foobegin, fooend</dd>
</dl>
</div></blockquote>
<dl class="attribute">
<dt id="hou.parmNamingScheme.Base1">
<code class="descname">Base1</code><em class="property"> = parmNamingScheme.Base1</em><a class="headerlink" href="#hou.parmNamingScheme.Base1" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.parmNamingScheme.BeginEnd">
<code class="descname">BeginEnd</code><em class="property"> = parmNamingScheme.BeginEnd</em><a class="headerlink" href="#hou.parmNamingScheme.BeginEnd" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.parmNamingScheme.MaxMin">
<code class="descname">MaxMin</code><em class="property"> = parmNamingScheme.MaxMin</em><a class="headerlink" href="#hou.parmNamingScheme.MaxMin" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.parmNamingScheme.MinMax">
<code class="descname">MinMax</code><em class="property"> = parmNamingScheme.MinMax</em><a class="headerlink" href="#hou.parmNamingScheme.MinMax" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.parmNamingScheme.RGBA">
<code class="descname">RGBA</code><em class="property"> = parmNamingScheme.RGBA</em><a class="headerlink" href="#hou.parmNamingScheme.RGBA" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.parmNamingScheme.StartEnd">
<code class="descname">StartEnd</code><em class="property"> = parmNamingScheme.StartEnd</em><a class="headerlink" href="#hou.parmNamingScheme.StartEnd" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.parmNamingScheme.UVW">
<code class="descname">UVW</code><em class="property"> = parmNamingScheme.UVW</em><a class="headerlink" href="#hou.parmNamingScheme.UVW" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.parmNamingScheme.XYWH">
<code class="descname">XYWH</code><em class="property"> = parmNamingScheme.XYWH</em><a class="headerlink" href="#hou.parmNamingScheme.XYWH" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.parmNamingScheme.XYZW">
<code class="descname">XYZW</code><em class="property"> = parmNamingScheme.XYZW</em><a class="headerlink" href="#hou.parmNamingScheme.XYZW" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.parmNamingScheme.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.parmNamingScheme.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.parmTemplateType">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">parmTemplateType</code><a class="headerlink" href="#hou.parmTemplateType" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Enumeration of parameter template types.</p>
<p>VALUES</p>
<blockquote>
<div>Int
Float
String
Toggle
Menu
Button
FolderSet
Separator
Label
Ramp</div></blockquote>
<dl class="attribute">
<dt id="hou.parmTemplateType.Button">
<code class="descname">Button</code><em class="property"> = parmTemplateType.Button</em><a class="headerlink" href="#hou.parmTemplateType.Button" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.parmTemplateType.Data">
<code class="descname">Data</code><em class="property"> = parmTemplateType.Data</em><a class="headerlink" href="#hou.parmTemplateType.Data" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.parmTemplateType.Float">
<code class="descname">Float</code><em class="property"> = parmTemplateType.Float</em><a class="headerlink" href="#hou.parmTemplateType.Float" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.parmTemplateType.Folder">
<code class="descname">Folder</code><em class="property"> = parmTemplateType.Folder</em><a class="headerlink" href="#hou.parmTemplateType.Folder" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.parmTemplateType.FolderSet">
<code class="descname">FolderSet</code><em class="property"> = parmTemplateType.FolderSet</em><a class="headerlink" href="#hou.parmTemplateType.FolderSet" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.parmTemplateType.Int">
<code class="descname">Int</code><em class="property"> = parmTemplateType.Int</em><a class="headerlink" href="#hou.parmTemplateType.Int" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.parmTemplateType.Label">
<code class="descname">Label</code><em class="property"> = parmTemplateType.Label</em><a class="headerlink" href="#hou.parmTemplateType.Label" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.parmTemplateType.Menu">
<code class="descname">Menu</code><em class="property"> = parmTemplateType.Menu</em><a class="headerlink" href="#hou.parmTemplateType.Menu" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.parmTemplateType.Ramp">
<code class="descname">Ramp</code><em class="property"> = parmTemplateType.Ramp</em><a class="headerlink" href="#hou.parmTemplateType.Ramp" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.parmTemplateType.Separator">
<code class="descname">Separator</code><em class="property"> = parmTemplateType.Separator</em><a class="headerlink" href="#hou.parmTemplateType.Separator" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.parmTemplateType.String">
<code class="descname">String</code><em class="property"> = parmTemplateType.String</em><a class="headerlink" href="#hou.parmTemplateType.String" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.parmTemplateType.Toggle">
<code class="descname">Toggle</code><em class="property"> = parmTemplateType.Toggle</em><a class="headerlink" href="#hou.parmTemplateType.Toggle" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.parmTemplateType.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.parmTemplateType.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="hou.parmTuple">
<code class="descclassname">hou.</code><code class="descname">parmTuple</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.parmTuple" title="Permalink to this definition"></a></dt>
<dd><p>Given a path string, return a ParmTuple object. Return None if the path
does not refer to a parameter tuple.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>parmTuple(path) -&gt; hou.ParmTuple or None</dd>
</dl>
<p>If the path starts with a /, Houdini will look for a parameter tuple
with that exact path. Otherwise, the Houdini searches relative to the
current node path. For each occurrence of .. in the path, Houdini will
move up one node from the current node location.</p>
<p>When a parameter is evaluating, hou.pwd returns the node containing that
parameter, so hou.parmTuple() can be used inside expressions to perform
relative parameter references.</p>
<p>&gt; &gt;&gt;&gt; node = hou.node(/obj).createNode(geo)
&gt; &gt;&gt;&gt; node.path()
&gt; /obj/geo1
&gt; &gt;&gt;&gt; hou.parmTuple(/obj/geo1/t)
&gt; &lt;hou.ParmTuple t in /obj/geo1&gt;
&gt; &gt;&gt;&gt; hou.setPwd(node)
&gt; &gt;&gt;&gt; hou.parmTuple(tx)
&gt; &lt;hou.ParmTuple t in /obj/geo1&gt;</p>
<p>Raises hou.NotAvailable if you call it from MPlay.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.ParmTuple</li>
<li>hou.evalParmTuple</li>
<li><a class="reference internal" href="#hou.parm">hou.parm</a></li>
</ul>
</div></blockquote>
<p>REPLACES</p>
<blockquote>
<div><ul class="simple">
<li>ch()</li>
<li>chexist()</li>
<li>chramp()</li>
<li>chs()</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.pasteNodesFromClipboard">
<code class="descclassname">hou.</code><code class="descname">pasteNodesFromClipboard</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.pasteNodesFromClipboard" title="Permalink to this definition"></a></dt>
<dd><p>Paste previously copied nodes to a given network.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>pasteNodesFromClipboard(destination_node)</dd>
</dl>
<p>This function pastes nodes from clipboard into the destination network.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.copyNodesToClipboard</li>
</ul>
</div></blockquote>
<p>REPLACES</p>
<blockquote>
<div><ul class="simple">
<li>oppaste</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.patternMatch">
<code class="descclassname">hou.</code><code class="descname">patternMatch</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.patternMatch" title="Permalink to this definition"></a></dt>
<dd><p>Matches a pattern in a string.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>patternMatch(pattern_string, input_string, ignore_case = False,
path_match = False) -&gt; int</dd>
</dl>
<p>This function is case-sensitive. Set ignore_case to True for case-
insensitive pattern matching.</p>
<p>This function does not treat path separator characters specially. Set
path_match to True for path-aware matching, where the multi-level
wildcard (**) is required to cover multiple path components.</p>
<p>Returns 1 if any patterns in the pattern string matches the input
string, or 0 if no patterns match.</p>
<p>In order to match, a pattern must match the input string from beginning
to end. Use wildcards (*) to match substrings, e.g.</p>
<p>&gt; &gt;&gt;&gt; hou.patternMatch(bar, foobarbaz)
&gt; 0
&gt; &gt;&gt;&gt; hou.patternMatch(<em>bar</em>, foobarbaz)
&gt; 1</p>
<p>pattern is a space-separated list of one or more patterns. This can
cause unintuitive behavior of this function. For example:</p>
<p>&gt; &gt;&gt;&gt; hou.patternMatch(foo bar, foo bar)
&gt; 0</p>
<p>will return 0, because the first argument consists of two patterns,
foo and bar, and neither of those patterns match foo bar (since the
pattern must match from beginning to end).</p>
<p>Similarly,</p>
<p>&gt; &gt;&gt;&gt; hou.patternMatch(foo bar, foo)
&gt; 1</p>
<p>will return 1, because the string matches the first of the two
arguments in the pattern (foo and bar).</p>
<p>&gt; &gt;&gt;&gt; hou.patternMatch(/foo/<a href="#id47"><span class="problematic" id="id48">*</span></a>, /foo/bar/blah, path_match = True)
&gt; 0</p>
<p>will return 0, because the wildcard only matches against the first
path component (/bar), leaving the last path component (/blah)
unmatched.</p>
<p>&gt; &gt;&gt;&gt; hou.patternMatch(/foo/<a href="#id49"><span class="problematic" id="id50">**</span></a>, /foo/bar/blah, path_match = True)
&gt; 1</p>
<p>will return 1, because the multi-level wildcard will matches against
any number of path components.</p>
</dd></dl>

<dl class="class">
<dt id="hou.perfMonObjectView">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">perfMonObjectView</code><a class="headerlink" href="#hou.perfMonObjectView" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Enumeration of the different structures that are used to view objects in
the Performance Monitor panetab.</p>
<p>VALUES</p>
<blockquote>
<div>List
Tree
EventLog</div></blockquote>
<dl class="attribute">
<dt id="hou.perfMonObjectView.EventLog">
<code class="descname">EventLog</code><em class="property"> = perfMonObjectView.EventLog</em><a class="headerlink" href="#hou.perfMonObjectView.EventLog" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.perfMonObjectView.List">
<code class="descname">List</code><em class="property"> = perfMonObjectView.List</em><a class="headerlink" href="#hou.perfMonObjectView.List" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.perfMonObjectView.Tree">
<code class="descname">Tree</code><em class="property"> = perfMonObjectView.Tree</em><a class="headerlink" href="#hou.perfMonObjectView.Tree" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.perfMonObjectView.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.perfMonObjectView.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.perfMonTimeFormat">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">perfMonTimeFormat</code><a class="headerlink" href="#hou.perfMonTimeFormat" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Enumeration of the different formats used when viewing times in the
Performance Monitor panetab.</p>
<p>VALUES</p>
<blockquote>
<div>Absolute
Percent</div></blockquote>
<dl class="attribute">
<dt id="hou.perfMonTimeFormat.Absolute">
<code class="descname">Absolute</code><em class="property"> = perfMonTimeFormat.Absolute</em><a class="headerlink" href="#hou.perfMonTimeFormat.Absolute" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.perfMonTimeFormat.Percent">
<code class="descname">Percent</code><em class="property"> = perfMonTimeFormat.Percent</em><a class="headerlink" href="#hou.perfMonTimeFormat.Percent" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.perfMonTimeFormat.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.perfMonTimeFormat.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="hou.phm">
<code class="descclassname">hou.</code><code class="descname">phm</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.phm" title="Permalink to this definition"></a></dt>
<dd><p>A shortcut for hou.pwd().hdaModule().</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>phm() -&gt; hou.HDAModule</dd>
</dl>
<p>This shortcut lets you write hou.phm() instead of hou.pwd().hdaModule().
You are most likely to use this shortcut from event handlers, button
callbacks, and menu generation scripts in digital assets.</p>
<p>See hou.pwd and hou.Node.hdaModule for more information.</p>
</dd></dl>

<dl class="class">
<dt id="hou.pickFacing">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">pickFacing</code><a class="headerlink" href="#hou.pickFacing" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Enumeration for describing the facing direction of pickable components.</p>
<p>VALUES</p>
<blockquote>
<div>Front
Back
FrontAndBack</div></blockquote>
<dl class="attribute">
<dt id="hou.pickFacing.Back">
<code class="descname">Back</code><em class="property"> = pickFacing.Back</em><a class="headerlink" href="#hou.pickFacing.Back" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.pickFacing.Front">
<code class="descname">Front</code><em class="property"> = pickFacing.Front</em><a class="headerlink" href="#hou.pickFacing.Front" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.pickFacing.FrontAndBack">
<code class="descname">FrontAndBack</code><em class="property"> = pickFacing.FrontAndBack</em><a class="headerlink" href="#hou.pickFacing.FrontAndBack" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.pickFacing.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.pickFacing.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.pickModifier">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">pickModifier</code><a class="headerlink" href="#hou.pickModifier" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Enumeration of methods for modifying selections with new components.</p>
<p>VALUES</p>
<blockquote>
<div>Add
Toggle
Remove
Replace
Intersect</div></blockquote>
<dl class="attribute">
<dt id="hou.pickModifier.Add">
<code class="descname">Add</code><em class="property"> = pickModifier.Add</em><a class="headerlink" href="#hou.pickModifier.Add" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.pickModifier.Intersect">
<code class="descname">Intersect</code><em class="property"> = pickModifier.Intersect</em><a class="headerlink" href="#hou.pickModifier.Intersect" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.pickModifier.Remove">
<code class="descname">Remove</code><em class="property"> = pickModifier.Remove</em><a class="headerlink" href="#hou.pickModifier.Remove" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.pickModifier.Replace">
<code class="descname">Replace</code><em class="property"> = pickModifier.Replace</em><a class="headerlink" href="#hou.pickModifier.Replace" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.pickModifier.Toggle">
<code class="descname">Toggle</code><em class="property"> = pickModifier.Toggle</em><a class="headerlink" href="#hou.pickModifier.Toggle" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.pickModifier.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.pickModifier.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.pickStyle">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">pickStyle</code><a class="headerlink" href="#hou.pickStyle" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Enumeration of pick styles.</p>
<p>VALUES</p>
<blockquote>
<div>Box
Lasso
Brush
Laser</div></blockquote>
<dl class="attribute">
<dt id="hou.pickStyle.Box">
<code class="descname">Box</code><em class="property"> = pickStyle.Box</em><a class="headerlink" href="#hou.pickStyle.Box" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.pickStyle.Brush">
<code class="descname">Brush</code><em class="property"> = pickStyle.Brush</em><a class="headerlink" href="#hou.pickStyle.Brush" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.pickStyle.Laser">
<code class="descname">Laser</code><em class="property"> = pickStyle.Laser</em><a class="headerlink" href="#hou.pickStyle.Laser" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.pickStyle.Lasso">
<code class="descname">Lasso</code><em class="property"> = pickStyle.Lasso</em><a class="headerlink" href="#hou.pickStyle.Lasso" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.pickStyle.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.pickStyle.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.playMode">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">playMode</code><a class="headerlink" href="#hou.playMode" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Enumeration of play modes for the main playbar in Houdini.</p>
<p>VALUES</p>
<blockquote>
<div><dl class="docutils">
<dt>Loop</dt>
<dd>Play through the frame range and when reaching the end of the
range loop back to the beginning and continue the playback.</dd>
<dt>Once</dt>
<dd>Play through the frame range and when reaching the end of the
range stop the playback.</dd>
<dt>Zigzag</dt>
<dd>Play through the frame range and when reaching the end of the
range reverse the playback. When the reverse playback reaches
the beginning of the range, then continue playback in the
forward direction, etc.</dd>
</dl>
</div></blockquote>
<dl class="attribute">
<dt id="hou.playMode.Loop">
<code class="descname">Loop</code><em class="property"> = playMode.Loop</em><a class="headerlink" href="#hou.playMode.Loop" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.playMode.Once">
<code class="descname">Once</code><em class="property"> = playMode.Once</em><a class="headerlink" href="#hou.playMode.Once" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.playMode.Zigzag">
<code class="descname">Zigzag</code><em class="property"> = playMode.Zigzag</em><a class="headerlink" href="#hou.playMode.Zigzag" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.playMode.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.playMode.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.playbarEvent">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">playbarEvent</code><a class="headerlink" href="#hou.playbarEvent" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Enumeration of the playbar events that can be handled by callback
functions.</p>
<p>See hou.playbar.addEventCallback.</p>
<p>VALUES</p>
<blockquote>
<div><dl class="docutils">
<dt>Started</dt>
<dd>This event is triggered when the playbar has started playback
either in the forward or reverse direction.</dd>
<dt>Stopped</dt>
<dd>This event is triggered when running playback has stopped.</dd>
<dt>FrameChanged</dt>
<dd>This event is triggered when the playbar has changed to another
frame and after the scene has been cooked for the new frame.</dd>
</dl>
</div></blockquote>
<dl class="attribute">
<dt id="hou.playbarEvent.FrameChanged">
<code class="descname">FrameChanged</code><em class="property"> = playbarEvent.FrameChanged</em><a class="headerlink" href="#hou.playbarEvent.FrameChanged" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.playbarEvent.Started">
<code class="descname">Started</code><em class="property"> = playbarEvent.Started</em><a class="headerlink" href="#hou.playbarEvent.Started" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.playbarEvent.Stopped">
<code class="descname">Stopped</code><em class="property"> = playbarEvent.Stopped</em><a class="headerlink" href="#hou.playbarEvent.Stopped" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.playbarEvent.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.playbarEvent.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="hou.popNetNodeTypeCategory">
<code class="descclassname">hou.</code><code class="descname">popNetNodeTypeCategory</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.popNetNodeTypeCategory" title="Permalink to this definition"></a></dt>
<dd><p>Return the NodeTypeCategory instance for Houdini particle container
(popnet) nodes.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>popNetNodeTypeCategory() -&gt; NodeTypeCategory</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="hou.popNodeTypeCategory">
<code class="descclassname">hou.</code><code class="descname">popNodeTypeCategory</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.popNodeTypeCategory" title="Permalink to this definition"></a></dt>
<dd><p>Return the NodeTypeCategory instance for Houdini particle (pop) nodes.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>popNodeTypeCategory() -&gt; NodeTypeCategory</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="hou.positionType">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">positionType</code><a class="headerlink" href="#hou.positionType" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Enumeration of spaces.</p>
<p>VALUES</p>
<blockquote>
<div>WorldSpace
ViewportXY
ViewportUV</div></blockquote>
<dl class="attribute">
<dt id="hou.positionType.ViewportUV">
<code class="descname">ViewportUV</code><em class="property"> = positionType.ViewportUV</em><a class="headerlink" href="#hou.positionType.ViewportUV" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.positionType.ViewportXY">
<code class="descname">ViewportXY</code><em class="property"> = positionType.ViewportXY</em><a class="headerlink" href="#hou.positionType.ViewportXY" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.positionType.WorldSpace">
<code class="descname">WorldSpace</code><em class="property"> = positionType.WorldSpace</em><a class="headerlink" href="#hou.positionType.WorldSpace" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.positionType.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.positionType.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="hou.preferredNodeType">
<code class="descclassname">hou.</code><code class="descname">preferredNodeType</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.preferredNodeType" title="Permalink to this definition"></a></dt>
<dd><p>Given a node type name that includes the category and optionally a
parent node, return the corresponding NodeType object after evaluating
aliases. Return None if there is no such type with that name.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>preferredNodeType(name, parent_node=None) -&gt; NodeType or None</dd>
<dt>name</dt>
<dd>The internal name of a node type including the category. To get the
internal name of any node type in Houdini, right-click a node of
that type and choose Type properties. The internal name is listed at
the top of the type properties window beside <em>Operator type</em>. For
example, the internal name of the Geometry object is geo.</dd>
<dt>parent_node</dt>
<dd>Optional. The node that will be the parent for this node type.</dd>
</dl>
<p>EXAMPLES</p>
<blockquote>
<div>&gt; &gt;&gt;&gt; hou.preferredNodeType(Shop/pyro)
&gt; &lt;hou.ShopNodeType for Shop pyro::3.0&gt;
&gt; 
&gt; &gt;&gt;&gt; hou.preferredNodeType(Shop/pyro, hou.node(/shop))
&gt; &lt;hou.ShopNodeType for Shop pyro::3.0&gt;</div></blockquote>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.NodeType</li>
<li>hou.nodeType</li>
<li>hou.nodeTypeCategories</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="class">
<dt id="hou.primType">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">primType</code><a class="headerlink" href="#hou.primType" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Enumeration of primitive types.</p>
<p>VALUES</p>
<blockquote>
<div><p>Agent
AlembicRef
BezierCurve
BezierSurface
Circle
Custom</p>
<blockquote>
<div>Catch-all for all HDK-defined primitives types.</div></blockquote>
<p>Mesh
Metaball
NURBSCurve
NURBSSurface
PackedFragment
PackedGeometry
PackedPrim
ParticleSystem
PastedSurface
Polygon
PolySoup
Sphere
Tetrahedron
TriangleBezier
TriangleFan
TriangleStrip
Tube
Unknown
VDB
Volume</p>
</div></blockquote>
<dl class="attribute">
<dt id="hou.primType.Agent">
<code class="descname">Agent</code><em class="property"> = primType.Agent</em><a class="headerlink" href="#hou.primType.Agent" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.primType.AlembicRef">
<code class="descname">AlembicRef</code><em class="property"> = primType.AlembicRef</em><a class="headerlink" href="#hou.primType.AlembicRef" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.primType.BezierCurve">
<code class="descname">BezierCurve</code><em class="property"> = primType.BezierCurve</em><a class="headerlink" href="#hou.primType.BezierCurve" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.primType.BezierSurface">
<code class="descname">BezierSurface</code><em class="property"> = primType.BezierSurface</em><a class="headerlink" href="#hou.primType.BezierSurface" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.primType.Circle">
<code class="descname">Circle</code><em class="property"> = primType.Circle</em><a class="headerlink" href="#hou.primType.Circle" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.primType.Custom">
<code class="descname">Custom</code><em class="property"> = primType.Custom</em><a class="headerlink" href="#hou.primType.Custom" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.primType.Mesh">
<code class="descname">Mesh</code><em class="property"> = primType.Mesh</em><a class="headerlink" href="#hou.primType.Mesh" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.primType.Metaball">
<code class="descname">Metaball</code><em class="property"> = primType.Metaball</em><a class="headerlink" href="#hou.primType.Metaball" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.primType.NURBSCurve">
<code class="descname">NURBSCurve</code><em class="property"> = primType.NURBSCurve</em><a class="headerlink" href="#hou.primType.NURBSCurve" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.primType.NURBSSurface">
<code class="descname">NURBSSurface</code><em class="property"> = primType.NURBSSurface</em><a class="headerlink" href="#hou.primType.NURBSSurface" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.primType.PackedFragment">
<code class="descname">PackedFragment</code><em class="property"> = primType.PackedFragment</em><a class="headerlink" href="#hou.primType.PackedFragment" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.primType.PackedGeometry">
<code class="descname">PackedGeometry</code><em class="property"> = primType.PackedGeometry</em><a class="headerlink" href="#hou.primType.PackedGeometry" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.primType.PackedPrim">
<code class="descname">PackedPrim</code><em class="property"> = primType.PackedPrim</em><a class="headerlink" href="#hou.primType.PackedPrim" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.primType.ParticleSystem">
<code class="descname">ParticleSystem</code><em class="property"> = primType.ParticleSystem</em><a class="headerlink" href="#hou.primType.ParticleSystem" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.primType.PastedSurface">
<code class="descname">PastedSurface</code><em class="property"> = primType.PastedSurface</em><a class="headerlink" href="#hou.primType.PastedSurface" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.primType.PolySoup">
<code class="descname">PolySoup</code><em class="property"> = primType.PolySoup</em><a class="headerlink" href="#hou.primType.PolySoup" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.primType.Polygon">
<code class="descname">Polygon</code><em class="property"> = primType.Polygon</em><a class="headerlink" href="#hou.primType.Polygon" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.primType.Sphere">
<code class="descname">Sphere</code><em class="property"> = primType.Sphere</em><a class="headerlink" href="#hou.primType.Sphere" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.primType.Tetrahedron">
<code class="descname">Tetrahedron</code><em class="property"> = primType.Tetrahedron</em><a class="headerlink" href="#hou.primType.Tetrahedron" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.primType.TriangleBezier">
<code class="descname">TriangleBezier</code><em class="property"> = primType.TriangleBezier</em><a class="headerlink" href="#hou.primType.TriangleBezier" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.primType.TriangleFan">
<code class="descname">TriangleFan</code><em class="property"> = primType.TriangleFan</em><a class="headerlink" href="#hou.primType.TriangleFan" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.primType.TriangleStrip">
<code class="descname">TriangleStrip</code><em class="property"> = primType.TriangleStrip</em><a class="headerlink" href="#hou.primType.TriangleStrip" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.primType.Tube">
<code class="descname">Tube</code><em class="property"> = primType.Tube</em><a class="headerlink" href="#hou.primType.Tube" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.primType.Unknown">
<code class="descname">Unknown</code><em class="property"> = primType.Unknown</em><a class="headerlink" href="#hou.primType.Unknown" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.primType.VDB">
<code class="descname">VDB</code><em class="property"> = primType.VDB</em><a class="headerlink" href="#hou.primType.VDB" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.primType.Volume">
<code class="descname">Volume</code><em class="property"> = primType.Volume</em><a class="headerlink" href="#hou.primType.Volume" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.primType.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.primType.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.promptMessageType">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">promptMessageType</code><a class="headerlink" href="#hou.promptMessageType" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Viewport Prompt Message Type</p>
<p>Defines the type of messages that can be used with
hou.SceneViewer.setPromptMessage.</p>
<p>VALUES</p>
<blockquote>
<div><dl class="docutils">
<dt>hou.promptMessageType.Error</dt>
<dd>Specifies an error message displayed in bold red.</dd>
<dt>hou.promptMessageType.Message</dt>
<dd>Specifies a regular message displayed in black.</dd>
<dt>hou.promptMessageType.Prompt</dt>
<dd>Specifies a prompt message displayed in bold blue.</dd>
<dt>hou.promptMessageType.Warning</dt>
<dd>Specifies a warning message displayed in bold yellow.</dd>
</dl>
</div></blockquote>
<dl class="attribute">
<dt id="hou.promptMessageType.Error">
<code class="descname">Error</code><em class="property"> = promptMessageType.Error</em><a class="headerlink" href="#hou.promptMessageType.Error" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.promptMessageType.Message">
<code class="descname">Message</code><em class="property"> = promptMessageType.Message</em><a class="headerlink" href="#hou.promptMessageType.Message" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.promptMessageType.Prompt">
<code class="descname">Prompt</code><em class="property"> = promptMessageType.Prompt</em><a class="headerlink" href="#hou.promptMessageType.Prompt" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.promptMessageType.Warning">
<code class="descname">Warning</code><em class="property"> = promptMessageType.Warning</em><a class="headerlink" href="#hou.promptMessageType.Warning" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.promptMessageType.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.promptMessageType.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="hou.putenv">
<code class="descclassname">hou.</code><code class="descname">putenv</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.putenv" title="Permalink to this definition"></a></dt>
<dd><p>Set the value of the specified Houdini environment variable.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>putenv(name, value)</dd>
</dl>
<p>Set the value of the specified Houdini environment variable.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.getenv</li>
<li>hou.unsetenv</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.pwd">
<code class="descclassname">hou.</code><code class="descname">pwd</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.pwd" title="Permalink to this definition"></a></dt>
<dd><p>If called from an evaluating parm, return the node containing the parm.
Otherwise, return Houdinis global current node. You can change this
current node with hou.cd</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>pwd() -&gt; hou.Node</dd>
</dl>
<p>This function is a shortcut for writing hou.node(.).</p>
<p>Note that Python and hscript both share the same global current node.
So, if you change that node in hscript, the return value of pwd() will
reflect that change, and vice versa.</p>
<p>Note that if this function is called from an expression inside a nodes
parameter, Houdini will return the node containing the expression, not
Houdinis current node. This behavior permits relative parameter and
node references from both Hscript and Python parameter expressions,
since functions like hou.ch, ch(), hou.evalParm, <a class="reference internal" href="#hou.parm">hou.parm</a>, and
<a class="reference internal" href="#hou.node">hou.node</a> are relative to the result of hou.pwd().</p>
<p>This function will raise hou.NotAvailable if you call it from MPlay.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.cd</li>
<li>hou.parent</li>
</ul>
</div></blockquote>
<p>REPLACES</p>
<blockquote>
<div><ul class="simple">
<li>oppwf</li>
<li>oppwf()</li>
<li>oppwd()</li>
<li>opfullpath()</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.qlinear">
<code class="descclassname">hou.</code><code class="descname">qlinear</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.qlinear" title="Permalink to this definition"></a></dt>
<dd><p>Linearly interpolates between keyframes using quaternions.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>qlinear() -&gt; float</dd>
</dl>
<p>The neighboring parameters must also be animated; for example, if rx
uses qlinear(), ry and rz should also use qlinear().</p>
<p>Because the interpolation is done in quaternion spaces, the orientations
will blend smoothly with no gimbal lock or unexpected spins. The Euler
rotation values may appear to jump suddenly, but thats simply because
different rotation values can represent the same orientation.</p>
<p>Note that the graph editor will display a qlinear() segment as a dashed
straight line. This line does not represent the actual intermediate
channel values, but it does give an accurate visual feel for the
behavior of the interpolation.</p>
<p>This function is one of the special animation functions that use the
current playbar time and information in the parameters keyframes, such
as in and out values, tangents, acceleration, etc., to evaluate
themselves. Because the information needed to evaluate these functions
comes from the keyframes, these functions take few or no parameters.</p>
<p>Calling this function from outside a parameters expression will raise a
hou.NotAvailable exception.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.bezier</li>
<li>hou.constant</li>
<li>hou.cubic</li>
<li>hou.cycle</li>
<li>hou.cyclet</li>
<li>hou.ease</li>
<li>hou.easein</li>
<li>hou.easeinp</li>
<li>hou.easeout</li>
<li>hou.easeoutp</li>
<li>hou.easep</li>
<li>hou.linear</li>
<li>hou.match</li>
<li>hou.matchin</li>
<li>hou.matchout</li>
<li>hou.quintic</li>
<li>hou.repeat</li>
<li>hou.repeatt</li>
<li>hou.spline</li>
<li>hou.vmatch</li>
<li>hou.vmatchin</li>
<li>hou.vmatchout</li>
</ul>
</div></blockquote>
<p>REPLACES</p>
<blockquote>
<div><ul class="simple">
<li>qlinear()</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.quintic">
<code class="descclassname">hou.</code><code class="descname">quintic</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.quintic" title="Permalink to this definition"></a></dt>
<dd><p>Evaluate an interpolation function for an animated parameter that gives
a smooth curve between the left keyframes outgoing value and the right
keyframes incoming value, using the lefts outgoing slope and
acceleration and the rights incoming slope and acceleration.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>quintic() -&gt; float</dd>
</dl>
<p>This function is one of the special animation functions that use the
current playbar time and information in the parameters keyframes, such
as in and out values, tangents, acceleration, etc., to evaluate
themselves. Because the information needed to evaluate these functions
comes from the keyframes, these functions take few or no parameters.</p>
<p>Calling this function from outside a parameters expression will raise a
hou.NotAvailable exception.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.bezier</li>
<li>hou.constant</li>
<li>hou.cubic</li>
<li>hou.cycle</li>
<li>hou.cyclet</li>
<li>hou.ease</li>
<li>hou.easein</li>
<li>hou.easeinp</li>
<li>hou.easeout</li>
<li>hou.easeoutp</li>
<li>hou.easep</li>
<li>hou.linear</li>
<li>hou.match</li>
<li>hou.matchin</li>
<li>hou.matchout</li>
<li>hou.qlinear</li>
<li>hou.repeat</li>
<li>hou.repeatt</li>
<li>hou.spline</li>
<li>hou.vmatch</li>
<li>hou.vmatchin</li>
<li>hou.vmatchout</li>
</ul>
</div></blockquote>
<p>REPLACES</p>
<blockquote>
<div><ul class="simple">
<li>quintic()</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="class">
<dt id="hou.radialItemLocation">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">radialItemLocation</code><a class="headerlink" href="#hou.radialItemLocation" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Enumeration of locations for radial menu items in Houdini.</p>
<p>VALUES</p>
<blockquote>
<div><dl class="docutils">
<dt>Top</dt>
<dd>Specifies top location of a radial menu item.</dd>
<dt>TopLeft</dt>
<dd>Specifies top left location of a radial menu item.</dd>
<dt>Left</dt>
<dd>Specifies left location of a radial menu item.</dd>
<dt>BottomLeft</dt>
<dd>Specifies bottom left location of a radial menu item.</dd>
<dt>Bottom</dt>
<dd>Specifies bottom location of a radial menu item.</dd>
<dt>BottomRight</dt>
<dd>Specifies bottom right location of a radial menu item.</dd>
<dt>Right</dt>
<dd>Specifies right location of a radial menu item.</dd>
<dt>TopRight</dt>
<dd>Specifies top right location of a radial menu item.</dd>
</dl>
</div></blockquote>
<dl class="attribute">
<dt id="hou.radialItemLocation.Bottom">
<code class="descname">Bottom</code><em class="property"> = radialItemLocation.Bottom</em><a class="headerlink" href="#hou.radialItemLocation.Bottom" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.radialItemLocation.BottomLeft">
<code class="descname">BottomLeft</code><em class="property"> = radialItemLocation.BottomLeft</em><a class="headerlink" href="#hou.radialItemLocation.BottomLeft" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.radialItemLocation.BottomRight">
<code class="descname">BottomRight</code><em class="property"> = radialItemLocation.BottomRight</em><a class="headerlink" href="#hou.radialItemLocation.BottomRight" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.radialItemLocation.Left">
<code class="descname">Left</code><em class="property"> = radialItemLocation.Left</em><a class="headerlink" href="#hou.radialItemLocation.Left" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.radialItemLocation.Right">
<code class="descname">Right</code><em class="property"> = radialItemLocation.Right</em><a class="headerlink" href="#hou.radialItemLocation.Right" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.radialItemLocation.Top">
<code class="descname">Top</code><em class="property"> = radialItemLocation.Top</em><a class="headerlink" href="#hou.radialItemLocation.Top" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.radialItemLocation.TopLeft">
<code class="descname">TopLeft</code><em class="property"> = radialItemLocation.TopLeft</em><a class="headerlink" href="#hou.radialItemLocation.TopLeft" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.radialItemLocation.TopRight">
<code class="descname">TopRight</code><em class="property"> = radialItemLocation.TopRight</em><a class="headerlink" href="#hou.radialItemLocation.TopRight" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.radialItemLocation.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.radialItemLocation.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.radialItemType">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">radialItemType</code><a class="headerlink" href="#hou.radialItemType" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Enumeration of types for radial menu items in Houdini.</p>
<p>VALUES</p>
<blockquote>
<div><dl class="docutils">
<dt>Script</dt>
<dd>Specifies a script radial menu item.</dd>
<dt>Submenu</dt>
<dd>Specifies a submenu radial menu item.</dd>
<dt>Menu</dt>
<dd>Specifies a radial menu.</dd>
</dl>
</div></blockquote>
<dl class="attribute">
<dt id="hou.radialItemType.Menu">
<code class="descname">Menu</code><em class="property"> = radialItemType.Menu</em><a class="headerlink" href="#hou.radialItemType.Menu" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.radialItemType.Script">
<code class="descname">Script</code><em class="property"> = radialItemType.Script</em><a class="headerlink" href="#hou.radialItemType.Script" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.radialItemType.Submenu">
<code class="descname">Submenu</code><em class="property"> = radialItemType.Submenu</em><a class="headerlink" href="#hou.radialItemType.Submenu" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.radialItemType.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.radialItemType.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.rampBasis">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">rampBasis</code><a class="headerlink" href="#hou.rampBasis" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Enumeration of ramp interpolation types.</p>
<p>These interpolation types specify how Houdini interpolates between
keyframed values in a hou.Ramp. See hou.Ramp.basis and hou.Ramp.__init__
for more information about how to get and set ramp interpolation types.</p>
<p>VALUES</p>
<blockquote>
<div><dl class="docutils">
<dt>Linear</dt>
<dd>Does a linear (straight line) interpolation between keys.</dd>
<dt>Constant</dt>
<dd>Holds the value constant until the next key.</dd>
<dt>CatmullRom</dt>
<dd>Interpolates smoothly between the keys. See Catmull-Rom_spline.</dd>
<dt>MonotoneCubic</dt>
<dd>Another smooth interpolation that ensures that there is no
overshoot. For example, if a keys value is smaller than the
values in the adjacent keys, this type ensures that the
interpolated value is never less than the keys value.</dd>
<dt>Bezier</dt>
<dd>Cubic Bezier curve that interpolates every third control point
and uses the other points to shape the curve. See Bezier curve.</dd>
<dt>BSpline</dt>
<dd>Cubic curve where the control points influence the shape of the
curve locally (that is, they influence only a section of the
curve). See B-Spline.</dd>
<dt>Hermite</dt>
<dd>Cubic Hermite curve that interpolates the odd control points,
while even control points control the tangent at the previous
interpolation point. See Hermite spline.</dd>
</dl>
</div></blockquote>
<dl class="attribute">
<dt id="hou.rampBasis.BSpline">
<code class="descname">BSpline</code><em class="property"> = rampBasis.BSpline</em><a class="headerlink" href="#hou.rampBasis.BSpline" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.rampBasis.Bezier">
<code class="descname">Bezier</code><em class="property"> = rampBasis.Bezier</em><a class="headerlink" href="#hou.rampBasis.Bezier" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.rampBasis.CatmullRom">
<code class="descname">CatmullRom</code><em class="property"> = rampBasis.CatmullRom</em><a class="headerlink" href="#hou.rampBasis.CatmullRom" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.rampBasis.Constant">
<code class="descname">Constant</code><em class="property"> = rampBasis.Constant</em><a class="headerlink" href="#hou.rampBasis.Constant" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.rampBasis.Hermite">
<code class="descname">Hermite</code><em class="property"> = rampBasis.Hermite</em><a class="headerlink" href="#hou.rampBasis.Hermite" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.rampBasis.Linear">
<code class="descname">Linear</code><em class="property"> = rampBasis.Linear</em><a class="headerlink" href="#hou.rampBasis.Linear" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.rampBasis.MonotoneCubic">
<code class="descname">MonotoneCubic</code><em class="property"> = rampBasis.MonotoneCubic</em><a class="headerlink" href="#hou.rampBasis.MonotoneCubic" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.rampBasis.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.rampBasis.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.rampParmType">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">rampParmType</code><a class="headerlink" href="#hou.rampParmType" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Enumeration of ramp types.</p>
<p>VALUES</p>
<blockquote>
<div>Color
Float</div></blockquote>
<p>:</p>
<blockquote>
<div><ul class="simple">
<li>hou.RampParmTemplate</li>
</ul>
</div></blockquote>
<dl class="attribute">
<dt id="hou.rampParmType.Color">
<code class="descname">Color</code><em class="property"> = rampParmType.Color</em><a class="headerlink" href="#hou.rampParmType.Color" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.rampParmType.Float">
<code class="descname">Float</code><em class="property"> = rampParmType.Float</em><a class="headerlink" href="#hou.rampParmType.Float" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.rampParmType.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.rampParmType.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="hou.readFile">
<code class="descclassname">hou.</code><code class="descname">readFile</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.readFile" title="Permalink to this definition"></a></dt>
<dd><p>Read a file, returning the contents in a string. Supports regular files,
opdef: and oplib: paths, and http URLs.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>readFile(file_path) -&gt; string</dd>
</dl>
<p>Opdef paths can be specified with the string opdef:/node?section (e.g.
opdef:/Object/subnet1?my_section). Oplib paths can be specified with
oplib:/operator?operator (e.g. oplib:/Cop2/grain?Cop2/grain).</p>
<p>If the file does not exist or an error occurs while reading, this
function raises hou.OperationFailed.</p>
</dd></dl>

<dl class="function">
<dt id="hou.releaseLicense">
<code class="descclassname">hou.</code><code class="descname">releaseLicense</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.releaseLicense" title="Permalink to this definition"></a></dt>
<dd><p>Release the currently held Houdini license.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>releaseLicense()</dd>
</dl>
<p>When you import the hou module into a Python shell, it will acquire a
Houdini license. This function exists so you can release that license
when youre done using the hou module. This way, you can have a long
running Python script that periodically uses Houdini without having to
hold a Houdini license for the entire duration of the script.</p>
<p>After you release the license, it will automatically be reacquired when
you access functions and objects from the hou module.</p>
</dd></dl>

<dl class="class">
<dt id="hou.renderMethod">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">renderMethod</code><a class="headerlink" href="#hou.renderMethod" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Enumeration of dependency rendering methods.</p>
<p>VALUES</p>
<blockquote>
<div>RopByRop
FrameByFrame</div></blockquote>
<dl class="attribute">
<dt id="hou.renderMethod.FrameByFrame">
<code class="descname">FrameByFrame</code><em class="property"> = renderMethod.FrameByFrame</em><a class="headerlink" href="#hou.renderMethod.FrameByFrame" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.renderMethod.RopByRop">
<code class="descname">RopByRop</code><em class="property"> = renderMethod.RopByRop</em><a class="headerlink" href="#hou.renderMethod.RopByRop" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.renderMethod.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.renderMethod.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="hou.repeat">
<code class="descclassname">hou.</code><code class="descname">repeat</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.repeat" title="Permalink to this definition"></a></dt>
<dd><p>Repeats the motion between two times.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>repeat(start_frame, end_frame) -&gt; float</dd>
</dl>
<p>The repeated values are repeated exactly. If you want to line up the
values with the value of the previous keyframe, use hou.cycle() instead.</p>
<p>This function is the same as hou.repeatt() except hou.repeatt() accepts
times instead of frames.</p>
<p>This function is one of the special animation functions that use the
current playbar time and information in the parameters keyframes, such
as in and out values, tangents, acceleration, etc., to evaluate
themselves. Because the information needed to evaluate these functions
comes from the keyframes, these functions take few or no parameters.</p>
<p>Calling this function from outside a parameters expression will raise a
hou.NotAvailable exception.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.bezier</li>
<li>hou.constant</li>
<li>hou.cubic</li>
<li>hou.cycle</li>
<li>hou.cyclet</li>
<li>hou.ease</li>
<li>hou.easein</li>
<li>hou.easeinp</li>
<li>hou.easeout</li>
<li>hou.easeoutp</li>
<li>hou.easep</li>
<li>hou.linear</li>
<li>hou.match</li>
<li>hou.matchin</li>
<li>hou.matchout</li>
<li>hou.qlinear</li>
<li>hou.quintic</li>
<li>hou.repeatt</li>
<li>hou.spline</li>
<li>hou.vmatch</li>
<li>hou.vmatchin</li>
<li>hou.vmatchout</li>
</ul>
</div></blockquote>
<p>REPLACES</p>
<blockquote>
<div><ul class="simple">
<li>repeat()</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.repeatt">
<code class="descclassname">hou.</code><code class="descname">repeatt</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.repeatt" title="Permalink to this definition"></a></dt>
<dd><p>Repeats the motion between two times.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>repeatt(start_time, end_time) -&gt; float</dd>
</dl>
<p>The repeated values are repeated exactly. If you want to line up the
values with the value of the previous keyframe, use hou.cyclet()
instead.</p>
<p>This function is the same as hou.repeat() except hou.repeat() it accepts
frames instead of times.</p>
<p>This function is one of the special animation functions that use the
current playbar time and information in the parameters keyframes, such
as in and out values, tangents, acceleration, etc., to evaluate
themselves. Because the information needed to evaluate these functions
comes from the keyframes, these functions take few or no parameters.</p>
<p>Calling this function from outside a parameters expression will raise a
hou.NotAvailable exception.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.bezier</li>
<li>hou.constant</li>
<li>hou.cubic</li>
<li>hou.cycle</li>
<li>hou.cycleoffset</li>
<li>hou.cyclet</li>
<li>hou.ease</li>
<li>hou.easein</li>
<li>hou.easeinp</li>
<li>hou.easeout</li>
<li>hou.easeoutp</li>
<li>hou.easep</li>
<li>hou.linear</li>
<li>hou.match</li>
<li>hou.matchin</li>
<li>hou.matchout</li>
<li>hou.qlinear</li>
<li>hou.quintic</li>
<li>hou.spline</li>
<li>hou.vmatch</li>
<li>hou.vmatchin</li>
<li>hou.vmatchout</li>
</ul>
</div></blockquote>
<p>REPLACES</p>
<blockquote>
<div><ul class="simple">
<li>repeatt()</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.root">
<code class="descclassname">hou.</code><code class="descname">root</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.root" title="Permalink to this definition"></a></dt>
<dd><p>Return the root node (i.e. /).</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>root() -&gt; hou.Node</dd>
</dl>
<p>This function is a shortcut for writing hou.node(/).</p>
<p>This function will raise hou.NotAvailable if you call it from MPlay.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li><a class="reference internal" href="#hou.node">hou.node</a></li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.rootNodeTypeCategory">
<code class="descclassname">hou.</code><code class="descname">rootNodeTypeCategory</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.rootNodeTypeCategory" title="Permalink to this definition"></a></dt>
<dd><p>Return the NodeTypeCategory instance for Houdini root (/) node. There is
only one instance of the root node, and it has its own node type
category.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>rootNodeTypeCategory() -&gt; NodeTypeCategory</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="hou.ropNodeTypeCategory">
<code class="descclassname">hou.</code><code class="descname">ropNodeTypeCategory</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.ropNodeTypeCategory" title="Permalink to this definition"></a></dt>
<dd><p>Return the NodeTypeCategory instance for Houdini output (rop) nodes.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>ropNodeTypeCategory() -&gt; NodeTypeCategory</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="hou.runVex">
<code class="descclassname">hou.</code><code class="descname">runVex</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.runVex" title="Permalink to this definition"></a></dt>
<dd><p>Invoke VEX code, passing in arrays of inputs and receiving arrays of
outputs.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>runVex(vex_file, inputs, precision=32) -&gt; dict of str to values</dd>
<dt>inputs</dt>
<dd><p class="first">A dictionary mapping VEX input names to values. Each value may be a
tuple or a single value; tuples of values become varying inputs and
single values become uniform inputs. If the input value is a tuple,
all elements in the tuple must be the same type.</p>
<p>Values may be single values or tuples of the following types: int,
float, str, hou.Vector3, hou.Vector4, hou.Matrix3, or hou.Matrix4.</p>
<p class="last">The precision argument can either be 32 or 64 (but not anything
else). 64 instructs VEX to run in 64 bit mode.</p>
</dd>
<dt>return value</dt>
<dd>A dictionary mapping VEX output names to values. Like the inputs
dictionary, values will be tuples if the output is varying and
single values if it is uniform.</dd>
</dl>
<p>For example, suppose you had the following VEX function and compiled it
to the file code.vex using vcc:</p>
<p>&gt; cvex add(float x=0; float y=0; export float out=0)
&gt; {
&gt;     out = x + y;
&gt; }</p>
<p>You could then invoke it from Python using the following:</p>
<p>&gt; &gt;&gt;&gt; hou.runVex(code.vex, {x:(1.0, 2.0, 3.0), y:(7.1, 8.1, 9.1)})
&gt; {out: (8.1, 10.1, 12.1)}
&gt; &gt;&gt;&gt; hou.runVex(code.vex, {x:(1.0, 2.0, 3.0), y:0.5})
&gt; {out: (1.5, 2.5, 3.5)}
&gt; &gt;&gt;&gt; hou.runVex(code.vex, {x:1.0, y:0.5})
&gt; {out: 1.5}
&gt; &gt;&gt;&gt; hou.runVex(code.vex, {x:1.0, y:0.5}, precision=64)
&gt; {out: 1.5}</p>
<p>The following function shows how you can run VEX on the code created by
a VOP network node, such as a CVEX VOP:</p>
<p>&gt; import os
&gt; import tempdir
&gt; 
&gt; def runVexFromNode(vop_node, inputs):
&gt;     temp_file_path = tempfile.gettempdir() + /%s.vex % vop_node.name()
&gt;     vop_node.saveCompiledCookCodeToFile(temp_file_path)
&gt;     os.unlink(temp_file_path)</p>
</dd></dl>

<dl class="function">
<dt id="hou.saveCPIODataToString">
<code class="descclassname">hou.</code><code class="descname">saveCPIODataToString</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.saveCPIODataToString" title="Permalink to this definition"></a></dt>
<dd><p>Given a sequence of (name, value) string tuples, encode that data into a
string in CPIO format.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>saveCPIODataToString(data_tuples) -&gt; str</dd>
</dl>
<p>The inverse of this function is hou.loadCPIODataFromString. See it for
more information about CPIO data format.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.loadCPIODataFromString</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.saveImageDataToFile">
<code class="descclassname">hou.</code><code class="descname">saveImageDataToFile</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.saveImageDataToFile" title="Permalink to this definition"></a></dt>
<dd><p>Create an image file from color and alpha pixel data.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>saveImageDataToFile(color_and_alpha_data, width, height, file_name)</dd>
<dt>color_and_alpha_data</dt>
<dd><p class="first">Either a sequence of floats or a string containing the image data.
The data must be in interleaved format, meaning that the first 4
values are the red, green, blue, and alpha (RGBA) values for the
first pixel, the next 4 are for the second pixel, and so on. The
first row of pixels in the data corresponds to the top scanline in
the image.</p>
<p>The length of this sequence must be width * height * 4.</p>
<p class="last">If you are writing a .pic file, the file will store 32-bit float
data if you pass in a sequence of floats and 8-bit unsigned data if
you pass in a string.</p>
</dd>
<dt>width, height</dt>
<dd>The width and height of the image to be written.</dd>
<dt>file_name</dt>
<dd>The name of the output image file to create. Houdini will
automatically determine which type of file to create based on this
files extension.</dd>
</dl>
<p>This function provides two features not provided by other imaging
libraries:</p>
<blockquote>
<div><ul class="simple">
<li>It lets you create files in Houdinis .pic format.</li>
<li>It lets you save images with 32-bit float data.</li>
</ul>
</div></blockquote>
<p>Raises hou.OperationFailed if the data is not the correct size, the
output file could not be created, or the output file format is not
supported by Houdini.</p>
<p>The following example uses the Python imaging library (PIL) to read in a
file and calls this function to write it out. Using the convertImage
function below, you can convert any image that can be read by PIL into
Houdinis .pic format.</p>
<p>&gt; import Image
&gt; 
&gt; def convertImage(input_image, output_image):
&gt;     im = Image.open(input_image)
&gt;     im.mode != RGBA:
&gt;         raise ValueError(The image must contain alpha information)
&gt;     hou.saveImageDataToFile(im.tostring(), im.size[0], im.size[1], output_image)
&gt; 
&gt; convertImage(image.png, image.pic)</p>
<p>See also Writing a COP in Python.</p>
</dd></dl>

<dl class="function">
<dt id="hou.saveIndexDataToFile">
<code class="descclassname">hou.</code><code class="descname">saveIndexDataToFile</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.saveIndexDataToFile" title="Permalink to this definition"></a></dt>
<dd><p>Given a dictionary mapping strings to strings, encode that data in index
data format and save it into a file.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>saveIndexDataToFile(file_path, index_data)</dd>
</dl>
<p>This function could be implemented as follows:</p>
<p>&gt; def saveIndexDataToFile(file_path, index_data):
&gt;     with open(file_path, wb) as open_file:
&gt;         open_file.write(hou.saveIndexDataToString(index_data))</p>
<p>See hou.loadIndexDataFromString for more details.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.loadIndexDataFromFile</li>
<li>hou.loadIndexDataFromString</li>
<li>hou.saveIndexDataToString</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.saveIndexDataToString">
<code class="descclassname">hou.</code><code class="descname">saveIndexDataToString</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.saveIndexDataToString" title="Permalink to this definition"></a></dt>
<dd><p>Given a dictionary mapping strings to strings, encode that data into a
string in index data format.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>saveIndexDataToString(data_dict) -&gt; str</dd>
</dl>
<p>The inverse of this function is hou.loadIndexDataFromString. See it for
more information about index data format.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.loadIndexDataFromString</li>
<li>hou.loadIndexDataFromFile</li>
<li>hou.saveIndexDataToFile</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="class">
<dt id="hou.saveMode">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">saveMode</code><a class="headerlink" href="#hou.saveMode" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Enumeration of hip file save modes.</p>
<p>VALUES</p>
<blockquote>
<div><dl class="docutils">
<dt>Text</dt>
<dd>Save in an ASCII format that is friendly to version control and
can be viewed and edited as plain text. This format is
compatible with Houdini 16 and above only and is only available
with a full commercial license.</dd>
<dt>Binary</dt>
<dd>Traditional binary hip file format. This is both smaller and
more performant than the text format.</dd>
</dl>
</div></blockquote>
<dl class="attribute">
<dt id="hou.saveMode.Binary">
<code class="descname">Binary</code><em class="property"> = saveMode.Binary</em><a class="headerlink" href="#hou.saveMode.Binary" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.saveMode.Text">
<code class="descname">Text</code><em class="property"> = saveMode.Text</em><a class="headerlink" href="#hou.saveMode.Text" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.saveMode.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.saveMode.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.scenePrimMask">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">scenePrimMask</code><a class="headerlink" href="#hou.scenePrimMask" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Scene Graph Selection Mask</p>
<p>Defines the primitive types that can be selected by
SceneViewer.selectSceneGraph() if the caller wishes to override the
current scene viewer selection mask.</p>
<p>VALUES</p>
<blockquote>
<div><dl class="docutils">
<dt>hou.scenePrimMask.All</dt>
<dd>All primitive types can be selected.</dd>
<dt>hou.scenePrimMask.Camera</dt>
<dd>Only camera primitive types can be selected.</dd>
<dt>hou.scenePrimMask.Geometry</dt>
<dd>Only geometry primitive types can be selected.</dd>
<dt>hou.scenePrimMask.Light</dt>
<dd>Only light primitive types can be selected.</dd>
<dt>hou.scenePrimMask.LightAndCamera</dt>
<dd>Only light and camera primitive types can be selected.</dd>
<dt>hou.scenePrimMask.ViewerSetting</dt>
<dd>Use the viewer setting for the primitive selection mask
(default).</dd>
</dl>
</div></blockquote>
<dl class="attribute">
<dt id="hou.scenePrimMask.All">
<code class="descname">All</code><em class="property"> = scenePrimMask.All</em><a class="headerlink" href="#hou.scenePrimMask.All" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.scenePrimMask.Camera">
<code class="descname">Camera</code><em class="property"> = scenePrimMask.Camera</em><a class="headerlink" href="#hou.scenePrimMask.Camera" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.scenePrimMask.Geometry">
<code class="descname">Geometry</code><em class="property"> = scenePrimMask.Geometry</em><a class="headerlink" href="#hou.scenePrimMask.Geometry" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.scenePrimMask.Light">
<code class="descname">Light</code><em class="property"> = scenePrimMask.Light</em><a class="headerlink" href="#hou.scenePrimMask.Light" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.scenePrimMask.LightAndCamera">
<code class="descname">LightAndCamera</code><em class="property"> = scenePrimMask.LightAndCamera</em><a class="headerlink" href="#hou.scenePrimMask.LightAndCamera" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.scenePrimMask.ViewerSetting">
<code class="descname">ViewerSetting</code><em class="property"> = scenePrimMask.ViewerSetting</em><a class="headerlink" href="#hou.scenePrimMask.ViewerSetting" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.scenePrimMask.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.scenePrimMask.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.scriptLanguage">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">scriptLanguage</code><a class="headerlink" href="#hou.scriptLanguage" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Enumeration of available script languages.</p>
<p>VALUES</p>
<blockquote>
<div>Python
Hscript</div></blockquote>
<dl class="attribute">
<dt id="hou.scriptLanguage.Hscript">
<code class="descname">Hscript</code><em class="property"> = scriptLanguage.Hscript</em><a class="headerlink" href="#hou.scriptLanguage.Hscript" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.scriptLanguage.Python">
<code class="descname">Python</code><em class="property"> = scriptLanguage.Python</em><a class="headerlink" href="#hou.scriptLanguage.Python" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.scriptLanguage.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.scriptLanguage.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="hou.selectedConnections">
<code class="descclassname">hou.</code><code class="descname">selectedConnections</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.selectedConnections" title="Permalink to this definition"></a></dt>
<dd><p>Return a list of all selected node connections.</p>
<p>selectedConnections() -&gt; tuple of hou.NodeConnection</p>
<p>The following example will print the name of the input node for all
selected connections:</p>
<p>&gt; for conn in hou.selectedConnections():
&gt;     print conn.inputNode().name()</p>
</dd></dl>

<dl class="function">
<dt id="hou.selectedItems">
<code class="descclassname">hou.</code><code class="descname">selectedItems</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.selectedItems" title="Permalink to this definition"></a></dt>
<dd><p>Return a list of all selected nodes, network boxes, sticky notes, subnet
indirect inputs, and network dots.</p>
<p>selectedItems(include_hidden=False) -&gt; tuple of hou.NetworkMovableItem</p>
<p>If include_hidden is False, hidden nodes will not in the result, even if
they are selected. See hou.Node.isHidden for more information about
hidden nodes. Other item types do not support hiding and so are
unaffected by the value of this parameter.</p>
<p>The following example will print the positions of all selected items:</p>
<p>&gt; for n in hou.selectedItems():
&gt;     print n.position()</p>
</dd></dl>

<dl class="function">
<dt id="hou.selectedNodeBundles">
<code class="descclassname">hou.</code><code class="descname">selectedNodeBundles</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.selectedNodeBundles" title="Permalink to this definition"></a></dt>
<dd><p>Return a tuple containing all the node bundles that are selected in the
bundle list pane.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>selectedNodeBundles() -&gt; tuple of hou.NodeBundle</dd>
</dl>
<p>This function is a shortcut for [bundle for bundle in hou.nodeBundles()
if bundle.isSelected].</p>
<p>See hou.NodeBundle for more information about bundles.</p>
<p>REPLACES</p>
<blockquote>
<div><ul class="simple">
<li>opbls</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.selectedNodes">
<code class="descclassname">hou.</code><code class="descname">selectedNodes</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.selectedNodes" title="Permalink to this definition"></a></dt>
<dd><p>Return a list of all selected nodes.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>selectedNodes(include_hidden=False) -&gt; tuple of hou.Node</dd>
</dl>
<p>Returns a sequence of hou.Node objects representing the nodes that are
currently selected.</p>
<p>&gt; print(The following nodes are currently selected:)
&gt; for node in hou.selectedNodes():
&gt;     print(node.path())</p>
<p>The last selected item has special meaning in Houdini: it controls what
network unpinned panes focus on.</p>
<p>&gt; selected = hou.selectedNodes()
&gt; # In Python, a negative index counts from the end
&gt; print(Following:, selected[-1])</p>
<dl class="docutils">
<dt>include_hidden</dt>
<dd>Normally, hidden nodes will not be included in the results, even if
they are selected. Use include_hidden=True to get the selected
hidden nodes as well. See hou.Node.isHidden for more information
about hidden nodes.</dd>
</dl>
<p>REPLACES</p>
<blockquote>
<div><ul class="simple">
<li>opselectrecurse()</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="class">
<dt id="hou.selectionMode">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">selectionMode</code><a class="headerlink" href="#hou.selectionMode" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Enumeration of selection modes.</p>
<p>See hou.SceneViewer.selectionMode.</p>
<p>VALUES</p>
<blockquote>
<div>Object
Geometry
Dynamics</div></blockquote>
<dl class="attribute">
<dt id="hou.selectionMode.Dynamics">
<code class="descname">Dynamics</code><em class="property"> = selectionMode.Dynamics</em><a class="headerlink" href="#hou.selectionMode.Dynamics" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.selectionMode.Geometry">
<code class="descname">Geometry</code><em class="property"> = selectionMode.Geometry</em><a class="headerlink" href="#hou.selectionMode.Geometry" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.selectionMode.Object">
<code class="descname">Object</code><em class="property"> = selectionMode.Object</em><a class="headerlink" href="#hou.selectionMode.Object" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.selectionMode.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.selectionMode.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="hou.sessionModuleSource">
<code class="descclassname">hou.</code><code class="descname">sessionModuleSource</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.sessionModuleSource" title="Permalink to this definition"></a></dt>
<dd><p>Returns the contents of the hou.session module.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>sessionModuleSource() -&gt; string</dd>
</dl>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.appendSessionModuleSource</li>
<li>hou.session</li>
<li>hou.setSessionModuleSource</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.setChopExportConflictResolutionPattern">
<code class="descclassname">hou.</code><code class="descname">setChopExportConflictResolutionPattern</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.setChopExportConflictResolutionPattern" title="Permalink to this definition"></a></dt>
<dd><p>Sets a CHOP node path pattern to take precedence when exporting to the
same channel.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>setChopExportConflictResolutionPattern(string pattern) -&gt; None</dd>
</dl>
<p>Sets a pattern for matching CHOP node paths that should take precedence
when there are other CHOPs that override the same channels thus leading
to conflicts.</p>
</dd></dl>

<dl class="function">
<dt id="hou.setCurrentDopNet">
<code class="descclassname">hou.</code><code class="descname">setCurrentDopNet</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.setCurrentDopNet" title="Permalink to this definition"></a></dt>
<dd><dl class="docutils">
<dt>USAGE</dt>
<dd>setCurrentDopNet(dopnet)</dd>
</dl>
<p>The current DOP network is the network the shelf tools put new nodes
into. The user can change this using the simulation menu in the bottom
right corner of the main window. This method lets you programmatically
set the current simulation network.</p>
<p>Call hou.currentDopNet to get a hou.Node object representing the current
DOP Network node.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.currentDopNet</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.setDefaultColor">
<code class="descclassname">hou.</code><code class="descname">setDefaultColor</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.setDefaultColor" title="Permalink to this definition"></a></dt>
<dd><p>Return the setDefault color for a particular network element.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>setDefaultColor(color_item, color)</dd>
</dl>
<p>Sets the default color that will be used for new network elements such
as network boxes and sticky notes. Node default colors are controlled
with methods on the hou.NodeType for each node type.</p>
<p>The color parameter can either be a hou.Color or None, in which case the
default color is cleared, and the standard default colors are used.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.colorItemType</li>
<li>hou.defaultColor</li>
<li>hou.NodeType.setDefaultColor</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.setDefaultContextOption">
<code class="descclassname">hou.</code><code class="descname">setDefaultContextOption</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.setDefaultContextOption" title="Permalink to this definition"></a></dt>
<dd><p>Sets the default value for a cook context option.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>setDefaultContextOption(option, value)</dd>
</dl>
<p>If the named context option doesnt already exist, it is created as part
of the set of default cook context options that are stored with the hip
file. Passing a value of None will remove the named context option from
the set of default options. The value may be either a string or a
number.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.contextOption</li>
<li>hou.contextOptionNames</li>
<li>hou.hasContextOption</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.setFps">
<code class="descclassname">hou.</code><code class="descname">setFps</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.setFps" title="Permalink to this definition"></a></dt>
<dd><p>Set the number of frames per second.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>setFps(fps)</dd>
</dl>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.fps</li>
</ul>
</div></blockquote>
<p>REPLACES</p>
<blockquote>
<div><ul class="simple">
<li>fps</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.setFrame">
<code class="descclassname">hou.</code><code class="descname">setFrame</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.setFrame" title="Permalink to this definition"></a></dt>
<dd><p>Set the playbars current frame. Note that the frame may be a fractional
value.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>setFrame(frame)</dd>
</dl>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.time</li>
<li>hou.setFrame</li>
</ul>
</div></blockquote>
<p>REPLACES</p>
<blockquote>
<div><ul class="simple">
<li>tcur</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.setMaxThreads">
<code class="descclassname">hou.</code><code class="descname">setMaxThreads</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.setMaxThreads" title="Permalink to this definition"></a></dt>
<dd><p>Sets the maximum number of threads to use for multi-processing.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>setMaxThreads(max_threads)</dd>
</dl>
<p>When Houdini/hython is started, it uses all available processors on the
machine for multi-threaded processing, unless overridden by the -j
command line option.</p>
<p>This function allows dynamically adjusting this setting at run-time.</p>
<p>Note that this function may only be called from the main thread. If
called from an expression that gets evaluated in a multi-threaded
context, or during other processing, it will throw an exception.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.maxThreads</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.setPreference">
<code class="descclassname">hou.</code><code class="descname">setPreference</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.setPreference" title="Permalink to this definition"></a></dt>
<dd><p>Sets a preference given a name and returns true on success.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>setPreference(name, value) -&gt; bool</dd>
</dl>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.getPreference</li>
<li>hou.getPreferenceNames</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.setPwd">
<code class="descclassname">hou.</code><code class="descname">setPwd</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.setPwd" title="Permalink to this definition"></a></dt>
<dd><p>Make the given node Houdinis current node. This function is equivalent
to hou.cd(node.path()).</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>setPwd(node)</dd>
</dl>
<p>This function will raise hou.ObjectWasDeleted if the parameter refers to
a node that no longer exists in Houdini.</p>
<p>This function will raise hou.NotAvailable if you call it from mplay.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.pwd</li>
<li>hou.cd</li>
<li>hou.ScriptEvalContext</li>
</ul>
</div></blockquote>
<p>REPLACES</p>
<blockquote>
<div><ul class="simple">
<li>opcf</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.setSessionModuleSource">
<code class="descclassname">hou.</code><code class="descname">setSessionModuleSource</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.setSessionModuleSource" title="Permalink to this definition"></a></dt>
<dd><p>Sets the contents of the hou.session module. The new contents is made
available immediately. You do not have to re-import hou.session.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>setSessionModuleSource(source)</dd>
</dl>
<p>This function throws a hou.OperationFailed exception if it fails to
update the hou.session module. This can happen if the new contents has
syntax errors.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.appendSessionModuleSource</li>
<li>hou.session</li>
<li>hou.setSessionModuleSource</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.setSimulationEnabled">
<code class="descclassname">hou.</code><code class="descname">setSimulationEnabled</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.setSimulationEnabled" title="Permalink to this definition"></a></dt>
<dd><dl class="docutils">
<dt>USAGE</dt>
<dd>setSimulationEnabled(enabled)</dd>
</dl>
<p>Call hou.setSimulationEnabled(True) to enable simulation updates or
hou.setSimulationEnabled(False) to disable them. The user can choose to
disable simulation updates to improve interactivity using the simulation
menu in the bottom right corner of the main window. This function lets
you set the state of that menu item programmatically. Use
hou.simulationEnabled to check whether simulation updates are currently
enabled.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.simulationEnabled</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.setTime">
<code class="descclassname">hou.</code><code class="descname">setTime</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.setTime" title="Permalink to this definition"></a></dt>
<dd><p>Set the playbars time.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>setTime(time)</dd>
</dl>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.time</li>
<li>hou.setFrame</li>
</ul>
</div></blockquote>
<p>REPLACES</p>
<blockquote>
<div><ul class="simple">
<li>tcur</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.setUpdateMode">
<code class="descclassname">hou.</code><code class="descname">setUpdateMode</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.setUpdateMode" title="Permalink to this definition"></a></dt>
<dd><p>Return Houdinis cook update mode (Auto Update/On Mouse Up/Manual) that
is displayed in the status bar.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>updateModeSetting() -&gt; hou.updateMode enum value</dd>
</dl>
<p>Set Houdinis cook update mode to a hou.updateMode enumerated value. See
hou.updateModeSetting for more information.</p>
</dd></dl>

<dl class="class">
<dt id="hou.severityType">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">severityType</code><a class="headerlink" href="#hou.severityType" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Enumeration of dialog message severities.</p>
<p>VALUES</p>
<blockquote>
<div>Message
ImportantMessage
Warning
Error
Fatal</div></blockquote>
<dl class="attribute">
<dt id="hou.severityType.Error">
<code class="descname">Error</code><em class="property"> = severityType.Error</em><a class="headerlink" href="#hou.severityType.Error" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.severityType.Fatal">
<code class="descname">Fatal</code><em class="property"> = severityType.Fatal</em><a class="headerlink" href="#hou.severityType.Fatal" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.severityType.ImportantMessage">
<code class="descname">ImportantMessage</code><em class="property"> = severityType.ImportantMessage</em><a class="headerlink" href="#hou.severityType.ImportantMessage" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.severityType.Message">
<code class="descname">Message</code><em class="property"> = severityType.Message</em><a class="headerlink" href="#hou.severityType.Message" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.severityType.Warning">
<code class="descname">Warning</code><em class="property"> = severityType.Warning</em><a class="headerlink" href="#hou.severityType.Warning" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.severityType.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.severityType.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.shaderType">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">shaderType</code><a class="headerlink" href="#hou.shaderType" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Enumeration of SHOP shader types.</p>
<p>Each SHOP type defines a particular type of shader. For example, it
might be a surface shader or a displacement shader. This enumeration
contains all the possible shader types.</p>
<p>Use hou.ShopNodeType.shaderType to determine what type of shader a
particular SHOP type is.</p>
<p>VALUES</p>
<blockquote>
<div>Invalid
Surface
SurfaceShadow
Displacement
Geometry
Interior
Light
LightShadow
Atmosphere
Lens
Output
Background
Photon
Image3D
BSDF
CVEX
Mutable
Properties
Material
VopMaterial
ShaderClass</div></blockquote>
<dl class="attribute">
<dt id="hou.shaderType.Atmosphere">
<code class="descname">Atmosphere</code><em class="property"> = shaderType.Atmosphere</em><a class="headerlink" href="#hou.shaderType.Atmosphere" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.shaderType.BSDF">
<code class="descname">BSDF</code><em class="property"> = shaderType.BSDF</em><a class="headerlink" href="#hou.shaderType.BSDF" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.shaderType.Background">
<code class="descname">Background</code><em class="property"> = shaderType.Background</em><a class="headerlink" href="#hou.shaderType.Background" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.shaderType.CVex">
<code class="descname">CVex</code><em class="property"> = shaderType.CVex</em><a class="headerlink" href="#hou.shaderType.CVex" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.shaderType.CoShader">
<code class="descname">CoShader</code><em class="property"> = shaderType.CoShader</em><a class="headerlink" href="#hou.shaderType.CoShader" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.shaderType.CoShaderArray">
<code class="descname">CoShaderArray</code><em class="property"> = shaderType.CoShaderArray</em><a class="headerlink" href="#hou.shaderType.CoShaderArray" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.shaderType.Displacement">
<code class="descname">Displacement</code><em class="property"> = shaderType.Displacement</em><a class="headerlink" href="#hou.shaderType.Displacement" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.shaderType.Generic">
<code class="descname">Generic</code><em class="property"> = shaderType.Generic</em><a class="headerlink" href="#hou.shaderType.Generic" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.shaderType.Geometry">
<code class="descname">Geometry</code><em class="property"> = shaderType.Geometry</em><a class="headerlink" href="#hou.shaderType.Geometry" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.shaderType.Image3D">
<code class="descname">Image3D</code><em class="property"> = shaderType.Image3D</em><a class="headerlink" href="#hou.shaderType.Image3D" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.shaderType.Integrator">
<code class="descname">Integrator</code><em class="property"> = shaderType.Integrator</em><a class="headerlink" href="#hou.shaderType.Integrator" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.shaderType.Interior">
<code class="descname">Interior</code><em class="property"> = shaderType.Interior</em><a class="headerlink" href="#hou.shaderType.Interior" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.shaderType.Invalid">
<code class="descname">Invalid</code><em class="property"> = shaderType.Invalid</em><a class="headerlink" href="#hou.shaderType.Invalid" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.shaderType.Lens">
<code class="descname">Lens</code><em class="property"> = shaderType.Lens</em><a class="headerlink" href="#hou.shaderType.Lens" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.shaderType.Light">
<code class="descname">Light</code><em class="property"> = shaderType.Light</em><a class="headerlink" href="#hou.shaderType.Light" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.shaderType.LightFilter">
<code class="descname">LightFilter</code><em class="property"> = shaderType.LightFilter</em><a class="headerlink" href="#hou.shaderType.LightFilter" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.shaderType.LightShadow">
<code class="descname">LightShadow</code><em class="property"> = shaderType.LightShadow</em><a class="headerlink" href="#hou.shaderType.LightShadow" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.shaderType.Material">
<code class="descname">Material</code><em class="property"> = shaderType.Material</em><a class="headerlink" href="#hou.shaderType.Material" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.shaderType.Mutable">
<code class="descname">Mutable</code><em class="property"> = shaderType.Mutable</em><a class="headerlink" href="#hou.shaderType.Mutable" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.shaderType.Output">
<code class="descname">Output</code><em class="property"> = shaderType.Output</em><a class="headerlink" href="#hou.shaderType.Output" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.shaderType.Photon">
<code class="descname">Photon</code><em class="property"> = shaderType.Photon</em><a class="headerlink" href="#hou.shaderType.Photon" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.shaderType.Properties">
<code class="descname">Properties</code><em class="property"> = shaderType.Properties</em><a class="headerlink" href="#hou.shaderType.Properties" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.shaderType.ShaderClass">
<code class="descname">ShaderClass</code><em class="property"> = shaderType.ShaderClass</em><a class="headerlink" href="#hou.shaderType.ShaderClass" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.shaderType.StructDef">
<code class="descname">StructDef</code><em class="property"> = shaderType.StructDef</em><a class="headerlink" href="#hou.shaderType.StructDef" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.shaderType.Surface">
<code class="descname">Surface</code><em class="property"> = shaderType.Surface</em><a class="headerlink" href="#hou.shaderType.Surface" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.shaderType.SurfaceShadow">
<code class="descname">SurfaceShadow</code><em class="property"> = shaderType.SurfaceShadow</em><a class="headerlink" href="#hou.shaderType.SurfaceShadow" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.shaderType.VopMaterial">
<code class="descname">VopMaterial</code><em class="property"> = shaderType.VopMaterial</em><a class="headerlink" href="#hou.shaderType.VopMaterial" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.shaderType.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.shaderType.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="hou.shopNodeTypeCategory">
<code class="descclassname">hou.</code><code class="descname">shopNodeTypeCategory</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.shopNodeTypeCategory" title="Permalink to this definition"></a></dt>
<dd><p>Return the NodeTypeCategory object corresponding to shader (SHOP) nodes.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>shopNodeTypeCategory() -&gt; hou.NodeTypeCategory</dd>
</dl>
<p>Be careful not to confuse this function with the class
hou.ShopNodeTypeCategory.</p>
</dd></dl>

<dl class="function">
<dt id="hou.simulationEnabled">
<code class="descclassname">hou.</code><code class="descname">simulationEnabled</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.simulationEnabled" title="Permalink to this definition"></a></dt>
<dd><dl class="docutils">
<dt>USAGE</dt>
<dd>simulationEnabled() -&gt; bool</dd>
</dl>
<p>Returns True if Houdini is currently set to update simulations. The user
can choose to disable simulation updates to improve interactivity using
the simulation menu in the bottom right corner of the main window. Use
hou.setSimulationEnabled to enable or disable simulation updates
programmatically.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.setSimulationEnabled</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="class">
<dt id="hou.snappingMode">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">snappingMode</code><a class="headerlink" href="#hou.snappingMode" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Enumeration of snapping modes.</p>
<p>See hou.SceneViewer.snappingMode.</p>
<p>VALUES</p>
<blockquote>
<div>Off
Grid
Prim
Point
Multi</div></blockquote>
<dl class="attribute">
<dt id="hou.snappingMode.Grid">
<code class="descname">Grid</code><em class="property"> = snappingMode.Grid</em><a class="headerlink" href="#hou.snappingMode.Grid" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.snappingMode.Multi">
<code class="descname">Multi</code><em class="property"> = snappingMode.Multi</em><a class="headerlink" href="#hou.snappingMode.Multi" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.snappingMode.Off">
<code class="descname">Off</code><em class="property"> = snappingMode.Off</em><a class="headerlink" href="#hou.snappingMode.Off" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.snappingMode.Point">
<code class="descname">Point</code><em class="property"> = snappingMode.Point</em><a class="headerlink" href="#hou.snappingMode.Point" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.snappingMode.Prim">
<code class="descname">Prim</code><em class="property"> = snappingMode.Prim</em><a class="headerlink" href="#hou.snappingMode.Prim" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.snappingMode.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.snappingMode.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="hou.sopNodeTypeCategory">
<code class="descclassname">hou.</code><code class="descname">sopNodeTypeCategory</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.sopNodeTypeCategory" title="Permalink to this definition"></a></dt>
<dd><p>Return the NodeTypeCategory instance for Houdini geometry (sop) nodes.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>sopNodeTypeCategory() -&gt; NodeTypeCategory</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="hou.sortedNodePaths">
<code class="descclassname">hou.</code><code class="descname">sortedNodePaths</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.sortedNodePaths" title="Permalink to this definition"></a></dt>
<dd><p>Given a tuple of path strings, return a tuple of path strings sorted in
input/outputs order. Invalid node paths wont be part of the sorted
list.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>sortedNodePaths(path_tuple) -&gt; tuple of string</dd>
</dl>
<p>Sorts nodes following the network traversal order. Root nodes appear
first and leaf nodes come last.</p>
<p>&gt; &gt;&gt;&gt; hou.node(/obj).createNode(simplefemale)
&gt; &lt;hou.ObjNode of type simplefemale at /obj/simplefemale1&gt;
&gt; &gt;&gt;&gt; paths = [/obj/simplefemale1/ctrl_master,/obj/simplefemale1/ctrl_IK_wrist_right,/obj/simplefemale1/ctrl_cog,/obj/simplefemale1/ctrl_neck,/obj/simplefemale1/ctrl_head,/obj/simplefemale1/ctrl_FK_hand_right]
&gt; &gt;&gt;&gt; hou.sortedNodePaths(paths)
&gt; (/obj/simplefemale1/ctrl_master, /obj/simplefemale1/ctrl_cog, /obj/simplefemale1/ctrl_IK_wrist_right, /obj/simplefemale1/ctrl_neck, /obj/simplefemale1/ctrl
&gt; _head, /obj/simplefemale1/ctrl_FK_hand_right)</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.node</li>
<li>hou.nodes</li>
<li>hou.Node</li>
<li>hou.sortedNodes</li>
</ul>
</div></blockquote>
<p>REPLACES</p>
<blockquote>
<div><ul class="simple">
<li>oplistsort()</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.sortedNodes">
<code class="descclassname">hou.</code><code class="descname">sortedNodes</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.sortedNodes" title="Permalink to this definition"></a></dt>
<dd><p>Given a tuple of hou.Node, return a tuple of hou.Node sorted in
input/outputs order.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>sortedNodePaths(node_tuple) -&gt; tuple of hou.Node</dd>
</dl>
<p>Sorts nodes following the network traversal order. Root nodes appear
first and leaf nodes come last.</p>
<p>&gt; &gt;&gt;&gt; hou.node(/obj).createNode(simplefemale)
&gt; &lt;hou.ObjNode of type simplefemale at /obj/simplefemale1&gt;
&gt; &gt;&gt;&gt; nodes = hou.nodes( [/obj/simplefemale1/ctrl_master,/obj/simplefemale1/ctrl_IK_wrist_right,/obj/simplefemale1/ctrl_cog,/obj/simplefemale1/ctrl_neck,/obj/simplefemale1/ctrl_head,/obj/simplefemale1/ctrl_FK_hand_right] )
&gt; &gt;&gt;&gt; hou.sortedNodes(nodes)
&gt; (/obj/simplefemale1/ctrl_master, /obj/simplefemale1/ctrl_cog, /obj/simplefemale1/ctrl_IK_wrist_right, /obj/simplefemale1/ctrl_neck, /obj/simplefemale1/ctrl
&gt; _head, /obj/simplefemale1/ctrl_FK_hand_right)</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.node</li>
<li>hou.nodes</li>
<li>hou.Node</li>
<li>hou.sortedNodePaths</li>
</ul>
</div></blockquote>
<p>REPLACES</p>
<blockquote>
<div><ul class="simple">
<li>oplistsort()</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.spline">
<code class="descclassname">hou.</code><code class="descname">spline</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.spline" title="Permalink to this definition"></a></dt>
<dd><p>Fits a spline through consecutive keyframe values.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>spline() -&gt; float</dd>
</dl>
<p>The resulting spline interpolates the channel values at the keyframes,
and slope values are not used.</p>
<p>This function is one of the special animation functions that use the
current playbar time and information in the parameters keyframes, such
as in and out values, tangents, acceleration, etc., to evaluate
themselves. Because the information needed to evaluate these functions
comes from the keyframes, these functions take few or no parameters.</p>
<p>Calling this function from outside a parameters expression will raise a
hou.NotAvailable exception.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.bezier</li>
<li>hou.constant</li>
<li>hou.cubic</li>
<li>hou.cycle</li>
<li>hou.cyclet</li>
<li>hou.ease</li>
<li>hou.easein</li>
<li>hou.easeinp</li>
<li>hou.easeout</li>
<li>hou.easeoutp</li>
<li>hou.easep</li>
<li>hou.linear</li>
<li>hou.match</li>
<li>hou.matchin</li>
<li>hou.matchout</li>
<li>hou.qlinear</li>
<li>hou.quintic</li>
<li>hou.repeat</li>
<li>hou.repeatt</li>
<li>hou.vmatch</li>
<li>hou.vmatchin</li>
<li>hou.vmatchout</li>
</ul>
</div></blockquote>
<p>REPLACES</p>
<blockquote>
<div><ul class="simple">
<li>spline()</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.startHoudiniEngineDebugger">
<code class="descclassname">hou.</code><code class="descname">startHoudiniEngineDebugger</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.startHoudiniEngineDebugger" title="Permalink to this definition"></a></dt>
<dd><p>Starts a Houdini Engine debugging session in Houdini if no session is
currently active</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>startHoudiniEngineDebugger(port) startHoudiniEngineDebugger(pipeName)</dd>
<dt>port</dt>
<dd>The port number that the debugging server should use</dd>
<dt>pipeName</dt>
<dd>The pipe name that the debugging server should use</dd>
</dl>
<p>EXAMPLES</p>
<blockquote>
<div>&gt; &gt;hou.startHoudiniEngineDebugger(9090)
&gt; &gt;hou.startHoudiniEngineDebugger(hapi_debug_session)</div></blockquote>
</dd></dl>

<dl class="class">
<dt id="hou.stateGenerateMode">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">stateGenerateMode</code><a class="headerlink" href="#hou.stateGenerateMode" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Enumeration of possible node generation modes by states.</p>
<p>See hou.SceneViewer.setCurrentState for more information.</p>
<p>VALUES</p>
<blockquote>
<div>Insert
Branch</div></blockquote>
<dl class="attribute">
<dt id="hou.stateGenerateMode.Branch">
<code class="descname">Branch</code><em class="property"> = stateGenerateMode.Branch</em><a class="headerlink" href="#hou.stateGenerateMode.Branch" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.stateGenerateMode.Insert">
<code class="descname">Insert</code><em class="property"> = stateGenerateMode.Insert</em><a class="headerlink" href="#hou.stateGenerateMode.Insert" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.stateGenerateMode.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.stateGenerateMode.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.stateViewerType">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">stateViewerType</code><a class="headerlink" href="#hou.stateViewerType" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Enumeration of state viewer types.</p>
<p>VALUES</p>
<blockquote>
<div>Scene
Compositor</div></blockquote>
<dl class="attribute">
<dt id="hou.stateViewerType.Compositor">
<code class="descname">Compositor</code><em class="property"> = stateViewerType.Compositor</em><a class="headerlink" href="#hou.stateViewerType.Compositor" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.stateViewerType.Scene">
<code class="descname">Scene</code><em class="property"> = stateViewerType.Scene</em><a class="headerlink" href="#hou.stateViewerType.Scene" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.stateViewerType.SceneGraph">
<code class="descname">SceneGraph</code><em class="property"> = stateViewerType.SceneGraph</em><a class="headerlink" href="#hou.stateViewerType.SceneGraph" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.stateViewerType.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.stateViewerType.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="hou.stickyNoteBySessionId">
<code class="descclassname">hou.</code><code class="descname">stickyNoteBySessionId</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.stickyNoteBySessionId" title="Permalink to this definition"></a></dt>
<dd><p>Given a sticky notes session id, return a StickyNote object. Return
None if the id does not correspond to a valid sticky note.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>stickyNoteBySessionId(session_id) -&gt; hou.StickyNote or None</dd>
</dl>
<p>See hou.StickyNote.sessionId for more information.</p>
<p>Raises hou.NotAvailable if you call it from MPlay.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.item</li>
<li>hou.StickyNote.sessionId</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="class">
<dt id="hou.stringParmType">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">stringParmType</code><a class="headerlink" href="#hou.stringParmType" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Enumeration of string parameter types.</p>
<p>A hou.StringParmTemplate is set to one of these types to specify whether
a string parameter will hold an arbitrary string, a reference to a file,
a reference to a node, or a reference to multiple nodes.</p>
<p>VALUES</p>
<blockquote>
<div>Regular
FileReference
NodeReference
NodeReferenceList</div></blockquote>
<dl class="attribute">
<dt id="hou.stringParmType.FileReference">
<code class="descname">FileReference</code><em class="property"> = stringParmType.FileReference</em><a class="headerlink" href="#hou.stringParmType.FileReference" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.stringParmType.NodeReference">
<code class="descname">NodeReference</code><em class="property"> = stringParmType.NodeReference</em><a class="headerlink" href="#hou.stringParmType.NodeReference" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.stringParmType.NodeReferenceList">
<code class="descname">NodeReferenceList</code><em class="property"> = stringParmType.NodeReferenceList</em><a class="headerlink" href="#hou.stringParmType.NodeReferenceList" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.stringParmType.Regular">
<code class="descname">Regular</code><em class="property"> = stringParmType.Regular</em><a class="headerlink" href="#hou.stringParmType.Regular" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.stringParmType.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.stringParmType.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="hou.subnetIndirectInputBySessionId">
<code class="descclassname">hou.</code><code class="descname">subnetIndirectInputBySessionId</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.subnetIndirectInputBySessionId" title="Permalink to this definition"></a></dt>
<dd><p>Given a subnet inputs session id, return a SubnetIndirectInput object.
Return None if the id does not correspond to a valid subnet input (e.g.
if the subnet containing the input was deleted).</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>subnetIndirectInputBySessionId(session_id) -&gt; hou.SubnetIndirectInput
or None</dd>
</dl>
<p>See hou.SubnetIndirectInput.sessionId for more information.</p>
<p>Raises hou.NotAvailable if you call it from MPlay.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.item</li>
<li>hou.SubnetIndirectInput.sessionId</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.time">
<code class="descclassname">hou.</code><code class="descname">time</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.time" title="Permalink to this definition"></a></dt>
<dd><p>Return the playbars current time, in seconds of playback.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>time() -&gt; float</dd>
</dl>
<p>Note that the time at frame 1 is 0s.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.setTime</li>
<li>hou.frame</li>
<li>hou.fps</li>
</ul>
</div></blockquote>
<p>REPLACES</p>
<blockquote>
<div><ul class="simple">
<li>tcur</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.timeToFrame">
<code class="descclassname">hou.</code><code class="descname">timeToFrame</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.timeToFrame" title="Permalink to this definition"></a></dt>
<dd><p>Convert from a given time value to a frame value, rounding the result to
a integer if it is close to an integer.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>timeToFrame(time) -&gt; float</dd>
</dl>
<p>Calling this function is roughly equivalent to evaluating time *
hou.fps() + 1.0, but the result is rounded to 6 digits of precision.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.fps</li>
<li>hou.frame</li>
<li>hou.time</li>
</ul>
</div></blockquote>
<p>REPLACES</p>
<blockquote>
<div><ul class="simple">
<li>fps</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.topNodeTypeCategory">
<code class="descclassname">hou.</code><code class="descname">topNodeTypeCategory</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.topNodeTypeCategory" title="Permalink to this definition"></a></dt>
<dd><p>Return the NodeTypeCategory instance for Houdini task (top) nodes.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>topNodeTypeCategory() -&gt; NodeTypeCategory</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="hou.uiEventReason">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">uiEventReason</code><a class="headerlink" href="#hou.uiEventReason" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Values representing reasons Houdini generated a particular UI event.</p>
<p>Calling hou.UIEvent.reason returns one of the following values.</p>
<p>VALUES</p>
<blockquote>
<div><dl class="docutils">
<dt>Picked</dt>
<dd>Quick mouse click without dragging.</dd>
<dt>Start</dt>
<dd>Left mouse button pressed (mouse down)</dd>
<dt>Active</dt>
<dd>Mouse dragged with the left mouse button down.</dd>
<dt>Changed</dt>
<dd>Left mouse button released (mouse up).</dd>
<dt>Located</dt>
<dd>Mouse pointer hovered over something in the interface. In a
viewer state, this is the reason associated with mouse moves.</dd>
<dt>ItemsChanged</dt>
<dd>Event generated as a change of values in hou.UIEvent</dd>
<dt>New</dt>
<dd>Event generated when a UI element was assigned a different
value.</dd>
<dt>RangeChanged</dt>
<dd>Event generated when a slider or scrollbar has changed.</dd>
<dt>NoReason</dt>
<dd>Event was likely explicitly generated.</dd>
</dl>
</div></blockquote>
<p>RELATED</p>
<blockquote>
<div>hou.UIEvent.reason</div></blockquote>
<dl class="attribute">
<dt id="hou.uiEventReason.Active">
<code class="descname">Active</code><em class="property"> = uiEventReason.Active</em><a class="headerlink" href="#hou.uiEventReason.Active" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.uiEventReason.Changed">
<code class="descname">Changed</code><em class="property"> = uiEventReason.Changed</em><a class="headerlink" href="#hou.uiEventReason.Changed" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.uiEventReason.ItemsChanged">
<code class="descname">ItemsChanged</code><em class="property"> = uiEventReason.ItemsChanged</em><a class="headerlink" href="#hou.uiEventReason.ItemsChanged" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.uiEventReason.Located">
<code class="descname">Located</code><em class="property"> = uiEventReason.Located</em><a class="headerlink" href="#hou.uiEventReason.Located" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.uiEventReason.New">
<code class="descname">New</code><em class="property"> = uiEventReason.New</em><a class="headerlink" href="#hou.uiEventReason.New" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.uiEventReason.NoReason">
<code class="descname">NoReason</code><em class="property"> = uiEventReason.NoReason</em><a class="headerlink" href="#hou.uiEventReason.NoReason" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.uiEventReason.Picked">
<code class="descname">Picked</code><em class="property"> = uiEventReason.Picked</em><a class="headerlink" href="#hou.uiEventReason.Picked" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.uiEventReason.RangeChanged">
<code class="descname">RangeChanged</code><em class="property"> = uiEventReason.RangeChanged</em><a class="headerlink" href="#hou.uiEventReason.RangeChanged" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.uiEventReason.Start">
<code class="descname">Start</code><em class="property"> = uiEventReason.Start</em><a class="headerlink" href="#hou.uiEventReason.Start" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.uiEventReason.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.uiEventReason.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.uiEventValueType">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">uiEventValueType</code><a class="headerlink" href="#hou.uiEventValueType" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Enumerator for UI event value types.</p>
<p>Represents the type of value stored in a hou.UIEvent object.</p>
<p>VALUES</p>
<blockquote>
<div><dl class="docutils">
<dt>hou.uiEventValueType.Float</dt>
<dd>float value type.</dd>
<dt>hou.uiEventValueType.FloatArray</dt>
<dd>Array of float values.</dd>
<dt>hou.uiEventValueType.IntArray</dt>
<dd>Array of int values.</dd>
<dt>hou.uiEventValueType.Integer</dt>
<dd>int value type.</dd>
<dt>hou.uiEventValueType.NoType</dt>
<dd>invalid value type.</dd>
<dt>hou.uiEventValueType.String</dt>
<dd>string value type.</dd>
<dt>hou.uiEventValueType.StringArray</dt>
<dd>Array of string values.</dd>
</dl>
</div></blockquote>
<p>RELATED</p>
<blockquote>
<div>hou.UIEvent.valueType</div></blockquote>
<dl class="attribute">
<dt id="hou.uiEventValueType.Float">
<code class="descname">Float</code><em class="property"> = uiEventValueType.Float</em><a class="headerlink" href="#hou.uiEventValueType.Float" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.uiEventValueType.FloatArray">
<code class="descname">FloatArray</code><em class="property"> = uiEventValueType.FloatArray</em><a class="headerlink" href="#hou.uiEventValueType.FloatArray" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.uiEventValueType.IntArray">
<code class="descname">IntArray</code><em class="property"> = uiEventValueType.IntArray</em><a class="headerlink" href="#hou.uiEventValueType.IntArray" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.uiEventValueType.Integer">
<code class="descname">Integer</code><em class="property"> = uiEventValueType.Integer</em><a class="headerlink" href="#hou.uiEventValueType.Integer" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.uiEventValueType.NoType">
<code class="descname">NoType</code><em class="property"> = uiEventValueType.NoType</em><a class="headerlink" href="#hou.uiEventValueType.NoType" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.uiEventValueType.String">
<code class="descname">String</code><em class="property"> = uiEventValueType.String</em><a class="headerlink" href="#hou.uiEventValueType.String" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.uiEventValueType.StringArray">
<code class="descname">StringArray</code><em class="property"> = uiEventValueType.StringArray</em><a class="headerlink" href="#hou.uiEventValueType.StringArray" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.uiEventValueType.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.uiEventValueType.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="hou.unsetenv">
<code class="descclassname">hou.</code><code class="descname">unsetenv</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.unsetenv" title="Permalink to this definition"></a></dt>
<dd><p>Unset the specified Houdini environment variable.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>unsetenv(name)</dd>
</dl>
<p>Unset the specified Houdini environment variable.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.getenv</li>
<li>hou.putenv</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="class">
<dt id="hou.updateMode">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">updateMode</code><a class="headerlink" href="#hou.updateMode" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Enumeration of interface update modes.</p>
<p>See hou.updateModeSetting.</p>
<p>VALUES</p>
<blockquote>
<div>AutoUpdate
OnMouseUp
Manual</div></blockquote>
<dl class="attribute">
<dt id="hou.updateMode.AutoUpdate">
<code class="descname">AutoUpdate</code><em class="property"> = updateMode.AutoUpdate</em><a class="headerlink" href="#hou.updateMode.AutoUpdate" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.updateMode.Manual">
<code class="descname">Manual</code><em class="property"> = updateMode.Manual</em><a class="headerlink" href="#hou.updateMode.Manual" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.updateMode.OnMouseUp">
<code class="descname">OnMouseUp</code><em class="property"> = updateMode.OnMouseUp</em><a class="headerlink" href="#hou.updateMode.OnMouseUp" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.updateMode.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.updateMode.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="hou.updateModeSetting">
<code class="descclassname">hou.</code><code class="descname">updateModeSetting</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.updateModeSetting" title="Permalink to this definition"></a></dt>
<dd><p>Return Houdinis cook update mode (Auto Update/On Mouse Up/Manual) that
is displayed in the status bar.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>updateModeSetting() -&gt; hou.updateMode enum value</dd>
</dl>
<p>Houdinis update mode determines when it will recook its nodes after you
make parameter changes. When it is Auto Update, it will recook whenever
any parameter changes. When it is On Mouse Up, it will not recook while
you are tuning a parameter with a viewport or ladder handle until you
release the mouse. When it is Manual, it will only recook when you press
the update button in the status bar.</p>
<p>Note that this function is named updateModeSetting because
hou.updateMode refers to the submodule containing enumeration values.
This function used to be in the hou.ui submodule, but it was moved into
the main hou module because it also applies to a non-graphical Houdini.</p>
<p>&gt; &gt;&gt;&gt; # Prevent Houdini from cooking any nodes.
&gt; &gt;&gt;&gt; hou.setUpdateMode(hou.updateMode.Manual)
&gt; &gt;&gt;&gt; hou.updateModeSetting()
&gt; hou.updateMode.Manual</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.setUpdateMode</li>
<li>hou.ui.triggerUpdate.</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.updateProgressAndCheckForInterrupt">
<code class="descclassname">hou.</code><code class="descname">updateProgressAndCheckForInterrupt</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.updateProgressAndCheckForInterrupt" title="Permalink to this definition"></a></dt>
<dd><p>Deprecated: Use InterruptableOperation.</p>
<p>Check if the user pressed Escape to interrupt the current operation, and
optionally update the completion progress.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>updateProgressAndCheckForInterrupt(percentage=-1) -&gt; bool</dd>
<dt>WARNING</dt>
<dd>This is deprecated. Use hou.InterruptableOperation instead.</dd>
</dl>
<p>Return True if the user pressed Escape and False otherwise.</p>
<dl class="docutils">
<dt>percentage</dt>
<dd>An integer value containing the percentage complete to display in
the taskbar. If the percentage is -1, the taskbar will not display
the completion percentage.</dd>
</dl>
<p>You would typically call this function from inside a Python SOP, to let
the user of the SOP press escape to interrupt a long cook.</p>
<p>See Define a new SOP type using Python for an example.</p>
</dd></dl>

<dl class="class">
<dt id="hou.valueLadderDataType">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">valueLadderDataType</code><a class="headerlink" href="#hou.valueLadderDataType" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Enumeration of the different data types that may be manipulated by a
value ladder.</p>
<p>See hou.ui.openValueLadder.</p>
<p>VALUES</p>
<blockquote>
<div><dl class="docutils">
<dt>Float</dt>
<dd>The ladder is being used to manipulate a single floating point
value.</dd>
<dt>Int</dt>
<dd>The ladder is being used to manipulate a single integer value.</dd>
<dt>FloatArray</dt>
<dd>The ladder is being used to manipulate an array of floating
point values.</dd>
<dt>IntArray</dt>
<dd>The ladder is being used to manipulate an array of integer
values.</dd>
</dl>
</div></blockquote>
<dl class="attribute">
<dt id="hou.valueLadderDataType.Float">
<code class="descname">Float</code><em class="property"> = valueLadderDataType.Float</em><a class="headerlink" href="#hou.valueLadderDataType.Float" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.valueLadderDataType.FloatArray">
<code class="descname">FloatArray</code><em class="property"> = valueLadderDataType.FloatArray</em><a class="headerlink" href="#hou.valueLadderDataType.FloatArray" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.valueLadderDataType.Int">
<code class="descname">Int</code><em class="property"> = valueLadderDataType.Int</em><a class="headerlink" href="#hou.valueLadderDataType.Int" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.valueLadderDataType.IntArray">
<code class="descname">IntArray</code><em class="property"> = valueLadderDataType.IntArray</em><a class="headerlink" href="#hou.valueLadderDataType.IntArray" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.valueLadderDataType.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.valueLadderDataType.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.valueLadderType">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">valueLadderType</code><a class="headerlink" href="#hou.valueLadderType" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Enumeration of the different value ladder types.</p>
<p>See hou.ui.openValueLadder.</p>
<p>VALUES</p>
<blockquote>
<div><dl class="docutils">
<dt>Generic</dt>
<dd>The ladder is being used to manipulate a generic numeric value.
The step sizes for this ladder type range from 0.0001 to 100.0.</dd>
<dt>Angle</dt>
<dd>The ladder is being used to manipulate a value representing an
angle. The step sizes for this ladder type range from 1.0 to
45.0.</dd>
</dl>
</div></blockquote>
<dl class="attribute">
<dt id="hou.valueLadderType.Angle">
<code class="descname">Angle</code><em class="property"> = valueLadderType.Angle</em><a class="headerlink" href="#hou.valueLadderType.Angle" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.valueLadderType.Generic">
<code class="descname">Generic</code><em class="property"> = valueLadderType.Generic</em><a class="headerlink" href="#hou.valueLadderType.Generic" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.valueLadderType.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.valueLadderType.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.vdbData">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">vdbData</code><a class="headerlink" href="#hou.vdbData" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Enumeration of voxel data types.</p>
<p>See hou.VDB.</p>
<p>VALUES</p>
<blockquote>
<div>Boolean
Float
Int
Vector3</div></blockquote>
<dl class="attribute">
<dt id="hou.vdbData.Boolean">
<code class="descname">Boolean</code><em class="property"> = vdbData.Boolean</em><a class="headerlink" href="#hou.vdbData.Boolean" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.vdbData.Float">
<code class="descname">Float</code><em class="property"> = vdbData.Float</em><a class="headerlink" href="#hou.vdbData.Float" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.vdbData.Int">
<code class="descname">Int</code><em class="property"> = vdbData.Int</em><a class="headerlink" href="#hou.vdbData.Int" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.vdbData.Vector3">
<code class="descname">Vector3</code><em class="property"> = vdbData.Vector3</em><a class="headerlink" href="#hou.vdbData.Vector3" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.vdbData.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.vdbData.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="hou.vexContextForNodeTypeCategory">
<code class="descclassname">hou.</code><code class="descname">vexContextForNodeTypeCategory</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.vexContextForNodeTypeCategory" title="Permalink to this definition"></a></dt>
<dd><p>Takes a NodeTypeCategory object and returns a VexContext object
representing the context of VOP networks the node would contain.</p>
<dl class="docutils">
<dt>NOTE</dt>
<dd>This function is for internal use by Houdini and isnt usually
necessary for scripting Houdini or creating tools.</dd>
<dt>USAGE</dt>
<dd>vexContextForNodeTypeCategory(node_type_category) -&gt; hou.VexContext or
None</dd>
</dl>
<p>&gt; &gt;&gt;&gt; # Get a reference to a SOP node
&gt; &gt;&gt;&gt; n = hou.node(/obj/geo1/pointvop1)
&gt; &gt;&gt;&gt; # Get its type category (SOPs)
&gt; &gt;&gt;&gt; sops = n.type().category()
&gt; &gt;&gt;&gt; # If a SOP contains a VOP network, what is its context?
&gt; &gt;&gt;&gt; hou.vexContextForNodeTypeCategory(sops)
&gt; &lt;hou.VexContext Sop&gt;
&gt; &gt;&gt;&gt; hou.vexContextForNodeTypeCategory(sops).name()
&gt; Sop
See hou.VexContext.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>VEX contexts</li>
<li>hou.vexContextForShaderType</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.vexContextForShaderType">
<code class="descclassname">hou.</code><code class="descname">vexContextForShaderType</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.vexContextForShaderType" title="Permalink to this definition"></a></dt>
<dd><dl class="docutils">
<dt>NOTE</dt>
<dd>This function is for internal use by Houdini and isnt usually
necessary for scripting Houdini or creating tools.</dd>
<dt>USAGE</dt>
<dd>vexContextForShaderType(shader_type) -&gt; hou.VexContext or None</dd>
</dl>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>VEX contexts</li>
<li>hou.vexContextForNodeTypeCategory</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.vexContexts">
<code class="descclassname">hou.</code><code class="descname">vexContexts</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.vexContexts" title="Permalink to this definition"></a></dt>
<dd><dl class="docutils">
<dt>USAGE</dt>
<dd>vexContexts() -&gt; tuple of VexContexts</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="hou.viewportAgentBoneDeform">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">viewportAgentBoneDeform</code><a class="headerlink" href="#hou.viewportAgentBoneDeform" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Enum for deforming agent quality</p>
<p>Defines the quality vs. performance tradeoff for deforming agent
geometry.</p>
<p>VALUES</p>
<blockquote>
<div><dl class="docutils">
<dt>hou.viewportAgentBoneDeform.Always</dt>
<dd>Only use 1 bone to deform on all agent instances (the one with
the most influence).</dd>
<dt>hou.viewportAgentBoneDeform.Disabled</dt>
<dd>Use up to 4 bones to deform the highest LOD agent instances, and
1 bone on all the reduced LOD instances.</dd>
<dt>hou.viewportAgentBoneDeform.ReducedLOD</dt>
<dd>Use up to 4 bones to deform on all agent instances.</dd>
</dl>
</div></blockquote>
<dl class="attribute">
<dt id="hou.viewportAgentBoneDeform.Always">
<code class="descname">Always</code><em class="property"> = viewportAgentBoneDeform.Always</em><a class="headerlink" href="#hou.viewportAgentBoneDeform.Always" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportAgentBoneDeform.Disabled">
<code class="descname">Disabled</code><em class="property"> = viewportAgentBoneDeform.Disabled</em><a class="headerlink" href="#hou.viewportAgentBoneDeform.Disabled" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportAgentBoneDeform.ReducedLOD">
<code class="descname">ReducedLOD</code><em class="property"> = viewportAgentBoneDeform.ReducedLOD</em><a class="headerlink" href="#hou.viewportAgentBoneDeform.ReducedLOD" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportAgentBoneDeform.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.viewportAgentBoneDeform.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.viewportAgentWireframe">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">viewportAgentWireframe</code><a class="headerlink" href="#hou.viewportAgentWireframe" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Enum for agent wireframe mode display</p>
<p>The look of agents in wireframe mode.</p>
<p>VALUES</p>
<blockquote>
<div><dl class="docutils">
<dt>hou.viewportAgentWireframe.Bone</dt>
<dd>Agents are rendered as bone-based skeletons.</dd>
<dt>hou.viewportAgentWireframe.Line</dt>
<dd>Agents are rendered as line-based skeletons.</dd>
</dl>
</div></blockquote>
<dl class="attribute">
<dt id="hou.viewportAgentWireframe.Bone">
<code class="descname">Bone</code><em class="property"> = viewportAgentWireframe.Bone</em><a class="headerlink" href="#hou.viewportAgentWireframe.Bone" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportAgentWireframe.Line">
<code class="descname">Line</code><em class="property"> = viewportAgentWireframe.Line</em><a class="headerlink" href="#hou.viewportAgentWireframe.Line" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportAgentWireframe.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.viewportAgentWireframe.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.viewportBGImageView">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">viewportBGImageView</code><a class="headerlink" href="#hou.viewportBGImageView" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Background image view target for the viewport display options</p>
<p>Selects a view target when choosing which background image to edit in
GeometryViewportSettings.</p>
<p>VALUES</p>
<blockquote>
<div><dl class="docutils">
<dt>hou.viewportBGImageView.Perspective</dt>
<dd>The 3D view not attached to a camera (No cam).</dd>
<dt>hou.viewportBGImageView.Camera</dt>
<dd>The 3D view looking through a camera.</dd>
<dt>hou.viewportBGImageView.Top</dt>
<dd>The orthographic top view.</dd>
<dt>hou.viewportBGImageView.Front</dt>
<dd>The orthographic front view.</dd>
<dt>hou.viewportBGImageView.Right</dt>
<dd>The orthographic right view.</dd>
<dt>hou.viewportBGImageView.Bottom</dt>
<dd>The orthographic bottom view.</dd>
<dt>hou.viewportBGImageView.Back</dt>
<dd>The orthographic back view.</dd>
<dt>hou.viewportBGImageView.Left</dt>
<dd>The orthographic left view.</dd>
<dt>hou.viewportBGImageView.UV</dt>
<dd>The UV texture viewport.</dd>
</dl>
</div></blockquote>
<dl class="attribute">
<dt id="hou.viewportBGImageView.Back">
<code class="descname">Back</code><em class="property"> = viewportBGImageView.Back</em><a class="headerlink" href="#hou.viewportBGImageView.Back" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportBGImageView.Bottom">
<code class="descname">Bottom</code><em class="property"> = viewportBGImageView.Bottom</em><a class="headerlink" href="#hou.viewportBGImageView.Bottom" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportBGImageView.Camera">
<code class="descname">Camera</code><em class="property"> = viewportBGImageView.Camera</em><a class="headerlink" href="#hou.viewportBGImageView.Camera" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportBGImageView.Front">
<code class="descname">Front</code><em class="property"> = viewportBGImageView.Front</em><a class="headerlink" href="#hou.viewportBGImageView.Front" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportBGImageView.Left">
<code class="descname">Left</code><em class="property"> = viewportBGImageView.Left</em><a class="headerlink" href="#hou.viewportBGImageView.Left" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportBGImageView.Perspective">
<code class="descname">Perspective</code><em class="property"> = viewportBGImageView.Perspective</em><a class="headerlink" href="#hou.viewportBGImageView.Perspective" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportBGImageView.Right">
<code class="descname">Right</code><em class="property"> = viewportBGImageView.Right</em><a class="headerlink" href="#hou.viewportBGImageView.Right" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportBGImageView.Top">
<code class="descname">Top</code><em class="property"> = viewportBGImageView.Top</em><a class="headerlink" href="#hou.viewportBGImageView.Top" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportBGImageView.UV">
<code class="descname">UV</code><em class="property"> = viewportBGImageView.UV</em><a class="headerlink" href="#hou.viewportBGImageView.UV" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportBGImageView.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.viewportBGImageView.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.viewportClosureSelection">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">viewportClosureSelection</code><a class="headerlink" href="#hou.viewportClosureSelection" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Viewport highlight of primitives with selected components</p>
<p>When components of a primitive are selected (points, vertices, edges),
the primitive can be highlighted as well to indicate which primitives
will be affected by the current selection.</p>
<p>VALUES</p>
<blockquote>
<div><dl class="docutils">
<dt>hou.viewportClosureSelection.Hide</dt>
<dd>Primitives are not highlighted.</dd>
<dt>hou.viewportClosureSelection.HullPrimitives</dt>
<dd>Only primitives whose points and edges reside on separate hull
geometry will be highlighted when those are selected (NURBS
surfaces, Bezier surfaces).</dd>
<dt>hou.viewportClosureSelection.Show</dt>
<dd>Highlight all primitives whose points, edges, or vertices belong
to the current selection.</dd>
</dl>
</div></blockquote>
<dl class="attribute">
<dt id="hou.viewportClosureSelection.Hide">
<code class="descname">Hide</code><em class="property"> = viewportClosureSelection.Hide</em><a class="headerlink" href="#hou.viewportClosureSelection.Hide" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportClosureSelection.HullPrimitives">
<code class="descname">HullPrimitives</code><em class="property"> = viewportClosureSelection.HullPrimitives</em><a class="headerlink" href="#hou.viewportClosureSelection.HullPrimitives" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportClosureSelection.Show">
<code class="descname">Show</code><em class="property"> = viewportClosureSelection.Show</em><a class="headerlink" href="#hou.viewportClosureSelection.Show" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportClosureSelection.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.viewportClosureSelection.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.viewportColorScheme">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">viewportColorScheme</code><a class="headerlink" href="#hou.viewportColorScheme" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Viewport Color Schemes</p>
<p>List of available color schemes for the viewport.</p>
<p>VALUES</p>
<blockquote>
<div><dl class="docutils">
<dt>hou.viewportColorScheme.Dark</dt>
<dd>Solid black backaground.</dd>
<dt>hou.viewportColorScheme.Grey</dt>
<dd>Solid grey background.</dd>
<dt>hou.viewportColorScheme.Light</dt>
<dd>Light blue gradient background.</dd>
</dl>
</div></blockquote>
<dl class="attribute">
<dt id="hou.viewportColorScheme.Dark">
<code class="descname">Dark</code><em class="property"> = viewportColorScheme.Dark</em><a class="headerlink" href="#hou.viewportColorScheme.Dark" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportColorScheme.Grey">
<code class="descname">Grey</code><em class="property"> = viewportColorScheme.Grey</em><a class="headerlink" href="#hou.viewportColorScheme.Grey" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportColorScheme.Light">
<code class="descname">Light</code><em class="property"> = viewportColorScheme.Light</em><a class="headerlink" href="#hou.viewportColorScheme.Light" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportColorScheme.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.viewportColorScheme.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.viewportGeometryInfo">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">viewportGeometryInfo</code><a class="headerlink" href="#hou.viewportGeometryInfo" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Geometry information display state</p>
<p>The state of the geometry information displayed in the lower right
corner of the viewport. This information takes additional time to
generate.</p>
<p>VALUES</p>
<blockquote>
<div><dl class="docutils">
<dt>hou.viewportGeometryInfo.Off</dt>
<dd>Do not show geometry information.</dd>
<dt>hou.viewportGeometryInfo.SelectedOnly</dt>
<dd>Only show information when a selection is present.</dd>
<dt>hou.viewportGeometryInfo.AlwaysOn</dt>
<dd>Always show information on the displayed geometry.</dd>
</dl>
</div></blockquote>
<dl class="attribute">
<dt id="hou.viewportGeometryInfo.AlwaysOn">
<code class="descname">AlwaysOn</code><em class="property"> = viewportGeometryInfo.AlwaysOn</em><a class="headerlink" href="#hou.viewportGeometryInfo.AlwaysOn" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportGeometryInfo.Off">
<code class="descname">Off</code><em class="property"> = viewportGeometryInfo.Off</em><a class="headerlink" href="#hou.viewportGeometryInfo.Off" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportGeometryInfo.SelectedOnly">
<code class="descname">SelectedOnly</code><em class="property"> = viewportGeometryInfo.SelectedOnly</em><a class="headerlink" href="#hou.viewportGeometryInfo.SelectedOnly" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportGeometryInfo.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.viewportGeometryInfo.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.viewportGridRuler">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">viewportGridRuler</code><a class="headerlink" href="#hou.viewportGridRuler" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Enum for grid numbering on viewport grids.</p>
<p>Specifies where the grid numbering occurs on viewport grids.</p>
<p>VALUES</p>
<blockquote>
<div><dl class="docutils">
<dt>hou.viewportGridRuler.Hide</dt>
<dd>No grid numbers are displayed.</dd>
<dt>hou.viewportGridRuler.MainAxis</dt>
<dd>Numbers appear along the max axes at grid line intersections.</dd>
<dt>hou.viewportGridRuler.GridPoints</dt>
<dd>Numbers appear at grid line intersections.</dd>
</dl>
</div></blockquote>
<dl class="attribute">
<dt id="hou.viewportGridRuler.GridPoints">
<code class="descname">GridPoints</code><em class="property"> = viewportGridRuler.GridPoints</em><a class="headerlink" href="#hou.viewportGridRuler.GridPoints" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportGridRuler.Hide">
<code class="descname">Hide</code><em class="property"> = viewportGridRuler.Hide</em><a class="headerlink" href="#hou.viewportGridRuler.Hide" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportGridRuler.MainAxis">
<code class="descname">MainAxis</code><em class="property"> = viewportGridRuler.MainAxis</em><a class="headerlink" href="#hou.viewportGridRuler.MainAxis" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportGridRuler.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.viewportGridRuler.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.viewportGuide">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">viewportGuide</code><a class="headerlink" href="#hou.viewportGuide" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Viewport guides</p>
<p>List of viewport guides that can be queried, enabled or disabled.</p>
<p>VALUES</p>
<blockquote>
<div><dl class="docutils">
<dt>hou.viewportGuide.CameraMask</dt>
<dd>The mask which dims out areas outside the camera aspect ratio.</dd>
<dt>hou.viewportGuide.CurrentGeometry</dt>
<dd>Geometry from the current modelling operator (SOP)</dd>
<dt>hou.viewportGuide.DisplayNodes</dt>
<dd>Geometry from the currently displayed modelling operator (SOP)</dd>
</dl>
<p>hou.viewportGuide.FieldGuide
hou.viewportGuide.FillSelections</p>
<blockquote>
<div>Polygon selections are highlighted with a solid color rather
than just an outline when in Wire-Over shading modes.</div></blockquote>
<dl class="docutils">
<dt>hou.viewportGuide.FloatingGnomon</dt>
<dd>Show the orientation axes in the lower left corner of the
viewport.</dd>
<dt>hou.viewportGuide.FollowSelection</dt>
<dd>Show point or vertex markers when point or selection is active.</dd>
<dt>hou.viewportGuide.GroupList</dt>
<dd>Show the group list in the top right corner of the viewport.</dd>
<dt>hou.viewportGuide.IKCriticalZone</dt>
<dd>Show the critical zone for IK bones.</dd>
<dt>hou.viewportGuide.NodeGuides</dt>
<dd>Show any node guides that are available.</dd>
<dt>hou.viewportGuide.NodeHandles</dt>
<dd>Show any handles that are available.</dd>
<dt>hou.viewportGuide.ObjectNames</dt>
<dd>Show object names for visible objects.</dd>
<dt>hou.viewportGuide.ObjectPaths</dt>
<dd>Show full objects paths for visible objects. Object names must
be displayed.</dd>
<dt>hou.viewportGuide.ObjectSelection</dt>
<dd>Show object selections.</dd>
<dt>hou.viewportGuide.OriginGnomon</dt>
<dd>Show the axes at the world origin.</dd>
<dt>hou.viewportGuide.ParticleGnomon</dt>
<dd>Show axes per particle.</dd>
<dt>hou.viewportGuide.SafeArea</dt>
<dd>Show the safe area overlay for broadcast.</dd>
<dt>hou.viewportGuide.SelectableTemplates</dt>
<dd>Show geometry from modelling operators with their selectable
template flags set.</dd>
<dt>hou.viewportGuide.ShowDrawTime</dt>
<dd>Show the time to update and render the viewport.</dd>
<dt>hou.viewportGuide.TemplateGeometry</dt>
<dd>Show geometry from modelling operators with their template flags
set.</dd>
<dt>hou.viewportGuide.ViewPivot</dt>
<dd>Show the camera pivot where tumbling will rotate about.</dd>
<dt>hou.viewportGuide.XYPlane</dt>
<dd>Show a grid along the XY plane.</dd>
<dt>hou.viewportGuide.XZPlane</dt>
<dd>Show a grid along the XZ plane.</dd>
<dt>hou.viewportGuide.YZPlane</dt>
<dd>Show a grid along the YZ plane.</dd>
</dl>
</div></blockquote>
<dl class="attribute">
<dt id="hou.viewportGuide.CameraMask">
<code class="descname">CameraMask</code><em class="property"> = viewportGuide.CameraMask</em><a class="headerlink" href="#hou.viewportGuide.CameraMask" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportGuide.CurrentGeometry">
<code class="descname">CurrentGeometry</code><em class="property"> = viewportGuide.CurrentGeometry</em><a class="headerlink" href="#hou.viewportGuide.CurrentGeometry" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportGuide.DisplayNodes">
<code class="descname">DisplayNodes</code><em class="property"> = viewportGuide.DisplayNodes</em><a class="headerlink" href="#hou.viewportGuide.DisplayNodes" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportGuide.FieldGuide">
<code class="descname">FieldGuide</code><em class="property"> = viewportGuide.FieldGuide</em><a class="headerlink" href="#hou.viewportGuide.FieldGuide" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportGuide.FillSelections">
<code class="descname">FillSelections</code><em class="property"> = viewportGuide.FillSelections</em><a class="headerlink" href="#hou.viewportGuide.FillSelections" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportGuide.FloatingGnomon">
<code class="descname">FloatingGnomon</code><em class="property"> = viewportGuide.FloatingGnomon</em><a class="headerlink" href="#hou.viewportGuide.FloatingGnomon" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportGuide.FollowSelection">
<code class="descname">FollowSelection</code><em class="property"> = viewportGuide.FollowSelection</em><a class="headerlink" href="#hou.viewportGuide.FollowSelection" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportGuide.GroupList">
<code class="descname">GroupList</code><em class="property"> = viewportGuide.GroupList</em><a class="headerlink" href="#hou.viewportGuide.GroupList" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportGuide.IKCriticalZone">
<code class="descname">IKCriticalZone</code><em class="property"> = viewportGuide.IKCriticalZone</em><a class="headerlink" href="#hou.viewportGuide.IKCriticalZone" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportGuide.NodeGuides">
<code class="descname">NodeGuides</code><em class="property"> = viewportGuide.NodeGuides</em><a class="headerlink" href="#hou.viewportGuide.NodeGuides" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportGuide.NodeHandles">
<code class="descname">NodeHandles</code><em class="property"> = viewportGuide.NodeHandles</em><a class="headerlink" href="#hou.viewportGuide.NodeHandles" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportGuide.ObjectNames">
<code class="descname">ObjectNames</code><em class="property"> = viewportGuide.ObjectNames</em><a class="headerlink" href="#hou.viewportGuide.ObjectNames" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportGuide.ObjectPaths">
<code class="descname">ObjectPaths</code><em class="property"> = viewportGuide.ObjectPaths</em><a class="headerlink" href="#hou.viewportGuide.ObjectPaths" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportGuide.ObjectSelection">
<code class="descname">ObjectSelection</code><em class="property"> = viewportGuide.ObjectSelection</em><a class="headerlink" href="#hou.viewportGuide.ObjectSelection" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportGuide.OriginGnomon">
<code class="descname">OriginGnomon</code><em class="property"> = viewportGuide.OriginGnomon</em><a class="headerlink" href="#hou.viewportGuide.OriginGnomon" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportGuide.ParticleGnomon">
<code class="descname">ParticleGnomon</code><em class="property"> = viewportGuide.ParticleGnomon</em><a class="headerlink" href="#hou.viewportGuide.ParticleGnomon" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportGuide.SafeArea">
<code class="descname">SafeArea</code><em class="property"> = viewportGuide.SafeArea</em><a class="headerlink" href="#hou.viewportGuide.SafeArea" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportGuide.SelectableTemplates">
<code class="descname">SelectableTemplates</code><em class="property"> = viewportGuide.SelectableTemplates</em><a class="headerlink" href="#hou.viewportGuide.SelectableTemplates" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportGuide.ShowDrawTime">
<code class="descname">ShowDrawTime</code><em class="property"> = viewportGuide.ShowDrawTime</em><a class="headerlink" href="#hou.viewportGuide.ShowDrawTime" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportGuide.TemplateGeometry">
<code class="descname">TemplateGeometry</code><em class="property"> = viewportGuide.TemplateGeometry</em><a class="headerlink" href="#hou.viewportGuide.TemplateGeometry" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportGuide.ViewPivot">
<code class="descname">ViewPivot</code><em class="property"> = viewportGuide.ViewPivot</em><a class="headerlink" href="#hou.viewportGuide.ViewPivot" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportGuide.XYPlane">
<code class="descname">XYPlane</code><em class="property"> = viewportGuide.XYPlane</em><a class="headerlink" href="#hou.viewportGuide.XYPlane" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportGuide.XZPlane">
<code class="descname">XZPlane</code><em class="property"> = viewportGuide.XZPlane</em><a class="headerlink" href="#hou.viewportGuide.XZPlane" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportGuide.YZPlane">
<code class="descname">YZPlane</code><em class="property"> = viewportGuide.YZPlane</em><a class="headerlink" href="#hou.viewportGuide.YZPlane" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportGuide.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.viewportGuide.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.viewportGuideFont">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">viewportGuideFont</code><a class="headerlink" href="#hou.viewportGuideFont" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Viewport font sizes for visualizer text</p>
<p>Font sizes for displaying text-based visualizers.</p>
<p>VALUES</p>
<blockquote>
<div><dl class="docutils">
<dt>hou.viewportGuideFont.Tiny</dt>
<dd>Tiny font.</dd>
<dt>hou.viewportGuideFont.Small</dt>
<dd>Small font.</dd>
<dt>hou.viewportGuideFont.Medium</dt>
<dd>The just right font.</dd>
<dt>hou.viewportGuideFont.Large</dt>
<dd>Largest font.</dd>
</dl>
</div></blockquote>
<dl class="attribute">
<dt id="hou.viewportGuideFont.Large">
<code class="descname">Large</code><em class="property"> = viewportGuideFont.Large</em><a class="headerlink" href="#hou.viewportGuideFont.Large" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportGuideFont.Medium">
<code class="descname">Medium</code><em class="property"> = viewportGuideFont.Medium</em><a class="headerlink" href="#hou.viewportGuideFont.Medium" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportGuideFont.Small">
<code class="descname">Small</code><em class="property"> = viewportGuideFont.Small</em><a class="headerlink" href="#hou.viewportGuideFont.Small" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportGuideFont.Tiny">
<code class="descname">Tiny</code><em class="property"> = viewportGuideFont.Tiny</em><a class="headerlink" href="#hou.viewportGuideFont.Tiny" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportGuideFont.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.viewportGuideFont.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.viewportHandleHighlight">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">viewportHandleHighlight</code><a class="headerlink" href="#hou.viewportHandleHighlight" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Handle highlight size</p>
<p>Highlight size when moving the mouse over a handle.</p>
<p>VALUES</p>
<blockquote>
<div><dl class="docutils">
<dt>hou.viewportHandleHighlight.Off</dt>
<dd>Dont display any highlights.</dd>
<dt>hou.viewportHandleHighlight.Small</dt>
<dd>Show a half-width highlight.</dd>
<dt>hou.viewportHandleHighlight.Normal</dt>
<dd>Show a full highlight.</dd>
</dl>
</div></blockquote>
<dl class="attribute">
<dt id="hou.viewportHandleHighlight.Normal">
<code class="descname">Normal</code><em class="property"> = viewportHandleHighlight.Normal</em><a class="headerlink" href="#hou.viewportHandleHighlight.Normal" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportHandleHighlight.Off">
<code class="descname">Off</code><em class="property"> = viewportHandleHighlight.Off</em><a class="headerlink" href="#hou.viewportHandleHighlight.Off" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportHandleHighlight.Small">
<code class="descname">Small</code><em class="property"> = viewportHandleHighlight.Small</em><a class="headerlink" href="#hou.viewportHandleHighlight.Small" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportHandleHighlight.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.viewportHandleHighlight.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.viewportHomeClipMode">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">viewportHomeClipMode</code><a class="headerlink" href="#hou.viewportHomeClipMode" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Automatic viewport clip plane adjustment during homing</p>
<p>Homing the viewport can adjust the viewports near and far clip planes
to adapt to what is being homed onto, so that geometry is fully visible
in the viewport.</p>
<p>VALUES</p>
<blockquote>
<div><dl class="docutils">
<dt>hou.viewportHomeClipMode.Neither</dt>
<dd>No clip planes are adjusted.</dd>
<dt>hou.viewportHomeClipMode.NearOnly</dt>
<dd>Only the near clip plane is adjusted. Far is left as is.</dd>
<dt>hou.viewportHomeClipMode.FarOnly</dt>
<dd>Only the far clip plane is adjusted. Near is left as is.</dd>
<dt>hou.viewportHomeClipMode.NearAndFar</dt>
<dd>Both clip planes are adjusted.</dd>
</dl>
</div></blockquote>
<dl class="attribute">
<dt id="hou.viewportHomeClipMode.FarOnly">
<code class="descname">FarOnly</code><em class="property"> = viewportHomeClipMode.FarOnly</em><a class="headerlink" href="#hou.viewportHomeClipMode.FarOnly" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportHomeClipMode.NearAndFar">
<code class="descname">NearAndFar</code><em class="property"> = viewportHomeClipMode.NearAndFar</em><a class="headerlink" href="#hou.viewportHomeClipMode.NearAndFar" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportHomeClipMode.NearOnly">
<code class="descname">NearOnly</code><em class="property"> = viewportHomeClipMode.NearOnly</em><a class="headerlink" href="#hou.viewportHomeClipMode.NearOnly" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportHomeClipMode.Neither">
<code class="descname">Neither</code><em class="property"> = viewportHomeClipMode.Neither</em><a class="headerlink" href="#hou.viewportHomeClipMode.Neither" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportHomeClipMode.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.viewportHomeClipMode.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.viewportLighting">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">viewportLighting</code><a class="headerlink" href="#hou.viewportLighting" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Lighting modes for the viewport</p>
<p>The viewport renderer supports several global lighting modes, from no
lighting whatsoever to full lighting with shadows.</p>
<p>VALUES</p>
<blockquote>
<div><dl class="docutils">
<dt>hou.viewportLighting.Off</dt>
<dd>No lighting, constant shaded.</dd>
<dt>hou.viewportLighting.Headlight</dt>
<dd>Basic lighting from a single directional light defined in the
display options.</dd>
<dt>hou.viewportLighting.Normal</dt>
<dd>Good quality lighting from up to 10 basic lights (area lights
modeled as point lights, limited environment lights).</dd>
<dt>hou.viewportLighting.HighQuality</dt>
<dd>High quality lighting from an unlimited number of lights
including area, geometry, environment and ambient occlusion.</dd>
<dt>hou.viewportLighting.HighQualityWithShadows</dt>
<dd>High quality lighting with shadows.</dd>
</dl>
</div></blockquote>
<dl class="attribute">
<dt id="hou.viewportLighting.Headlight">
<code class="descname">Headlight</code><em class="property"> = viewportLighting.Headlight</em><a class="headerlink" href="#hou.viewportLighting.Headlight" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportLighting.HighQuality">
<code class="descname">HighQuality</code><em class="property"> = viewportLighting.HighQuality</em><a class="headerlink" href="#hou.viewportLighting.HighQuality" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportLighting.HighQualityWithShadows">
<code class="descname">HighQualityWithShadows</code><em class="property"> = viewportLighting.HighQualityWithShadows</em><a class="headerlink" href="#hou.viewportLighting.HighQualityWithShadows" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportLighting.Normal">
<code class="descname">Normal</code><em class="property"> = viewportLighting.Normal</em><a class="headerlink" href="#hou.viewportLighting.Normal" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportLighting.Off">
<code class="descname">Off</code><em class="property"> = viewportLighting.Off</em><a class="headerlink" href="#hou.viewportLighting.Off" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportLighting.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.viewportLighting.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.viewportMaterialUpdate">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">viewportMaterialUpdate</code><a class="headerlink" href="#hou.viewportMaterialUpdate" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Enum for the update frequency of viewport material assignments</p>
<p>When material assignments are re-evaluated for a displayed object.</p>
<p>VALUES</p>
<blockquote>
<div><dl class="docutils">
<dt>hou.viewportMaterialUpdate.Always</dt>
<dd>Update assignments whenever needeed.</dd>
<dt>hou.viewportMaterialUpdate.Manual</dt>
<dd>Only update assignments when Update Materials is pressed.</dd>
<dt>hou.viewportMaterialUpdate.OffForPlayback</dt>
<dd>Update assignments whenever needed, but not during playback.</dd>
</dl>
</div></blockquote>
<dl class="attribute">
<dt id="hou.viewportMaterialUpdate.Always">
<code class="descname">Always</code><em class="property"> = viewportMaterialUpdate.Always</em><a class="headerlink" href="#hou.viewportMaterialUpdate.Always" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportMaterialUpdate.Manual">
<code class="descname">Manual</code><em class="property"> = viewportMaterialUpdate.Manual</em><a class="headerlink" href="#hou.viewportMaterialUpdate.Manual" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportMaterialUpdate.OffForPlayback">
<code class="descname">OffForPlayback</code><em class="property"> = viewportMaterialUpdate.OffForPlayback</em><a class="headerlink" href="#hou.viewportMaterialUpdate.OffForPlayback" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportMaterialUpdate.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.viewportMaterialUpdate.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.viewportPackedBoxMode">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">viewportPackedBoxMode</code><a class="headerlink" href="#hou.viewportPackedBoxMode" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Enum for the culled packed geometry display mode.</p>
<p>Defines how culled packed primitives are displayed in the viewport.</p>
<p>VALUES</p>
<blockquote>
<div><dl class="docutils">
<dt>hou.viewportPackedBoxMode.NoDisplay</dt>
<dd>Culled packed primitives are not displayed at all.</dd>
<dt>hou.viewportPackedBoxMode.Wireframe</dt>
<dd>A wireframe bounding box replaces the packed primitive.</dd>
<dt>hou.viewportPackedBoxMode.Shaded</dt>
<dd>A shaded bounding box replaces the packed primitive.</dd>
<dt>hou.viewportPackedBoxMode.CurrentShadingMode</dt>
<dd>A bounding box replaces the packed primitive, drawn wireframe in
wireframe shading modes and shaded otherwise.</dd>
</dl>
</div></blockquote>
<dl class="attribute">
<dt id="hou.viewportPackedBoxMode.CurrentShadingMode">
<code class="descname">CurrentShadingMode</code><em class="property"> = viewportPackedBoxMode.CurrentShadingMode</em><a class="headerlink" href="#hou.viewportPackedBoxMode.CurrentShadingMode" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportPackedBoxMode.NoDisplay">
<code class="descname">NoDisplay</code><em class="property"> = viewportPackedBoxMode.NoDisplay</em><a class="headerlink" href="#hou.viewportPackedBoxMode.NoDisplay" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportPackedBoxMode.Shaded">
<code class="descname">Shaded</code><em class="property"> = viewportPackedBoxMode.Shaded</em><a class="headerlink" href="#hou.viewportPackedBoxMode.Shaded" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportPackedBoxMode.Wireframe">
<code class="descname">Wireframe</code><em class="property"> = viewportPackedBoxMode.Wireframe</em><a class="headerlink" href="#hou.viewportPackedBoxMode.Wireframe" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportPackedBoxMode.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.viewportPackedBoxMode.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.viewportParticleDisplay">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">viewportParticleDisplay</code><a class="headerlink" href="#hou.viewportParticleDisplay" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Viewport display option for particle display visualization.</p>
<p>Specifies the visualization for particles and points in the viewport.</p>
<p>VALUES</p>
<blockquote>
<div><dl class="docutils">
<dt>Points</dt>
<dd>Fixed size points in screen space.</dd>
<dt>Lines</dt>
<dd>Points with streaks indicating velocity.</dd>
<dt>Pixels</dt>
<dd>Single pixel particle (fixed size)</dd>
<dt>Discs</dt>
<dd>Circular disc, variable world size.</dd>
</dl>
</div></blockquote>
<dl class="attribute">
<dt id="hou.viewportParticleDisplay.Discs">
<code class="descname">Discs</code><em class="property"> = viewportParticleDisplay.Discs</em><a class="headerlink" href="#hou.viewportParticleDisplay.Discs" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportParticleDisplay.Lines">
<code class="descname">Lines</code><em class="property"> = viewportParticleDisplay.Lines</em><a class="headerlink" href="#hou.viewportParticleDisplay.Lines" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportParticleDisplay.Pixels">
<code class="descname">Pixels</code><em class="property"> = viewportParticleDisplay.Pixels</em><a class="headerlink" href="#hou.viewportParticleDisplay.Pixels" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportParticleDisplay.Points">
<code class="descname">Points</code><em class="property"> = viewportParticleDisplay.Points</em><a class="headerlink" href="#hou.viewportParticleDisplay.Points" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportParticleDisplay.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.viewportParticleDisplay.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.viewportShadowQuality">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">viewportShadowQuality</code><a class="headerlink" href="#hou.viewportShadowQuality" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>The quality of shadows produced in the viewport</p>
<p>The viewport renderer can do various amounts of shadowmap sampling to
produce a higher quality result.</p>
<p>VALUES</p>
<blockquote>
<div><dl class="docutils">
<dt>hou.viewportShadowQuality.Point</dt>
<dd>Area lights are treated as point lights when generating and
sampling shadow maps. This is the fastest option.</dd>
<dt>hou.viewportShadowQuality.PointAA</dt>
<dd>Do some antialiasing of shadow edges. Treat area lights as point
lights when generating and sampling shadow maps.</dd>
<dt>hou.viewportShadowQuality.Area</dt>
<dd>Area lights generate multiple shadow maps which are sampled to
generate an approximation of a blurred shadow from an area
source.</dd>
<dt>hou.viewportShadowQuality.AreaAA</dt>
<dd>Area lights generate multiple maps and antialias the shadow
lookups.</dd>
</dl>
</div></blockquote>
<dl class="attribute">
<dt id="hou.viewportShadowQuality.Area">
<code class="descname">Area</code><em class="property"> = viewportShadowQuality.Area</em><a class="headerlink" href="#hou.viewportShadowQuality.Area" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportShadowQuality.AreaAA">
<code class="descname">AreaAA</code><em class="property"> = viewportShadowQuality.AreaAA</em><a class="headerlink" href="#hou.viewportShadowQuality.AreaAA" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportShadowQuality.Point">
<code class="descname">Point</code><em class="property"> = viewportShadowQuality.Point</em><a class="headerlink" href="#hou.viewportShadowQuality.Point" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportShadowQuality.PointAA">
<code class="descname">PointAA</code><em class="property"> = viewportShadowQuality.PointAA</em><a class="headerlink" href="#hou.viewportShadowQuality.PointAA" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportShadowQuality.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.viewportShadowQuality.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.viewportStandInGeometry">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">viewportStandInGeometry</code><a class="headerlink" href="#hou.viewportStandInGeometry" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Replacement geometry for instances culled in the viewport.</p>
<p>When using point instancing, instances can be culled because of the
Point Instancing Percent, or the Instancing Limit display options.
Culled instances can be replaced by a marker or bounding box, or
completely hidden.</p>
<p>VALUES</p>
<blockquote>
<div><dl class="docutils">
<dt>DisplayOff</dt>
<dd>Dont show anything for culled instances.</dd>
<dt>LocationMarker</dt>
<dd>Show a point marker at the local space origin of the instance.</dd>
<dt>BoundingBox</dt>
<dd>Show the bounding box of the culled instance.</dd>
</dl>
</div></blockquote>
<dl class="attribute">
<dt id="hou.viewportStandInGeometry.BoundingBox">
<code class="descname">BoundingBox</code><em class="property"> = viewportStandInGeometry.BoundingBox</em><a class="headerlink" href="#hou.viewportStandInGeometry.BoundingBox" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportStandInGeometry.DisplayOff">
<code class="descname">DisplayOff</code><em class="property"> = viewportStandInGeometry.DisplayOff</em><a class="headerlink" href="#hou.viewportStandInGeometry.DisplayOff" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportStandInGeometry.LocationMarker">
<code class="descname">LocationMarker</code><em class="property"> = viewportStandInGeometry.LocationMarker</em><a class="headerlink" href="#hou.viewportStandInGeometry.LocationMarker" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportStandInGeometry.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.viewportStandInGeometry.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.viewportStereoMode">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">viewportStereoMode</code><a class="headerlink" href="#hou.viewportStereoMode" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Stereoscopic viewport display modes</p>
<p>The stereoscopic viewport display modes available when viewing through a
stereo camera rig.</p>
<p>VALUES</p>
<blockquote>
<div><dl class="docutils">
<dt>hou.viewportStereoMode.Anaglyph</dt>
<dd>Anaglyph display of left/right as red/cyan.</dd>
<dt>hou.viewportStereoMode.HorizontalInterlace</dt>
<dd>Interlace left and right on alternating scanlines. Only useful
for 3D monitors which support this.</dd>
<dt>hou.viewportStereoMode.HorizontalInterlaceReverse</dt>
<dd>Interlace left and right on alternating scanlines, swapping
which scanlines are used for left and right.</dd>
<dt>hou.viewportStereoMode.QuadBufferGL</dt>
<dd>Use OpenGL quad buffer stereo, generally only available on
professional cards.</dd>
</dl>
</div></blockquote>
<dl class="attribute">
<dt id="hou.viewportStereoMode.Anaglyph">
<code class="descname">Anaglyph</code><em class="property"> = viewportStereoMode.Anaglyph</em><a class="headerlink" href="#hou.viewportStereoMode.Anaglyph" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportStereoMode.HorizontalInterlace">
<code class="descname">HorizontalInterlace</code><em class="property"> = viewportStereoMode.HorizontalInterlace</em><a class="headerlink" href="#hou.viewportStereoMode.HorizontalInterlace" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportStereoMode.HorizontalInterlaceReverse">
<code class="descname">HorizontalInterlaceReverse</code><em class="property"> = viewportStereoMode.HorizontalInterlaceReverse</em><a class="headerlink" href="#hou.viewportStereoMode.HorizontalInterlaceReverse" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportStereoMode.QuadBufferGL">
<code class="descname">QuadBufferGL</code><em class="property"> = viewportStereoMode.QuadBufferGL</em><a class="headerlink" href="#hou.viewportStereoMode.QuadBufferGL" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportStereoMode.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.viewportStereoMode.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.viewportTextureDepth">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">viewportTextureDepth</code><a class="headerlink" href="#hou.viewportTextureDepth" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Enum for the viewport texture bit depth limit</p>
<p>Specifies the maximum bit depth that can be used for textures in the
viewport.</p>
<p>VALUES</p>
<blockquote>
<div><dl class="docutils">
<dt>hou.viewportTextureDepth.Compressed8</dt>
<dd>Compressed, 8b SDR texture format. Smallest memory use.</dd>
<dt>hou.viewportTextureDepth.Fixed8</dt>
<dd>8b SDR texture format. Good balance between memory and quality.</dd>
<dt>hou.viewportTextureDepth.FullHDR</dt>
<dd>16b HDR texture format. Excellent dynamic range, but more memory
use and slower texturing performance.</dd>
<dt>hou.viewportTextureDepth.HDR16</dt>
<dd>32b HDR texture format. Extreme dynamic range, but very high
memory use and slow texturing performance. Use with care.</dd>
</dl>
</div></blockquote>
<dl class="attribute">
<dt id="hou.viewportTextureDepth.Compressed8">
<code class="descname">Compressed8</code><em class="property"> = viewportTextureDepth.Compressed8</em><a class="headerlink" href="#hou.viewportTextureDepth.Compressed8" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportTextureDepth.Fixed8">
<code class="descname">Fixed8</code><em class="property"> = viewportTextureDepth.Fixed8</em><a class="headerlink" href="#hou.viewportTextureDepth.Fixed8" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportTextureDepth.FullHDR">
<code class="descname">FullHDR</code><em class="property"> = viewportTextureDepth.FullHDR</em><a class="headerlink" href="#hou.viewportTextureDepth.FullHDR" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportTextureDepth.HDR16">
<code class="descname">HDR16</code><em class="property"> = viewportTextureDepth.HDR16</em><a class="headerlink" href="#hou.viewportTextureDepth.HDR16" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportTextureDepth.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.viewportTextureDepth.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.viewportTransparency">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">viewportTransparency</code><a class="headerlink" href="#hou.viewportTransparency" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Transparency rendering quality for the viewport</p>
<p>Quality levels for rendering objects with transparency in the viewport.</p>
<p>VALUES</p>
<blockquote>
<div><dl class="docutils">
<dt>hou.viewportTransparency.Cutout</dt>
<dd>Fast test to render the transparent pixel as opaque (&gt;0) or to
discard it (0). This can be used for texture cards such as
leaves. This doesnt require an additional pass for
transparency.</dd>
<dt>hou.viewportTransparency.Low</dt>
<dd>Render transparent pixels in a separate pass. Only the front-
most transparent pixel is rendered.</dd>
<dt>hou.viewportTransparency.Medium</dt>
<dd>Render transparent pixels in an Order-Independent buffer of 8
samples, which is then sorted and composited together to do
multi-layer transparency for up to 8 layers of overlapping
transparency.</dd>
<dt>hou.viewportTransparency.High</dt>
<dd>Render transparent pixels in an Order-Independent buffer of 16
samples, which is then sorted and composited together to do
multi-layer transparency for up to 16 layers of overlapping
transparency.</dd>
</dl>
</div></blockquote>
<dl class="attribute">
<dt id="hou.viewportTransparency.Cutout">
<code class="descname">Cutout</code><em class="property"> = viewportTransparency.Cutout</em><a class="headerlink" href="#hou.viewportTransparency.Cutout" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportTransparency.High">
<code class="descname">High</code><em class="property"> = viewportTransparency.High</em><a class="headerlink" href="#hou.viewportTransparency.High" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportTransparency.Low">
<code class="descname">Low</code><em class="property"> = viewportTransparency.Low</em><a class="headerlink" href="#hou.viewportTransparency.Low" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportTransparency.Medium">
<code class="descname">Medium</code><em class="property"> = viewportTransparency.Medium</em><a class="headerlink" href="#hou.viewportTransparency.Medium" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportTransparency.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.viewportTransparency.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.viewportVisualizerCategory">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">viewportVisualizerCategory</code><a class="headerlink" href="#hou.viewportVisualizerCategory" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Enumeration of the different categories of viewport visualizers.</p>
<p>VALUES</p>
<blockquote>
<div><dl class="docutils">
<dt>Common</dt>
<dd>Viewport visualizers in the common category are available across
all scene files.</dd>
<dt>Scene</dt>
<dd>Viewport visualizers in the scene category are saved to the
scene file and are only available in the specific scene file in
which they are created or saved.</dd>
<dt>Node</dt>
<dd>Node visualizers are installed on individual nodes in Houdini
and have a limited scope.</dd>
</dl>
</div></blockquote>
<dl class="attribute">
<dt id="hou.viewportVisualizerCategory.Common">
<code class="descname">Common</code><em class="property"> = viewportVisualizerCategory.Common</em><a class="headerlink" href="#hou.viewportVisualizerCategory.Common" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportVisualizerCategory.Node">
<code class="descname">Node</code><em class="property"> = viewportVisualizerCategory.Node</em><a class="headerlink" href="#hou.viewportVisualizerCategory.Node" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportVisualizerCategory.Scene">
<code class="descname">Scene</code><em class="property"> = viewportVisualizerCategory.Scene</em><a class="headerlink" href="#hou.viewportVisualizerCategory.Scene" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportVisualizerCategory.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.viewportVisualizerCategory.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.viewportVisualizerScope">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">viewportVisualizerScope</code><a class="headerlink" href="#hou.viewportVisualizerScope" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Enumeration of the different scopes of viewport visualizers.</p>
<p>VALUES</p>
<blockquote>
<div><dl class="docutils">
<dt>NodeOnly</dt>
<dd>The visualizer affects only the geometry produced by the node on
which it is installed. This value only applies to visualizers in
the hou.viewportVisualizerCategory.Node category.</dd>
<dt>SameNetworkTypeDescendents</dt>
<dd>The visualizer affects only the geometries produced by the node
and its descendent nodes of the same network type. This value
only applies to visualizers in the
hou.viewportVisualizerCategory.Node category.</dd>
<dt>AllDescendents</dt>
<dd>The visualizer affects the geometries produced by the node and
its descendent nodes regardless of the network type. This value
only applies to visualizers in the
hou.viewportVisualizerCategory.Node category.</dd>
<dt>Global</dt>
<dd>The visualizer affects any geometry that is displayed in the
viewport. This value only applies to visualizers in the
hou.viewportVisualizerCategory.Common and
hou.viewportVisualizerCategory.Scene categories.</dd>
</dl>
</div></blockquote>
<dl class="attribute">
<dt id="hou.viewportVisualizerScope.AllDescendents">
<code class="descname">AllDescendents</code><em class="property"> = viewportVisualizerScope.AllDescendents</em><a class="headerlink" href="#hou.viewportVisualizerScope.AllDescendents" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportVisualizerScope.Global">
<code class="descname">Global</code><em class="property"> = viewportVisualizerScope.Global</em><a class="headerlink" href="#hou.viewportVisualizerScope.Global" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportVisualizerScope.NodeOnly">
<code class="descname">NodeOnly</code><em class="property"> = viewportVisualizerScope.NodeOnly</em><a class="headerlink" href="#hou.viewportVisualizerScope.NodeOnly" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportVisualizerScope.SameNetworkTypeDescendents">
<code class="descname">SameNetworkTypeDescendents</code><em class="property"> = viewportVisualizerScope.SameNetworkTypeDescendents</em><a class="headerlink" href="#hou.viewportVisualizerScope.SameNetworkTypeDescendents" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportVisualizerScope.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.viewportVisualizerScope.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hou.viewportVolumeQuality">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">viewportVolumeQuality</code><a class="headerlink" href="#hou.viewportVolumeQuality" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Display options for viewport volume rendering quality</p>
<p>Volume display in the viewport can be an expensive drawing operation.
The volume quality can be adjusted to provide better viewport
performance or better volume quality.</p>
<p>VALUES</p>
<blockquote>
<div><dl class="docutils">
<dt>VeryLow</dt>
<dd>Quick volume preview.</dd>
<dt>Low</dt>
<dd>Minor quality loss for performance.</dd>
<dt>Normal</dt>
<dd>Balanced quality/performance setting.</dd>
<dt>High</dt>
<dd>Jittered, high quality volume with more passes.</dd>
</dl>
</div></blockquote>
<dl class="attribute">
<dt id="hou.viewportVolumeQuality.High">
<code class="descname">High</code><em class="property"> = viewportVolumeQuality.High</em><a class="headerlink" href="#hou.viewportVolumeQuality.High" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportVolumeQuality.Low">
<code class="descname">Low</code><em class="property"> = viewportVolumeQuality.Low</em><a class="headerlink" href="#hou.viewportVolumeQuality.Low" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportVolumeQuality.Normal">
<code class="descname">Normal</code><em class="property"> = viewportVolumeQuality.Normal</em><a class="headerlink" href="#hou.viewportVolumeQuality.Normal" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportVolumeQuality.VeryLow">
<code class="descname">VeryLow</code><em class="property"> = viewportVolumeQuality.VeryLow</em><a class="headerlink" href="#hou.viewportVolumeQuality.VeryLow" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.viewportVolumeQuality.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.viewportVolumeQuality.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="hou.vmatch">
<code class="descclassname">hou.</code><code class="descname">vmatch</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.vmatch" title="Permalink to this definition"></a></dt>
<dd><p>Matches the incoming and outgoing values and slopes.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>vmatch() -&gt; float</dd>
</dl>
<p>Unlike hou.match, this function will use its left keyframes outgoing
value and the right keyframes incoming value, so hou.vmatch() can
produce curves that are discontinuous with the previous segment.</p>
<p>This function is one of the special animation functions that use the
current playbar time and information in the parameters keyframes, such
as in and out values, tangents, acceleration, etc., to evaluate
themselves. Because the information needed to evaluate these functions
comes from the keyframes, these functions take few or no parameters.</p>
<p>Calling this function from outside a parameters expression will raise a
hou.NotAvailable exception.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.bezier</li>
<li>hou.constant</li>
<li>hou.cubic</li>
<li>hou.cycle</li>
<li>hou.cyclet</li>
<li>hou.ease</li>
<li>hou.easein</li>
<li>hou.easeinp</li>
<li>hou.easeout</li>
<li>hou.easeoutp</li>
<li>hou.easep</li>
<li>hou.linear</li>
<li>hou.match</li>
<li>hou.matchin</li>
<li>hou.matchout</li>
<li>hou.qlinear</li>
<li>hou.quintic</li>
<li>hou.repeat</li>
<li>hou.repeatt</li>
<li>hou.spline</li>
<li>hou.vmatchin</li>
<li>hou.vmatchout</li>
</ul>
</div></blockquote>
<p>REPLACES</p>
<blockquote>
<div><ul class="simple">
<li>vmatch()</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.vmatchin">
<code class="descclassname">hou.</code><code class="descname">vmatchin</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.vmatchin" title="Permalink to this definition"></a></dt>
<dd><p>Matches the left keyframes incoming slope.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>vmatchin() -&gt; float</dd>
</dl>
<p>The curve will be a straight line from the left keyframes outgoing
value, and will not match the right keyframes outgoing value. Unlike
the hou.matchin() function, the left keyframes outgoing value can
differ from its incoming value, so so hou.vmatchin() can produce curves
whose left tangent matches the left keyframe but whose left values do
not line up.</p>
<p>This function is one of the special animation functions that use the
current playbar time and information in the parameters keyframes, such
as in and out values, tangents, acceleration, etc., to evaluate
themselves. Because the information needed to evaluate these functions
comes from the keyframes, these functions take few or no parameters.</p>
<p>Calling this function from outside a parameters expression will raise a
hou.NotAvailable exception.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.bezier</li>
<li>hou.constant</li>
<li>hou.cubic</li>
<li>hou.cycle</li>
<li>hou.cyclet</li>
<li>hou.ease</li>
<li>hou.easein</li>
<li>hou.easeinp</li>
<li>hou.easeout</li>
<li>hou.easeoutp</li>
<li>hou.easep</li>
<li>hou.linear</li>
<li>hou.match</li>
<li>hou.matchin</li>
<li>hou.matchout</li>
<li>hou.qlinear</li>
<li>hou.quintic</li>
<li>hou.repeat</li>
<li>hou.repeatt</li>
<li>hou.spline</li>
<li>hou.vmatch</li>
<li>hou.vmatchout</li>
</ul>
</div></blockquote>
<p>REPLACES</p>
<blockquote>
<div><ul class="simple">
<li>vmatchin()</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.vmatchout">
<code class="descclassname">hou.</code><code class="descname">vmatchout</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.vmatchout" title="Permalink to this definition"></a></dt>
<dd><p>Matches the right keyframes outgoing slope.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>vmatchout() -&gt; float</dd>
</dl>
<p>The curve will be a straight line ending at the right keyframes
incoming value, and will not match the left keyframes incoming value.
Unlike the hou.matchout() function, the right keyframes incoming value
can differ from its outgoing value, so so hou.vmatchout() can produce
curves whose right tangent matches the right keyframe but whose right
values do not line up.</p>
<p>This function is one of the special animation functions that use the
current playbar time and information in the parameters keyframes, such
as in and out values, tangents, acceleration, etc., to evaluate
themselves. Because the information needed to evaluate these functions
comes from the keyframes, these functions take few or no parameters.</p>
<p>Calling this function from outside a parameters expression will raise a
hou.NotAvailable exception.</p>
<p>RELATED</p>
<blockquote>
<div><ul class="simple">
<li>hou.bezier</li>
<li>hou.constant</li>
<li>hou.cubic</li>
<li>hou.cycle</li>
<li>hou.cyclet</li>
<li>hou.ease</li>
<li>hou.easein</li>
<li>hou.easeinp</li>
<li>hou.easeout</li>
<li>hou.easeoutp</li>
<li>hou.easep</li>
<li>hou.linear</li>
<li>hou.match</li>
<li>hou.matchin</li>
<li>hou.matchout</li>
<li>hou.qlinear</li>
<li>hou.quintic</li>
<li>hou.repeat</li>
<li>hou.repeatt</li>
<li>hou.spline</li>
<li>hou.vmatch</li>
<li>hou.vmatchin</li>
</ul>
</div></blockquote>
<p>REPLACES</p>
<blockquote>
<div><ul class="simple">
<li>vmatchout()</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="hou.vopNetNodeTypeCategory">
<code class="descclassname">hou.</code><code class="descname">vopNetNodeTypeCategory</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.vopNetNodeTypeCategory" title="Permalink to this definition"></a></dt>
<dd><p>Return the NodeTypeCategory instance for Houdini vex builder container
(vopnet) nodes.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>vopNetNodeTypeCategory() -&gt; NodeTypeCategory</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="hou.vopNodeTypeCategory">
<code class="descclassname">hou.</code><code class="descname">vopNodeTypeCategory</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hou.vopNodeTypeCategory" title="Permalink to this definition"></a></dt>
<dd><p>Return the NodeTypeCategory instance for Houdini vex builder (VOP)
nodes.</p>
<dl class="docutils">
<dt>USAGE</dt>
<dd>vopNodeTypeCategory() -&gt; NodeTypeCategory</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="hou.vopParmGenType">
<em class="property">class </em><code class="descclassname">hou.</code><code class="descname">vopParmGenType</code><a class="headerlink" href="#hou.vopParmGenType" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Enumeration of the different node configurations that can be created for
the inputs of a VOP node.</p>
<p>See hou.VopNode.insertParmGenerator and
hou.VopNode.insertParmGeneratorsForAllInputs.</p>
<p>VALUES</p>
<blockquote>
<div><dl class="docutils">
<dt>Constant</dt>
<dd>Create a Constant VOP and connect it to the VOP nodes input.</dd>
<dt>Parameter</dt>
<dd>Create a Parameter VOP and connect it to the VOP nodes input.
The input parameter is automatically promoted to the VOP
networks parameter interface.</dd>
<dt>SubnetInput</dt>
<dd>Create a Parameter VOP and connect it to the VOP nodes input.
Additionally set the Parameter VOPs Scope parameter to Subnet.
The input parameter is automatically promoted to the owning
Subnet VOPs parameter interface.</dd>
</dl>
</div></blockquote>
<dl class="attribute">
<dt id="hou.vopParmGenType.Constant">
<code class="descname">Constant</code><em class="property"> = vopParmGenType.Constant</em><a class="headerlink" href="#hou.vopParmGenType.Constant" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.vopParmGenType.Parameter">
<code class="descname">Parameter</code><em class="property"> = vopParmGenType.Parameter</em><a class="headerlink" href="#hou.vopParmGenType.Parameter" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.vopParmGenType.SubnetInput">
<code class="descname">SubnetInput</code><em class="property"> = vopParmGenType.SubnetInput</em><a class="headerlink" href="#hou.vopParmGenType.SubnetInput" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="hou.vopParmGenType.thisown">
<code class="descname">thisown</code><a class="headerlink" href="#hou.vopParmGenType.thisown" title="Permalink to this definition"></a></dt>
<dd><p>The membership flag</p>
</dd></dl>

</dd></dl>

</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="houdiniInterpreter.html" class="btn btn-neutral float-right" title="houdiniInterpreter module" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="hotkeys.html" class="btn btn-neutral" title="hotkeys package" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, jtomori

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
    

  

  <script type="text/javascript" src="_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>